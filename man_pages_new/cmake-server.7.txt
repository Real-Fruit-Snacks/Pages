NAME

cmake-server -
CMake Server

Deprecated
since version 3.15: This will be removed from a future
version of CMake. Clients should use the
cmake-file-api(7) instead.

INTRODUCTION

cmake(1)
is capable of providing semantic information about CMake
code it executes to generate a buildsystem. If executed with
the -E server command line options, it starts in a
long running mode and allows a client to request the
available information via a JSON protocol.

The protocol is
designed to be useful to IDEs, refactoring tools, and other
tools which have a need to understand the buildsystem in
entirety.

A single
cmake-buildsystem(7) may describe buildsystem
contents and build properties which differ based on
generation-time context including:

&bull;

The Platform (eg, Windows, APPLE, Linux).

&bull;

The build configuration (eg, Debug, Release,
Coverage). 

&bull;

The Compiler (eg, MSVC, GCC, Clang) and compiler
version. 

&bull;

The language of the source files compiled.

&bull;

Available compile features (eg CXX variadic
templates). 

&bull;

CMake policies.

The protocol
aims to provide information to tooling to satisfy several
needs:

1.

Provide a complete and easily
parsed source of all information relevant to the tooling as
it relates to the source code. There should be no need for
tooling to parse generated buildsystems to access include
directories or compile definitions for example.

2.

Semantic information about the CMake buildsystem
itself. 

3.

Provide a stable interface for reading the information
in the CMake cache.

4.

Information for determining when cmake needs to be
re-run as a result of file changes.

OPERATION

Start
cmake(1) in the server command mode, supplying the
path to the build directory to process:

cmake -E server (--debug|--pipe=)

The server will
communicate using stdin/stdout (with the --debug
parameter) or using a named pipe (with the
--pipe= parameter). Note that
&ldquo;named pipe&rdquo; refers to a local domain socket on
Unix and to a named pipe on Windows.

When connecting
to the server (via named pipe or by starting it in
--debug mode), the server will reply with a hello
message:

[== "CMake Server" ==[
{"supportedProtocolVersions":[{"major":1,"minor":0}],"type":"hello"}
]== "CMake Server" ==]

Messages sent
to and from the process are wrapped in magic strings:

[== "CMake Server" ==[
{
  ... some JSON message ...
}
]== "CMake Server" ==]

The server is
now ready to accept further requests via the named pipe or
stdin.

DEBUGGING

CMake server
mode can be asked to provide statistics on execution times,
etc. or to dump a copy of the response into a file. This is
done passing a &ldquo;debug&rdquo; JSON object as a child of
the request.

The debug
object supports the &ldquo;showStats&rdquo; key, which takes
a boolean and makes the server mode return a
&ldquo;zzzDebug&rdquo; object with stats as part of its
response. &ldquo;dumpToFile&rdquo; takes a string value and
will cause the cmake server to copy the response into the
given filename.

This is a
response from the cmake server with &ldquo;showStats&rdquo;
set to true:

[== "CMake Server" ==[
{
  "cookie":"",
  "errorMessage":"Waiting for type \"handshake\".",
  "inReplyTo":"unknown",
 "type":"error",
  "zzzDebug": {
    "dumpFile":"/tmp/error.txt",
    "jsonSerialization":0.011016,
    "size":111,
    "totalTime":0.025995
  }
}
]== "CMake Server" ==]

The server has
made a copy of this response into the file /tmp/error.txt
and took 0.011 seconds to turn the JSON response into a
string, and it took 0.025 seconds to process the request in
total. The reply has a size of 111 bytes.

PROTOCOL API

General
Message Layout 
All messages need to have a &ldquo;type&rdquo; value, which
identifies the type of message that is passed back or forth.
E.g. the initial message sent by the server is of type
&ldquo;hello&rdquo;. Messages without a type will generate
an response of type &ldquo;error&rdquo;.

All requests
sent to the server may contain a &ldquo;cookie&rdquo; value.
This value will he handed back unchanged in all responses
triggered by the request.

All responses
will contain a value &ldquo;inReplyTo&rdquo;, which may be
empty in case of parse errors, but will contain the type of
the request message in all other cases.

Type
&ldquo;reply&rdquo; 
This type is used by the server to reply to requests.

The message may
&ndash; depending on the type of the original request
&ndash; contain values.

Example:

[== "CMake Server" ==[
{"cookie":"zimtstern","inReplyTo":"handshake","type":"reply"}
]== "CMake Server" ==]

Type
&ldquo;error&rdquo; 
This type is used to return an error condition to the
client. It will contain an &ldquo;errorMessage&rdquo;.

Example:

[== "CMake Server" ==[
{"cookie":"","errorMessage":"Protocol version not supported.","inReplyTo":"handshake","type":"error"}
]== "CMake Server" ==]

Type
&ldquo;progress&rdquo; 
When the server is busy for a long time, it is polite to
send back replies of type &ldquo;progress&rdquo; to the
client. These will contain a &ldquo;progressMessage&rdquo;
with a string describing the action currently taking place
as well as &ldquo;progressMinimum&rdquo;,
&ldquo;progressMaximum&rdquo; and
&ldquo;progressCurrent&rdquo; with integer values describing
the range of progress.

Messages of
type &ldquo;progress&rdquo; will be followed by more
&ldquo;progress&rdquo; messages or with a message of type
&ldquo;reply&rdquo; or &ldquo;error&rdquo; that complete the
request.

&ldquo;progress&rdquo;
messages may not be emitted after the &ldquo;reply&rdquo; or
&ldquo;error&rdquo; message for the request that triggered
the responses was delivered.

Type
&ldquo;message&rdquo; 
A message is triggered when the server processes a request
and produces some form of output that should be displayed to
the user. A Message has a &ldquo;message&rdquo; with the
actual text to display as well as a &ldquo;title&rdquo; with
a suggested dialog box title.

Example:

[== "CMake Server" ==[
{"cookie":"","message":"Something happened.","title":"Title Text","inReplyTo":"handshake","type":"message"}
]== "CMake Server" ==]

Type
&ldquo;signal&rdquo; 
The server can send signals when it detects changes in the
system state. Signals are of type &ldquo;signal&rdquo;, have
an empty &ldquo;cookie&rdquo; and &ldquo;inReplyTo&rdquo;
field and always have a &ldquo;name&rdquo; set to show which
signal was sent.

Specific
Signals 
The cmake server may sent signals with the following
names:

&ldquo;dirty&rdquo;
Signal 
The &ldquo;dirty&rdquo; signal is sent whenever the server
determines that the configuration of the project is no
longer up-to-date. This happens when any of the files that
have an influence on the build system is changed.

The
&ldquo;dirty&rdquo; signal may look like this:

[== "CMake Server" ==[
{
  "cookie":"",
  "inReplyTo":"",
  "name":"dirty",
  "type":"signal"}
]== "CMake Server" ==]

&ldquo;fileChange&rdquo;
Signal 
The &ldquo;fileChange&rdquo; signal is sent whenever a
watched file is changed. It contains the &ldquo;path&rdquo;
that has changed and a list of &ldquo;properties&rdquo; with
the kind of change that was detected. Possible changes are
&ldquo;change&rdquo; and &ldquo;rename&rdquo;.

The
&ldquo;fileChange&rdquo; signal looks like this:

[== "CMake Server" ==[
{
  "cookie":"",
  "inReplyTo":"",
  "name":"fileChange",
  "path":"/absolute/CMakeLists.txt",
  "properties":["change"],
  "type":"signal"}
]== "CMake Server" ==]

Specific
Message Types 
Type &ldquo;hello&rdquo; 
The initial message send by the cmake server on startup is
of type &ldquo;hello&rdquo;. This is the only message ever
sent by the server that is not of type &ldquo;reply&rdquo;,
&ldquo;progress&rdquo; or &ldquo;error&rdquo;.

It will contain
&ldquo;supportedProtocolVersions&rdquo; with an array of
server protocol versions supported by the cmake server.
These are JSON objects with &ldquo;major&rdquo; and
&ldquo;minor&rdquo; keys containing non-negative integer
values. Some versions may be marked as experimental. These
will contain the &ldquo;isExperimental&rdquo; key set to
true. Enabling these requires a special command line
argument when starting the cmake server mode.

Within a
&ldquo;major&rdquo; version all &ldquo;minor&rdquo; versions
are fully backwards compatible. New &ldquo;minor&rdquo;
versions may introduce functionality in such a way that
existing clients of the same &ldquo;major&rdquo; version
will continue to work, provided they ignore keys in the
output that they do not know about.

Example:

[== "CMake Server" ==[
{"supportedProtocolVersions":[{"major":0,"minor":1}],"type":"hello"}
]== "CMake Server" ==]

Type
&ldquo;handshake&rdquo; 
The first request that the client may send to the server is
of type &ldquo;handshake&rdquo;.

This request
needs to pass one of the
&ldquo;supportedProtocolVersions&rdquo; of the
&ldquo;hello&rdquo; type response received earlier back to
the server in the &ldquo;protocolVersion&rdquo; field.
Giving the &ldquo;major&rdquo; version of the requested
protocol version will make the server use the latest minor
version of that protocol. Use this if you do not explicitly
need to depend on a specific minor version.

Protocol
version 1.0 requires the following attributes to be set:

&bull;

&ldquo;sourceDirectory&rdquo;
with a path to the sources

&bull;

&ldquo;buildDirectory&rdquo; with a path to the build
directory 

&bull;

&ldquo;generator&rdquo; with the generator name

&bull;

&ldquo;extraGenerator&rdquo; (optional!) with the extra
generator to be used

&bull;

&ldquo;platform&rdquo; with the generator platform (if
supported by the generator)

&bull;

&ldquo;toolset&rdquo; with the generator toolset (if
supported by the generator)

Protocol
version 1.2 makes all but the build directory optional,
provided there is a valid cache in the build directory that
contains all the other information already.

Example:

[== "CMake Server" ==[
{"cookie":"zimtstern","type":"handshake","protocolVersion":{"major":0},
 "sourceDirectory":"/home/code/cmake", "buildDirectory":"/tmp/testbuild",
 "generator":"Ninja"}
]== "CMake Server" ==]

which will
result in a response type &ldquo;reply&rdquo;:

[== "CMake Server" ==[
{"cookie":"zimtstern","inReplyTo":"handshake","type":"reply"}
]== "CMake Server" ==]

indicating that
the server is ready for action.

Type
&ldquo;globalSettings&rdquo; 
This request can be sent after the initial handshake. It
will return a JSON structure with information on cmake
state.

Example:

[== "CMake Server" ==[
{"type":"globalSettings"}
]== "CMake Server" ==]

which will
result in a response type &ldquo;reply&rdquo;:

[== "CMake Server" ==[
{
  "buildDirectory": "/tmp/test-build",
  "capabilities": {
    "generators": [
      {
        "extraGenerators": [],
        "name": "Watcom WMake",
        "platformSupport": false,
        "toolsetSupport": false
      },

    ],
    "serverMode": false,
    "version": {
      "isDirty": false,
      "major": 3,
      "minor": 6,
      "patch": 20160830,
      "string": "3.6.20160830-gd6abad",
      "suffix": "gd6abad"
    }
  },
  "checkSystemVars": false,
  "cookie": "",
  "extraGenerator": "",
  "generator": "Ninja",
  "debugOutput": false,
  "inReplyTo": "globalSettings",
  "sourceDirectory": "/home/code/cmake",
  "trace": false,
  "traceExpand": false,
  "type": "reply",
  "warnUninitialized": false,
  "warnUnused": false,
  "warnUnusedCli": true
}
]== "CMake Server" ==]

Type
&ldquo;setGlobalSettings&rdquo; 
This request can be sent to change the global settings
attributes. Unknown attributes are going to be ignored.
Read-only attributes reported by
&ldquo;globalSettings&rdquo; are all capabilities,
buildDirectory, generator, extraGenerator and
sourceDirectory. Any attempt to set these will be ignored,
too.

All other
settings will be changed.

The server will
respond with an empty reply message or an error.

Example:

[== "CMake Server" ==[
{"type":"setGlobalSettings","debugOutput":true}
]== "CMake Server" ==]

CMake will
reply to this with:

[== "CMake Server" ==[
{"inReplyTo":"setGlobalSettings","type":"reply"}
]== "CMake Server" ==]

Type
&ldquo;configure&rdquo; 
This request will configure a project for build.

To configure a
build directory already containing cmake files, it is enough
to set &ldquo;buildDirectory&rdquo; via
&ldquo;setGlobalSettings&rdquo;. To create a fresh build
directory you also need to set
&ldquo;currentGenerator&rdquo; and
&ldquo;sourceDirectory&rdquo; via
&ldquo;setGlobalSettings&rdquo; in addition to
&ldquo;buildDirectory&rdquo;.

You may a list
of strings to &ldquo;configure&rdquo; via the
&ldquo;cacheArguments&rdquo; key. These strings will be
interpreted similar to command line arguments related to
cache handling that are passed to the cmake command line
client.

Example:

[== "CMake Server" ==[
{"type":"configure", "cacheArguments":["-Dsomething=else"]}
]== "CMake Server" ==]

CMake will
reply like this (after reporting progress for some
time):

[== "CMake Server" ==[
{"cookie":"","inReplyTo":"configure","type":"reply"}
]== "CMake Server" ==]

Type
&ldquo;compute&rdquo; 
This request will generate build system files in the build
directory and is only available after a project was
successfully &ldquo;configure&rdquo;d.

Example:

[== "CMake Server" ==[
{"type":"compute"}
]== "CMake Server" ==]

CMake will
reply (after reporting progress information):

[== "CMake Server" ==[
{"cookie":"","inReplyTo":"compute","type":"reply"}
]== "CMake Server" ==]

Type
&ldquo;codemodel&rdquo; 
The &ldquo;codemodel&rdquo; request can be used after a
project was &ldquo;compute&rdquo;d successfully.

It will list
the complete project structure as it is known to cmake.

The reply will
contain a key &ldquo;configurations&rdquo;, which will
contain a list of configuration objects. Configuration
objects are used to destinquish between different
configurations the build directory might have enabled. While
most generators only support one configuration, others might
support several.

Each
configuration object can have the following keys:

&ldquo;name&rdquo;

contains the name of the
configuration. The name may be empty.

&ldquo;projects&rdquo;

contains a list of project
objects, one for each build project.

Project objects
define one (sub-)project defined in the cmake build
system.

Each project
object can have the following keys:

&ldquo;name&rdquo;

contains the (sub-)projects name.

&ldquo;minimumCMakeVersion&rdquo;

contains the minimum cmake
version allowed for this project, null if the project
doesn&rsquo;t specify one.

&ldquo;hasInstallRule&rdquo;

true if the project contains
any install rules, false otherwise.

&ldquo;sourceDirectory&rdquo;

contains the current source
directory

&ldquo;buildDirectory&rdquo;

contains the current build
directory.

&ldquo;targets&rdquo;

contains a list of build system
target objects.

Target objects
define individual build targets for a certain
configuration.

Each target
object can have the following keys:

&ldquo;name&rdquo;

contains the name of the target.

&ldquo;type&rdquo;

defines the type of build of the target. Possible values
are &ldquo;STATIC_LIBRARY&rdquo;,
&ldquo;MODULE_LIBRARY&rdquo;, &ldquo;SHARED_LIBRARY&rdquo;,
&ldquo;OBJECT_LIBRARY&rdquo;, &ldquo;EXECUTABLE&rdquo;,
&ldquo;UTILITY&rdquo; and
&ldquo;INTERFACE_LIBRARY&rdquo;. 

&ldquo;fullName&rdquo;

contains the full name of the
build result (incl. extensions, etc.).

&ldquo;sourceDirectory&rdquo;

contains the current source
directory.

&ldquo;buildDirectory&rdquo;

contains the current build
directory.

&ldquo;isGeneratorProvided&rdquo;

true if the target is
auto-created by a generator, false otherwise

&ldquo;hasInstallRule&rdquo;

true if the target contains any
install rules, false otherwise.

&ldquo;installPaths&rdquo;

full path to the destination
directories defined by target install rules.

&ldquo;artifacts&rdquo;

with a list of build artifacts.
The list is sorted with the most important artifacts first
(e.g. a .DLL file is listed before a .PDB file on
windows).

&ldquo;linkerLanguage&rdquo;

contains the language of the
linker used to produce the artifact.

&ldquo;linkLibraries&rdquo;

with a list of libraries to
link to. This value is encoded in the system&rsquo;s native
shell format.

&ldquo;linkFlags&rdquo;

with a list of flags to pass to
the linker. This value is encoded in the system&rsquo;s
native shell format.

&ldquo;linkLanguageFlags&rdquo;

with the flags for a compiler
using the linkerLanguage. This value is encoded in the
system&rsquo;s native shell format.

&ldquo;frameworkPath&rdquo;

with the framework path (on
Apple computers). This value is encoded in the
system&rsquo;s native shell format.

&ldquo;linkPath&rdquo;

with the link path. This value
is encoded in the system&rsquo;s native shell format.

&ldquo;sysroot&rdquo;

with the sysroot path.

&ldquo;fileGroups&rdquo;

contains the source files
making up the target.

FileGroups are
used to group sources using similar settings together.

Each fileGroup
object may contain the following keys: 
&ldquo;language&rdquo;

contains the programming
language used by all files in the group.

&ldquo;compileFlags&rdquo;

with a string containing all
the flags passed to the compiler when building any of the
files in this group. This value is encoded in the
system&rsquo;s native shell format.

&ldquo;includePath&rdquo;

with a list of include paths.
Each include path is an object containing a
&ldquo;path&rdquo; with the actual include path and
&ldquo;isSystem&rdquo; with a bool value informing whether
this is a normal include or a system include. This value is
encoded in the system&rsquo;s native shell format.

&ldquo;defines&rdquo;

with a list of defines in the
form &ldquo;SOMEVALUE&rdquo; or &ldquo;SOMEVALUE=42&rdquo;.
This value is encoded in the system&rsquo;s native shell
format.

&ldquo;sources&rdquo;

with a list of source
files.

All file paths
in the fileGroup are either absolute or relative to the
sourceDirectory of the target.

Example:

[== "CMake Server" ==[
{"type":"codemodel"}
]== "CMake Server" ==]

CMake will
reply:

[== "CMake Server" ==[
{
  "configurations": [
    {
      "name": "",
      "projects": [
        {
          "buildDirectory": "/tmp/build/Source/CursesDialog/form",
          "name": "CMAKE_FORM",
          "sourceDirectory": "/home/code/src/cmake/Source/CursesDialog/form",
          "targets": [
            {
              "artifacts": [ "/tmp/build/Source/CursesDialog/form/libcmForm.a" ],
              "buildDirectory": "/tmp/build/Source/CursesDialog/form",
              "fileGroups": [
                {
                  "compileFlags": "  -std=gnu11",
                  "defines": [ "CURL_STATICLIB", "LIBARCHIVE_STATIC" ],
                  "includePath": [ { "path": "/tmp/build/Utilities" },  ],
                  "isGenerated": false,
                  "language": "C",
                  "sources": [ "fld_arg.c",  ]
                }
              ],
              "fullName": "libcmForm.a",
              "linkerLanguage": "C",
              "name": "cmForm",
              "sourceDirectory": "/home/code/src/cmake/Source/CursesDialog/form",
              "type": "STATIC_LIBRARY"
            }
          ]
        },

      ]
    }
  ],
  "cookie": "",
  "inReplyTo": "codemodel",
  "type": "reply"
}
]== "CMake Server" ==]

Type
&ldquo;ctestInfo&rdquo; 
The &ldquo;ctestInfo&rdquo; request can be used after a
project was &ldquo;compute&rdquo;d successfully.

It will list
the complete project test structure as it is known to
cmake.

The reply will
contain a key &ldquo;configurations&rdquo;, which will
contain a list of configuration objects. Configuration
objects are used to destinquish between different
configurations the build directory might have enabled. While
most generators only support one configuration, others might
support several.

Each
configuration object can have the following keys:

&ldquo;name&rdquo;

contains the name of the configuration. The name may be
empty. 

&ldquo;projects&rdquo;

contains a list of project
objects, one for each build project.

Project objects
define one (sub-)project defined in the cmake build
system.

Each project
object can have the following keys:

&ldquo;name&rdquo;

contains the (sub-)projects name.

&ldquo;ctestInfo&rdquo;

contains a list of test
objects.

Each test
object can have the following keys: 
&ldquo;ctestName&rdquo;

contains the name of the
test.

&ldquo;ctestCommand&rdquo;

contains the test command.

&ldquo;properties&rdquo;

contains a list of test
property objects.

Each test
property object can have the following keys:

&ldquo;key&rdquo;

contains the test property key.

&ldquo;value&rdquo;

contains the test property
value.

Type
&ldquo;cmakeInputs&rdquo; 
The &ldquo;cmakeInputs&rdquo; requests will report files
used by CMake as part of the build system itself.

This request is
only available after a project was successfully
&ldquo;configure&rdquo;d.

Example:

[== "CMake Server" ==[
{"type":"cmakeInputs"}
]== "CMake Server" ==]

CMake will
reply with the following information:

[== "CMake Server" ==[
{"buildFiles":
  [
    {"isCMake":true,"isTemporary":false,"sources":["/usr/lib/cmake/...", ... ]},
    {"isCMake":false,"isTemporary":false,"sources":["CMakeLists.txt", ...]},
    {"isCMake":false,"isTemporary":true,"sources":["/tmp/build/CMakeFiles/...", ...]}
  ],
  "cmakeRootDirectory":"/usr/lib/cmake",
  "sourceDirectory":"/home/code/src/cmake",
  "cookie":"",
  "inReplyTo":"cmakeInputs",
  "type":"reply"
}
]== "CMake Server" ==]

All file names
are either relative to the top level source directory or
absolute.

The list of
files which &ldquo;isCMake&rdquo; set to true are part of
the cmake installation.

The list of
files witch &ldquo;isTemporary&rdquo; set to true are part
of the build directory and will not survive the build
directory getting cleaned out.

Type
&ldquo;cache&rdquo; 
The &ldquo;cache&rdquo; request will list the cached
configuration values.

Example:

[== "CMake Server" ==[
{"type":"cache"}
]== "CMake Server" ==]

CMake will
respond with the following output:

[== "CMake Server" ==[
{
  "cookie":"","inReplyTo":"cache","type":"reply",
  "cache":
  [
    {
      "key":"SOMEVALUE",
      "properties":
      {
        "ADVANCED":"1",
        "HELPSTRING":"This is not helpful"
      }
      "type":"STRING",
      "value":"TEST"}
  ]
}
]== "CMake Server" ==]

The output can
be limited to a list of keys by passing an array of key
names to the &ldquo;keys&rdquo; optional field of the
&ldquo;cache&rdquo; request.

Type
&ldquo;fileSystemWatchers&rdquo; 
The server can watch the filesystem for changes. The
&ldquo;fileSystemWatchers&rdquo; command will report on the
files and directories watched.

Example:

[== "CMake Server" ==[
{"type":"fileSystemWatchers"}
]== "CMake Server" ==]

CMake will
respond with the following output:

[== "CMake Server" ==[
{
  "cookie":"","inReplyTo":"fileSystemWatchers","type":"reply",
  "watchedFiles": [ "/absolute/path" ],
  "watchedDirectories": [ "/absolute" ]
}
]== "CMake Server" ==]

COPYRIGHT

2000-2020
Kitware, Inc. and Contributors