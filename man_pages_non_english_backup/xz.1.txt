XZ(1)                              XZ Utils                              XZ(1)

НАЗВА
       xz,  unxz,  xzcat,  lzma,  unlzma,  lzcat — стискання та розпаковування
       файлів .xz і .lzma

КОРОТКИЙ ОПИС
       xz [параметр...] [файл...]

СКОРОЧЕННЯ КОМАНД
       unxz є рівноцінним до xz --decompress.
       xzcat є рівноцінним до xz --decompress --stdout.
       lzma є рівноцінним до xz --format=lzma.
       unlzma є рівноцінним до xz --format=lzma --decompress.
       lzcat є рівноцінним до xz --format=lzma --decompress --stdout.

       При написанні скриптів, де потрібно розпаковувати  файли,  рекомендуємо
       завжди  використовувати  xz  із  відповідними аргументами (xz -d або xz
       -dc), замість unxz і xzcat.

ОПИС
       xz інструмент загального призначення для стискання даних із синтаксисом
       командного  рядка,  подібним  для  gzip(1) і bzip2(1). Власним форматом
       файлів є .xz, але передбачено підтримку застарілого формату .lzma, який
       було  використано у LZMA Utils, та необроблених потоків стиснених даних
       без заголовків формату контейнера.  Крім  того,  передбачено  підтримку
       розпаковування формату .lz, який використано у lzip.

       xz  стискає  або  розпаковує  кожен файл відповідно до вибраного режиму
       дій. Якщо файли не задано або якщо файлом є  -,  xz  читатиме  дані  зі
       стандартного  джерела  вхідних  даних  і записуватиме оброблені дані до
       стандартного виведення. xz відмовить (покаже повідомлення про помилку і
       пропустить  файл)  у записів стиснених даних до стандартного виведення,
       якщо це термінал. Так само, xz відмовить у читанні стиснених  даних  зі
       стандартного джерела вхідних даних, якщо це термінал.

       Якщо  не  вказано  --stdout,  файли,  відмінні  від -, буде записано до
       нового файла, чию назву буде визначено з назви початкового файла:

       •  При стисканні суфікс формату файла призначення (.xz або .lzma)  буде
          дописано  до  назви  початкового  файла  для  отримання  назви файла
          призначення.

       •  При розпаковуванні суфікс .xz, .lzma або .lz буде вилучено  з  назви
          файла для отримання назви файла призначення. Крім того, xz розпізнає
          суфікси .txz і .tlz і замінює їх на суфікс .tar.

       Якщо  файл  призначення  вже  існує,  буде  показано  повідомлення  про
       помилку, а файл буде пропущено.

       Окрім  випадку запису до стандартного виведення, xz покаже попередження
       і пропустить обробку файла, якщо буде виконано будь-яку з таких умов:

       •  Файл не є звичайним файлом. Програма не переходитиме за символічними
          посиланнями, а отже, не вважатиме їх звичайними файлами.

       •  На файл існує декілька жорстких посилань.

       •  Для файла встановлено setuid, setgid або «липкий» біт.

       •  Режим  дій встановлено у значення «стискання», і файл вже має суфікс
          назви формату файла призначення  (.xz  або  .txz  при  стисканні  до
          формату .xz, і .lzma або .tlz при стисканні до формату .lzma).

       •  Режим  дій  встановлено  у  значення «розпаковування», і файл не має
          суфікса назви жодного з підтримуваних форматів  (.xz,  .txz,  .lzma,
          .tlz або .lz).

       Після успішного стискання або розпаковування файла, xz копіює дані щодо
       власника, групи, прав доступу, часу доступу та моменту внесення змін  з
       початкового  файла  до  файла  призначення.  Якщо копіювання даних щодо
       групи  зазнає  невдачі,  права  доступу  буде  змінено  так,  що   файл
       призначення  стане  недоступним  для  користувачів,  які не мають права
       доступу  до  початкового  файла.  В  xz  ще  не  передбачено  підтримки
       копіювання  інших  метаданих,  зокрема  списків  керування доступом або
       розширених атрибутів.

       Щойно файл призначення  буде  успішно  закрито,  початковий  файл  буде
       вилучено,  якщо  не вказано параметра --keep. Початковий файл ніколи не
       буде  вилучено,  якщо  виведені  дані  буде  записано  до  стандартного
       виведення або якщо станеться помилка.

       Надсилання  SIGINFO  або  SIGUSR1 до процесу xz призводить до виведення
       даних щодо поступу до  стандартного  виведення  помилок.  Це  має  лише
       обмежене  використання,  оскільки якщо стандартним виведенням помилок є
       термінал,  використання  --verbose  призведе  до   показу   автоматично
       оновлюваного індикатора поступу.

   Використання пам'яті
       Використання   xz  пам'яті  може  бути  різним:  від  декількох  сотень
       кілобайтів до декількох гігабайтів, залежно від  параметрів  стискання.
       Параметри,  які  використано  при стисканні файла, визначають вимоги до
       об'єму пам'яті при розпакуванні. Типово, засобу розпаковування потрібно
       від  5 %  до  20 %  об'єму  пам'яті, якого засіб стискання потребує при
       створенні файла.  Наприклад,  розпаковування  файла,  який  створено  з
       використанням  xz  -9, у поточній версії потребує 65 МіБ пам'яті. Втім,
       можливе створення файлів .xz, які  потребуватимуть  для  розпаковування
       декількох гігабайтів пам'яті.

       Ймовірність  високого  рівня  використання  пам'яті  може бути особливо
       дошкульною  для  користувачів  застарілих  комп'ютерів.  Щоб  запобігти
       прикрим  несподіванкам,  у xz передбачено вбудований обмежувач пам'яті,
       який типово вимкнено. Хоча у деяких  операційних  системах  передбачено
       спосіб  обмежити  використання  пам'яті  процесами,  сподівання на його
       ефективність не є аж надто гнучким (наприклад,  використання  ulimit(1)
       для  обмеження  віртуальної  пам'яті  призводить  до  викривлення даних
       mmap(2)).

       Обмежувач пам'яті можна увімкнути  за  допомогою  параметра  командного
       рядка  --memlimit=обмеження.  Часто,  зручніше  увімкнути  обмежувач на
       типовому рівні, встановивши  значення  для  змінної  середовища  XZ_DE‐
       FAULTS,   наприклад,  XZ_DEFAULTS=--memlimit=150MiB.  Можна  встановити
       обмеження окремо для  стискання  і  розпакування  за  допомогою  --mem‐
       limit-compress=limit  and --memlimit-decompress=обмеження. Використання
       цих двох параметрів поза XZ_DEFAULTS не таке вже  і  корисне,  оскільки
       одноразовий  запуск  xz  не  може  одночасно призводити до стискання та
       розпаковування, а набрати у командному рядку --memlimit=обмеження  (або
       -M обмеження) набагато швидше.

       Якщо  під  час  розпаковування  вказане  обмеження  буде перевищено, xz
       покаже повідомлення про помилку, а розпаковування файла зазнає невдачі.
       Якщо  обмеження  буде перевищено при стисканні, xz спробує масштабувати
       параметри  так,  щоб  не   перевищувати   обмеження   (окрім   випадків
       використання  --format=raw  або  --no-adjust). Отже, дію буде виконано,
       якщо обмеження не  є  надто  жорстким.  Масштабування  параметрів  буде
       виконано  кроками,  які  не  збігаються  із рівнями шаблонів стискання.
       Наприклад, якщо обмеження лише трохи не вкладається у  об'єм  потрібний
       для xz -9, параметри буде змінено лише трохи, не до рівня xz -8.

   Поєднання і заповнення з файлами .xz
       Можна поєднати файли .xz без додаткової обробки. xz розпакує такі файли
       так, наче вони є єдиним файлом .xz.

       Можна додати доповнення між з'єднаними частинами  або  після  останньої
       частини.  Доповнення  має  складатися із нульових байтів і мати розмір,
       який є кратним до чотирьох байтів. Це може  бути  корисним,  наприклад,
       якщо файл .xz зберігається на носії даних, де розміри файла вимірюються
       у 512-байтових блоках.

       Поєднання та заповнення не можна використовувати для файлів  .lzma  або
       потоків необроблених даних.

ПАРАМЕТРИ
   Цілочисельні суфікси і спеціальні значення
       У  більшості  місць,  де  потрібен  цілочисельний аргумент, передбачено
       підтримку необов'язкового суфікса для простого визначення великих цілих
       чисел. Між цілим числом і суфіксом не повинно бути пробілів.

       KiB    Помножити ціле число на 1024 (2^10). Синонімами KiB є Ki, k, kB,
              K та KB.

       MiB    Помножити ціле число на 1048576 (2^20). Синонімами MiB є B,  Mi,
              m, M та MB.

       GiB    Помножити  ціле  число на 1073741824 (2^30). Синонімами GiB є B,
              Gi, g, G та GB.

       Можна скористатися особливим значенням max для позначення максимального
       цілого значення, підтримку якого передбачено для параметра.

   Режим операції
       Якщо  вказано  декілька  параметрів  режиму  дій, буде використано лише
       останній з них.

       -z, --compress
              Стиснути. Це типовий режим дій, якщо не вказано параметр  режиму
              дій, а назва команди неявним чином не визначає іншого режиму дій
              (наприклад, unxz неявно визначає --decompress).

       -d, --decompress, --uncompress
              Розпакувати.

       -t, --test
              Перевірити  цілісність  стиснених  файлів  файли.  Цей  параметр
              еквівалентний  до  --decompress  --stdout,  але розпаковані дані
              буде відкинуто, замість запису до стандартного виведення. Жодних
              файлів не буде створено або вилучено.

       -l, --list
              Вивести  відомості  щодо  стиснених  файлів  файли. Розпакування
              даних не виконуватиметься, жодних файлів не  буде  створено  або
              вилучено.  У  режимі  списку  програма  не  може  читати дані зі
              стандартного  введення  або  з  інших   джерел,   де   неможливе
              позиціювання.

              У  типовому  списку  буде  показано базові відомості щодо файлів
              файли,  по  одному  файлу  на  рядок.  Щоб  отримати  докладніші
              відомості,  скористайтеся  параметром  --verbose.  Щоб розширити
              спектр відомостей, скористайтеся параметром --verbose двічі, але
              зауважте,  що це може призвести до значного уповільнення роботи,
              оскільки  отримання  додаткових  відомостей   потребує   великої
              кількості позиціювань. Ширина області докладного виведення даних
              перевищує 80  символів,  тому  передавання  конвеєром  виведених
              даних,   наприклад,  до  less -S,  може  бути  зручним  способом
              перегляду даних, якщо термінал недостатньо широкий.

              Виведені дані залежать від версії xz та використаної локалі. Для
              отримання  даних,  які  будуть  придатні до обробки комп'ютером,
              слід скористатися параметрами --robot --list.

   Модифікатори режиму роботи
       -k, --keep
              Не вилучати вхідні файли.

              Починаючи з версії xz 5.2.6, використання цього параметра  також
              наказує  xz виконувати стискання або розпаковування, навіть якщо
              вхідними даними є символічне посилання на звичайний файл,  файл,
              який  має  декілька  жорстких  посилань,  або  файл,  для  якого
              встановлено  setuid, setgid або липкий біт.  setuid,  setgid  та
              липкий біт не буде скопійовано до файла-результату. У попередніх
              версіях,  ці  дії  виконувалися,  лише  якщо  було   використано
              параметр --force.

       -f, --force
              Результатів використання цього параметра буде декілька:

              •  Якщо файл-результат вже існує, вилучити його до стискання або
                 розпаковування.

              •  Виконувати стискання або розпаковування, навіть якщо вхідними
                 даними  є  символічне посилання на звичайний файл, файл, який
                 має  декілька  жорстких  посилань,  або   файл,   для   якого
                 встановлено   setuid, setgid або липкий біт setuid, setgid та
                 липкий біт не буде скопійовано до файла-результату.

              •  Якщо використано разом із --decompress,  --stdout,  і  xz  не
                 зможе  розпізнати тип початкового файла, копіювати початковий
                 файл без змін  до  стандартного  виведення.  Це  надає  змогу
                 користуватися xzcat --force подібно до cat(1) для файлів, які
                 не було стиснено за допомогою xz. Зауважте, що у  майбутньому
                 у xz може бути реалізовано підтримку нових форматів стиснених
                 файлів,  замість  копіювання  їх  без  змін  до  стандартного
                 виведення.  Можна  скористатися --format=формат для обмеження
                 стискання у xz єдиним форматом файлів.

       -c, --stdout, --to-stdout
              Записати  стиснені  або   розпаковані   дані   до   стандартного
              виведення, а не до файла. Неявним чином встановлює --keep.

       --single-stream
              Розпакувати  лише  перший  потік  даних  .xz  і  без повідомлень
              проігнорувати решту вхідних даних, які слідують за цим  потоком.
              Зазвичай,  такі зайві дані наприкінці файла призводять до показу
              xz повідомлення про помилку.

              xz ніколи не виконуватиме спроби видобути декілька потоків даних
              з  файлів .lzma або необроблених потоків даних, але використання
              цього параметра все одно наказує xz ігнорувати  можливі  кінцеві
              дані після файла .lzma або необробленого потоку даних.

              Цей  параметр  нічого  не змінює, якщо режимом дій не є --decom‐
              press або --test.

       --no-sparse
              Вимкнути створення розріджених файлів. Типово, якщо  видобування
              виконується   до   звичайного  файла,  xz  намагається  створити
              розріджений  файл,   якщо   розпаковані   дані   містять   довгі
              послідовності двійкових нулів. Це також працює, коли виконується
              запис  до  стандартного  виведення,  доки  стандартне  виведення
              з'єднано  зі  звичайним  файлом  і  виконуються  певні додаткові
              умови, які убезпечують роботу. Створення розріджених файлів може
              заощадити  місце  на  диску  і пришвидшити розпаковування шляхом
              зменшення кількості дій введення та виведення даних на диску.

       -S .suf, --suffix=.suf
              При стисканні використати суфікс .suf  для  файлів  призначення,
              замість  суфікса  .xz або .lzma. Якщо записування виконується не
              до стандартного виведення і початковий файл вже має суфікс назви
              .suf,  буде показано попередження, а файл буде пропущено під час
              обробки.

              При розпаковуванні розпізнавати файли із  суфіксом  назви  .suf,
              окрім  файлів  із суфіксами назв .xz, .txz, .lzma, .tlz або .lz.
              Якщо початковий файл мав суфікс назви .suf, для отримання  назви
              файла призначення цей суфікс буде вилучено.

              При   стисканні  або  розпакуванні  необроблених  потоків  даних
              (--format=raw) суфікс  слід  вказувати  завжди,  якщо  запис  не
              виконується до стандартного виведення, оскільки типового суфікса
              назви для необроблених потоків даних не передбачено.

       --files[=файл]
              Прочитати назви файлів для обробки з файла файл;  якщо  file  не
              вказано,  назви  файлів  буде  прочитано  зі стандартного потоку
              вхідних даних.  Назви  файлів  має  бути  відокремлено  символом
              нового рядка. Символ дефіса (-) буде оброблено як звичайну назву
              файла; він не позначатиме стандартного  джерела  вхідних  даних.
              Якщо також буде вказано назви файлів у аргументах рядка команди,
              файли з цими назвами буде оброблено  до  обробки  файлів,  назви
              яких було прочитано з файла файл.

       --files0[=файл]
              Те  саме,  що  і  --files[=файл],  але  файли  у списку має бути
              відокремлено нульовим символом.

   Параметри базового формату файлів та стискання
       -F format, --format=формат
              Вказати файл формат для стискання або розпакування:

              auto   Типовий варіант. При стисканні auto  є  еквівалентом  xz.
                     При розпакуванні формат файла вхідних даних буде виявлено
                     автоматично.   Зауважте,   що    автоматичне    виявлення
                     необроблених потоків даних (створених за допомогою --for‐
                     mat=raw) неможливе.

              xz     Стиснути до формату .xz або приймати лише файли  .xz  при
                     розпаковуванні.

              lzma, alone
                     Стиснути  дані  до  застарілого  формату файлів .lzma або
                     приймати   лише   файли   .lzma    при    розпаковуванні.
                     Альтернативну  назву  alone  може  бути  використано  для
                     зворотної сумісності із LZMA Utils.

              lzip   Приймати  лише  файли  .lz  при  розпакуванні.  Підтримки
                     стискання не передбачено.

                     Передбачено   підтримку   версії   формату   .lz   0   та
                     нерозширеної версії 1. Файли версії 0 було створено  lzip
                     1.3  та  старішими  версіями. Такі файли не є поширеними,
                     але їх можна знайти у файлових  архівах,  оскільки  певну
                     незначну  кількість  пакунків  із  початковим  кодом було
                     випущено у цьому форматі. Також можуть існувати  особисті
                     файли  у  цьому  форматі.  Підтримку  розпаковування  для
                     формату версії 0 було вилучено у lzip 1.18.

                     lzip 1.4 і  пізніші  версії  створюють  файли  у  форматі
                     версії  1. Розширення синхронізації позначки витирання до
                     формату версії 1 було додано у lzip  1.6.  Це  розширення
                     використовують   не   часто,   його  підтримки  у  xz  не
                     передбачено (програма повідомлятиме про пошкоджені вхідні
                     дані).

              raw    Стиснути  або  розпакувати  потік необроблених даних (лез
                     заголовків). Цей параметр призначено лише для досвідчених
                     користувачів.  Для  розпаковування  необроблених  потоків
                     даних слід користуватися параметром  --format=raw і  явно
                     вказати  ланцюжок  фільтрування,  який  за звичайних умов
                     мало б бути збережено у заголовках контейнера.

       -C перевірка, --check=перевірка
              Вказати тип перевірки цілісності. Контрольну суму буде обчислено
              на  основі  нестиснених  даних  і  збережено  у  файлі  .xz. Цей
              параметр працюватиме, лише якщо дані стиснено до файла у форматі
              .xz;  для формату файлів .lzma підтримки перевірки цілісності не
              передбачено. Перевірку  контрольної  суми  (якщо  така  є)  буде
              виконано під час розпаковування файла .xz.

              Підтримувані типи перевірок:

              none   Не  обчислювати  контрольну  суму  взагалі.  Зазвичай, не
                     варто цього робити. Цим варіантом слід скористатися, якщо
                     цілісність даних буде перевірено в інший спосіб.

              crc32  Обчислити  CRC32 за допомогою полінома з IEEE-802.3 (Eth‐
                     ernet).

              crc64  Обчислити CRC64 за  допомогою  полінома  з  ECMA-182.  Це
                     типовий  варіант,  оскільки  він дещо кращий за CRC32 при
                     виявленні пошкоджених файлів, а  різниця  у  швидкості  є
                     незрачною.

              sha256 Обчислити  SHA-256. Цей варіант дещо повільніший за CRC32
                     і CRC64.

              Цілісність заголовків .xz завжди перевіряють за допомогою CRC32.
              Таку перевірку не можна змінити або скасувати.

       --ignore-check
              Не  перевіряти  цілісність  стиснених  даних при розпаковуванні.
              Значення  CRC32  у  заголовках  .xz  буде  у  звичайний   спосіб
              перевірено попри цей параметр.

              Не   користуйтеся   цим  параметром,  якщо  ви  не  усвідомлюєте
              наслідків  ваших   дій.   Можливі   причини   скористатися   цим
              параметром:

              •  Спроба отримання даних з пошкодженого файла .xz.

              •  Пришвидшення   розпакування.   Це,   здебільшого,  стосується
                 SHA-256 або файлів із надзвичайно високим  рівнем  пакування.
                 Не  рекомендуємо  користуватися  цим параметром з цією метою,
                 якщо цілісність файлів не  буде  перевірено  у  якийсь  інший
                 спосіб.

       -0 ... -9
              Вибрати  рівень  стискання.  Типовим  є  -6.  Якщо  буде вказано
              декілька  рівнів   стискання,   програма   використає   останній
              вказаний.  Якщо  вже  було  вказано нетиповий ланцюжок фільтрів,
              встановлення  рівня  стискання  призведе   до   нехтування   цим
              нетиповим ланцюжком фільтрів.

              Різниця  між  рівнями  є  суттєвішою,  ніж у gzip(1) і bzip2(1).
              Вибрані параметри стискання визначають вимоги до пам'яті під час
              розпаковування, отже використання надто високого рівня стискання
              може призвести  до  проблем  під  час  розпаковування  файла  на
              застарілих комп'ютерах із невеликим обсягом оперативної пам'яті.
              Зокрема, не варто використовувати -9 для  усього,  як  це  часто
              буває для gzip(1) і bzip2(1).

              -0 ... -3
                     Це  дещо швидші набори налаштувань. -0 іноді є швидшим за
                     gzip  -9,  забезпечуючи   набагато   більший   коефіцієнт
                     стискання.  Вищі  рівні  часто мають швидкість, яку можна
                     порівняти з bzip2(1) із подібним або кращим  коефіцієнтом
                     стискання,  хоча  результати  значно  залежать  від  типу
                     даних, які стискають.

              -4 ... -6
                     Стискання від доброго до дуже доброго рівня із одночасним
                     підтриманням  помірного  рівня споживання пам'яті засобом
                     розпаковування, навіть для застарілих системи. Типовим  є
                     значення -6, яке є добрим варіантом для поширення файлів,
                     які мають бути  придатними  до  розпаковування  навіть  у
                     системах із лише 16 МіБ оперативної пам'яті. (Також можна
                     розглянути варіанти -5e і -6e. Див. --extreme.)

              -7 ... -9
                     Ці варіанти подібні до -6, але із  вищими  вимогами  щодо
                     пам'яті  для  стискання  і  розпаковування.  Можуть  бути
                     корисними  лише  для  стискання  файлів  з  розміром,  що
                     перевищує 8 МіБ, 16 МіБ та 32 МіБ, відповідно.

              На  однаковому  обладнанні  швидкість  розпакування  є приблизно
              сталою кількістю  байтів  стиснених  даних  за  секунду.  Іншими
              словами,  чим  кращим  є  стискання, тим швидшим буде, зазвичай,
              розпаковування.  Це  також  означає,   що   об'єм   розпакованих
              виведених  даних, які видає програма за секунду, може коливатися
              у широкому діапазоні.

              У наведеній нижче таблиці підсумовано можливості шаблонів:

                     Шаблон   DictSize   CompCPU   CompMem   DecMem
                       -0     256 КіБ       0        3 МіБ    1 МіБ
                       -1       1 МіБ       1        9 МіБ    2 МіБ
                       -2       2 МіБ       2       17 МіБ    3 МіБ
                       -3       4 МіБ       3       32 МіБ    5 МіБ
                       -4       4 МіБ       4       48 МіБ    5 МіБ
                       -5       8 МіБ       5       94 МіБ    9 МіБ
                       -6       8 МіБ       6       94 МіБ    9 МіБ
                       -7      16 МіБ       6      186 МіБ   17 МіБ
                       -8      32 МіБ       6      370 МіБ   33 МіБ
                       -9      64 МіБ       6      674 МіБ   65 МіБ

              Описи стовпчиків:

              •  DictSize є розміром словника  LZMA2.  Використання  словника,
                 розмір  якого  перевищує  розмір нестисненого файла, — проста
                 витрата пам'яті. Ось чому не варто використовувати шаблони -7
                 ...  -9,  якщо у них немає реальної потреби. Для -6 та нижчих
                 рівнів об'єм витраченої пам'яті, зазвичай, такий низький,  що
                 цей фактор ні на що не впливає.

              •  CompCPU  є  спрощеним  представленням  параметрів  LZMA2, які
                 впливають  на  швидкість  стискання.  Розмір  словника  також
                 впливає на швидкість, тому, хоча значення CompCPU є однаковим
                 для рівнів -6 ... -9, обробка на  вищих  рівнях  все  одно  є
                 трошки повільнішою. Що отримати повільніше і, ймовірно, краще
                 стискання, див. --extreme.

              •  CompMem  містить  вимоги  до  пам'яті  засобу   стискання   у
                 однопотоковому  режимі. Значення можуть бути дещо різними для
                 різних  версій  xz.  Вимоги  до  пам'яті   деяких   майбутніх
                 багатопотокових  режимів  можуть  бути  набагато  вищими, ніж
                 вимоги у однопотоковому режимі.

              •  У DecMem містяться  вимоги  до  пам'яті  при  розпаковуванні.
                 Тобто параметри засобу стискання визначають вимоги до пам'яті
                 при розпаковуванні. Точний об'єм пам'яті,  яка  потрібна  для
                 розпаковування,  дещо  перевищує  розмір  словника LZMA2, але
                 значення  у  таблиці  було  округлено  до  наступного  цілого
                 значення МіБ.

       -e, --extreme
              Використати  повільніший  варіант  вибраного рівня стискання (-0
              ... -9) у сподіванні отримати трохи кращий коефіцієнт стискання,
              але,  якщо  не поталанить, можна його і погіршити. Не впливає на
              використання  пам'яті  при  розпаковуванні,   але   використання
              пам'яті при стисканні дещо збільшиться на рівнях -0 ... -3.

              Оскільки  існує  два  набори  налаштувань із розмірами словників
              4 МіБ та 8 МіБ, у наборах -3e і -5e  використано  трошки  швидші
              параметри  (нижче CompCPU), ніж у наборах -4e і -6e, відповідно.
              Тому двох однакових наборів у списку немає.

                     Шаблон   DictSize   CompCPU   CompMem   DecMem
                      -0e     256 КіБ       8        4 МіБ    1 МіБ
                      -1e       1 МіБ       8       13 МіБ    2 МіБ
                      -2e       2 МіБ       8       25 МіБ    3 МіБ
                      -3e       4 МіБ       7       48 МіБ    5 МіБ
                      -4e       4 МіБ       8       48 МіБ    5 МіБ
                      -5e       8 МіБ       7       94 МіБ    9 МіБ
                      -6e       8 МіБ       8       94 МіБ    9 МіБ
                      -7e      16 МіБ       8      186 МіБ   17 МіБ
                      -8e      32 МіБ       8      370 МіБ   33 МіБ
                      -9e      64 МіБ       8      674 МіБ   65 МіБ

              Наприклад, передбачено  загалом  чотири  набори  налаштувань  із
              використанням  словника у 8 МіБ, порядок яких від найшвидшого до
              найповільнішого є таким: -5, -6, -5e і -6e.

       --fast
       --best Це дещо оманливі альтернативні варіанти для -0 і -9, відповідно.
              Реалізовано  лише  для забезпечення зворотної сумісності із LZMA
              Utils. Намагайтеся не користуватися цими варіантами параметрів.

       --block-size=розмір
              При стисканні до формату .xz поділити вхідні  дані  на  блоки  у
              розмір байтів. Ці блоки буде стиснуто незалежно один від одного,
              що  допоможе  у  багатопотоковій  обробці  і  зробить   можливим
              обмежене  розпакування  для  доступу  до  будь-яких  даних.  Цим
              параметром слід типово користуватися для перевизначення типового
              розміру   блоку  у  багатопотоковому  режимі  обробки,  але  цим
              параметром можна  також  скористатися  в  однопотоковому  режимі
              обробки.

              У  багатопотоковому  режимі для кожного потоку буде отримано для
              буферів вхідних і вихідних даних майже утричі більше  за  розмір
              байтів.  Типовий  розмір утричі більший за розмір словника LZMA2
              або дорівнює 1 МіБ, буде вибрано більше значення. Типовим добрим
              значенням  буде  значення,  яке  у  2–4  рази  перевищує  розмір
              словника  LZMA2  або  дорівнює  принаймні  1  МіБ.  Використання
              значення  розмір,  яке  є  меншим  за розмір словника LZMA2, має
              наслідком  марну  витрату  оперативної  пам'яті,  оскільки  його
              використання  призводить до того, що буфер словника LZMA2 ніколи
              не буде використано повністю. Розміри блоків  зберігатимуться  у
              заголовках  блоків, які майбутня версія xz використовуватиме для
              багатопотокового розпаковування.

              У   однопотоковому   режимі   поділ   на   блоки    типово    не
              виконуватиметься.  Встановлення  значення для цього параметра не
              впливатиме на  використання  пам'яті.  У  заголовках  блоків  не
              зберігатимуться  дані  щодо  розміру, отже файли, які створено в
              однопотоковому режимі  не  будуть  ідентичними  до  файлів,  які
              створено  у  багатопотоковому режимі. Те, що у заголовках блоків
              не зберігатимуться дані щодо розміру також означає, що  майбутні
              версії xz не зможуть розпаковувати такі файли у багатопотоковому
              режимі.

       --block-list=розміри
              При стисканні у форматі .xz починати новий блок  після  вказаної
              кількості інтервалів нестиснених даних.

              Значення  розмірів  розпакованих  блоків слід задавати у форматі
              списку відокремлених комами значень. Якщо розмір пропущено  (дві
              або   декілька   послідовних   коми),  буде  використано  розмір
              попереднього блоку.

              Якщо файл вхідних даних є більшим за розміром за суму  розмірів,
              останнє  значення  у  розмірах  буде  повторено  до кінця файла.
              Особливе значення 0 може бути використано як  останнє  значення,
              щоб  позначити,  що  решту  файла  має бути закодовано як єдиний
              блок.

              Якщо вказати розміри, які перевищують розмір блоку  кодувальника
              (або типове значення у режимі із потоками обробки, або значення,
              яке  встановлено  за   допомогою   --block-size=розмір),   засіб
              кодування створить додаткові блоки, зберігаючи межі, які вказано
              у   розмірах.   Наприклад,   якщо   вказати   --block-size=10MiB
              --block-list=5MiB,10MiB,8MiB,12MiB,24MiB,  а  файл вхідних даних
              має розмір 80 МіБ, буде отримано такі 11 блоків: 5, 10,  8,  10,
              2, 10, 10, 4, 10, 10 і 1 МіБ.

              У   багатопотоковому  режимі  розмір  блоків  буде  збережено  у
              заголовках  блоків.  Програма   не   зберігатиме   ці   дані   у
              однопотоковому   режимі,  отже  закодований  результат  не  буде
              ідентичним до отриманого у багатопотоковому режимі.

       --flush-timeout=час_очікування
              При стискання, якщо з моменту попереднього витирання мине  понад
              час_очікування  мілісекунд  (додатне  ціле  значення)  і читання
              додаткових даних буде  заблоковано,  усі  вхідні  дані  у  черзі
              обробки  буде  витерто  з  кодувальника  і  зроблено доступним у
              потоці  вихідних  даних.  Це  може  бути   корисним,   якщо   xz
              використовують   для  стискання  даних,  які  передають  потоком
              мережею. Невеликі  значення  аргументу  час_очікування  зроблять
              дані  доступними  на боці отримання із малою затримкою, а великі
              значення аргумент час_очікування уможливлять  кращий  коефіцієнт
              стискання.

              Типово,  цю  можливість  вимкнено.  Якщо  цей  параметр  вказано
              декілька разів, буде використано лише останнє вказане  значення.
              Особливим  значенням  аргументу  час_очікування, рівним 0, можна
              скористатися для вимикання цієї можливості явним чином.

              Ця можливість недоступна у системах, які не є системами POSIX.

              Ця можливість усе ще є експериментальною. У поточній версії,  xz
              не  може розпаковувати потік даних у режимі реального часу через
              те, у який спосіб xz виконує буферизацію.

       --memlimit-compress=обмеження
              Встановити обмеження на використання пам'яті при стисканні. Якщо
              цей параметр вказано декілька разів, враховано буде лише останнє
              вказане значення.

              Якщо  параметри  стискання  перевищують  обмеження,  xz  спробує
              скоригувати  параметри  так, щоб обмеження не було перевищено, і
              покаже  повідомлення  про  те,  що  було  виконано   автоматичне
              коригування.   Коригування   буде  виконано  у  такому  порядку:
              зменшення кількості потоків обробки, перемикання у однопотоковий
              режим,  якщо  хоч  в  одному потоці багатопотокового режиму буде
              перевищено обмеження,  і  нарешті,  зменшення  розміру  словника
              LZMA2.

              При  стисканні  з  використанням  --format=raw,  або  якщо  було
              вказано --no-adjust, може бути зменшена лише  кількість  потоків
              обробки,  оскільки  це може бути зроблено без впливу на стиснені
              виведені дані.

              Якщо обмеження не може бути виконано  за  допомогою  коригувань,
              які  описано  вище, буде показано повідомлення про помилку, а xz
              завершить роботу зі станом виходу 1.

              Аргумент обмеження можна вказати у декілька способів:

              •  Значенням обмеження може бути додатне ціле значення у байтах.
                 Можна  скористатися  цілочисельним суфіксом, подібним до MiB.
                 Приклад: --memlimit-compress=80MiB

              •  Аргумент обмеження може бути задано у відсотках від загальної
                 фізичної   пам'яті  системи  (RAM).  Це  може  бути  корисним
                 особливо при встановленні змінної  середовища  XZ_DEFAULTS  у
                 скрипті  ініціалізації  системи,  який  є спільним для різних
                 комп'ютерів.  У  такий  спосіб  можна  вказати  вищий  рівень
                 обмеження  для  систем  із  більшим об'ємом пам'яті. Приклад:
                 --memlimit-compress=70%

              •  Аргументу  обмеження  може  бути  повернуто  типове  значення
                 встановленням  значення  0. У поточній версії це еквівалентно
                 до  встановлення  значення  аргументу  обмеження   max   (без
                 обмеження на використання пам'яті).

              Для  32-бітової  версії  xz  передбачено особливий випадок: якщо
              обмеження   перевищуватиме   4020 МіБ,   для   обмеження    буде
              встановлено  значення  4020 MiB.  На  MIPS32  замість цього буде
              використано  2000 MiB.  (Це  не  стосується  значень  0  і  max.
              Подібної  можливості  для розпаковування не існує.) Це може бути
              корисним,  коли  32-бітовий  виконуваний  файл  має  доступ   до
              простору адрес у 4 ГіБ (2 GiB на MIPS32), хоча, сподіваємося, не
              зашкодить і в інших випадках.

              Див. також розділ Використання пам'яті.

       --memlimit-decompress=обмеження
              Встановити обмеження пам'яті на розпаковування. це також  вплине
              на   режим   --list.  Якщо  дія  є  неможливою  без  перевищення
              обмеження, xz покаже повідомлення про помилку  і  розпаковування
              файла  не  відбудеться.  Див. --memlimit-compress=обмеження, щоб
              дізнатися більше про те, як можна задати обмеження.

       --memlimit-mt-decompress=обмеження
              Встановити обмеження використання пам'яті  для  багатопотокового
              розпаковування.  Це  може  вплинути  лише  на  кількість потоків
              обробки;  це  ніколи   не   призводитиме   до   відмови   xz   у
              розпаковуванні  файла.  Якщо  обмеження  є  надто  низьким,  щоб
              уможливити  будь-яку  багатопотокову  обробку,  обмеження   буде
              проігноровано,  і xz продовжить обробку в однопотоковому режимі.
              Зауважте, що якщо використано також  --memlimit-decompress,  цей
              параметр  буде  застосовано  до  обох режимів, однопотокового та
              багатопотокового, а отже, задіяне обмеження для багатопотокового
              режиму  ніколи  не  перевищуватиме обмеження, яке встановлено за
              допомогою --memlimit-decompress.

              На відміну від інших параметрів обмеження використання  пам'яті,
              --memlimit-mt-decompress=обмеження    містить   специфічне   для
              системи  типове  значення  обмеження.  Можна   скористатися   xz
              --info-memory для перегляду поточного значення.

              Цей  параметр  і  його  типове  значення  існують,  оскільки без
              будь-яких обмежень засіб розпакування  зі  підтримкою  потокової
              обробки  міг би намагатися отримати величезний об'єм пам'яті для
              деяких файлів вхідних  даних.  Якщо  типове  обмеження  є  надто
              низьким  для вашої системи, не вагайтеся і збільшуйте обмеження,
              але ніколи не встановлюйте для нього значення, яке є більшим  за
              придатний до користування об'єм оперативної пам'яті, оскільки за
              відповідних файлів вхідних даних  xz  спробує  скористатися  цим
              об'ємом  пам'яті,  навіть  із низькою кількістю потоків обробки.
              Вичерпання об'єму оперативної пам'яті або використання резервної
              пам'яті   на  диску  не  покращить  швидкодію  системи  під  час
              розпаковування.

              Див.   --memlimit-compress=обмеження,   щоб   ознайомитися    із
              можливими   способами  визначення  обмеження.  Встановлення  для
              обмеження значення 0 відновлює  типове  специфічне  для  системи
              значення обмеження.

       -M обмеження, --memlimit=обмеження, --memory=обмеження
              Є  еквівалентом  визначення --memlimit-compress=обмеження --mem‐
              limit-decompress=обмеження --memlimit-mt-decompress=обмеження.

       --no-adjust
              Показати повідомлення про помилку і завершити  роботу,  якщо  не
              вдасться  виконати умови щодо обмеження використання пам'яті без
              коригування параметрів, які  впливають  на  стиснених  виведених
              даних.   Тобто   це   забороняє   xz  перемикати  кодувальник  з
              багатопотокового режиму  на  однопотоковий  режим  і  зменшувати
              розмір  словника  LZMA2.  Навіть  якщо використано цей параметр,
              кількість потоків може бути зменшено для виконання обмеження  на
              використання  пам'яті,  оскільки  це  не  вплине  на  результати
              стискання.

              Автоматичне  коригування  завжди  буде  вимкнено  при  створенні
              потоків необроблених даних (--format=raw).

       -T потоки, --threads=потоки
              Вказати  кількість  потоків  обробки,  якими  слід скористатися.
              Встановлення для аргументу потоки особливого значення 0  наказує
              xz  використати  не  більше  потоків  обробки,  ніж  передбачено
              підтримку у процесорах системи. Справжня кількість потоків  може
              бути  меншою  за  значення  потоки, якщо файл вхідних даних не є
              достатньо великим для  поділу  на  потоки  обробки  при  заданих
              параметрах  або якщо використання додаткових потоків призведе до
              перевищення обмеження на використання пам'яті.

              Засоби стискання в  однопотоковому  та  багатопотоковому  режимі
              дають  різні  результати.  Однопотоковий  засіб  стискання дасть
              найменший   розмір   файла,   але   лише    результати    роботи
              багатопотокового   засобу  стискання  може  бути  розпаковано  з
              використанням  декількох  потоків.  Встановлення  для  аргументу
              потоки   значення  1  призведе  до  використання  однопотокового
              режиму. Встановлення  для  аргументу  потоки  будь-якого  іншого
              значення, включно з 0, призведе до використання багатопотокового
              засобу стискання, навіть якщо у  системі  передбачено  підтримки
              лише  одного апаратного потоку обробки даних. (Версія xz 5.2.x у
              цьому випадку використовувала однопотоковий режим.)

              Щоб скористатися багатопотоковим режимом із лише  одним  потоком
              обробки,  встановіть для аргументу потоки значення +1. Префікс +
              не впливає на  значення,  окрім  1.  Обмеження  на  використання
              пам'яті  можуть  перемкнути  xz  в  однопотоковий режим, якщо не
              використано параметр --no-adjust. Підтримку + prefix було додано
              у версії xz 5.4.0.

              Якщо  було вказано автоматичне визначення кількості потоків і не
              вказано обмеження  на  використання  пам'яті,  буде  використано
              специфічне  для  системи  типове  м'яке  обмеження для можливого
              обмеження кількості потоків обробки. Це  обмеження  є  м'яким  у
              сенсі  того,  що його буде проігноровано, якщо кількість потоків
              зрівняється з  одиницею,  а  отже,  м'яке  обмеження  ніколи  не
              запобігатиму  у xz стисканню або розпаковуванню. Це типове м'яке
              обмеження  не  перемкне  xz   з   багатопотокового   режиму   на
              однопотоковий  режим.  Активні  обмеження  можна  переглянути за
              допомогою команди xz --info-memory.

              У поточній версії єдиним способом поділу  на  потоки  обробки  є
              поділ  вхідних  даних  на блоки і стискання цих блоків незалежно
              один  від  одного.  Типовий  розмір  блоку  залежить  від  рівня
              стискання.  Його  може бути перевизначено за допомогою параметра
              --block-size=розмір.

              Розпакування з потоками обробки  працює  лише  для  файлів,  які
              містять  декілька  блоків  із  даними  щодо розміру у заголовках
              блоків. Цю умову задовольняють усі достатньо великі  файли,  які
              стиснено   у   багатопотоковому  режимі,  але  не  задовольняють
              будь-які файли,  які  було  стиснуто  у  однопотоковому  режимі,
              навіть якщо було використано параметр --block-size=розмір.

   Нетипові ланцюжки фільтрів засобу стискання
       Нетиповий   ланцюжок   фільтрування   уможливлює   докладне  визначення
       параметрів стискання замість використання параметрів, які пов'язано  із
       наперед  визначеними рівнями стискання. Якщо вказано нетиповий ланцюжок
       фільтрів, параметри рівнів стискання  (-0  ...  -9  і  --extreme),  які
       передують  їм  у  рядку  команди,  буде знехтувано. Якщо параметр рівня
       стискання вказано після  одного  або  декількох  параметрів  нетипового
       ланцюжка  фільтрів,  буде  використано  рівень стискання, а попередніми
       параметрами ланцюжка фільтрування буде знехтувано.

       Ланцюжок фільтрів можна порівняти із конвеєром у командному рядку.  При
       стисканні  нестиснені  вхідні  дані  потрапляють  до  першого  фільтра,
       виведені ним дані йдуть до наступного фільтра (якщо такий є).  Виведені
       останнім  фільтром  дані буде записано до стисненого файла. Максимальна
       кількість  фільтрів  у  ланцюжку  дорівнює  чотирьом,  але  у  типовому
       ланцюжку фільтрів використовують один або два фільтри.

       У  багатьох  фільтрів  є  обмеження  на  місце  перебування  у ланцюжку
       фільтрів: деякі фільтри можуть працювати, лише якщо вони є останніми  у
       ланцюжку,  деякі,  лише якщо не останніми, а деякі працюють у будь-якій
       позиції  ланцюжка.  Залежно  від  фільтра,  це  обмеження  є  наслідком
       структури фільтра або існує для запобігання проблем із захистом.

       Нетиповий   ланцюжок   фільтрів  визначають  за  допомогою  одного  або
       декількох параметрів фільтрування у бажаному для ланцюжка  фільтрування
       порядку.  Тобто  порядок  параметрів фільтрування впливає на результат!
       При декодуванні  необробленого  потоку  даних  (--format=raw)  ланцюжок
       фільтрів  визначають  у  тому  самому  порядку, який використовують для
       стискання даних.

       Фільтри приймають специфічні для фільтрів параметри  у  форматі  списку
       значень,   які  відокремлено  комами.  Зайві  коми  у  параметрах  буде
       проігноровано. У кожного параметра є типове значення,  отже,  вам  слід
       вказати лише ті параметри, значення яких ви хочете змінити.

       Щоб  переглянути  увесь  ланцюжок  фільтрів та параметри, скористайтеся
       командою xz -vv (тобто, скористайтеся --verbose двічі). Це працює також
       для  перегляду  параметрів ланцюжка фільтрів, який використано у рівнях
       стискання.

       --lzma1[=параметри]
       --lzma2[=параметри]
              Додати фільтр LZMA1 або LZMA2 до ланцюжка фільтрів.  Ці  фільтри
              може бути використано лише як останній фільтр у ланцюжку.

              LZMA1  є  застарілим  фільтром,  підтримку якого збережено майже
              лише через використання формату файлів .lzma, у яких передбачено
              підтримку  лише  LZMA1.  LZMA2 є оновленою версією LZMA1, у якій
              виправлено деякі практичні вади LZMA1. У форматі .xz використано
              LZMA2  і  взагалі  не  передбачено  підтримки  LZMA1.  Швидкість
              стискання та коефіцієнт стискання для LZMA1 і LZMA2 є  практично
              однаковими.

              LZMA1 і LZMA2 спільно використовують той самий набір параметрів:

              preset=шаблон
                     Скинути  усі  параметри  LZMA1  або  LZMA2  до параметрів
                     шаблона. Аргумент  шаблон  складається  з  цілого  числа,
                     після  якого  може бути однолітерний модифікатор шаблона.
                     Ціле число може належати лише діапазону від 0  до  9,  що
                     відповідає  параметрам командного рядка -0 ... -9. Єдиним
                     підтримуваним модифікатором у поточній версії  є  e,  щоб
                     відповідає  параметру  --extreme. Якщо аргумент шаблон не
                     вказано, типові значення параметрів LZMA1 або LZMA2  буде
                     взято із шаблона 6.

              dict=розмір
                     Параметр  розміру  словника  (буфера  журналу)  визначає,
                     скільки байтів  нещодавно  оброблених  нестиснених  даних
                     слід  зберігати  у  пам'яті.  Алгоритм намагається знайти
                     повторювані   послідовності   байтів   (відповідники)   у
                     нестиснених  даних  і замінити їх на посилання на дані зі
                     словника. Чим більшим є словник, тим вищою є  ймовірність
                     відшукати відповідник. Отже, збільшення розміру словника,
                     зазвичай, покращує коефіцієнт стискання, але використання
                     словника,  розмір  якого  перевищу  є розмір нестисненого
                     файла є простоюю витратою пам'яті.

                     Розмір типового словника складає від  64 КіБ  до  64 МіБ.
                     Мінімальним  є  розмір  4 КіБ.  Максимальним розміром для
                     стискання у поточній версії 1.5 ГіБ (1536 МіБ). У  засобі
                     розпаковування  вже  передбачено  підтримку  словників на
                     один байт менших за 4 ГіБ, що  є  максимальним  значенням
                     для форматів потоків даних LZMA1 і LZMA2.

                     Аргумент  розміру  словника  і засіб пошуку відповідників
                     (mf) разом визначають параметри використання пам'яті  для
                     кодувальника LZMA1 або LZMA2. Для розпаковування потрібен
                     такий самий (або  більший)  розмір  словника,  що  і  для
                     стискання,   отже,   використання   пам'яті   для  засобу
                     розпаковування буде визначено за розміром словника,  який
                     було   використано   для   стискання.  У  заголовках  .xz
                     зберігається розмір словника або як 2^n,  або  як  2^n  +
                     2^(n-1),  отже,  ці  розміри  є  дещо  пріоритетними  для
                     стискання. Інші розміри  буде  отримано  округленням  при
                     зберіганні у заголовках .xz.

              lc=lc  Визначає    кількість   буквальних   контекстних   бітів.
                     Мінімальною кількістю є 0, а максимальною  —  4.  Типовою
                     кількістю   є   3.  Крім  того,  сума  lc  і  lp  має  не
                     перевищувати 4.

                     Усі байти, які не може бути закодовано як  відповідності,
                     буде  закодовано  як  літерали.  Тобто  літерали є просто
                     8-бітовими байтами, які буде закодовано по одному за раз.

                     При кодуванні літералів роблять  припущення,  що  найвищі
                     біти  lc  попереднього  нестисненого  байта  корелюють із
                     наступним   байтом.   Наприклад,   у   типовому    тексті
                     англійською  за літерою у верхньому регістрі йде літера у
                     нижньому регістрі, а  за  літерою  у  нижньому  регістрі,
                     зазвичай,  йде  інша літера у нижньому регістрі. У наборі
                     символів US-ASCII найвищими трьома бітами є 010 для літер
                     верхнього  регістру  і  011  для літер нижнього регістру.
                     Якщо lc дорівнює принаймні  3,  при  кодуванні  літералів
                     можна отримати перевагу встановлення цієї властивості для
                     нестиснених даних.

                     Зазвичай,  типового  значення  (3)  достатньо.  Якщо  вам
                     потрібне  максимальне стискання, спробуйте lc=4. Іноді це
                     трохи допомагає, а іноді, робить стискання  гіршим.  Якщо
                     стискання стане гіршим, спробуйте також lc=2.

              lp=lp  Визначає    кількість    буквальних   позиційних   бітів.
                     Мінімальною кількістю є 0, а максимальною  —  4.  Типовою
                     кількістю є 0.

                     Lp  впливає  на  те, яке вирівнювання у нестиснених даних
                     слід припускати при кодуванні літералів. Див.  pb  нижче,
                     щоб дізнатися більше про вирівнювання.

              pb=pb  Визначає    кількість   позиційних   бітів.   Мінімальною
                     кількістю є 0, а максимальною — 4. Типовою кількістю є 2.

                     Pb  впливає  на  те,  який   тип   вирівнювання   загалом
                     припускатиметься   для   нестиснених   даних.  Типовим  є
                     чотирибайтове вирівнювання (2^pb=2^2=4), яке, зазвичай, є
                     добрим варіантом, якщо немає кращих припущень.

                     Якщо  вирівнювання  є  відомим,  встановлення відповідним
                     чином pb може трохи зменшити розмір файла.  Наприклад,  у
                     текстових файлах із однобайтовим вирівнюванням (US-ASCII,
                     ISO-8859-*, UTF-8), встановлення значення pb=0 може трохи
                     поліпшити стискання. Для тексту UTF-16 добрим варіантом є
                     pb=1. Якщо вирівнювання є непарним  числом,  наприклад  3
                     байти, найкращим вибором, ймовірно, є pb=0.

                     Хоча   прогнозоване  вирівнювання  можна  скоригувати  за
                     допомогою pb і lp, у LZMA1 і LZMA2  дещо  пріоритетним  є
                     16-байтове  вирівнювання.  Це, ймовірно, слід враховувати
                     при компонуванні форматів файлів,  які,  ймовірно,  часто
                     будуть стискатися з використанням LZMA1 або LZMA2.

              mf=mf  Засіб   пошуку   відповідників   має   значний  вплив  на
                     швидкість, використання пам'яті та  коефіцієнт  стискання
                     кодувальника.  Зазвичай,  засоби  пошуку відповідників на
                     основі  ланцюжка  хешів  є  швидшими  за  засоби   пошуку
                     відповідників  на основі двійкового дерева. Типовий засіб
                     залежить від шаблона: для 0 використовують hc3, для 1–3 —
                     hc4, а для решти використовують bt4.

                     Передбачено   підтримку  вказаних  нижче  засобів  пошуку
                     відповідників.   Наведені   нижче   формули    обчислення
                     використання   пам'яті  є  грубими  наближеннями,  які  є
                     найближчими до реальних значень, якщо значенням словник є
                     степінь двійки.

                     hc3    Ланцюжок хешів із 2- та 3-байтовим хешуванням
                            Мінімальне значення пріоритетності: 3
                            Використання пам'яті:
                            dict * 7.5 (якщо dict <= 16 МіБ);
                            dict * 5.5 + 64 МіБ (якщо dict > 16 МіБ)

                     hc4    Ланцюжок хешів із 2-, 3- та 4-байтовим хешуванням
                            Мінімальне значення пріоритетності: 4
                            Використання пам'яті:
                            dict * 7.5 (якщо dict <= 32 МіБ);
                            dict * 6.5 (якщо dict > 32 МіБ)

                     bt2    Двійкове дерево із 2-байтовим хешуванням
                            Мінімальне значення пріоритетності: 2
                            Використання пам'яті: dict * 9.5

                     bt3    Двійкове дерево із 2- і 3-байтовим хешуванням
                            Мінімальне значення пріоритетності: 3
                            Використання пам'яті:
                            dict * 11.5 (якщо dict <= 16 МіБ);
                            dict * 9.5 + 64 МіБ (якщо dict > 16 МіБ)

                     bt4    Двійкове дерево із 2-, 3- і 4-байтовим хешуванням
                            Мінімальне значення пріоритетності: 4
                            Використання пам'яті:
                            dict * 11.5 (якщо dict <= 32 МіБ);
                            dict * 10.5 (якщо dict > 32 МіБ)

              mode=режим
                     Параметр  режиму  стискання  визначає  спосіб,  який буде
                     використано  для  аналізу  даних,  які  створено  засобом
                     пошуку  відповідників.  Підтримуваними  режимами  є  fast
                     (швидкий) і normal (нормальний). Типовим є режим fast для
                     шаблонів 0–3 і режим normal для шаблонів 4–9.

                     Зазвичай,  із  засобом  пошуку  відповідників  на  основі
                     ланцюжка хешів використовують fast, а із  засобом  пошуку
                     відповідників  на основі двійкового дерева використовують
                     normal. Так само налаштовано і шаблони.

              nice=пріоритетність
                     Вказати, яка довжина є  пріоритетною  для  відповідності.
                     Щойно    буде    виявлено   відповідність   у   принаймні
                     пріоритетність байтів, алгоритм зупинятиме пошук можливих
                     кращих відповідників.

                     Пріоритетністю  може  бути  число  до  2–273 байтів. Вищі
                     значення дають кращий  коефіцієнт  стискання  за  рахунок
                     швидкості. Типове значення залежить від шаблона.

              depth=глибина
                     Вказати   максимальну  глибину  пошуку  у  засобі  пошуку
                     відповідності. Типовим є особливе значення 0, яке наказує
                     засобу стискання визначити прийнятну глибину на основі mf
                     і пріоритетності.

                     Прийнятним значенням глибини для ланцюжків хешів є  4–100
                     і  16–1000 для двійкових дерев. Використання дуже високих
                     значень  для  глибини  може  зробити   кодувальник   дуже
                     повільним  для  деяких  файлів.  Не встановлюйте значення
                     глибини, що перевищує 1000, якщо ви не  готові  перервати
                     стискання, якщо воно триватиме надто довго.

              При декодуванні необроблених потоків даних (--format=raw), LZMA2
              потребує лише розміру словника. LZMA1 потребує також  lc,  lp  і
              pb.

       --x86[=параметри]
       --arm[=параметри]
       --armthumb[=параметри]
       --arm64[=параметри]
       --powerpc[=параметри]
       --ia64[=параметри]
       --sparc[=параметри]
              Додати  фільтр  гілок/викликів/переходів  (branch/call/jump  або
              BCJ) до ланцюжка фільтрів. Цими  фільтрами  можна  скористатися,
              лише якщо вони не є останнім фільтром у ланцюжку фільтрів.

              Фільтр  BCJ  перетворює відносні адреси у машинному коді на їхні
              абсолютні відповідники. Це не змінює розміру даних, але підвищує
              резервування,  що  може  допомогти  LZMA2  створити  файл .xz на
              0–15 % менше. Фільтри BCJ завжди є придатними до обернення, тому
              використання   фільтра   BCJ   до   помилкового  типу  даних  не
              спричинятиме втрати даних, хоча може дещо  погіршити  коефіцієнт
              стискання.   Фільтри   BCJ   є   дуже   швидкими  і  такими,  що
              використовують незначний об'єм пам'яті.

              Ці фільтри BCJ мають відомі проблеми, які  пов'язано  із  рівнем
              стискання:

              •  У  деяких  типах  файлів,  де  зберігається  виконуваний код,
                 (наприклад, в  об'єктних  файлах,  статичних  бібліотеках  та
                 модулях ядра Linux) адреси в інструкціях заповнено значеннями
                 заповнювача.  Ці  фільтри  BCJ  виконуватимуть   перетворення
                 адрес, яке зробить стискання для цих файлів гіршим.

              •  Якщо  фільтр  BCJ застосовано до архіву, може так статися, що
                 він погіршить коефіцієнт стискання порівняно із варіантом без
                 фільтра  BCJ.  Наприклад,  якщо є подібні або навіть однакові
                 виконувані файли, фільтрування, ймовірно,  зробить  ці  файли
                 менш  подібними,  а  отже,  зробить  стискання  гіршим. Вміст
                 файлів, які не є виконуваними, у  тому  самому  архіві  також
                 може  вплинути  на  результат.  На практиці, варто спробувати
                 варіанти з фільтром BCJ і без нього, щоб визначитися із  тим,
                 що буде кращим у кожній ситуації.

              Різні  набори  інструкцій  мають різне вирівнювання: виконуваний
              файл має бути вирівняно на кратне до цього  значення  у  вхідних
              даних, щоб фільтр спрацював.

                     Фільтр      Вирівнювання    Нотатки
                     x86                   1     32-бітова або 64-бітова x86
                     ARM                   4
                     ARM-Thumb             2
                     ARM64                 4     Найкращим є вирівнювання за
                                                 4096 байтами
                     PowerPC               4     Лише зворотний порядок байтів
                     IA-64                16     Itanium
                     SPARC                 4

              Оскільки  фільтровані BCJ дані, зазвичай, стискають за допомогою
              LZMA2,  коефіцієнт  стискання  можна   трохи   поліпшити,   якщо
              параметри  LZMA2  буде  встановлено  так,  щоб  вони відповідали
              вирівнюванню вибраного фільтра BCJ. Наприклад, з фільтром  IA-64
              варто   встановити   pb=4  або  навіть  pb=4,lp=4,lc=0  з  LZMA2
              (2^4=16).  Фільтр  x86  є  винятком;   його,   зазвичай,   варто
              поєднувати  із  типовим  чотирибайтовим  вирівнюванням LZMA2 при
              стисканні виконуваних файлів x86.

              У всіх фільтрах BCJ передбачено підтримку тих самих параметрів:

              start=зсув
                     Встановити початковий зсув,  який  буде  використано  при
                     перетворенні   між   відносною  та  абсолютною  адресами.
                     Значення зсув має бути кратним  до  вирівнювання  фільтра
                     (див.  таблицю  вище).   Типовим  зсувом  є  нульовий. На
                     практиці,  типове  значення  є   прийнятним;   визначення
                     нетипового значення зсув майже завжди нічого корисного не
                     дає.

       --delta[=параметри]
              Додати дельта-фільтр до ланцюжка  фільтрів.  Дельта-фільтр  може
              бути  використано,  лише  якщо  він  не  є  останнім  у ланцюжку
              фільтрів.

              У поточній версії передбачено підтримку обчислення лише  простої
              побітової   дельти.   Це   може  бути  корисним  при  стисканні,
              наприклад,  нестиснутих  растрових  зображень  або   нестиснутих
              звукових даних PCM. Втім, спеціалізовані алгоритми можуть давати
              значно кращі результати за дельту + LZMA2. Це  правило  особливо
              стосується   звукових   даних,   які  стискає  швидше  і  краще,
              наприклад, flac(1).

              Підтримувані параметри:

              dist=відстань
                     Вказати відстань обчислень  різниці  у  байтах.  Значення
                     відстань   має   потрапляти  у  діапазон  1–256.  Типовим
                     значенням є 1.

                     Наприклад, з dist=2 та восьмибайтовими вхідними даними A1
                     B1  A2 B3 A3 B5 A4 B7, результатом буде A1 B1 01 02 01 02
                     01 02.

   Інші параметри
       -q, --quiet
              Придушити  попередження  та  сповіщення.  Вкажіть  цей  параметр
              двічі,   щоб  придушити  також  повідомлення  про  помилки.  Цей
              параметр не впливає на стан виходу  з  програми.  Тобто,  навіть
              якщо було придушено попередження, стан виходу вказуватиме на те,
              що попередження були.

       -v, --verbose
              Докладний режим повідомлень. Якщо стандартне  виведення  помилок
              з'єднано  із  терміналом,  xz  показуватиме  індикатор  поступу.
              Використання  --verbose  двічі  призведе  до   ще   докладнішого
              виведення.

              Індикатор поступу показує такі дані:

              •  Частку  завершеності буде показано, якщо відомий розмір файла
                 вхідних даних. Тобто, для каналів даних частку не  може  бути
                 показано.

              •  Об'єм  стиснених  виведених  даних (стискання) або оброблених
                 (розпаковування).

              •  Об'єм незапакованих даних  (стискання)  або  виведених  даних
                 (розпаковування).

              •  Коефіцієнт   стискання,   який   обчислено   діленням  об'єму
                 оброблених стиснутих даних на  об'єм  оброблених  нестиснутих
                 даних.

              •  Швидкість стискання або розпаковування. Обчислюється як об'єм
                 нестиснутих   даних   (стискання)   або    виведених    даних
                 (розпаковування)  за  секунду. Його буде показано за декілька
                 секунд з моменту, коли xz почала обробляти файл.

              •  Витрачений час у форматі Х:СС або Г:ХХ:СС.

              •  Оцінку часу, що лишився,  буде  показано,  лише  якщо  розмір
                 файла  вхідних  даних  є відомим, і минуло принаймні декілька
                 секунд з моменту, коли xz почала  обробляти  файл.  Час  буде
                 показано  у менш точному форматі, без двокрапок, наприклад, 2
                 хв. 30 с.

              Якщо стандартним виведенням помилок  не  є  термінал,  --verbose
              призведе  до  того,  що xz виведе назву файла, стиснений розмір,
              нестиснений розмір,  коефіцієнт  стискання  та,  можливо,  також
              швидкість  та  витрачений  час  у  одному  рядку до стандартного
              виведення помилок  після  стискання  або  розпаковування  файла.
              Швидкість  та витрачений час буде включено, лише якщо дія триває
              принаймні  декілька  секунд.  Якщо  дію   не   буде   завершено,
              наприклад,  через  втручання  користувача,  буде  також виведено
              частку виконання, якщо відомий розмір файла вхідних даних.

       -Q, --no-warn
              Не встановлювати  стан  виходу  2,  навіть  якщо  було  виявлено
              відповідність  умові,  яка  варта  попередження. Цей параметр не
              впливає  на   рівень   докладності   повідомлень,   отже,   слід
              використати  --quiet  і  --no-warn,  щоб  програма не показувала
              попереджень і не змінювала стан виходу.

       --robot
              Виводити  повідомлення  у  придатному  для  обробки  комп'ютером
              форматі.   Цей   формат   призначено  для  полегшення  написання
              оболонок, які використовуватимуть xz замість  liblzma,  що  може
              бути  зручним  для  різноманітних  скриптів. Виведені дані з цим
              параметром має бути стабільним для усіх випусків xz. Докладніший
              опис можна знайти у розділі РЕЖИМ РОБОТА.

       --info-memory
              Вивести  у  придатному  для  читання  людиною  форматі,  скільки
              фізичної пам'яті (RAM) та скільки потоків процесора є за  даними
              xz у системі, обмеження для стискання та розпаковування, а потім
              успішно завершити роботу.

       -h, --help
              Вивести повідомлення  про  помилку  з  описом  найбільш  типових
              використаних параметрів і успішно завершити роботу.

       -H, --long-help
              Вивести  довідкове  повідомлення  з описом усіх можливостей xz і
              успішно завершити роботу

       -V, --version
              Вивести номер версії  xz  та  liblzma  у  зручному  для  читання
              форматі.  Щоб  отримати  дані, зручні для обробки на комп'ютері,
              вкажіть --robot до --version.

РЕЖИМ РОБОТА
       Режим робота активують за  допомогою  параметра  --robot.  Він  спрощує
       обробку  виведених  xz  даних  іншими  програмами.  У  поточній  версії
       підтримку --robot передбачено лише разом із --version, --info-memory та
       --list.   У   майбутньому  підтримку  параметра  буде  передбачено  для
       стискання та розпаковування.

   Версія
       xz --robot --version виведе назву версії xz і liblzma у такому форматі:

       XZ_VERSION=XYYYZZZS
       LIBLZMA_VERSION=XYYYZZZS

       X      Основна версія.

       YYY    Проміжна версія. Непарні номери буде використано для  стабільних
              версій. Непарні номери є номерами тестових версій.

       ZZZ    Рівень  латання для стабільних випусків або просто лічильник для
              випусків, які перебувають у розробці.

       S      Стабільність. 0 — alpha,  1  —  beta,  а  2  означає  «стабільна
              версія». S має завжди дорівнювати 2, якщо YYY є парним.

       XYYYZZZS  є  тим  самим  в  обох  рядках, якщо xz і liblzma належать до
       одного випуску XZ Utils.

       Приклади: 4.999.9beta — це 49990091, а 5.0.0 — це 50000002.

   Дані щодо обмеження пам'яті
       xz --robot --info-memory виводить один рядок  з  трьома  відокремленими
       табуляціями стовпчиками:

       1.  Загальний об'єм фізичної пам'яті (RAM) у байтах.

       2.  Обмеження  на  використання  пам'яті для стискання у байтах (--mem‐
           limit-compress). Особливе значення 0 вказує на типові налаштування,
           якими  для  однопотокового  режиму  є налаштування без обмеження на
           використання пам'яті.

       3.  Обмеження на використання пам'яті для розпакування у байтах (--mem‐
           limit-decompress).   Особливе   значення   0   вказує   на   типові
           налаштування, якими для однопотокового режиму  є  налаштування  без
           обмеження на використання пам'яті.

       4.  Починаючи    з    xz    5.3.4alpha:    використання   пам'яті   для
           багатопотокового  розпаковування  у  байтах   (--memlimit-mt-decom‐
           press).  Ніколи  не  дорівнює  нулеві,  оскільки  буде  використано
           специфічне для системи типове значення, яке показано у стовпчику 5,
           якщо   обмеження  не  встановлено  явним  чином.  Також  ніколи  не
           перевищуватиме значення у стовпчику 3,  навіть  якщо  було  вказано
           більше значення за допомогою --memlimit-mt-decompress.

       5.  Починаючи  з xz 5.3.4alpha: специфічне для системи типове обмеження
           на використання пам'яті, яке використовують для обмеження кількості
           потоків    при   стисканні   з   автоматичною   кількістю   потоків
           (--threads=0) і без визначення обмеження  на  використання  пам'яті
           (--memlimit-compress).  Це  значення також використовують як типове
           значення для --memlimit-mt-decompress.

       6.  Починаючи з xz  5.3.4alpha:  кількість  доступних  потоків  обробки
           процесора.

       У  майбутньому  у  виведенні  xz --robot --info-memory може бути більше
       стовпчиків, але у виведеному буде не більше за один рядок.

   Режим списку
       У xz --robot --list використано табуляції для поділу  виведених  даних.
       Першим стовпчиком у кожному рядку є рядок, що вказує на тип відомостей,
       які можна знайти у цьому рядку:

       назва  Це  завжди  перший  рядок  на  початку  списку   файла.   Другим
              стовпчиком у рядку є назва файла.

       файл   У  цьому  рядку містяться загальні відомості щодо файла .xz. Цей
              рядок завжди виводять після рядка name.

       stream Цей тип рядка використовують, лише якщо було вказано  --verbose.
              Буде стільки рядків stream, скільки потоків у файлі .xz.

       block  Цей  тип рядка використовують, лише якщо було вказано --verbose.
              Буде стільки рядків block, скільки блоків  у  файлі  .xz.  Рядки
              block  буде показано після усіх рядків stream; різні типи рядків
              не перемежовуються.

       summary
              Цей тип рядків використовують, лише якщо --verbose було  вказано
              двічі.  Цей рядок буде виведено після усіх рядків block. Подібно
              до рядка file, рядок summary  містить  загальні  відомості  щодо
              файла .xz.

       totals Цей  рядок  завжди є найостаннішим рядком у виведеному списку. У
              ньому буде показано загальні кількості та розміри.

       Стовпчики у рядках файла:
              2.  Кількість потоків у файлі
              3.  Загальна кількість блоків у потоках
              4.  Розмір стисненого файла
              5.  Розмір нестисненого файла
              6.  Коефіцієнт  стискання,  наприклад,  0.123.  Якщо  коефіцієнт
                  перевищує  9.999,  замість  коефіцієнта буде показано дефіси
                  (---).
              7.  Список  відокремлених  комами  назв  перевірок   цілісності.
                  Наведені   нижче  рядки  використовують  для  відомих  типів
                  перевірок: None, CRC32, CRC64 і SHA-256. Для невідомих типів
                  перевірок буде використано Unknown-N, де N є ідентифікатором
                  перевірки у форматі десяткового числа (одна або дві цифри).
              8.  Загальний розмір доповнення потоку у файлі

       Стовпчики у рядках stream:
              2.  Номер потоку (перший потік має номер 1)
              3.  Кількість блоків у потоці
              4.  Зсув початку стисненого
              5.  Зсув початку нестисненого
              6.  Стиснений розмір (не включає доповнення потоку)
              7.  Нестиснутий розмір
              8.  Рівень стискання
              9.  Назва перевірки цілісності
              10. Розмір доповнення потоку

       Стовпчики у рядках block:
              2.  Номер потоку, що містить цей блок
              3.  Номер блоку відносно початку потоку (перший блок  має  номер
                  1)
              4.  Номер блоку відносно початку файла
              5.  Зсув початку стисненого відносно початку файла
              6.  Зсув початку нестисненого відносно початку файла
              7.  Загальний стиснений розмір блоку (включено з заголовками)
              8.  Нестиснутий розмір
              9.  Рівень стискання
              10. Назва перевірки цілісності

       Якщо  --verbose  було  вказано  двічі,  до  рядків  block буде включено
       додаткові стовпчики.  Ці  стовпчики  не  буде  показано,  якщо  вказано
       одинарний   параметр   --verbose,  оскільки  отримання  цих  відомостей
       потребує багатьох позиціювань, а ця процедура може бути повільною:
              11. Значення перевірки цілісності у шістнадцятковій формі
              12. Розмір заголовка блоку
              13. Прапорці блоку: c вказує, що наявний стиснений розмір,  а  u
                  вказує,  що  наявний  нестиснений  розмір. Якщо прапорець не
                  встановлено,   буде   показано   (-)   замість   підтримання
                  фіксованого  розміру  рядка.  У майбутньому наприкінці рядка
                  може бути додано нові прапорці.
              14. Розмір  справжніх  стиснених  даних  у  блоці  (це   включає
                  заголовок блоку, доповнення блоку та поля перевірок)
              15. Об'єм  пам'яті  (у байтах), який потрібен для розпаковування
                  цього блоку за допомогою цієї версії xz
              16. Ланцюжок фільтрів. Зауважте, що  більшість  параметрів,  які
                  використано   під  час  стискання,  не  є  наперед  відомим,
                  оскільки у заголовках .xz зберігаються лише  параметри,  які
                  потрібні для розпаковування.

       Стовпчики у рядках summary:
              2.  Об'єм  пам'яті  (у байтах), який потрібен для розпаковування
                  цього файла за допомогою цієї версії xz
              3.  yes або no вказує, якщо усі заголовки блоків містять  одразу
                  стиснений розмір та розпакований розмір
              Починаючи з xz 5.1.2alpha:
              4.  Мінімальна версія xz, яка потрібна для розпаковування файла

       Стовпчики рядка totals:
              2.  Кількість потоків
              3.  Кількість блоків
              4.  Стиснутий розмір
              5.  Нестиснутий розмір
              6.  Середній коефіцієнт стискання
              7.  Список   відокремлених  комами  назв  перевірок  цілісності,
                  результати яких наявні у файлах
              8.  Розмір доповнення потоку
              9.  Кількість файлів. Наявний тут для зберігання  такого  самого
                  порядку стовпчиків, що і у попередніх рядках file.

       Якщо  --verbose  було  вказано  двічі,  до  рядка  totals буде включено
       додаткові стовпчики:
              10. Максимальний об'єм пам'яті (у  байтах),  який  потрібен  для
                  розпаковування файлів за допомогою цієї версії xz
              11. yes  або no вказує, якщо усі заголовки блоків містять одразу
                  стиснений розмір та розпакований розмір
              Починаючи з xz 5.1.2alpha:
              12. Мінімальна версія xz, яка потрібна для розпаковування файла

       У майбутніх версіях може бути додано нові типи рядків і нові  стовпчики
       до   наявних   типів   рядків,  але  наявні  стовпчики  мають  лишитися
       незмінними.

СТАН ВИХОДУ
       0      Усе добре.

       1      Сталася помилка.

       2      Сталося  щось  варте  попередження,  але  справжніх  помилок  не
              сталося.

       Зауваження  (не попередження або помилки), які виведено до стандартного
       виведення помилок, не впливають на стан виходу.

СЕРЕДОВИЩЕ
       xz  обробляє  списки  відокремлених  пробілами  параметрів  зі  змінних
       середовища  XZ_DEFAULTS  і XZ_OPT, перш ніж обробляти параметри з рядка
       команди.  Зауважте,  що  буде  оброблено  лише  параметри  зі   змінних
       середовища;    усі   непараметричні   записи   буде   без   повідомлень
       проігноровано.   Обробку   буде   виконано   за    допомогою    функції
       getopt_long(3), яку також використовують для аргументів рядка команди.

       XZ_DEFAULTS
              Специфічні   для   користувача   або   загальносистемні   типові
              параметри. Зазвичай, їх  встановлюють  у  скрипті  ініціалізації
              оболонки для типового вмикання обмеження на використання пам'яті
              у xz. Окрім скриптів ініціалізації оболонки і подібних особливих
              випадків,  не  слід  встановлювати  або скасовувати встановлення
              значення XZ_DEFAULTS у скриптах.

       XZ_OPT Цю змінну призначено для  передавання  параметрів  до  xz,  якщо
              неможливо встановити параметри безпосередньо у рядку команди xz.
              Це трапляється, якщо  xz  запущено  скриптом  або  інструментом,
              наприклад, GNU tar(1):

                     XZ_OPT=-2v tar caf foo.tar.xz foo

              Скрипти    можуть   використовувати   XZ_OPT,   наприклад,   для
              встановлення специфічних  типових  параметрів  стискання.  Втім,
              рекомендуємо  дозволити  користувачам перевизначати XZ_OPT, якщо
              це  має  якісь  причини.  Наприклад,  у  скриптах  sh(1)   можна
              скористатися чимось таким:

                     XZ_OPT=${XZ_OPT-"-7e"} export XZ_OPT

СУМІСНІСТЬ ІЗ LZMA UTILS
       Синтаксис  рядка  команди xz практично є надбудовою щодо lzma, unlzma і
       lzcat з LZMA Utils 4.32.x. У більшості  випадків  можна  замінити  LZMA
       Utils  XZ  Utils  без  порушення працездатності наявних скриптів. Втім,
       існують певні несумісності, які іноді можуть спричиняти проблеми.

   Рівні шаблонів стискання
       Нумерація у шаблонах рівнів стискання у xz не є тотожною до нумерації у
       LZMA  Utils. Найважливішою відмінністю є прив'язка розмірів словника до
       різних шаблонів. Розмір словника грубо рівний  використанню  пам'яті  у
       засобі розпаковування.

              Рівень     xz      LZMA Utils
                -0     256 КіБ        н/д
                -1       1 МіБ     64 КіБ
                -2       2 МіБ      1 МіБ
                -3       4 МіБ    512 КіБ
                -4       4 МіБ      1 МіБ
                -5       8 МіБ      2 МіБ
                -6       8 МіБ      4 МіБ
                -7      16 МіБ      8 МіБ
                -8      32 МіБ     16 МіБ
                -9      64 МіБ     32 МіБ

       Відмінності  у  розмірах  словників  також  впливають  на  використання
       пам'яті засобом стискання, але є і інші відмінності між LZMA Utils і XZ
       Utils, які роблять різницю ще помітнішою:

              Рівень     xz      LZMA Utils 4.32.x
                -0       3 МіБ            н/д
                -1       9 МіБ          2 МіБ
                -2      17 МіБ         12 МіБ
                -3      32 МіБ         12 МіБ
                -4      48 МіБ         16 МіБ
                -5      94 МіБ         26 МіБ
                -6      94 МіБ         45 МіБ
                -7     186 МіБ         83 МіБ
                -8     370 МіБ        159 МіБ
                -9     674 МіБ        311 МіБ

       Типовим  рівнем  стискання  у LZMA Utils є -7, а у XZ Utils — -6, отже,
       обидва комплекти програм типово використовують  словник  розміром  у  8
       МіБ.

   Потокові і непотокові файл .lzma
       Розмір  нестисненого  файла може бути збережено у заголовку .lzma. LZMA
       Utils зберігають дані при стисканні  звичайних  файлів.  Альтернативним
       підходом є позначення нестисненого розміру як невідомого і використання
       позначки кінця вмісту для позначення місця, де засіб розпаковування має
       зупинитися.  У  LZMA  Utils цей спосіб використовують, якщо нестиснений
       розмір є невідомим, що трапляється, наприклад,  для  конвеєрів  обробки
       даних.

       У  xz  передбачено  підтримку  розпаковування  файлів .lzma з позначкою
       кінця вмісту та без неї, але усі файли .lzma, які створено за допомогою
       xz,  використовують  позначку  кінця  вмісту,  а  нестиснений  розмір у
       заголовку .lzma позначають як невідомий. Це може призвести до проблем у
       деяких   нетипових   ситуаціях.   Наприклад,   розпакувальник  .lzma  у
       вбудованому пристрої може працювати лише з файлами,  для  яких  відомий
       нестиснений  розмір.  Якщо  ви  зіткнулися  з  цією проблемою, вам слід
       скористатися LZMA Utils або LZMA SDK  для  створення  файлів  .lzma  із
       відомим розміром нестиснених даних.

   Непідтримувані файли .lzma
       У форматі .lzma можливі значення lc аж до 8 і значення lp аж до 4. LZMA
       Utils можуть розпаковувати файли із будь-якими значеннями lc і lp,  але
       завжди  створюють  файли  з  lc=3  і  lp=0.  Створення  файлів з іншими
       значеннями lc і lp є можливим за допомогою xz і LZMA SDK.

       Реалізація фільтра LZMA1 у liblzma потребує,  щоби  сума  lc  і  lp  не
       перевищувала 4. Отже, файли .lzma, у яких перевищено обмеження, не може
       бути розпаковано за допомогою xz.

       LZMA Utils створюють лише файли .lzma, які мають розмір словника у  2^n
       (степінь  2),  але  приймають файли із будь-яким розміром словника. li‐
       blzma приймає лише файли .lzma, які мають розмір словника 2^n або 2^n +
       2^(n-1). Так зроблено для зменшення помилок при виявленні файлів .lzma.

       Ці  обмеження  не  мають  призводити  до  проблем на практиці, оскільки
       практично усі файли .lzma було стиснено з використанням параметрів, які
       приймає liblzma.

   Кінцевий мотлох
       При  розпаковуванні LZMA Utils без повідомлень ігнорують усі дані після
       першого потоку .lzma. У більшості випадків  це  пов'язано  із  вадою  у
       програмі.  Це  також  означає, що у LZMA Utils не передбачено підтримки
       розпаковування з'єднаних файлів .lzma.

       Якщо після першого  потоку  .lzma  лишилися  дані,  xz  вважатиме  файл
       пошкодженим,   якщо   не  було  використано  --single-stream.  Це  може
       зашкодити роботі скриптів, де зроблено  припущення,  що  кінцеві  зайві
       дані буде проігноровано.

ПРИМІТКИ
   Стискання даних може бути різним
       Точні  стиснені  дані,  які створено на основі того самого нестисненого
       файла вхідних даних, можуть бути різними для різних  версій  XZ  Utils,
       навіть  якщо використано однакові параметри стискання. Причиною цього є
       удосконалення у кодувальнику (пришвидшення  або  краще  стискання)  без
       зміни  формату  файлів.  Виведені  дані  можуть бути різними навіть для
       різних збірок тієї  самої  версії  XZ  Utils,  якщо  використано  різні
       параметри збирання.

       Написане вище означає, що після реалізації --rsyncable файли-результати
       не обов'язково можна буде синхронізувати за допомогою  rsyncable,  якщо
       старий  і  новий файли було стиснено за допомогою тієї самої версії xz.
       Цю проблему можна усунути,  якщо  буде  заморожено  частину  реалізації
       кодувальника,  щоб введені для rsync дані були стабільними між версіями
       xz.

   Вбудовані розпакувальники .xz
       У вбудованих реалізаціях розпакувальника .xz, подібних до XZ  Embedded,
       не  обов'язково  передбачено  підтримку  файлів, які створено із типами
       перевірки цілісності, відмінними від none і crc32. Оскільки  типовим  є
       --check=crc64, вам слід використовувати  --check=none або --check=crc32
       при створенні файлів для вбудованих систем.

       Поза вбудованими системами, в усіх засобах розпаковування  формату  .xz
       передбачено  підтримку  усіх  типів  перевірок або принаймні можливість
       розпакувати  файл  без  перевірки  цілісності,  якщо  підтримки  певної
       перевірки не передбачено.

       У  XZ Embedded передбачено підтримку BCJ, але лише з типовим початковим
       зсувом.

ПРИКЛАДИ
   Основи
       Стиснути файл foo до foo.xz за допомогою типового рівня стискання  (-6)
       і вилучити foo, якщо стискання відбулося успішно:

              xz foo

       Розпакувати   bar.xz   до   bar  і  не  вилучати  bar.xz,  навіть  якщо
       розпаковування відбулося успішно:

              xz -dk bar.xz

       Створити baz.tar.xz з використанням шаблона -4e (-4 --extreme), який  є
       повільнішими за типовий -6, але потребує менше пам'яті для стискання та
       розпаковування (48 МіБ та 5 МіБ, відповідно):

              tar cf - baz | xz -4e > baz.tar.xz

       Суміш стиснених і нестиснених файлів можна розпакувати до  стандартного
       виведення за допомогою єдиної команди:

              xz -dcf a.txt b.txt.xz c.txt d.txt.lzma > abcd.txt

   Паралельне стискання багатьох файлів
       У  GNU  і  *BSD  можна скористатися find(1) і xargs(1) для паралельного
       стискання багатьох файлів:

              find . -type f \! -name '*.xz' -print0 \     | xargs -0r -P4 -n16 xz -T1

       Параметр -P xargs(1)  встановлює  кількість  паралельних  процесів  xz.
       Найкраще  значення  параметра  -n залежить від того, скільки файлів має
       бути стиснено. Якщо файлів мало, значенням, ймовірно, має бути 1.  Якщо
       файлів  десятки тисяч, може знадобитися значення 100 або навіть більше,
       щоб зменшити кількість процесів xz, які врешті створить xargs(1).

       Параметр -T1 для xz тут  для  примусового  встановлення  однопотокового
       режиму,   оскільки   для  керування  рівнем  паралелізації  використано
       xargs(1).

   Режим робота
       Обчислити  скільки  байтів  було  заощаджено  загалом  після  стискання
       декількох файлів:

              xz --robot --list *.xz | awk '/^totals/{print $5-$4}'

       Скрипту  можуть  знадобитися  дані  щодо того, що використано достатньо
       нову версію xz. У наведеному нижче  скрипті  sh(1)  виконано  перевірку
       того,  що номер версії засобу xz є принаймні рівним 5.0.0. Цей спосіб є
       сумісним зі старими тестовими версіями,  де  не  передбачено  підтримки
       параметра --robot:

              if ! eval "$(xz --robot --version 2> /dev/null)" ||         [ "$XZ_VERSION" -lt 50000002 ]; then     echo "Your xz is too old." fi unset XZ_VERSION LIBLZMA_VERSION

       Встановити  обмеження  на  використання  пам'яті  для розпаковування за
       допомогою  XZ_OPT,  але  якщо  обмеження  вже  було   встановлено,   не
       збільшувати його:

              NEWLIM=$((123 << 20))  # 123 MiB OLDLIM=$(xz --robot --info-memory | cut -f3) if [ $OLDLIM -eq 0 -o $OLDLIM -gt $NEWLIM ]; then     XZ_OPT="$XZ_OPT --memlimit-decompress=$NEWLIM"     export XZ_OPT fi

   Нетипові ланцюжки фільтрів засобу стискання
       Найпростішим  використанням  ланцюжка фільтрів є налаштовування шаблона
       LZMA2. Це може бути корисним,  оскільки  у  шаблонах  використано  лише
       підмножину потенційно корисних комбінацій параметрів стискання.

       При налаштовуванні шаблонів LZMA2 корисними є стовпчики CompCPU таблиць
       з описів параметрів -0 ... -9 і --extreme. Ось відповідні частини з цих
       двох таблиць:

              Шаблон   CompCPU
               -0         0
               -1         1
               -2         2
               -3         3
               -4         4
               -5         5
               -6         6
               -5e        7
               -6e        8

       Якщо  вам  відомо,  що  певний  файл  потребує  дещо  більшого словника
       (наприклад, 32 МіБ) для якісного стискання, але ви хочете стиснути його
       швидше  за  команду  xz  -8,  можна  внести  зміни до шаблона із нижчим
       значенням CompCPU (наприклад, 1) для використання більшого словника:

              xz --lzma2=preset=1,dict=32MiB foo.tar

       Для певних файлів наведена вище команда може працювати швидше за xz  -6
       і  стискати дані значно краще. Втім, слід наголосити, переваги більшого
       словника з одночасним низьким значенням CompCPU проявляються  лише  для
       деяких   файлів.   Найочевиднішим  випадком,  коли  великий  словник  є
       корисним, є випадок, коли архів містить дуже подібні файли  розміром  у
       принаймні  декілька мегабайтів. Розмір словника має бути значно більшим
       за будь-який окремий файл, щоб у LZMA2 було  використано  усі  переваги
       подібностей між послідовними файлами.

       Якщо  дуже  високий  рівень використання пам'яті у засобі стискання або
       розпаковування не є проблемою, і файли,  який  стискають  має  об'єм  у
       принаймні декілька десятків мегабайтів, може бути корисним використання
       навіть більшого за 64 МіБ словника, який використано у xz -9:

              xz -vv --lzma2=dict=192MiB big_foo.tar

       Використання -vv (--verbose  --verbose),  подібно  до  наведеного  вище
       прикладу,  може  бути  корисним  для  перегляду  вимог  з  боку засобів
       стискання та розпаковування до  пам'яті.  Пам'ятайте,  що  використання
       словника,  розмір  якого  перевищує  розмір  файла,  який  стискають, є
       простоюю  витратою  пам'яті,  отже  наведену  вище  команду  не   варто
       використовувати для малих файлів.

       Іноді  час  стискання не має значення, але використання пам'яті засобом
       розпаковування має бути низьким для того,  щоб,  наприклад,  уможливити
       розпаковування  файла  у  вбудованій системі. У наведеній нижче команді
       використано -6e (-6 --extreme) як основу і встановлено розмір  словника
       лише  у 64 КіБ. Файл-результат можна розпакувати за допомогою XZ Embed‐
       ded (ось чому використано --check=crc32) з використанням  лише  100 КіБ
       пам'яті.

              xz --check=crc32 --lzma2=preset=6e,dict=64KiB foo

       Якщо  вам потрібно витиснути зі стискання максимальну кількість байтів,
       може допомогти коригування кількості бітів контексту літералів (lc)  та
       кількість  позиційних  бітів  (pb).  Також  може  допомогти коригування
       кількості бітів позиції літералів (lp), але, зазвичай, важливішими є lc
       і  pb.  Наприклад,  в архівах зі початковим кодом міститься здебільшого
       текст US-ASCII, щось подібне до наведеного нижче  може  дещо  (на  щось
       близьке  до  0,1 %) зменшити файл, порівняно із xz -6e (спробуйте також
       без lc=4):

              xz --lzma2=preset=6e,pb=0,lc=4 source_code.tar

       Використання іншого фільтра разом із LZMA2 може покращити стискання для
       певних  типів  файлів.  Наприклад,  для  стискання бібліотеки спільного
       користування  x86-32  або  x86-64  з  використанням  фільтра  BCJ   x86
       скористайтеся такою командою:

              xz --x86 --lzma2 libfoo.so

       Зауважте,  що  порядок параметрів фільтрування має значення. Якщо --x86
       вказано після --lzma2, xz повідомить про помилку, оскільки після  LZMA2
       не  може бути жодного фільтра, а також оскільки фільтр BCJ x86 не можна
       використовувати як останній фільтр у ланцюжку.

       Фільтр Delta разом із LZMA2 може дати добрі  результати  для  растрових
       зображень.  Зазвичай,  результати  є  кращими  за формат PNG, у якого є
       декілька  більш  досконалих  фільтрів,  ніж  проста  дельта,  але   там
       використовують для стискання Deflate.

       Зображення   слід   берегти   у  нестисненому  форматі,  наприклад,  як
       нестиснений TIFF. Параметр відстані фільтра Delta встановлюють так, щоб
       він  збігався  із  кількістю байтів на піксель у зображенні. Наприклад,
       для 24-бітового растрового зображення RGB слід вказати dist=3, а  також
       добре  передати  pb=0  до  LZMA2  для  пристосовування  до трибайтового
       вирівнювання:

              xz --delta=dist=3 --lzma2=pb=0 foo.tiff

       Якщо в один архів запаковано декілька  зображень  (наприклад,  в  архів
       .tar),  фільтр  Delta  також  даватиме  добрі  результати,  якщо у всіх
       зображеннях однакова кількість байтів для кожного пікселя.

ДИВ. ТАКОЖ
       xzdec(1),  xzdiff(1),   xzgrep(1),   xzless(1),   xzmore(1),   gzip(1),
       bzip2(1), 7z(1)

       XZ Utils: <https://tukaani.org/xz/>
       Вбудовуваний XZ: <https://tukaani.org/xz/embedded.html>
       LZMA SDK: <http://7-zip.org/sdk.html>

Tukaani                       1 грудня 2022 року                         XZ(1)