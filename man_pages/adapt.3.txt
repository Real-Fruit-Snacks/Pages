NAME

adapt -
adaptive mesh generation (rheolef-7.2)

SYNOPSIS

geo adapt
(const field& criterion); 
geo adapt (const field& criterion, const
adapt_option& aopt);

DESCRIPTION

The
adapt function implements an adaptive mesh
procedure, based either on the gmsh (isotropic) or
bamg(1) (anisotropic) mesh generators. The
bamg(1) mesh generator is the default in two
dimension. For dimension one or three, gmsh is the
only generator supported yet. In the two dimensional case,
the gmsh correspond to the option
aopt.generator=&rsquo;gmsh&rsquo;, where
aopt is an adap_option variable (see
adapt(3)).

CRITERION AND METRIC

The strategy
bases on a metric determined by the Hessian of a scalar
criterion field, denoted here as phi, and that is
supplied by the user as the first argument of the
adapt function.

Let us denote
by H=Hessian(phi) the Hessian tensor field of the
scalar field phi. Then, |H| denotes the
tensor that has the same eigenvector as H, but with
absolute value of its eigenvalues:

|H| =
Q*diag(|lambda_i|)*Qt

The metric
M is determined from |H|. Recall that an
isotropic metric is such that M(x)=hloc(x)^(-2)*Id
where hloc(x) is the element size field and
Id is the identity d*d matrix, and
d=1,2,3 is the physical space dimension.

GMSH ISOTROPIC METRIC

max_(i=0..d-1)(|lambda_i(x)|)*Id

M(x) = ----------------------------------------- 
err*hcoef^2*(sup_y(phi(y))-inf_y(phi(y)))

Notice that the
denominator involves a global (absolute) normalization
sup_y(phi(y))-inf_y(phi(y)) of the criterion field
phi and the two parameters aopt.err, the
target error, and aopt.hcoef, a secondary
normalization parameter (defaults to 1).

BAMG ANISOTROPIC METRIC

There are two
approach for the normalization of the metric. The first one
involves a global (absolute) normalization:

|H(x))| 
M(x) = ----------------------------------------- 
err*hcoef^2*(sup_y(phi(y))-inf_y(phi(y)))

The first one
involves a local (relative) normalization:

|H(x))| 
M(x) = ----------------------------------------- 
err*hcoef^2*(|phi(x)|, cutoff*max_y|phi(y)|)

Notice that the
denominator involves a local value phi(x). The
parameter is provided by the optional variable
aopt.cutoff; its default value is 1e-7.
The default strategy is the local normalization. The global
normalization can be enforced by setting
aopt.additional=&rsquo;-AbsError&rsquo;.

When choosing
global or local normalization ?

When the
governing field phi is bounded, i.e. when
err*hcoef^2*(sup_y(phi(y))-inf_y(phi(y))) will
converge versus mesh refinement to a bounded value, the
global normalization defines a metric that is
mesh-independent and thus the adaptation loop will
converge.

Otherwise, when
phi presents singularities, with unbounded values
(such as corner singularity, i.e. presents picks when
represented in elevation view), then the mesh adaptation
procedure is more difficult. The global normalization
divides by quantities that can be very large and the mesh
adaptation can diverges when focusing on the singularities.
In that case, the local normalization is preferable.
Moreover, the focus on singularities can also be controlled
by setting aopt.hmin not too small.

The local
normalization has been chosen as the default since it is
more robust. When your field phi does not present
singularities, then you can switch to the global numbering
that leads to a best equirepartition of the error over the
domain.

OPTIONS

struct
adapt_option { 
typedef std::vector::size_type size_type; 
std::string generator; 
bool isotropic; 
Float err; 
Float errg; 
Float hcoef; 
Float hmin; 
Float hmax; 
Float ratio; 
Float cutoff; 
size_type n_vertices_max; 
size_type n_smooth_metric; 
bool splitpbedge; 
Float thetaquad; 
Float anisomax; 
bool clean; 
std::string additional; 
bool double_precision; 
Float anglecorner; // angle below which bamg considers 2
consecutive edge to be part of 
// the same spline 
adapt_option() : 
generator(""), 
isotropic(true), err(1e-2), errg(1e-1), hcoef(1),
hmin(0.0001), hmax(0.3), ratio(0), cutoff(1e-7), 
n_vertices_max(50000), n_smooth_metric(1), 
splitpbedge(true),
thetaquad(std::numeric_limits::max()), 
anisomax(1e6), clean(false),
additional("-RelError"), double_precision(false),

anglecorner(0) 
{} 
};

IMPLEMENTATION

This
documentation has been generated from file
main/lib/adapt.h

AUTHOR

Pierre Saramito
Pierre.Saramito [AT] imag.fr>

COPYRIGHT

Copyright (C)
2000-2018 Pierre Saramito Pierre.Saramito [AT] imag.fr>
GPLv3+: GNU GPL version 3 or later
http://gnu.org/licenses/gpl.html&gt;. This is free
software: you are free to change and redistribute it. There
is NO WARRANTY, to the extent permitted by law.