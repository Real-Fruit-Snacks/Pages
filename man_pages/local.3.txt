NAME

grib2.h -
Header file for NCEPLIBS-g2c library.

SYNOPSIS

#include

#include 

Data
Structures

struct gribfield 
Struct for GRIB field. 
struct gtemplate 
Struct for GRIB template.

Macros

#define G2_VERSION
’g2clib-1.6.4’ 
Current version of NCEPLIBS-g2c library.

Typedefs

typedef float g2float

Float type. 
typedef int64_t g2int 
Long integer type. 
typedef uint64_t g2intu 
Unsigned long integer type. 
typedef struct gribfield gribfield 
Struct for GRIB field. 
typedef struct gtemplate gtemplate 
Struct for GRIB template.

Functions

void compack
(g2float *, g2int, g2int, g2int
*, unsigned char *, g2int *) 
This subroutine packs up a data field using a complex
packing algorithm as defined in the GRIB2 documention.

gtemplate * extdrstemplate (g2int,
g2int *) 
This subroutine generates the remaining octet map for a
given Data Representation Template, if required. 
gtemplate * extgridtemplate (g2int,
g2int *) 
This subroutine generates the remaining octet map for a
given Grid Definition Template, if required. 
gtemplate * extpdstemplate (g2int,
g2int *) 
This subroutine generates the remaining octet map for a
given Product Definition Template, if required. 
g2int g2_addfield (unsigned char *, g2int,
g2int *, g2float *, g2int,
g2int, g2int *, g2float *,
g2int, g2int, g2int *) 
This routine packs up Sections 4 through 7 for a given field
and adds them to a GRIB2 message. 
g2int g2_addgrid (unsigned char *, g2int *,
g2int *, g2int *, g2int) 
This routine packs up a Grid Definition Section (Section 3)
and adds it to a GRIB2 message. 
g2int g2_addlocal (unsigned char *, unsigned char *,
g2int) 
This routine adds a Local Use Section (Section 2) to a GRIB2
message. 
g2int g2_create (unsigned char *, g2int *,
g2int *) 
This routine initializes a new GRIB2 message and packs GRIB2
sections 0 (Indicator Section) and 1 (Identification
Section). 
void g2_free (gribfield *) 
This routine frees up memory that was allocated for struct
gribfield. 
g2int g2_getfld (unsigned char *, g2int,
g2int, g2int, gribfield **) 
This subroutine returns all the metadata, template values,
Bit-map (if applicable), and the unpacked data for a given
data field. 
g2int g2_gribend (unsigned char *) 
This routine finalizes a GRIB2 message after all grids and
fields have been added. 
g2int g2_info (unsigned char *, g2int *,
g2int *, g2int *, g2int *) 
This subroutine searches through a GRIB2 message and returns
the number of gridded fields found in the message and the
number (and maximum size) of Local Use Sections. 
g2int g2_unpack1 (unsigned char *, g2int *,
g2int **, g2int *) 
This subroutine unpacks Section 1 (Identification Section)
as defined in GRIB Edition 2. 
g2int g2_unpack3 (unsigned char *, g2int *,
g2int **, g2int **, g2int *,
g2int **, g2int *) 
This routine unpacks Section 3 (Grid Definition Section) as
defined in GRIB Edition 2. 
g2int g2_unpack4 (unsigned char *, g2int *,
g2int *, g2int **, g2int *,
g2float **, g2int *) 
This subroutine unpacks Section 4 (Product Definition
Section) as defined in GRIB Edition 2. 
g2int g2_unpack5 (unsigned char *, g2int *,
g2int *, g2int *, g2int **,
g2int *) 
This subroutine unpacks Section 5 (Data Representation
Section) as defined in GRIB Edition 2. 
g2int g2_unpack6 (unsigned char *, g2int *,
g2int, g2int *, g2int **) 
This subroutine unpacks Section 6 (Bit-Map Section) as
defined in GRIB Edition 2. 
g2int g2_unpack7 (unsigned char *, g2int *,
g2int, g2int *, g2int, g2int *,
g2int, g2float **) 
This subroutine unpacks Section 7 (Data Section) as defined
in GRIB Edition 2. 
void gbit (unsigned char *, g2int *,
g2int, g2int) 
Get bits - unpack bits: Extract arbitrary size values from a
packed bit string, right justifying each value in the
unpacked iout array. 
void gbits (unsigned char *, g2int *,
g2int, g2int, g2int, g2int) 
Get bits - unpack bits: Extract arbitrary size values from a
packed bit string, right justifying each value in the
unpacked iout array. 
gtemplate * getdrstemplate (g2int) 
This subroutine returns DRS template information for a
specified Data Representation Template 5.NN. 
gtemplate * getgridtemplate (g2int) 
This subroutine returns grid template information for a
specified Grid Definition Template 3.NN. 
gtemplate * getpdstemplate (g2int) 
This subroutine returns PDS template information for a
specified Product Definition Template 4.NN. 
double int_power (double, g2int) 
Function similar to C pow() power function. 
void misspack (g2float *, g2int,
g2int, g2int *, unsigned char *, g2int
*) 
This subroutine packs up a data field using a complex
packing algorithm as defined in the GRIB2 documention. 
void mkieee (g2float *, g2int *,
g2int) 
This subroutine stores a list of real values in 32-bit IEEE
floating point format. 
int pack_gp (g2int *, g2int *,
g2int *, g2int *, g2int *, g2int
*, g2int *, g2int *, g2int *,
g2int *, g2int *, g2int *, g2int
*, g2int *, g2int *, g2int *,
g2int *, g2int *, g2int *, g2int
*) 
Determines groups of variable size, but at least of size
minpk, the associated max (jmax( )) and min (jmin( )), the
number of bits necessary to hold the values in each group
(lbit( )), the number of values in each group (nov( )), the
number of bits necessary to pack the jmin( ) values (ibit),
the number of bits necessary to pack the lbit( ) values
(jbit), and the number of bits necessary to pack the nov( )
values (kbit). 
void rdieee (g2int *, g2float *,
g2int) 
This subroutine reads a list of real values in 32-bit IEEE
floating point format. 
void sbit (unsigned char *, g2int *,
g2int, g2int) 
Store bits - put arbitrary size values into a packed bit
string, taking the low order bits from each value in the
unpacked array. 
void sbits (unsigned char *, g2int *,
g2int, g2int, g2int, g2int) 
Store bits - put arbitrary size values into a packed bit
string, taking the low order bits from each value in the
unpacked array. 
void seekgb (FILE *, g2int, g2int,
g2int *, g2int *) 
This subprogram searches a file for the next GRIB Message.

void simpack (g2float *, g2int,
g2int *, unsigned char *, g2int *) 
This subroutine packs up a data field using the simple
packing algorithm as defined in the GRIB2 documention.

Detailed Description

Header file for
NCEPLIBS-g2c library.

PROGRAM HISTORY
LOG:

•

2002-10-25 Gilbert

•

2009-01-14 Vuong Changed struct template to
gtemplate 

Each element of
structure gribfield is defined as:

gribfield
gfld;

gfld->version
= GRIB edition number ( currently 2 ) 
gfld->discipline = Message Discipline ( see Code Table
0.0 ) 
gfld->idsect = Contains the entries in the Identification

Section ( Section 1 ) 
This element is a pointer to an array 
that holds the data. 
gfld->idsect[0] = Identification of originating Centre

( see Common Code Table C-1 ) 
7 - US National Weather Service 
gfld->idsect[1] = Identification of originating
Sub-centre 
gfld->idsect[2] = GRIB Master Tables Version Number 
( see Code Table 1.0 ) 
0 - Experimental 
1 - Initial operational version number 
gfld->idsect[3] = GRIB Local Tables Version Number 
( see Code Table 1.1 ) 
0 - Local tables not used 
1-254 - Number of local tables version used 
gfld->idsect[4] = Significance of Reference Time (Code
Table 1.2) 
0 - Analysis 
1 - Start of forecast 
2 - Verifying time of forecast 
3 - Observation time 
gfld->idsect[5] = Year ( 4 digits ) 
gfld->idsect[6] = Month 
gfld->idsect[7) = Day 
gfld->idsect[8] = Hour 
gfld->idsect[9] = Minute 
gfld->idsect[10] = Second 
gfld->idsect[11] = Production status of processed data

( see Code Table 1.3 ) 
0 - Operational products 
1 - Operational test products 
2 - Research products 
3 - Re-analysis products 
gfld->idsect[12] = Type of processed data ( see Code
Table 1.4 ) 
0 - Analysis products 
1 - Forecast products 
2 - Analysis and forecast products 
3 - Control forecast products 
4 - Perturbed forecast products 
5 - Control and perturbed forecast products 
6 - Processed satellite observations 
7 - Processed radar observations 
gfld->idsectlen = Number of elements in
gfld->idsect[]. 
gfld->local = Pointer to character array containing
contents 
of Local Section 2, if included 
gfld->locallen = length of array gfld->local[] 
gfld->ifldnum = field number within GRIB message 
gfld->griddef = Source of grid definition (see Code Table
3.0) 
0 - Specified in Code table 3.1 
1 - Predetermined grid Defined by originating centre 
gfld->ngrdpts = Number of grid points in the defined
grid. 
gfld->numoct_opt = Number of octets needed for each 
additional grid points definition. 
Used to define number of 
points in each row ( or column ) for 
non-regular grids. 
= 0, if using regular grid. 
gfld->interp_opt = Interpretation of list for optional
points 
definition. (Code Table 3.11) 
gfld->igdtnum = Grid Definition Template Number (Code
Table 3.1) 
gfld->igdtmpl = Contains the data values for the
specified Grid 
Definition Template ( NN=gfld->igdtnum ). Each 
element of this integer array contains an entry (in 
the order specified) of Grid Defintion Template 3.NN 
This element is a pointer to an array 
that holds the data. 
gfld->igdtlen = Number of elements in gfld->igdtmpl[].
i.e. number of 
entries in Grid Defintion Template 3.NN 
( NN=gfld->igdtnum ). 
gfld->list_opt = (Used if gfld->numoct_opt .ne. 0)
This array 
contains the number of grid points contained in 
each row ( or column ). (part of Section 3) 
This element is a pointer to an array 
that holds the data. This pointer is nullified 
if gfld->numoct_opt=0. 
gfld->num_opt = (Used if gfld->numoct_opt .ne. 0) The
number of entries 
in array ideflist. i.e. number of rows ( or columns ) 
for which optional grid points are defined. This value 
is set to zero, if gfld->numoct_opt=0. 
gfdl->ipdtnum = Product Definition Template Number (see
Code Table 4.0) 
gfld->ipdtmpl = Contains the data values for the
specified Product 
Definition Template ( N=gfdl->ipdtnum ). Each element

of this integer array contains an entry (in the 
order specified) of Product Defintion Template 4.N. 
This element is a pointer to an array 
that holds the data. 
gfld->ipdtlen = Number of elements in gfld->ipdtmpl[].
i.e. number of 
entries in Product Defintion Template 4.N 
( N=gfdl->ipdtnum ). 
gfld->coord_list = Real array containing floating point
values 
intended to document the vertical discretisation 
associated to model data on hybrid coordinate 
vertical levels. (part of Section 4) 
This element is a pointer to an array 
that holds the data. 
gfld->num_coord = number of values in array
gfld->coord_list[]. 
gfld->ndpts = Number of data points unpacked and
returned. 
gfld->idrtnum = Data Representation Template Number 
( see Code Table 5.0) 
gfld->idrtmpl = Contains the data values for the
specified Data 
Representation Template ( N=gfld->idrtnum ). Each 
element of this integer array contains an entry 
(in the order specified) of Product Defintion 
Template 5.N. 
This element is a pointer to an array 
that holds the data. 
gfld->idrtlen = Number of elements in gfld->idrtmpl[].
i.e. number 
of entries in Data Representation Template 5.N 
( N=gfld->idrtnum ). 
gfld->unpacked = logical value indicating whether the
bitmap and 
data values were unpacked. If false, 
gfld->bmap and gfld->fld pointers are nullified. 
gfld->expanded = Logical value indicating whether the
data field 
was expanded to the grid in the case where a 
bit-map is present. If true, the data points in 
gfld->fld match the grid points and zeros were 
inserted at grid points where data was bit-mapped 
out. If false, the data values in gfld->fld were 
not expanded to the grid and are just a consecutive 
array of data points corresponding to each value of 
’1’ in gfld->bmap. 
gfld->ibmap = Bitmap indicator ( see Code Table 6.0 )

0 = bitmap applies and is included in Section 6. 
1-253 = Predefined bitmap applies 
254 = Previously defined bitmap applies to this field 
255 = Bit map does not apply to this product. 
gfld->bmap = integer array containing decoded bitmap,

if gfld->ibmap=0 or gfld->ibap=254. Otherwise
nullified. 
This element is a pointer to an array 
that holds the data. 
gfld->fld = Array of gfld->ndpts unpacked data points.

This element is a pointer to an array 
that holds the data.

Author

Stephen Gilbert

Date

2002-10-25

Definition in
file grib2.h.

Data Type Documentation

struct gribfield

Struct for GRIB
field.

Definition at
line 186 of file grib2.h.

Data
Fields:

g2int * bmap

g2float
* coord_list

g2int
discipline

g2int
expanded

g2float
* fld

g2int
griddef

g2int
ibmap

g2int
idrtlen

g2int *
idrtmpl

g2int
idrtnum

g2int *
idsect

g2int
idsectlen

g2int
ifldnum

g2int
igdtlen

g2int *
igdtmpl

g2int
igdtnum

g2int
interp_opt

g2int
ipdtlen

g2int *
ipdtmpl

g2int
ipdtnum

g2int *
list_opt

unsigned char *
local

g2int
locallen

g2int
ndpts

g2int
ngrdpts

g2int
num_coord

g2int
num_opt

g2int
numoct_opt

g2int
unpacked

g2int
version

struct gtemplate

Struct for GRIB
template.

Definition at
line 165 of file grib2.h.

Data
Fields:

g2int * ext num
of octets of each entry in the extension 
part of the template.

g2int
extlen number of entries in the template
extension.

g2int *
map num of octets of each entry in the 
static part of the template.

g2int
maplen number of entries in the static part 
of the template.

g2int
needext indicates whether or not the template needs

to be extended.

g2int
num template number.

g2int
type 3=Grid Defintion Template. 4=Product Defintion
Template. 5=Data Representation Template.

Macro Definition Documentation

#define
G2_VERSION ’g2clib-1.6.4’ 
Current version of NCEPLIBS-g2c library.

Definition at
line 156 of file grib2.h.

Typedef Documentation

typedef
float g2float 
Float type.

Definition at
line 160 of file grib2.h.

typedef
int64_t g2int 
Long integer type.

Definition at
line 158 of file grib2.h.

typedef
uint64_t g2intu 
Unsigned long integer type.

Definition at
line 159 of file grib2.h.

typedef
struct gribfield gribfield 
Struct for GRIB field.

Definition at
line 160 of file grib2.h.

typedef
struct gtemplate gtemplate 
Struct for GRIB template.

Definition at
line 160 of file grib2.h.

Function Documentation

void compack
(g2float * fld, g2int ndpts, g2int idrsnum, g2int *
idrstmpl, unsigned char * cpack, g2int * lcpack) 
This subroutine packs up a data field using a complex
packing algorithm as defined in the GRIB2 documention. It
supports GRIB2 complex packing templates with or without
spatial differences (i.e. DRTs 5.2 and 5.3). It also fills
in GRIB2 Data Representation Template 5.2 or 5.3 with the
appropriate values.

Parameters

fld Contains the data
values to pack 
ndpts The number of data values in array fld 
idrsnum Data Representation Template number 5.N Must
equal 2 or 3. 
idrstmpl Contains the array of values for Data
Representation Template 5.2 or 5.3.

•

0 Reference value - ignored on
input, set my compack().

•

1 Binary Scale Factor

•

2 Decimal Scale Factor

•

6 Missing value management

•

7 Primary missing value

•

8 Secondary missing value

•

16 Order of Spatial Differencing ( 1 or 2 )

Parameters

cpack The packed data
field 
lcpack length of packed field cpack.

Author

Stephen Gilbert

Date

2002-11-07

Definition at
line 39 of file compack.c.

References
int_power(), mkieee(), pack_gp(), sbit(), and sbits().

Referenced by
cmplxpack().

gtemplate*
extdrstemplate (g2int number, g2int * list) 
This subroutine generates the remaining octet map for a
given Data Representation Template, if required. Some
Templates can vary depending on data values given in an
earlier part of the Template, and it is necessary to know
some of the earlier entry values to generate the full octet
map of the Template.

PROGRAM HISTORY
LOG:

•

2000-05-11 Gilbert

•

2009-01-14 Vuong Changed structure name template to
gtemplate 

Parameters

number NN, indicating
the number of the Data Representation Template 5.NN that is
being requested. 
list The list of values for each entry in the the Data
Representation Template 5.NN.

Returns

Pointer to the returned
template struct. Returns NULL pointer, if template not
found.

Author

Stephen Gilbert

Date

2000-05-11

Definition at
line 104 of file drstemplates.c.

References
getdrsindex(), and getdrstemplate().

Referenced by
g2_unpack5().

gtemplate*
extgridtemplate (g2int number, g2int * list) 
This subroutine generates the remaining octet map for a
given Grid Definition Template, if required. Some Templates
can vary depending on data values given in an earlier part
of the Template, and it is necessary to know some of the
earlier entry values to generate the full octet map of the
Template.

PROGRAM HISTORY
LOG:

•

2000-05-09 Gilbert

•

2008-07-08 Vuong Added GDT 3.32768 Rotate Lat/Lon E-grid
(Arakawa) 

•

2009-01-14 Vuong Changed structure name template to
gtemplate 

•

2010-05-11 Vuong Added GDT 3.32769 Rotate Lat/Lon Non-E
Staggered grid (Arakawa)

•

2013-08-06 Vuong Added GDT 3.4,3.5,3.12,3.101,3.140

Parameters

number NN, indicating
the number of the Grid Definition Template 3.NN that is
being requested. 
list The list of values for each entry in the Grid
Definition Template.

Returns

Pointer to the returned
template struct. Returns NULL pointer, if template not
found.

Author

Stephen Gilbert

Date

2000-05-09

Definition at
line 119 of file gridtemplates.c.

References
getgridindex(), and getgridtemplate().

Referenced by
g2_addgrid(), and g2_unpack3().

gtemplate*
extpdstemplate (g2int number, g2int * list) 
This subroutine generates the remaining octet map for a
given Product Definition Template, if required. Some
Templates can vary depending on data values given in an
earlier part of the Template, and it is necessary to know
some of the earlier entry values to generate the full octet
map of the Template.

Parameters

number NN, indicating
the number of the Product Definition Template 4.NN that is
being requested. 
list The list of values for each entry in the the
Product Definition Template 4.NN.

Returns

Pointer to the returned
template struct. Returns NULL pointer, if template not
found.

Author

Stephen Gilbert

Date

2000-05-11

Definition at
line 108 of file pdstemplates.c.

References
getpdsindex(), and getpdstemplate().

Referenced by
g2_addfield(), and g2_unpack4().

g2int
g2_addfield (unsigned char * cgrib, g2int ipdsnum, g2int *
ipdstmpl, g2float * coordlist, g2int numcoord, g2int
idrsnum, g2int * idrstmpl, g2float * fld, g2int ngrdpts,
g2int ibmap, g2int * bmap) 
This routine packs up Sections 4 through 7 for a given field
and adds them to a GRIB2 message. They are Product
Definition Section, Data Representation Section, Bit-Map
Section and Data Section, respectively.

This routine is
used with routines g2_create(), g2_addlocal(),
g2_addgrid(), and g2_gribend() to create a
complete GRIB2 message. g2_create() must be called
first to initialize a new GRIB2 message. Also, routine
g2_addgrid() must be called after g2_create()
and before this routine to add the appropriate grid
description to the GRIB2 message. Also, a call to
g2_gribend() is required to complete GRIB2 message
after all fields have been added.

PROGRAM HISTORY
LOG:

•

2002-11-05 Gilbert

•

2002-12-23 Gilbert - Added complex spherical harmonic
packing 

•

2003-08-27 Gilbert - Added support for new templates
using PNG and JPEG2000 algorithms/templates.

•

2004-11-29 Gilbert - JPEG2000 now allowed to use WMO
Template no. 5.40 PNG now allowed to use WMO Template no.
5.41 

•

Added check to determine if
packing algorithm failed.

•

2005-05-10 Gilbert - Imposed minimum size on cpack, used
to hold encoded bit string.

•

2009-01-14 Vuong Changed structure name template to
gtemplate 

Parameters

cgrib Char array that
contains the GRIB2 message to which sections 4 through 7
should be added. Must be allocated large enough to store the
entire GRIB2 message. 
ipdsnum Product Definition Template Number (see Code
Table 4.0). 
ipdstmpl Contains the data values for the specified
Product Definition Template (N=ipdsnum). Each element of
this integer array contains an entry (in the order
specified) of Product Defintion Template 4.N. 
coordlist Array containg floating point values intended
to document the vertical discretisation associated to model
data on hybrid coordinate vertical levels. 
numcoord number of values in array coordlist. 
idrsnum Data Representation Template Number (see Code
Table 5.0). 
idrstmpl Contains the data values for the specified Data
Representation Template (N=idrsnum). Each element of this
integer array contains an entry (in the order specified) of
Data Representation Template 5.N. Note that some values in
this template (eg. reference values, number of bits, etc...)
may be changed by the data packing algorithms. Use this to
specify scaling factors and order of spatial differencing,
if desired. 
fld Array of data points to pack. 
ngrdpts- Number of data points in grid. i.e. size of fld
and bmap. 
ibmap - Bitmap indicator (see Code Table 6.0)

•

0 = bitmap applies and is
included in Section 6.

•

1-253 = Predefined bitmap applies.

•

254 = Previously defined bitmap applies to this
field. 

•

255 = Bit map does not apply to this product.

bmap
Integer array containing bitmap to be added. (if
ibmap=0).

Returns

•

> 0 Current size of updated
GRIB2 message

•

-1 GRIB message was not initialized. Need to call
routine g2_create() first.

•

-2 GRIB message already complete. Cannot add new
section. 

•

-3 Sum of Section byte counts doesn’t add to total
byte count.

•

-4 Previous Section was not 3 or 7.

•

-5 Could not find requested Product Definition
Template. 

•

-6 Section 3 (GDS) not previously defined in
message. 

•

-7 Tried to use unsupported Data Representationi
Template. 

•

-8 Specified use of a previously defined bitmap, but one
does not exist in the GRIB message.

•

-9 GDT of one of 5.50 through 5.53 required to pack
field using DRT 5.51.

•

-10 Error packing data field.

Note

Note that the Sections 4
through 7 can only follow Section 3 or Section 7 in a GRIB2
message.

Author

Stephen Gilbert

Date

2002-11-05

Definition at
line 103 of file g2_addfield.c.

References
cmplxpack(), gtemplate::ext, gtemplate::extlen,
extpdstemplate(), gbit(), getdim(), getdrstemplate(),
getpdstemplate(), getpoly(), jpcpack(), gtemplate::map,
gtemplate::maplen, mkieee(), gtemplate::needext, pngpack(),
sbit(), sbits(), simpack(), and specpack().

g2int
g2_addgrid (unsigned char * cgrib, g2int * igds, g2int *
igdstmpl, g2int * ideflist, g2int idefnum) 
This routine packs up a Grid Definition Section (Section 3)
and adds it to a GRIB2 message. It is used with routines
g2_create(), g2_addlocal(),
g2_addfield(), and g2_gribend() to create a
complete GRIB2 message. g2_create() must be called
first to initialize a new GRIB2 message.

Parameters

cgrib Char array that
contains the GRIB2 message to which section should be added.
Must be allocated large enough to store the entire GRIB2
message. 
igds Contains information needed for GRIB Grid
Definition Section 3. Must be dimensioned >= 5.

•

igds[0] Source of grid
definition (see Code Table 3.0)

•

igds[1] Number of grid points in the defined grid.

•

igds[2] Number of octets needed for each additional grid
points definition. Used to define number of points in each
row (or column) for non-regular grids. = 0, if using regular
grid. 

•

igds[3] Interpretation of list for optional points
definition. (Code Table 3.11)

•

igds[4] Grid Definition Template Number (Code Table
3.1) 

igdstmpl
Contains the data values for the specified Grid Definition
Template (NN=igds[4]). Each element of this integer array
contains an entry (in the order specified) of Grid Defintion
Template 3.NN 
ideflist (Used if igds[2] != 0) This array contains the
number of grid points contained in each row (or column).

idefnum (Used if igds[2] != 0) The number of entries in
array ideflist. i.e. number of rows (or columns) for which
optional grid points are defined.

Returns

•

> 0 Current size of updated
GRIB2 message

•

-1 GRIB message was not initialized. Need to call
routine gribcreate first.

•

-2 GRIB message already complete. Cannot add new
section. 

•

-3 Sum of Section byte counts doesn’t add to total
byte count

•

-4 Previous Section was not 1, 2 or 7.

•

-5 Could not find requested Grid Definition
Template. 

Note

The Grid Def Section ( Section
3 ) can only follow Section 1, 2 or Section 7 in a GRIB2
message.

PROGRAM HISTORY
LOG

•

2002-11-01 Gilbert

•

2009-01-14 Vuong Changed structure name template to
gtemplate 

Author

Stephen Gilbeert

Date

2002-11-01

Definition at
line 60 of file g2_addgrid.c.

References
gtemplate::ext, extgridtemplate(), gtemplate::extlen,
gbit(), getgridtemplate(), gtemplate::map,
gtemplate::maplen, gtemplate::needext, sbit(), and
sbits().

g2int
g2_addlocal (unsigned char * cgrib, unsigned char * csec2,
g2int lcsec2) 
This routine adds a Local Use Section (Section 2) to a GRIB2
message. It is used with routines g2_create(),
g2_addgrid(), g2_addfield(), and
g2_gribend() to create a complete GRIB2 message.
g2_create() must be called first to initialize a new
GRIB2 message.

Parameters

cgrib Char array that
contains the GRIB2 message to which section 2 should be
added. Must be allocated large enough to store the entire
GRIB2 message. 
csec2 Character array containing information to be added
in Section 2. 
lcsec2 Number of bytes of character array csec2 to be
added to Section 2.

Returns

> 0 = Current size of
updated GRIB2 message.

•

-1 GRIB message was not
initialized. Need to call routine gribcreate first.

•

-2 GRIB message already complete. Cannot add new
section. 

•

-3 Sum of Section byte counts doesn’t add to total
byte count

•

-4 Previous Section was not 1 or 7.

Note

The Local Use Section (Section
2) can only follow Section 1 or Section 7 in a GRIB2
message.

Author

Stephen Gilbeert

Date

2002-11-01

Definition at
line 37 of file g2_addlocal.c.

References
gbit(), and sbit().

g2int
g2_create (unsigned char * cgrib, g2int * listsec0, g2int *
listsec1) 
This routine initializes a new GRIB2 message and packs GRIB2
sections 0 (Indicator Section) and 1 (Identification
Section). This routine is used with routines
g2_addlocal(), g2_addgrid(),
g2_addfield(), and g2_gribend() to create a
complete GRIB2 message. g2_create() must be called
first to initialize a new GRIB2 message. Also, a call to
g2_gribend() is required to complete GRIB2 message
after all fields have been added.

Parameters

cgrib Character array to
contain the GRIB2 message. Must be allocated large enough to
store the entire GRIB2 message. 
listsec0 Contains information needed for GRIB Indicator
Section 0. Must be dimensioned >= 2.

•

listsec0[0]=Discipline-GRIB
Master Table Number (see Code Table 0.0)

•

listsec0[1]=GRIB Edition Number (currently 2)

listsec1
Contains information needed for GRIB Identification Section
1. Must be dimensioned >= 13.

•

listsec1[0] Id of orginating
centre (Common Code Table C-1)

•

listsec1[1] Id of orginating sub-centre (local
table) 

•

listsec1[2] GRIB Master Tables Version Number (Code
Table 1.0)

•

listsec1[3] GRIB Local Tables Version Number (Code Table
1.1) 

•

listsec1[4] Significance of Reference Time (Code Table
1.2) 

•

listsec1[5] Reference Time - Year (4 digits)

•

listsec1[6] Reference Time - Month

•

listsec1[7] Reference Time - Day

•

listsec1[8] Reference Time - Hour

•

listsec1[9] Reference Time - Minute

•

listsec1[10] Reference Time - Second

•

listsec1[11] Production status of data (Code Table
1.3) 

•

listsec1[12] Type of processed data (Code Table 1.4)

Returns

- > 0 Current size of new
GRIB2 message

•

-1 Tried to use for version
other than GRIB Edition 2

This routine is
intended for use with routines g2_addlocal(),
g2_addgrid(), g2_addfield(), and
g2_gribend() to create a complete GRIB2 message.

Author

Stephen Gilbeert

Date

2002-10-31

Definition at
line 52 of file g2_create.c.

References
MAPSEC1LEN, and sbit().

void g2_free
(gribfield * gfld) 
This routine frees up memory that was allocated for struct
gribfield.

Parameters

gfld pointer to
gribfield structure (defined in include file grib2.h)
returned from routine g2_getfld().

Note

This routine must be called to
free up memory used by the decode routine,
g2_getfld(), when user no longer needs to reference
this data.

Author

Stephen Gilbeert

Date

2002-10-28

Definition at
line 24 of file g2_free.c.

g2int
g2_getfld (unsigned char * cgrib, g2int ifldnum, g2int
unpack, g2int expand, gribfield ** gfld) 
This subroutine returns all the metadata, template values,
Bit-map (if applicable), and the unpacked data for a given
data field. All of the information returned is stored in a
gribfield structure, which is defined in file
grib2.h. Users of this routine will need to include
grib2.h in their source code that calls this
routine.

Since there can
be multiple data fields packed into a GRIB2 message, the
calling routine indicates which field is being requested
with the ifldnum argument.

PROGRAM HISTORY
LOG:

•

2002-10-28 Gilbert

•

2013-08-08 Vuong Free up memory in array igds -
free(igds) 

Parameters

cgrib Character pointer
to the GRIB2 message. 
ifldnum Specifies which field in the GRIB2 message to
return. 
unpack Boolean value indicating whether to unpack
bitmap/data field.

•

1 unpack bitmap (if present) and
data values.

•

0 do not unpack bitmap and data values.

expand
Boolean value indicating whether the data points should be
expanded to the correspond grid, if a bit-map is present.
This argument is ignored if unpack == 0 OR if the returned
field does not contain a bit-map.

•

1 if possible, expand data field
to grid, inserting zero values at gridpoints that are
bitmapped out. (SEE REMARKS2)

•

0 do not expand data field, leaving it an array of
consecutive data points for each ’1’ in the
bitmap. 

gfld
pointer to structure gribfield containing all decoded data
for the data field.

gfld->version
= GRIB edition number ( currently 2 ) 
gfld->discipline = Message Discipline ( see Code Table
0.0 ) 
gfld->idsect = Contains the entries in the Identification

Section ( Section 1 ) 
This element is a pointer to an array 
that holds the data. 
gfld->idsect[0] = Identification of originating Centre

( see Common Code Table C-1 ) 
7 - US National Weather Service 
gfld->idsect[1] = Identification of originating
Sub-centre 
gfld->idsect[2] = GRIB Master Tables Version Number 
( see Code Table 1.0 ) 
0 - Experimental 
1 - Initial operational version number 
gfld->idsect[3] = GRIB Local Tables Version Number 
( see Code Table 1.1 ) 
0 - Local tables not used 
1-254 - Number of local tables version used 
gfld->idsect[4] = Significance of Reference Time (Code
Table 1.2) 
0 - Analysis 
1 - Start of forecast 
2 - Verifying time of forecast 
3 - Observation time 
gfld->idsect[5] = Year ( 4 digits ) 
gfld->idsect[6] = Month 
gfld->idsect[7) = Day 
gfld->idsect[8] = Hour 
gfld->idsect[9] = Minute 
gfld->idsect[10] = Second 
gfld->idsect[11] = Production status of processed data

( see Code Table 1.3 ) 
0 - Operational products 
1 - Operational test products 
2 - Research products 
3 - Re-analysis products 
gfld->idsect[12] = Type of processed data ( see Code
Table 1.4 ) 
0 - Analysis products 
1 - Forecast products 
2 - Analysis and forecast products 
3 - Control forecast products 
4 - Perturbed forecast products 
5 - Control and perturbed forecast products 
6 - Processed satellite observations 
7 - Processed radar observations 
gfld->idsectlen = Number of elements in
gfld->idsect[]. 
gfld->local = Pointer to character array containing
contents 
of Local Section 2, if included 
gfld->locallen = length of array gfld->local[] 
gfld->ifldnum = field number within GRIB message 
gfld->griddef = Source of grid definition (see Code Table
3.0) 
0 - Specified in Code table 3.1 
1 - Predetermined grid Defined by originating centre 
gfld->ngrdpts = Number of grid points in the defined
grid. 
gfld->numoct_opt = Number of octets needed for each 
additional grid points definition. 
Used to define number of 
points in each row ( or column ) for 
non-regular grids. 
= 0, if using regular grid. 
gfld->interp_opt = Interpretation of list for optional
points 
definition. (Code Table 3.11) 
gfld->igdtnum = Grid Definition Template Number (Code
Table 3.1) 
gfld->igdtmpl = Contains the data values for the
specified Grid 
Definition Template ( NN=gfld->igdtnum ). Each 
element of this integer array contains an entry (in 
the order specified) of Grid Defintion Template 3.NN 
This element is a pointer to an array 
that holds the data. 
gfld->igdtlen = Number of elements in gfld->igdtmpl[].
i.e. number of 
entries in Grid Defintion Template 3.NN 
( NN=gfld->igdtnum ). 
gfld->list_opt = (Used if gfld->numoct_opt .ne. 0)
This array 
contains the number of grid points contained in 
each row ( or column ). (part of Section 3) 
This element is a pointer to an array 
that holds the data. This pointer is nullified 
if gfld->numoct_opt=0. 
gfld->num_opt = (Used if gfld->numoct_opt .ne. 0) 
The number of entries 
in array ideflist. i.e. number of rows ( or columns ) 
for which optional grid points are defined. This value 
is set to zero, if gfld->numoct_opt=0. 
gfdl->ipdtnum = Product Definition Template Number(see
Code Table 4.0) 
gfld->ipdtmpl = Contains the data values for the
specified Product 
Definition Template ( N=gfdl->ipdtnum ). Each element

of this integer array contains an entry (in the 
order specified) of Product Defintion Template 4.N. 
This element is a pointer to an array 
that holds the data. 
gfld->ipdtlen = Number of elements in gfld->ipdtmpl[].
i.e. number of 
entries in Product Defintion Template 4.N 
( N=gfdl->ipdtnum ). 
gfld->coord_list = Real array containing floating point
values 
intended to document the vertical discretisation 
associated to model data on hybrid coordinate 
vertical levels. (part of Section 4) 
This element is a pointer to an array 
that holds the data. 
gfld->num_coord = number of values in array
gfld->coord_list[]. 
gfld->ndpts = Number of data points unpacked and
returned. 
gfld->idrtnum = Data Representation Template Number 
( see Code Table 5.0) 
gfld->idrtmpl = Contains the data values for the
specified Data 
Representation Template ( N=gfld->idrtnum ). Each 
element of this integer array contains an entry 
(in the order specified) of Product Defintion 
Template 5.N. 
This element is a pointer to an array 
that holds the data. 
gfld->idrtlen = Number of elements in gfld->idrtmpl[].
i.e. number 
of entries in Data Representation Template 5.N 
( N=gfld->idrtnum ). 
gfld->unpacked = logical value indicating whether the
bitmap and 
data values were unpacked. If false, 
gfld->bmap and gfld->fld pointers are nullified. 
gfld->expanded = Logical value indicating whether the
data field 
was expanded to the grid in the case where a 
bit-map is present. If true, the data points in 
gfld->fld match the grid points and zeros were 
inserted at grid points where data was bit-mapped 
out. If false, the data values in gfld->fld were 
not expanded to the grid and are just a consecutive 
array of data points corresponding to each value of 
’1’ in gfld->bmap. 
gfld->ibmap = Bitmap indicator ( see Code Table 6.0 )

0 = bitmap applies and is included in Section 6. 
1-253 = Predefined bitmap applies 
254 = Previously defined bitmap applies to this field 
255 = Bit map does not apply to this product. 
gfld->bmap = integer array containing decoded bitmap,

if gfld->ibmap=0 or gfld->ibap=254. Otherwise
nullified 
This element is a pointer to an array 
that holds the data. 
gfld->fld = Array of gfld->ndpts unpacked data points.

This element is a pointer to an array 
that holds the data.

Returns

•

0 no error

•

1 Beginning characters ’GRIB’ not found.

•

2 GRIB message is not Edition 2.

•

3 The data field request number was not positive.

•

4 End string ’7777’ found, but not where
expected. 

•

6 GRIB message did not contain the requested number of
data fields.

•

7 End string ’7777’ not found at end of
message. 

•

8 Unrecognized Section encountered.

•

9 Data Representation Template 5.NN not yet
implemented. 

•

15 Error unpacking Section 1.

•

16 Error unpacking Section 2.

•

10 Error unpacking Section 3.

•

11 Error unpacking Section 4.

•

12 Error unpacking Section 5.

•

13 Error unpacking Section 6.

•

14 Error unpacking Section 7.

•

17 Previous bitmap specified, yet none exists.

Note

Struct gribfield is allocated
by this routine and it also contains pointers to many arrays
of data that were allocated during decoding. Users are
encouraged to free up this memory, when it is no longer
needed, by an explicit call to routine g2_free.

EXAMPLE:

#include
"grib2.h" 
gribfield *gfld; 
ret=g2_getfld(cgrib,1,1,1,&gfld); 
... 
g2_free(gfld);

Routine g2_info
can be used to first determine how many data fields exist in
a given GRIB message.

Note

It may not always be possible
to expand a bit-mapped data field. If a pre-defined bit-map
is used and not included in the GRIB2 message itself, this
routine would not have the necessary information to expand
the data. In this case, gfld->expanded would would be set
to 0 (false), regardless of the value of input argument
expand.

Author

Stephen Gilbert

Date

2002-10-28

Definition at
line 237 of file g2_getfld.c.

References
g2_unpack1(), g2_unpack2(), g2_unpack3(), g2_unpack4(),
g2_unpack5(), g2_unpack6(), g2_unpack7(), and gbit().

g2int
g2_gribend (unsigned char * cgrib) 
This routine finalizes a GRIB2 message after all grids and
fields have been added. It adds the End Section
(’7777’) to the end of the GRIB message and
calculates the length and stores it in the appropriate place
in Section 0. This routine is used with routines
g2_create(), g2_addlocal(),
g2_addgrid(), and g2_addfield() to create a
complete GRIB2 message. g2_create() must be called
first to initialize a new GRIB2 message.

Parameters

cgrib Char array
containing all the data sections added be previous calls to
g2_create, g2_addlocal, g2_addgrid, and g2_addfield. After
function is called, contains the finalized GRIB2
message.

Returns

•

> 0 = Length of the final
GRIB2 message in bytes.

•

-1 = GRIB message was not initialized. Need to call
routine g2_create first.

•

-2 = GRIB message already complete.

•

-3 = Sum of Section byte counts doesn’t add to
total byte count

•

-4 = Previous Section was not 7.

Note

This routine is intended for
use with routines g2_create(), g2_addlocal(),
g2_addgrid(), and g2_addfield() to create a
complete GRIB2 message.

Author

Stephen Gilbert

Date

2002-10-31

Definition at
line 36 of file g2_gribend.c.

References
gbit(), and sbit().

g2int
g2_info (unsigned char * cgrib, g2int * listsec0, g2int *
listsec1, g2int * numfields, g2int * numlocal) 
This subroutine searches through a GRIB2 message and returns
the number of gridded fields found in the message and the
number (and maximum size) of Local Use Sections. Also
various checks are performed to see if the message is a
valid GRIB2 message.

Parameters

cgrib Character pointer
to the GRIB2 message. 
listsec0 pointer to an array containing information
decoded from GRIB Indicator Section 0. Must be allocated
with >= 3 elements.

•

listsec0[0] Discipline-GRIB
Master Table Number (see Code Table 0.0).

•

listsec0[1] GRIB Edition Number (currently 2).

•

listsec0[2] Length of GRIB message.

listsec1
Pointer to an array containing information read from GRIB
Identification Section 1. Must be allocated with >= 13
elements.

•

listsec1[0] Id of orginating
centre (Common Code Table C-1)

•

listsec1[1] Id of orginating sub-centre (local
table) 

•

listsec1[2] GRIB Master Tables Version Number (Code
Table 1.0)

•

listsec1[3] GRIB Local Tables Version Number

•

listsec1[4] Significance of Reference Time (Code Table
1.1) 

•

listsec1[5] Reference Time - Year (4 digits)

•

listsec1[6] Reference Time - Month

•

listsec1[7] Reference Time - Day

•

listsec1[8] Reference Time - Hour

•

listsec1[9] Reference Time - Minute

•

listsec1[10] Reference Time - Second

•

listsec1[11] Production status of data (Code Table
1.2) 

•

listsec1[12] Type of processed data (Code Table 1.3)

numfields
The number of gridded fields found in the GRIB message. That
is, the number of occurences of Sections 4 - 7. 
numlocal The number of Local Use Sections ( Section 2 )
found in the GRIB message.

Returns

0 foe success, otherwise:

•

1 Beginning characters
’GRIB’ not found.

•

2 GRIB message is not Edition 2.

•

3 Could not find Section 1, where expected.

•

4 End string ’7777’ found, but not where
expected. 

•

5 End string ’7777’ not found at end of
message. 

•

6 Invalid section number found.

Author

Stephen Gilbeert

Date

2002-10-28

Definition at
line 59 of file g2_info.c.

References
gbit().

g2int
g2_unpack1 (unsigned char * cgrib, g2int * iofst, g2int **
ids, g2int * idslen) 
This subroutine unpacks Section 1 (Identification Section)
as defined in GRIB Edition 2.

Parameters

cgrib char array
containing Section 1 of the GRIB2 message. 
iofst Bit offset for the beginning of Section 1 in
cgrib. 
ids address of pointer to integer array containing
information read from Section 1, the Identification
section.

•

ids[0] Identification of
originating Centre (see Common Code Table C-1).

•

ids[1] Identification of originating Sub-centre.

•

ids[2] GRIB Master Tables Version Number (see Code Table
1.0). 

•

ids[3] GRIB Local Tables Version Number (see Code Table
1.1). 

•

ids[4] Significance of Reference Time (Code Table
1.2) 

•

ids[5] Year ( 4 digits )

•

ids[6] Month

•

ids[7] Day

•

ids[8] Hour

•

ids[9] Minute

•

ids[10] Second

•

ids[11] Production status of processed data (see Code
Table 1.3).

•

ids[12] Type of processed data (see Code Table 1.4).

idslen
Number of elements in ids.

Returns

•

0 no error

•

2 Array passed is not section 1

•

6 memory allocation error

Author

Stephen Gilbert

Date

2002-10-29

Definition at
line 44 of file g2_unpack1.c.

g2int
g2_unpack3 (unsigned char * cgrib, g2int * iofst, g2int **
igds, g2int ** igdstmpl, g2int * mapgridlen, g2int **
ideflist, g2int * idefnum) 
This routine unpacks Section 3 (Grid Definition Section) as
defined in GRIB Edition 2. PROGRAM HISTORY LOG:

•

2002-10-31 Gilbert

•

2009-01-14 Vuong Changed structure name template to
gtemplate 

Parameters

cgrib Char array
ontaining Section 3 of the GRIB2 message. 
iofst Bit offset for the beginning of Section 3 in
cgrib. 
igds Contains information read from the appropriate GRIB
Grid Definition Section 3 for the field being returned.

•

igds[0] Source of grid
definition (see Code Table 3.0)

•

igds[1] Number of grid points in the defined grid.

•

igds[2] Number of octets needed for each additional grid
points definition. Used to define number of points in each
row (or column) for non-regular grids. = 0, if using regular
grid. 

•

igds[3] Interpretation of list for optional points
definition. (Code Table 3.11)

•

igds[4] Grid Definition Template Number (Code Table
3.1). 

igdstmpl
- Pointer to integer array containing the data values for
the specified Grid Definition Template (NN=igds[4]). Each
element of this integer array contains an entry (in the
order specified) of Grid Defintion Template 3.NN 
mapgridlen- Number of elements in igdstmpl[]. i.e.
number of entries in Grid Defintion Template 3.NN
(NN=igds[4]). 
ideflist (Used if igds[2] .ne. 0) Pointer to integer
array containing the number of grid points contained in each
row ( or column ). (part of Section 3). 
idefnum (Used if igds[2] .ne. 0) The number of entries
in array ideflist. i.e. number of rows (or columns) for
which optional grid points are defined.

Returns

•

0 no error

•

2 Not Section 3

•

5 ’GRIB’ message contains an undefined Grid
Definition Template.

•

6 memory allocation error

Author

Stephen Gilbert

Date

2002-10-31

Definition at
line 53 of file g2_unpack3.c.

g2int
g2_unpack4 (unsigned char * cgrib, g2int * iofst, g2int *
ipdsnum, g2int ** ipdstmpl, g2int * mappdslen, g2float **
coordlist, g2int * numcoord) 
This subroutine unpacks Section 4 (Product Definition
Section) as defined in GRIB Edition 2. PROGRAM HISTORY
LOG:

•

2002-10-31 Gilbert

•

2009-01-14 Vuong Changed structure name template to
gtemplate 

Parameters

cgrib Char array
containing Section 4 of the GRIB2 message. 
iofst Bit offset of the beginning of Section 4 in cgrib.
Returned with updated bit offset. 
ipdsnum Product Definition Template Number (see Code
Table 4.0). 
ipdstmpl Pointer to integer array containing the data
values for the specified Product Definition Template
(N=ipdsnum). Each element of this integer array contains an
entry (in the order specified) of Product Defintion Template
4.N. 
mappdslen Number of elements in ipdstmpl. i.e. number of
entries in Product Defintion Template 4.N (N=ipdsnum).

coordlist Pointer to real array containing floating
point values intended to document the vertical
discretisation associated to model data on hybrid coordinate
vertical levels. (part of Section 4). 
numcoord number of values in array coordlist.

Returns

•

0 no error

•

2 Not section 4

•

5 ’GRIB’ message contains an undefined
Product Definition Template.

•

6 memory allocation error

Author

Stephen Gilbert

Date

2002-10-31

Definition at
line 42 of file g2_unpack4.c.

g2int
g2_unpack5 (unsigned char * cgrib, g2int * iofst, g2int *
ndpts, g2int * idrsnum, g2int ** idrstmpl, g2int *
mapdrslen) 
This subroutine unpacks Section 5 (Data Representation
Section) as defined in GRIB Edition 2. PROGRAM HISTORY
LOG:

•

2002-10-31 Gilbert

•

2009-01-14 Vuong Changed structure name template to
gtemplate 

Parameters

cgrib char array
containing Section 5 of the GRIB2 message. 
iofst Bit offset for the beginning of Section 5 in
cgrib. Returned with bit offset at the end of Section 5.

ndpts Number of data points unpacked and returned.

idrsnum Data Representation Template Number (see Code
Table 5.0). 
idrstmpl Pointer to an integer array containing the data
values for the specified Data Representation Template
(N=idrsnum). Each element of this integer array contains an
entry (in the order specified) of Data Representation
Template 5.N. 
mapdrslen- Number of elements in idrstmpl. i.e. number
of entries in Data Representation Template 5.N
(N=idrsnum).

Returns

•

0 no error

•

2 Not Section 5

•

6 memory allocation error

•

7 ’GRIB’ message contains an undefined Data
Representation Template.

Author

Stephen Gilbert

Date

2002-10-31

Definition at
line 40 of file g2_unpack5.c.

g2int
g2_unpack6 (unsigned char * cgrib, g2int * iofst, g2int
ngpts, g2int * ibmap, g2int ** bmap) 
This subroutine unpacks Section 6 (Bit-Map Section) as
defined in GRIB Edition 2.

Parameters

cgrib char array
containing Section 6 of the GRIB2 message. 
iofst Bit offset of the beginning of Section 6 in cgrib.

ngpts Number of grid points specified in the bit-map

ibmap Bitmap indicator (see Code Table 6.0)

•

0 bitmap applies and is included
in Section 6.

•

1-253 Predefined bitmap applies

•

254 Previously defined bitmap applies to this field

•

255 Bit map does not apply to this product.

bmap
Pointer to an integer array containing decoded bitmap. (if
ibmap=0)

Returns

•

0 no error

•

2 Not Section 6

•

4 Unrecognized pre-defined bit-map.

•

6 memory allocation error

Author

Stephen Gilbert

Date

2002-10-31

Definition at
line 33 of file g2_unpack6.c.

g2int
g2_unpack7 (unsigned char * cgrib, g2int * iofst, g2int
igdsnum, g2int * igdstmpl, g2int idrsnum, g2int * idrstmpl,
g2int ndpts, g2float ** fld) 
This subroutine unpacks Section 7 (Data Section) as defined
in GRIB Edition 2. PROGRAM HISTORY LOG:

•

2002-10-31 Gilbert

•

2002-12-20 Gilbert - Added GDT info to arguments and
added 5.51 processing.

•

2003-08-29 Gilbert - Added support for new templates
using PNG and JPEG2000 algorithms/templates.

•

2004-11-29 Gilbert - JPEG2000 now allowed to use WMO
Template no. 5.40 PNG now allowed to use WMO Template no.
5.41 

•

2004-12-16 Taylor - Added check on comunpack return
code. 

•

2008-12-23 Wesley - Initialize Number of data points
unpacked 

Parameters

cgrib char array
containing Section 7 of the GRIB2 message 
iofst Bit offset of the beginning of Section 7 in cgrib.

igdsnum Grid Definition Template Number (see Code Table
3.0) (Only used for DRS Template 5.51) 
igdstmpl Pointer to an integer array containing the data
values for the specified Grid Definition Template
(N=igdsnum). Each element of this integer array contains an
entry (in the order specified) of Grid Definition Template
3.N. (Only used for DRS Template 5.51). 
idrsnum Data Representation Template Number (see Code
Table 5.0) 
idrstmpl Pointer to an integer array containing the data
values for the specified Data Representation Template
(N=idrsnum). Each element of this integer array contains an
entry (in the order specified) of Data Representation
Template 5.N 
ndpts Number of data points unpacked and returned.

fld Pointer to a float array containing the unpacked
data field.

Returns

•

0 no error

•

2 Not section 7

•

4 Unrecognized Data Representation Template

•

5 need one of GDT 3.50 through 3.53 to decode DRT
5.51 

•

6 memory allocation error

•

7 corrupt section 7.

Author

Stephen Gilbert

Date

2002-10-31

Definition at
line 66 of file g2_unpack7.c.

void gbit
(unsigned char * in, g2int * iout, g2int iskip, g2int
nbyte) 
Get bits - unpack bits: Extract arbitrary size values from a
packed bit string, right justifying each value in the
unpacked iout array.

Parameters

in pointer to character
array input. 
iout pointer to unpacked array output. 
iskip initial number of bits to skip. 
nbyte number of bits to take.

Author

NOAA Programmer

Definition at
line 20 of file gbits.c.

References
gbits().

Referenced by
comunpack(), g2_addfield(), g2_addgrid(), g2_addlocal(),
g2_getfld(), g2_gribend(), g2_info(), g2_unpack1(),
g2_unpack2(), g2_unpack3(), g2_unpack4(), g2_unpack5(),
g2_unpack6(), g2_unpack7(), and seekgb().

void gbits
(unsigned char * in, g2int * iout, g2int iskip, g2int nbyte,
g2int nskip, g2int n) 
Get bits - unpack bits: Extract arbitrary size values from a
packed bit string, right justifying each value in the
unpacked iout array.

Parameters

in pointer to character
array input. 
iout pointer to unpacked array output. 
iskip initial number of bits to skip. 
nbyte number of bits to take. 
nskip additional number of bits to skip on each
iteration. 
n number of iterations.

Author

NOAA Programmer

Definition at
line 57 of file gbits.c.

Referenced by
comunpack(), g2_unpack3(), g2_unpack4(), g2_unpack6(),
gbit(), pngunpack(), simunpack(), and specunpack().

gtemplate*
getdrstemplate (g2int number) 
This subroutine returns DRS template information for a
specified Data Representation Template 5.NN. The number of
entries in the template is returned along with a map of the
number of octets occupied by each entry. Also, a flag is
returned to indicate whether the template would need to be
extended.

PROGRAM HISTORY
LOG:

•

2000-05-11 Gilbert

•

2009-01-14 Vuong Changed structure name template to
gtemplate 

Parameters

number NN, indicating
the number of the Data Representation Template 5.NN that is
being requested.

Returns

Pointer to the returned
template struct. Returns NULL pointer, if template not
found.

Author

Stephen Gilbert

Date

2000-05-11

Definition at
line 57 of file drstemplates.c.

References
getdrsindex(), drstemplate::mapdrslen, drstemplate::needext,
drstemplate::template_num, and templatesdrs.

Referenced by
extdrstemplate(), g2_addfield(), and g2_unpack5().

gtemplate*
getgridtemplate (g2int number) 
This subroutine returns grid template information for a
specified Grid Definition Template 3.NN. The number of
entries in the template is returned along with a map of the
number of octets occupied by each entry. Also, a flag is
returned to indicate whether the template would need to be
extended.

PROGRAM HISTORY
LOG:

•

2000-05-09 Gilbert

•

2007-08-16 Vuong - Added GDT 3.204 Curvilinear
Orthogonal Grid

•

2008-07-08 Vuong - Added GDT 3.32768 Rotate Lat/Lon
E-grid (Arakawa)

•

2010-05-11 Vuong - Added GDT 3.32769 Rotate Lat/Lon
Non-E Staggered grid (Arakawa)

•

2009-01-14 Vuong - Changed structure name template to
gtemplate 

Parameters

number NN, indicating
the number of the Grid Definition Template 3.NN that is
being requested.

Returns

Pointer to the returned
template struct. Returns NULL pointer, if template not
found.

Author

Stephen Gilbert

Date

2000-05-09

Definition at
line 68 of file gridtemplates.c.

References
getgridindex(), and templatesgrid.

Referenced by
extgridtemplate(), g2_addgrid(), and g2_unpack3().

gtemplate*
getpdstemplate (g2int number) 
This subroutine returns PDS template information for a
specified Product Definition Template 4.NN. The number of
entries in the template is returned along with a map of the
number of octets occupied by each entry. Also, a flag is
returned to indicate whether the template would need to be
extended.

Parameters

number NN, indicating
the number of the Product Definition Template 4.NN that is
being requested.

Returns

Pointer to the returned
template struct. Returns NULL pointer, if template not
found.

Author

Stephen Gilbert

Date

2000-05-11

Definition at
line 65 of file pdstemplates.c.

References
getpdsindex(), and templatespds.

Referenced by
extpdstemplate(), g2_addfield(), and g2_unpack4().

double
int_power (double x, g2int y) 
Function similar to C pow() power function.

Parameters

x The base value whose
power is to be calculated. 
y The power value.

Returns

x**y

Author

Wesley Ebisuzaki

Definition at
line 17 of file int_power.c.

Referenced by
compack(), comunpack(), jpcpack(), jpcunpack(), misspack(),
mkieee(), pngpack(), pngunpack(), rdieee(), simpack(),
simunpack(), specpack(), and specunpack().

void
misspack (g2float * fld, g2int ndpts, g2int idrsnum, g2int *
idrstmpl, unsigned char * cpack, g2int * lcpack) 
This subroutine packs up a data field using a complex
packing algorithm as defined in the GRIB2 documention. It
supports GRIB2 complex packing templates with or without
spatial differences (i.e. DRTs 5.2 and 5.3). It also fills
in GRIB2 Data Representation Template 5.2 or 5.3 with the
appropriate values. This version assumes that Missing Value
Management is being used and that 1 or 2 missing values
appear in the data.

Parameters

fld Contains the data
values to pack 
ndpts The number of data values in array fld 
idrsnum Data Representation Template number 5.N Must
equal 2 or 3. 
idrstmpl Contains the array of values for Data
Representation Template 5.2 or 5.3.

•

0 Reference value - ignored on
input, set by misspack routine.

•

1 Binary Scale Factor - used on input.

•

2 Decimal Scale Factor- used on input.

•

6 Missing value management.

•

7 Primary missing value.

•

8 Secondary missing value.

•

16 Order of Spatial Differencing (1 or 2).

cpack
The packed data field (character*1 array). 
lcpack length of packed field cpack.

Author

Stephen Gilbert

Date

2000-06-21

Definition at
line 38 of file misspack.c.

References
int_power(), mkieee(), pack_gp(), rdieee(), sbit(), and
sbits().

Referenced by
cmplxpack().

void mkieee
(g2float * a, g2int * rieee, g2int num) 
This subroutine stores a list of real values in 32-bit IEEE
floating point format.

Parameters

a Input array of
floating point values. 
num Number of floating point values to convert. 
rieee Output array of data values in 32-bit IEEE format
stored in g2int integer array. rieee must be allocated with
at least 4*num bytes of memory before calling this
function.

Author

Stephen Gilbert

Date

2002-10-29

Definition at
line 21 of file mkieee.c.

References
int_power().

Referenced by
compack(), g2_addfield(), jpcpack(), misspack(), pngpack(),
simpack(), and specpack().

int pack_gp
(integer * kfildo, integer * ic, integer * nxy, integer *
is523, integer * minpk, integer * inc, integer * missp,
integer * misss, integer * jmin, integer * jmax, integer *
lbit, integer * nov, integer * ndg, integer * lx, integer *
ibit, integer * jbit, integer * kbit, integer * novref,
integer * lbitref, integer * ier) 
Determines groups of variable size, but at least of size
minpk, the associated max (jmax( )) and min (jmin( )), the
number of bits necessary to hold the values in each group
(lbit( )), the number of values in each group (nov( )), the
number of bits necessary to pack the jmin( ) values (ibit),
the number of bits necessary to pack the lbit( ) values
(jbit), and the number of bits necessary to pack the nov( )
values (kbit). The routine is designed to determine the
groups such that a small number of bits is necessary to pack
the data without excessive computations. If all values in
the group are zero, the number of bits to use in packing is
defined as zero when there can be no missing values; when
there can be missing values, the number of bits must be at
least 1 to have the capability to recognize the missing
value. However, if all values in a group are missing, the
number of bits needed is 0, and the unpacker recognizes
this. All variables are integer. Even though the groups are
initially of size minpk or larger, an adjustment between two
groups (the lookback procedure) may make a group smaller
than minpk. The control on group size is that the sum of the
sizes of the two consecutive groups, each of size minpk or
larger, is not decreased. When determining the number of
bits necessary for packing, the largest value that can be
accommodated in, say, mbits, is 2**mbits-1; this largest
value (and the next smallest value) is reserved for the
missing value indicator (only) when is523 ne 0. If the
dimension ndg is not large enough to hold all the groups,
the local value of minpk is increased by 50 percent. This is
repeated until ndg will suffice. A diagnostic is printed
whenever this happens, which should be very rarely. If it
happens often, ndg in subroutine pack should be increased
and a corresponding increase in subroutine unpack made.
Considerable code is provided so that no more checking for
missing values within loops is done than necessary; the
added efficiency of this is relatively minor, but does no
harm. For grib2, the reference value for the length of
groups in nov( ) and for the number of bits necessary to
pack group values are determined, and subtracted before jbit
and kbit are determined.

When 1 or more
groups are large compared to the others, the width of all
groups must be as large as the largest. A subroutine reduce
breaks up large groups into 2 or more to reduce total bits
required. If reduce should abort, pack_gp will be executed
again without the call to reduce.

PROGRAM HISTORY
LOG:

•

February 1994 Glahn tdl
mos-2000 

•

June 1995 Glahn modified for lmiss error.

•

July 1996 Glahn added misss

•

February 1997 Glahn removed 4 redundant tests for
missp.eq.0; inserted a test to better handle a string of
9999’s 

•

February 1997 Glahn added loops to eliminate test for
misss when misss = 0

•

March 1997 Glahn corrected for secondary missing
value 

•

March 1997 Glahn corrected for use of local value of
minpk 

•

March 1997 Glahn corrected for secondary missing
value 

•

March 1997 Glahn changed calculating number of bits
through exponents to an array (improved overall packing
performance by about 35 percent!). allowed 0 bits for
packing jmin( ), lbit( ), and nov( ).

•

May 1997 Glahn a number of changes for efficiency. mod
functions eliminated and one ifthen added. jount removed.
recomputation of bits not made unless necessary after moving
points from one group to another. nendb adjusted to
eliminate possibility of very small group at the end. about
8 percent improvement in overall packing. iskipa removed;
there is always a group b that can become group a. control
on size of group b (statement below 150) added. added adda,
and use of ge and le instead of gt and lt in loops between
150 and 160. ibitbs added to shorten trips through loop.

•

March 2000 Glahn modified for grib2; changed name from
packgp 

•

january 2001 Glahn comments; ier = 706 substituted for
stops; added return1; removed statement number 110; added
ier and * return

•

November 2001 Glahn changed some diagnostic formats to
allow printing larger numbers

•

November 2001 Glahn added misslx( ) to put maximum value
into jmin( ) when all values missing to agree with grib
standard. 

•

November 2001 Glahn changed two tests on missp and misss
eq 0 to tests on is523. however, missp and misss cannot in
general be = 0.

•

November 2001 Glahn added call to reduce; defined itest
before loops to reduce computation; started large group when
all same value

•

December 2001 Glahn modified and added a few
comments 

•

January 2002 Glahn removed loop before 150 to determine
a group of all same value

•

January 2002 Glahn changed mallow from 9999999 to
2**30+1, and made it a parameter

•

March 2002 Glahn added non fatal ier = 716, 717; removed
nendb=nxy above 150; added iersav=0; comments

DATA SET
USE

•

kfildo - unit number for output
(print) file. (output)

Parameters

kfildo unit number for
output (print) file. (input) 
ic array to hold data for packing. the values do not
have to be positive at this point, but must be in the range
-2**30 to +2**30 (the the value of mallow). these integer
values will be retained exactly through packing and
unpacking. (input) 
nxy number of values in ic( ). also treated as its
dimension. (input) 
is523 missing value management 0=data contains no
missing values 1=data contains primary missing values 2=data
contains primary and secondary missing values (input)

minpk the minimum size of each group, except possibly
the last one. (input) 
inc the number of values to add to an already existing
group in determining whether or not to start a new group.
ideally, this would be 1, but each time inc values are
attempted, the max and min of the next minpk values must be
found. this is ’a loop within a loop,’ and a
slightly larger value may give about as good results with
slightly less computational time. if inc is le 0, 1 is used,
and a diagnostic is output. note: it is expected that inc
will equal 1. the code uses inc primarily in the loops
starting at statement 180. if inc were 1, there would not
need to be loops as such. however, kinc (the local value of
inc) is set ge 1 when near the end of the data to forestall
a very small group at the end. (input) 
missp when missing points can be present in the data,
they will have the value missp or misss. missp is the
primary missing value and misss is the secondary missing
value . these must not be values that would occur with
subtracting the minimum (reference) value or scaling. for
example, missp = 0 would not be advisable. (input) 
misss secondary missing value indicator (see missp).
(input) 
jmin the minimum of each group (j=1,lx). (output)

jmax the maximum of each group (j=1,lx). this is not
really needed, but since the max of each group must be
found, saving it here is cheap in case the user wants it.
(output) 
lbit the number of bits necessary to pack each group
(j=1,lx). it is assumed the minimum of each group will be
removed before packing, and the values to pack will,
therefore, all be positive. however, ic( ) does not
necessarily contain all positive values. if the overall
minimum has been removed (the usual case), then ic( ) will
contain only positive values. (output) 
nov the number of values in each group (j=1,lx).
(output) 
ndg the dimension of jmin, jmax, lbit, and nov. (input)

lx the number of groups determined. (output) 
ibit the number of bits necessary to pack the jmin(j)
values, j=1,lx. (output) 
jbit the number of bits necessary to pack the lbit(j)
values, j=1,lx. (output) 
kbit the number of bits necessary to pack the nov(j)
values, j=1,lx. (output) 
novref reference value for nov( ). (output) 
lbitref reference value for lbit( ). (output) 
ier Error code

•

0 No error.

•

706 value will not pack in 30 bits--fatal

•

714 error in reduce--non-fatal

•

715 ngp not large enough in reduce--non-fatal

•

716 minpk inceased--non-fatal

•

717 inc set

•

1--non-fatal

•

alternate return when ier ne 0 and fatal error.

Returns

0 - check ier for error
code.

INTERNAL
VARIABLES

cfeed =
contains the character representation 
of a printer form feed. 
ifeed = contains the integer value of a printer 
form feed. 
kinc = working copy of inc. may be modified. 
mina = minimum value in group a. 
maxa = maximum value in group a. 
nenda = the place in ic( ) where group a ends. 
kstart = the place in ic( ) where group a starts. 
ibita = number of bits needed to hold values in group a.

minb = minimum value in group b. 
maxb = maximum value in group b. 
nendb = the place in ic( ) where group b ends. 
ibitb = number of bits needed to hold values in group b.

minc = minimum value in group c. 
maxc = maximum value in group c. 
ktotal = count of number of values in ic( ) processed. 
nount = number of values added to group a. 
lmiss = 0 when is523 = 0. when packing into a 
specific number of bits, say mbits, 
the maximum value that can be handled is 
2**mbits-1. when is523 = 1, indicating 
primary missing values, this maximum value 
is reserved to hold the primary missing value 
indicator and lmiss = 1. when is523 = 2, 
the value just below the maximum (i.e., 
2**mbits-2) is reserved to hold the secondary 
missing value indicator and lmiss = 2. 
lminpk = local value of minpk. this will be adjusted 
upward whenever ndg is not large enough to hold 
all the groups. 
mallow = the largest allowable value for packing. 
mislla = set to 1 when all values in group a are missing.

this is used to distinguish between a real 
minimum when all values are not missing 
and a minimum that has been set to zero when 
all values are missing. 0 otherwise. 
note that this does not distinguish between 
primary and secondary missings when secondary 
missings are present. this means that 
lbit( ) will not be zero with the resulting 
compression efficiency when secondary missings 
are present. also note that a check has been 
made earlier to determine that secondary 
missings are really there. 
misllb = set to 1 when all values in group b are missing.

this is used to distinguish between a real 
minimum when all values are not missing 
and a minimum that has been set to zero when 
all values are missing. 0 otherwise. 
misllc = performs the same function for group c that 
mislla and misllb do for groups b and c, 
respectively. 
ibxx2(j) = an array that when this routine is first entered

is set to 2**j, j=0,30. ibxx2(30) = 2**30, which 
is the largest value packable, because 2**31 
is larger than the integer word size. 
ifirst = set by data statement to 0. changed to 1 on 
first 
entry when ibxx2( ) is filled. 
minak = keeps track of the location in ic( ) where the 
minimum value in group a is located. 
maxak = does the same as minak, except for the maximum. 
minbk = the same as minak for group b. 
maxbk = the same as maxak for group b. 
minck = the same as minak for group c. 
maxck = the same as maxak for group c. 
adda = keeps track whether or not an attempt to add 
points to group a was made. if so, then adda 
keeps from trying to put one back into b. 
(logical) 
ibitbs = keeps current value if ibitb so that loop 
ending at 166 doesn’t have to start at 
ibitb = 0 every time. 
misslx(j) = mallow except when a group is all one value (and

lbit(j) = 0) and that value is missing. in 
that case, misslx(j) is missp or misss. this 
gets inserted into jmin(j) later as the 
missing indicator; it can’t be put in until 
the end, because jmin( ) is used to calculate 
the maximum number of bits (ibits) needed to 
pack jmin( ).

Definition at
line 256 of file pack_gp.c.

References
FALSE_, reduce(), and TRUE_.

Referenced by
compack(), and misspack().

void rdieee
(g2int * rieee, g2float * a, g2int num) 
This subroutine reads a list of real values in 32-bit IEEE
floating point format.

Parameters

rieee g2int array of
floating point values in 32-bit IEEE format. 
num Number of floating point values to convert. 
a float array of real values. a must be allocated with
at least 4*num bytes of memory before calling this
function.

Author

Stephen Gilbert

Date

2002-10-25

Definition at
line 20 of file rdieee.c.

References
int_power().

Referenced by
comunpack(), g2_miss(), g2_unpack4(), g2_unpack7(),
jpcunpack(), misspack(), pngunpack(), simunpack(), and
specunpack().

void sbit
(unsigned char * out, g2int * in, g2int iskip, g2int
nbyte) 
Store bits - put arbitrary size values into a packed bit
string, taking the low order bits from each value in the
unpacked array.

Parameters

out pointer to packed
array output. Must be allocated large enough to hold output.

in pointer to unpacked array input. 
iskip initial number of bits to skip. 
nbyte number of bits to pack.

Author

NOAA Programmer

Definition at
line 38 of file gbits.c.

References
sbits().

Referenced by
compack(), g2_addfield(), g2_addgrid(), g2_addlocal(),
g2_create(), g2_gribend(), misspack(), and simpack().

void sbits
(unsigned char * out, g2int * in, g2int iskip, g2int nbyte,
g2int nskip, g2int n) 
Store bits - put arbitrary size values into a packed bit
string, taking the low order bits from each value in the
unpacked array.

Parameters

out pointer to packed
array output. Must be allocated large enough to hold output.

in pointer to unpacked array input. 
iskip initial number of bits to skip. 
nbyte number of bits to pack. 
nskip additional number of bits to skip on each
iteration. 
n number of iterations.

Author

NOAA Programmer

Definition at
line 110 of file gbits.c.

Referenced by
compack(), g2_addfield(), g2_addgrid(), jpcpack(),
misspack(), pngpack(), sbit(), and simpack().

void seekgb
(FILE * lugb, g2int iseek, g2int mseek, g2int * lskip, g2int
* lgrib) 
This subprogram searches a file for the next GRIB Message.
The search is done starting at byte offset iseek of the file
referenced by lugb for mseek bytes at a time. If found, the
starting position and length of the message are returned in
lskip and lgrib, respectively. The search is terminated when
an EOF or I/O error is encountered.

PROGRAM HISTORY
LOG:

•

2002-10-28 GILBERT Modified from
Iredell’s skgb subroutine

•

2009-01-16 VUONG Changed lskip to 4 instead of
sizof(g2int) 

Parameters

lugb FILE pointer for
the file to search. File must be opened before this routine
is called. 
iseek number of bytes in the file to skip before search.

mseek number of bytes to search at a time. 
lskip number of bytes to skip from the beggining of the
file to where the GRIB message starts. 
lgrib number of bytes in message (set to 0, if no
message found).

Author

Stephen Gilbert

Date

2002-10-28

Definition at
line 32 of file seekgb.c.

References
gbit().

void simpack
(g2float * fld, g2int ndpts, g2int * idrstmpl, unsigned char
* cpack, g2int * lcpack) 
This subroutine packs up a data field using the simple
packing algorithm as defined in the GRIB2 documention. It
also fills in GRIB2 Data Representation Template 5.0 with
the appropriate values.

Parameters

fld Contains the data
values to pack. 
ndpts The number of data values in array fld. 
idrstmpl Contains the array of values for Data
Representation Template 5.0.

•

0 Reference value - ignored on
input - set by simpack routine.

•

1 Binary Scale Factor - unchanged from input.

•

2 Decimal Scale Factor - unchanged from input.

•

3 Number of bits used to pack data, if value is > 0
and 

•

4 Original field type - currently ignored on input. Data
values assumed to be reals. Set to 0 by simpack routine.

cpack
The packed data field 
lcpack length of packed field starting at cpack.

Author

Stephen Gilbert

Date

2002-11-06

Definition at
line 32 of file simpack.c.

Author

Generated
automatically by Doxygen for NCEPLIBS-g2c from the source
code.