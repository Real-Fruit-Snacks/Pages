NAME

guestfs -
Library for accessing and modifying virtual machine
images

SYNOPSIS

#include

guestfs_h *g = guestfs_create (); 
guestfs_add_drive (g, "guest.img"); 
guestfs_launch (g); 
guestfs_mount (g, "/dev/sda1", "/");

guestfs_touch (g, "/hello"); 
guestfs_umount (g, "/"); 
guestfs_shutdown (g); 
guestfs_close (g); 
cc prog.c -o prog -lguestfs 
or: 
cc prog.c -o prog `pkg-config libguestfs --cflags
--libs`

DESCRIPTION

Libguestfs is a
library for accessing and modifying disk images and virtual
machines.

This manual
page documents the C API.

If you are
looking for an introduction to libguestfs, see the web site:
http://libguestfs.org/

Each virt tool
has its own man page (for a full list, go to "SEE
ALSO" at the end of this file).

Other
libguestfs manual pages: 
guestfs-faq(1)

Frequently Asked Questions
(FAQ).

guestfs-examples(3)

Examples of using the API from
C. For examples in other languages, see "USING
LIBGUESTFS WITH OTHER PROGRAMMING LANGUAGES" below.

guestfs-recipes(1)

Tips and recipes.

guestfs-performance(1)

Performance tips and
solutions.

libguestfs-test-tool(1)

guestfs-testing(1)

Help testing libguestfs.

guestfs-building(1)

How to build libguestfs from
source.

guestfs-hacking(1)

Contribute code to
libguestfs.

guestfs-internals(1)

How libguestfs works.

guestfs-security(1)

Security information, including
CVEs affecting libguestfs.

API OVERVIEW

This section
provides a gentler overview of the libguestfs API. We also
try to group API calls together, where that may not be
obvious from reading about the individual calls in the main
section of this manual.

HANDLES

Before you can use libguestfs calls, you have to create a
handle. Then you must add at least one disk image to the
handle, followed by launching the handle, then performing
whatever operations you want, and finally closing the
handle. By convention we use the single letter "g"
for the name of the handle variable, although of course you
can use any name you want.

The general
structure of all libguestfs-using programs looks like
this:

guestfs_h *g =
guestfs_create (); 
/* Call guestfs_add_drive additional times if there are 
* multiple disk images. 
*/ 
guestfs_add_drive (g, "guest.img"); 
/* Most manipulation calls won't work until you've launched

* the handle 'g'. You have to do this _after_ adding drives

* and _before_ other commands. 
*/ 
guestfs_launch (g); 
/* Either: examine what partitions, LVs etc are available:
*/ 
char **partitions = guestfs_list_partitions (g); 
char **logvols = guestfs_lvs (g); 
/* Or: ask libguestfs to find filesystems for you: */ 
char **filesystems = guestfs_list_filesystems (g); 
/* Or: use inspection (see INSPECTION section below). */

/* To access a filesystem in the image, you must mount it.
*/ 
guestfs_mount (g, "/dev/sda1", "/");

/* Now you can perform filesystem actions on the guest 
* disk image. 
*/ 
guestfs_touch (g, "/hello"); 
/* Synchronize the disk. This is the opposite of
guestfs_launch. */ 
guestfs_shutdown (g); 
/* Close and free the handle 'g'. */ 
guestfs_close (g);

The code above
doesn&rsquo;t include any error checking. In real code you
should check return values carefully for errors. In general
all functions that return integers return -1 on error, and
all functions that return pointers return "NULL"
on error. See section "ERROR HANDLING" below for
how to handle errors, and consult the documentation for each
function call below to see precisely how they return error
indications.

The code above
does not free(3) the strings and arrays returned from
functions. Consult the documentation for each function to
find out how to free the return value.

See
guestfs-examples(3) for fully worked examples.

DISK
IMAGES 
The image filename ("guest.img" in the example
above) could be a disk image from a virtual machine, a
dd(1) copy of a physical hard disk, an actual block
device, or simply an empty file of zeroes that you have
created through posix_fallocate(3). Libguestfs lets
you do useful things to all of these.

The call you
should use in modern code for adding drives is
"guestfs_add_drive_opts". To add a disk image,
allowing writes, and specifying that the format is raw,
do:

guestfs_add_drive_opts
(g, filename, 
GUESTFS_ADD_DRIVE_OPTS_FORMAT, "raw", 
-1);

You can add a
disk read-only using:

guestfs_add_drive_opts
(g, filename, 
GUESTFS_ADD_DRIVE_OPTS_FORMAT, "raw", 
GUESTFS_ADD_DRIVE_OPTS_READONLY, 1, 
-1);

or by calling
the older function "guestfs_add_drive_ro". If you
use the readonly flag, libguestfs won&rsquo;t modify the
file. (See also "DISK IMAGE FORMATS" below).

Be extremely
cautious if the disk image is in use, eg. if it is being
used by a virtual machine. Adding it read-write will almost
certainly cause disk corruption, but adding it read-only is
safe.

You should
usually add at least one disk image, and you may add
multiple disk images. If adding multiple disk images, they
usually have to be "related", ie. from the same
guest. In the API, the disk images are usually referred to
as /dev/sda (for the first one you added),
/dev/sdb (for the second one you added), etc.

Once
"guestfs_launch" has been called you cannot add
any more images. You can call
"guestfs_list_devices" to get a list of the device
names, in the order that you added them. See also
"BLOCK DEVICE NAMING" below.

MOUNTING

Before you can read or write files, create directories and
so on in a disk image that contains filesystems, you have to
mount those filesystems using "guestfs_mount" or
"guestfs_mount_ro". If you already know that a
disk image contains (for example) one partition with a
filesystem on that partition, then you can mount it
directly:

guestfs_mount
(g, "/dev/sda1", "/");

where
/dev/sda1 means literally the first partition (1) of
the first disk image that we added (/dev/sda). If the
disk contains Linux LVM2 logical volumes you could refer to
those instead (eg. /dev/VG/LV). Note that these are
libguestfs virtual devices, and are nothing to do with host
devices.

If you are
given a disk image and you don&rsquo;t know what it contains
then you have to find out. Libguestfs can do that too: use
"guestfs_list_partitions" and
"guestfs_lvs" to list possible partitions and LVs,
and either try mounting each to see what is mountable, or
else examine them with "guestfs_vfs_type" or
"guestfs_file". To list just filesystems, use
"guestfs_list_filesystems".

Libguestfs also
has a set of APIs for inspection of unknown disk images (see
"INSPECTION" below). You might also want to look
at higher level programs built on top of libguestfs, in
particular virt-inspector(1).

To mount a
filesystem read-only, use "guestfs_mount_ro".
There are several other variations of the
"guestfs_mount_*" call.

FILESYSTEM
ACCESS AND MODIFICATION 
The majority of the libguestfs API consists of fairly
low-level calls for accessing and modifying the files,
directories, symlinks etc on mounted filesystems. There are
over a hundred such calls which you can find listed in
detail below in this man page, and we don&rsquo;t even
pretend to cover them all in this overview.

Specify
filenames as full paths, starting with "/" and
including the mount point.

For example, if
you mounted a filesystem at "/" and you want to
read the file called "etc/passwd" then you could
do:

char *data =
guestfs_cat (g, "/etc/passwd");

This would
return "data" as a newly allocated buffer
containing the full content of that file (with some
conditions: see also "DOWNLOADING" below), or
"NULL" if there was an error.

As another
example, to create a top-level directory on that filesystem
called "var" you would do:

guestfs_mkdir
(g, "/var");

To create a
symlink you could do:

guestfs_ln_s
(g, "/etc/init.d/portmap", 
"/etc/rc3.d/S30portmap");

Libguestfs will
reject attempts to use relative paths and there is no
concept of a current working directory.

Libguestfs can
return errors in many situations: for example if the
filesystem isn&rsquo;t writable, or if a file or directory
that you requested doesn&rsquo;t exist. If you are using the
C API (documented here) you have to check for those error
conditions after each call. (Other language bindings turn
these errors into exceptions).

File writes are
affected by the per-handle umask, set by calling
"guestfs_umask" and defaulting to 022. See
"UMASK".

Since
libguestfs 1.18, it is possible to mount the libguestfs
filesystem on a local directory, subject to some
restrictions. See "MOUNT LOCAL" below.

PARTITIONING

Libguestfs contains API calls to read, create and modify
partition tables on disk images.

In the common
case where you want to create a single partition covering
the whole disk, you should use the
"guestfs_part_disk" call:

const char
*parttype = "mbr"; 
if (disk_is_larger_than_2TB) 
parttype = "gpt"; 
guestfs_part_disk (g, "/dev/sda", parttype);

Obviously this
effectively wipes anything that was on that disk image
before.

LVM2

Libguestfs provides access to a large part of the LVM2 API,
such as "guestfs_lvcreate" and
"guestfs_vgremove". It won&rsquo;t make much sense
unless you familiarize yourself with the concepts of
physical volumes, volume groups and logical volumes.

This author
strongly recommends reading the LVM HOWTO, online at
http://tldp.org/HOWTO/LVM-HOWTO/.

DOWNLOADING

Use "guestfs_cat" to download small, text only
files. This call cannot handle files containing any ASCII
NUL ("\0") characters. However the API is very
simple to use.

"guestfs_read_file"
can be used to read files which contain arbitrary 8 bit
data, since it returns a (pointer, size) pair.

"guestfs_download"
can be used to download any file, with no limits on content
or size.

To download
multiple files, see "guestfs_tar_out" and
"guestfs_tgz_out".

UPLOADING

To write a small file with fixed content, use
"guestfs_write". To create a file of all zeroes,
use "guestfs_truncate_size" (sparse) or
"guestfs_fallocate64" (with all disk blocks
allocated). There are a variety of other functions for
creating test files, for example "guestfs_fill"
and "guestfs_fill_pattern".

To upload a
single file, use "guestfs_upload". This call has
no limits on file content or size.

To upload
multiple files, see "guestfs_tar_in" and
"guestfs_tgz_in".

However the
fastest way to upload large numbers of arbitrary
files is to turn them into a squashfs or CD ISO (see
mksquashfs(8) and mkisofs(8)), then attach
this using "guestfs_add_drive_ro". If you add the
drive in a predictable way (eg. adding it last after all
other drives) then you can get the device name from
"guestfs_list_devices" and mount it directly using
"guestfs_mount_ro". Note that squashfs images are
sometimes non-portable between kernel versions, and they
don&rsquo;t support labels or UUIDs. If you want to
pre-build an image or you need to mount it using a label or
UUID, use an ISO image instead.

COPYING

There are various different commands for copying between
files and devices and in and out of the guest filesystem.
These are summarised in the table below. 
file to file

Use "guestfs_cp" to
copy a single file, or "guestfs_cp_a" to copy
directories recursively.

To copy part of
a file (offset and size) use
"guestfs_copy_file_to_file".

file to device 
device to file 
device to device

Use
"guestfs_copy_file_to_device",
"guestfs_copy_device_to_file", or
"guestfs_copy_device_to_device".

Example:
duplicate the contents of an LV:

guestfs_copy_device_to_device
(g, 
"/dev/VG/Original", "/dev/VG/Copy", 
/* -1 marks the end of the list of optional parameters */

-1);

The destination
(/dev/VG/Copy) must be at least as large as the
source (/dev/VG/Original). To copy less than the
whole source device, use the optional "size"
parameter:

guestfs_copy_device_to_device
(g, 
"/dev/VG/Original", "/dev/VG/Copy", 
GUESTFS_COPY_DEVICE_TO_DEVICE_SIZE, 10000, 
-1);

file on the host to
file or device

Use "guestfs_upload".
See "UPLOADING" above.

file or device to
file on the host

Use
"guestfs_download". See "DOWNLOADING"
above.

UPLOADING
AND DOWNLOADING TO PIPES AND FILE DESCRIPTORS 
Calls like "guestfs_upload",
"guestfs_download", "guestfs_tar_in",
"guestfs_tar_out" etc appear to only take
filenames as arguments, so it appears you can only upload
and download to files. However many Un*x-like hosts let you
use the special device files /dev/stdin,
/dev/stdout, /dev/stderr and /dev/fd/N
to read and write from stdin, stdout, stderr, and arbitrary
file descriptor N.

For example,
virt-cat(1) writes its output to stdout by doing:

guestfs_download
(g, filename, "/dev/stdout");

and you can
write tar output to a file descriptor "fd" by
doing:

char devfd[64];

snprintf (devfd, sizeof devfd, "/dev/fd/%d", fd);

guestfs_tar_out (g, "/", devfd);

LISTING
FILES 
"guestfs_ll" is just designed for humans to read
(mainly when using the guestfish(1)-equivalent
command "ll").

"guestfs_ls"
is a quick way to get a list of files in a directory from
programs, as a flat list of strings.

"guestfs_readdir"
is a programmatic way to get a list of files in a directory,
plus additional information about each one. It is more
equivalent to using the readdir(3) call on a local
filesystem.

"guestfs_find"
and "guestfs_find0" can be used to recursively
list files.

RUNNING
COMMANDS 
Although libguestfs is primarily an API for manipulating
files inside guest images, we also provide some limited
facilities for running commands inside guests.

There are many
limitations to this:

&bull;

The kernel version that the command runs under will be
different from what it expects.

&bull;

If the command needs to communicate with daemons, then
most likely they won&rsquo;t be running.

&bull;

The command will be running in limited memory.

&bull;

The network may not be available unless you enable it
(see "guestfs_set_network").

&bull;

Only supports Linux guests (not Windows, BSD, etc).

&bull;

Architecture limitations (eg. won&rsquo;t work for a PPC
guest on an X86 host).

&bull;

For SELinux guests, you may need to relabel the guest
after creating new files. See "SELINUX" below.

&bull;

Security: It is not safe to run commands from
untrusted, possibly malicious guests. These commands may
attempt to exploit your program by sending unexpected
output. They could also try to exploit the Linux kernel or
qemu provided by the libguestfs appliance. They could use
the network provided by the libguestfs appliance to bypass
ordinary network partitions and firewalls. They could use
the elevated privileges or different SELinux context of your
program to their advantage.

A secure
alternative is to use libguestfs to install a
"firstboot" script (a script which runs when the
guest next boots normally), and to have this script run the
commands you want in the normal context of the running
guest, network security and so on. For information about
other security issues, see guestfs-security(1).

The two main
API calls to run commands are "guestfs_command"
and "guestfs_sh" (there are also variations).

The difference
is that "guestfs_sh" runs commands using the
shell, so any shell globs, redirections, etc will work.

CONFIGURATION
FILES 
To read and write configuration files in Linux guest
filesystems, we strongly recommend using Augeas. For
example, Augeas understands how to read and write, say, a
Linux shadow password file or X.org configuration file, and
so avoids you having to write that code.

The main Augeas
calls are bound through the "guestfs_aug_*" APIs.
We don&rsquo;t document Augeas itself here because there is
excellent documentation on the http://augeas.net/
website.

If you
don&rsquo;t want to use Augeas (you fool!) then try calling
"guestfs_read_lines" to get the file as a list of
lines which you can iterate over.

SYSTEMD
JOURNAL FILES 
To read the systemd journal from a Linux guest, use the
"guestfs_journal_*" APIs starting with
"guestfs_journal_open".

Consult the
journal documentation here: sd-journal(3),
sd_journal_open(3).

SELINUX

We support SELinux guests. However it is not possible to
load the SELinux policy of the guest into the appliance
kernel. Therefore the strategy for dealing with SELinux
guests is to relabel them after making changes.

In libguestfs
&ge; 1.34 there is a new API, "guestfs_setfiles",
which can be used for this. To properly use this API you
have to parse the guest SELinux configuration. See the
virt-customize(1) module
customize/SELinux_relabel.ml for how to do this.

A simpler but
slower alternative is to touch /.autorelabel in the
guest, which means that the guest will relabel itself at
next boot.

Libguestfs &le;
1.32 had APIs "guestfs_set_selinux",
"guestfs_get_selinux", "guestfs_setcon"
and "guestfs_getcon". These did not work properly,
are deprecated, and should not be used in new code.

UMASK

Certain calls are affected by the current file mode creation
mask (the "umask"). In particular ones which
create files or directories, such as
"guestfs_touch", "guestfs_mknod" or
"guestfs_mkdir". This affects either the default
mode that the file is created with or modifies the mode that
you supply.

The default
umask is 022, so files are created with modes such as 0644
and directories with 0755.

There are two
ways to avoid being affected by umask. Either set umask to 0
(call "guestfs_umask (g, 0)" early after
launching). Or call "guestfs_chmod" after creating
each file or directory.

For more
information about umask, see umask(2).

LABELS AND
UUIDS 
Many filesystems, devices and logical volumes support either
labels (short strings like "BOOT" which might not
be unique) and/or UUIDs (globally unique IDs).

For
filesystems, use "guestfs_vfs_label" or
"guestfs_vfs_uuid" to read the label or UUID. Some
filesystems let you call "guestfs_set_label" or
"guestfs_set_uuid" to change the label or
UUID.

You can locate
a filesystem by its label or UUID using
"guestfs_findfs_label" or
"guestfs_findfs_uuid".

For LVM2 (which
supports only UUIDs), there is a rich set of APIs for
fetching UUIDs, fetching UUIDs of the contained objects, and
changing UUIDs. See: "guestfs_lvuuid",
"guestfs_vguuid", "guestfs_pvuuid",
"guestfs_vglvuuids",
"guestfs_vgpvuuids",
"guestfs_vgchange_uuid",
"guestfs_vgchange_uuid_all",
"guestfs_pvchange_uuid",
"guestfs_pvchange_uuid_all".

Note when
cloning a filesystem, device or whole guest, it is a good
idea to set new randomly generated UUIDs on the copy.

ENCRYPTED
DISKS 
Libguestfs allows you to access Linux guests which have been
encrypted using whole disk encryption that conforms to the
Linux Unified Key Setup (LUKS) standard. This includes
nearly all whole disk encryption systems used by modern
Linux guests. Windows BitLocker is also supported.

Use
"guestfs_vfs_type" to identify encrypted block
devices. For LUKS it returns the string
"crypto_LUKS". For Windows BitLocker it returns
"BitLocker".

Then open these
devices by calling "guestfs_cryptsetup_open".
Obviously you will require the passphrase!

Passphrase-less
unlocking is supported for LUKS (not BitLocker) block
devices that have been encrypted with network-bound disk
encryption (NBDE), using Clevis on the Linux guest side, and
Tang on a separate Linux server. Open such devices with
"guestfs_clevis_luks_unlock". The appliance will
need networking enabled (refer to
"guestfs_set_network") and actual connectivity to
the Tang servers noted in the "tang" Clevis pins
that are bound to the LUKS header. (This includes the
ability to resolve the names of the Tang servers.)

Opening an
encrypted device creates a new device mapper device called
/dev/mapper/mapname (where "mapname" is the
string you supply to "guestfs_cryptsetup_open" or
"guestfs_clevis_luks_unlock"). Reads and writes to
this mapper device are decrypted from and encrypted to the
underlying block device respectively.

LVM volume
groups on the device can be made visible by calling
"guestfs_vgscan" followed by
"guestfs_vg_activate_all". The logical volume(s)
can now be mounted in the usual way.

Use the reverse
process to close an encrypted device. Unmount any logical
volumes on it, deactivate the volume groups by calling
"guestfs_vg_activate (g, 0,
["/dev/VG"])". Then close the mapper device
by calling "guestfs_cryptsetup_close" on the
/dev/mapper/mapname device (not the underlying
encrypted block device).

MOUNT
LOCAL 
In libguestfs &ge; 1.18, it is possible to mount the
libguestfs filesystem on a local directory and access it
using ordinary POSIX calls and programs.

Availability of
this is subject to a number of restrictions: it requires
FUSE (the Filesystem in USErspace), and libfuse must also
have been available when libguestfs was compiled. FUSE may
require that a kernel module is loaded, and it may be
necessary to add the current user to a special
"fuse" group. See the documentation for your
distribution and http://fuse.sf.net for further
information.

The call to
mount the libguestfs filesystem on a local directory is
"guestfs_mount_local" (q.v.) followed by
"guestfs_mount_local_run". The latter does not
return until you unmount the filesystem. The reason is that
the call enters the FUSE main loop and processes kernel
requests, turning them into libguestfs calls. An alternative
design would have been to create a background thread to do
this, but libguestfs doesn&rsquo;t require pthreads. This
way is also more flexible: for example the user can create
another thread for "guestfs_mount_local_run".

"guestfs_mount_local"
needs a certain amount of time to set up the mountpoint. The
mountpoint is not ready to use until the call returns. At
this point, accesses to the filesystem will block until the
main loop is entered (ie.
"guestfs_mount_local_run"). So if you need to
start another process to access the filesystem, put the fork
between "guestfs_mount_local" and
"guestfs_mount_local_run".

MOUNT LOCAL
COMPATIBILITY

Since local
mounting was only added in libguestfs 1.18, and may not be
available even in these builds, you should consider writing
code so that it doesn&rsquo;t depend on this feature, and
can fall back to using libguestfs file system calls.

If libguestfs
was compiled without support for
"guestfs_mount_local" then calling it will return
an error with errno set to "ENOTSUP" (see
"guestfs_last_errno").

MOUNT LOCAL
PERFORMANCE

Libguestfs on
top of FUSE performs quite poorly. For best performance do
not use it. Use ordinary libguestfs filesystem calls,
upload, download etc. instead.

REMOTE
STORAGE 
CEPH

Libguestfs can
access Ceph (librbd/RBD) disks.

To do this, set
the optional "protocol" and "server"
parameters of "guestfs_add_drive_opts" like
this:

char **servers
= { "ceph1.example.org:3000", /* ... */, NULL };

guestfs_add_drive_opts (g, "pool/image", 
GUESTFS_ADD_DRIVE_OPTS_FORMAT, "raw", 
GUESTFS_ADD_DRIVE_OPTS_PROTOCOL, "rbd", 
GUESTFS_ADD_DRIVE_OPTS_SERVER, servers, 
GUESTFS_ADD_DRIVE_OPTS_USERNAME, "rbduser", 
GUESTFS_ADD_DRIVE_OPTS_SECRET,
"AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA==", 
-1);

"servers"
(the "server" parameter) is a list of one or more
Ceph servers. The server string is documented in
"guestfs_add_drive_opts". The "username"
and "secret" parameters are also optional, and if
not given, then no authentication will be used.

An encrypted
RBD disk -- directly opening which would require the
"username" and "secret" parameters --
cannot be accessed if the following conditions all hold:

&bull;

the backend is libvirt,

&bull;

the image specified by the "filename"
parameter is different from the encrypted RBD disk,

&bull;

the image specified by the "filename"
parameter has qcow2 format,

&bull;

the encrypted RBD disk is specified as a backing file at
some level in the qcow2 backing chain.

This limitation
is due to libvirt&rsquo;s (justified) separate handling of
disks vs. secrets. When the RBD username and secret are
provided inside a qcow2 backing file specification, libvirt
does not construct an ephemeral secret object from those,
for Ceph authentication. Refer to
https://bugzilla.redhat.com/2033247.

FTP, HTTP
AND TFTP

Libguestfs can
access remote disks over FTP, FTPS, HTTP, HTTPS or TFTP
protocols.

To do this, set
the optional "protocol" and "server"
parameters of "guestfs_add_drive_opts" like
this:

char **servers
= { "www.example.org", NULL }; 
guestfs_add_drive_opts (g, "/disk.img", 
GUESTFS_ADD_DRIVE_OPTS_FORMAT, "raw", 
GUESTFS_ADD_DRIVE_OPTS_PROTOCOL, "http", 
GUESTFS_ADD_DRIVE_OPTS_SERVER, servers, 
-1);

The
"protocol" can be one of "ftp",
"ftps", "http", "https" or
"tftp".

"servers"
(the "server" parameter) is a list which must have
a single element. The single element is a string defining
the web, FTP or TFTP server. The format of this string is
documented in "guestfs_add_drive_opts".

GLUSTER

Libguestfs can
access Gluster disks.

To do this, set
the optional "protocol" and "server"
parameters of "guestfs_add_drive_opts" like
this:

char **servers
= { "gluster.example.org:24007", NULL }; 
guestfs_add_drive_opts (g, "volname/image", 
GUESTFS_ADD_DRIVE_OPTS_FORMAT, "raw", 
GUESTFS_ADD_DRIVE_OPTS_PROTOCOL, "gluster", 
GUESTFS_ADD_DRIVE_OPTS_SERVER, servers, 
-1);

"servers"
(the "server" parameter) is a list which must have
a single element. The single element is a string defining
the Gluster server. The format of this string is documented
in "guestfs_add_drive_opts".

Note that
gluster usually requires the client process (ie. libguestfs)
to run as root and will give unfathomable errors if
it is not (eg. "No data available").

ISCSI

Libguestfs can
access iSCSI disks remotely.

To do this, set
the optional "protocol" and "server"
parameters like this:

char **server =
{ "iscsi.example.org:3000", NULL }; 
guestfs_add_drive_opts (g, "target-iqn-name/lun",

GUESTFS_ADD_DRIVE_OPTS_FORMAT, "raw", 
GUESTFS_ADD_DRIVE_OPTS_PROTOCOL, "iscsi", 
GUESTFS_ADD_DRIVE_OPTS_SERVER, server, 
-1);

The
"server" parameter is a list which must have a
single element. The single element is a string defining the
iSCSI server. The format of this string is documented in
"guestfs_add_drive_opts".

NETWORK
BLOCK DEVICE

Libguestfs can
access Network Block Device (NBD) disks remotely.

To do this, set
the optional "protocol" and "server"
parameters of "guestfs_add_drive_opts" like
this:

char **server =
{ "nbd.example.org:3000", NULL }; 
guestfs_add_drive_opts (g, "" /* export name - see
below */, 
GUESTFS_ADD_DRIVE_OPTS_FORMAT, "raw", 
GUESTFS_ADD_DRIVE_OPTS_PROTOCOL, "nbd", 
GUESTFS_ADD_DRIVE_OPTS_SERVER, server, 
-1);

Notes:

&bull;

"server" is in fact a
list of servers. For NBD you must always supply a list with
a single element. (Other remote protocols require zero or
more than one server, hence the requirement for this
parameter to be a list).

&bull;

The "server" string is documented in
"guestfs_add_drive_opts". To connect to a local
qemu-nbd instance over a Unix domain socket, use
"unix:/path/to/socket". 

&bull;

The "filename" parameter is the NBD export
name. Use an empty string to mean the default export. Many
NBD servers, including qemu-nbd, do not support export
names. 

&bull;

If using qemu-nbd as your server, you should always
specify the "-t" option. The reason is that
libguestfs may open several connections to the server.

&bull;

The libvirt backend requires that you set the
"format" parameter of
"guestfs_add_drive_opts" accurately when you use
writable NBD disks.

&bull;

The libvirt backend has a bug that stops Unix domain
socket connections from working:
https://bugzilla.redhat.com/show_bug.cgi?id=922888 

&bull;

The direct backend does not support readonly connections
because of a bug in qemu:
https://bugs.launchpad.net/qemu/+bug/1155677 

SHEEPDOG

Libguestfs can
access Sheepdog disks.

To do this, set
the optional "protocol" and "server"
parameters of "guestfs_add_drive_opts" like
this:

char **servers
= { /* optional servers ... */ NULL }; 
guestfs_add_drive_opts (g, "volume", 
GUESTFS_ADD_DRIVE_OPTS_FORMAT, "raw", 
GUESTFS_ADD_DRIVE_OPTS_PROTOCOL, "sheepdog", 
GUESTFS_ADD_DRIVE_OPTS_SERVER, servers, 
-1);

The optional
list of "servers" may be zero or more server
addresses ("hostname:port"). The format of the
server strings is documented in
"guestfs_add_drive_opts".

SSH

Libguestfs can
access disks over a Secure Shell (SSH) connection.

To do this, set
the "protocol" and "server" and
(optionally) "username" parameters of
"guestfs_add_drive_opts" like this:

char **server =
{ "remote.example.com", NULL }; 
guestfs_add_drive_opts (g, "/path/to/disk.img",

GUESTFS_ADD_DRIVE_OPTS_FORMAT, "raw", 
GUESTFS_ADD_DRIVE_OPTS_PROTOCOL, "ssh", 
GUESTFS_ADD_DRIVE_OPTS_SERVER, server, 
GUESTFS_ADD_DRIVE_OPTS_USERNAME, "remoteuser",

-1);

The format of
the server string is documented in
"guestfs_add_drive_opts".

INSPECTION

Libguestfs has APIs for inspecting an unknown disk image to
find out if it contains operating systems, an install CD or
a live CD.

Add all disks
belonging to the unknown virtual machine and call
"guestfs_launch" in the usual way.

Then call
"guestfs_inspect_os". This function uses other
libguestfs calls and certain heuristics, and returns a list
of operating systems that were found. An empty list means
none were found. A single element is the root filesystem of
the operating system. For dual- or multi-boot guests,
multiple roots can be returned, each one corresponding to a
separate operating system. (Multi-boot virtual machines are
extremely rare in the world of virtualization, but since
this scenario can happen, we have built libguestfs to deal
with it.)

For each root,
you can then call various "guestfs_inspect_get_*"
functions to get additional details about that operating
system. For example, call
"guestfs_inspect_get_type" to return the string
"windows" or "linux" for Windows and
Linux-based operating systems respectively.

Un*x-like and
Linux-based operating systems usually consist of several
filesystems which are mounted at boot time (for example, a
separate boot partition mounted on /boot). The
inspection rules are able to detect how filesystems
correspond to mount points. Call
"guestfs_inspect_get_mountpoints" to get this
mapping. It might return a hash table like this example:

/boot =>
/dev/sda1 
/ => /dev/vg_guest/lv_root 
/usr => /dev/vg_guest/lv_usr

The caller can
then make calls to "guestfs_mount" to mount the
filesystems as suggested.

Be careful to
mount filesystems in the right order (eg. / before
/usr). Sorting the keys of the hash by length,
shortest first, should work.

Inspection
currently only works for some common operating systems.
Contributors are welcome to send patches for other operating
systems that we currently cannot detect.

Encrypted disks
must be opened before inspection. See "ENCRYPTED
DISKS" for more details. The
"guestfs_inspect_os" function just ignores any
encrypted devices.

A note on the
implementation: The call "guestfs_inspect_os"
performs inspection and caches the results in the guest
handle. Subsequent calls to
"guestfs_inspect_get_*" return this cached
information, but do not re-read the disks. If you
change the content of the guest disks, you can redo
inspection by calling "guestfs_inspect_os" again.
("guestfs_inspect_list_applications2" works a
little differently from the other calls and does read the
disks. See documentation for that function for details).

INSPECTING
INSTALL DISKS

Libguestfs
(since 1.9.4) can detect some install disks, install CDs,
live CDs and more.

Further
information is available about the operating system that can
be installed using the regular inspection APIs like
"guestfs_inspect_get_product_name",
"guestfs_inspect_get_major_version" etc.

SPECIAL
CONSIDERATIONS FOR WINDOWS GUESTS 
Libguestfs can mount NTFS partitions. It does this using the
http://www.ntfs-3g.org/ driver.

DRIVE
LETTERS AND PATHS

DOS and Windows
still use drive letters, and the filesystems are always
treated as case insensitive by Windows itself, and therefore
you might find a Windows configuration file referring to a
path like "c:\windows\system32". When the
filesystem is mounted in libguestfs, that directory might be
referred to as /WINDOWS/System32.

Drive letter
mappings can be found using inspection (see
"INSPECTION" and
"guestfs_inspect_get_drive_mappings")

Dealing with
separator characters (backslash vs forward slash) is outside
the scope of libguestfs, but usually a simple character
replacement will work.

To resolve the
case insensitivity of paths, call
"guestfs_case_sensitive_path".

LONG
FILENAMES ON NTFS

NTFS supports
filenames up to 255 characters long. "Character"
means a 2 byte UTF-16 codepoint which can encode the most
common Unicode codepoints.

Most Linux
filesystems support filenames up to 255 bytes. This
means you may get an error:

File name too
long

when you copy a
file from NTFS to a Linux filesystem if the name, when
reencoded as UTF-8, would exceed 255 bytes in length.

This will most
often happen when using non-ASCII names that are longer than
~127 characters (eg. Greek, Cyrillic) or longer than ~85
characters (Asian languages).

A workaround is
not to try to store such long filenames on Linux native
filesystems. Since the tar(1) format can store
unlimited length filenames, keep the files in a tarball.

ACCESSING
THE WINDOWS REGISTRY

Libguestfs also
provides some help for decoding Windows Registry
"hive" files, through a separate C library called
hivex(3).

Before
libguestfs 1.19.35 you had to download the hive file,
operate on it locally using hivex, and upload it again.
Since this version, we have included the major hivex APIs
directly in the libguestfs API (see
"guestfs_hivex_open"). This means that if you have
opened a Windows guest, you can read and write the registry
directly.

See also
virt-win-reg(1).

SYMLINKS ON
NTFS-3G FILESYSTEMS

Ntfs-3g tries
to rewrite "Junction Points" and NTFS
"symbolic links" to provide something which looks
like a Linux symlink. The way it tries to do the rewriting
is described here:

http://www.tuxera.com/community/ntfs-3g-advanced/junction-points-and-symbolic-links/

The essential
problem is that ntfs-3g simply does not have enough
information to do a correct job. NTFS links can contain
drive letters and references to external device GUIDs that
ntfs-3g has no way of resolving. It is almost certainly the
case that libguestfs callers should ignore what ntfs-3g does
(ie. don&rsquo;t use "guestfs_readlink" on NTFS
volumes).

Instead if you
encounter a symbolic link on an ntfs-3g filesystem, use
"guestfs_lgetxattr" to read the
"system.ntfs_reparse_data" extended attribute, and
read the raw reparse data from that (you can find the format
documented in various places around the web).

EXTENDED
ATTRIBUTES ON NTFS-3G FILESYSTEMS

There are other
useful extended attributes that can be read from ntfs-3g
filesystems (using "guestfs_getxattr"). See:

http://www.tuxera.com/community/ntfs-3g-advanced/extended-attributes/

WINDOWS
HIBERNATION AND WINDOWS 8 FAST STARTUP

Windows guests
which have been hibernated (instead of fully shut down)
cannot be mounted. This is a limitation of ntfs-3g. You will
see an error like this:

The disk
contains an unclean file system (0, 0). 
Metadata kept in Windows cache, refused to mount. 
Failed to mount '/dev/sda2': Operation not permitted 
The NTFS partition is in an unsafe state. Please resume 
and shutdown Windows fully (no hibernation or fast 
restarting), or mount the volume read-only with the 
'ro' mount option.

In Windows 8,
the shutdown button does not shut down the guest at all.
Instead it usually hibernates the guest. This is known as
"fast startup".

Some suggested
workarounds are:

&bull;

Mount read-only (eg.
"guestfs_mount_ro"). 

&bull;

On Windows 8, turn off fast startup. It is in the
Control Panel &rarr; Power Options &rarr; Choose what the
power buttons do &rarr; Change settings that are currently
unavailable &rarr; Turn on fast startup.

&bull;

On Windows 7 and earlier, shut the guest off properly
instead of hibernating it.

RESIZE2FS
ERRORS 
The "guestfs_resize2fs",
"guestfs_resize2fs_size" and
"guestfs_resize2fs_M" calls are used to resize
ext2/3/4 filesystems.

The underlying
program (resize2fs(8)) requires that the filesystem
is clean and recently fsck&rsquo;d before you can resize it.
Also, if the resize operation fails for some reason, then
you had to call fsck the filesystem again to fix it.

In libguestfs
"lt" 1.17.14, you usually had to call
"guestfs_e2fsck_f" before the resize. However, in
"ge" 1.17.14, e2fsck(8) is called
automatically before the resize, so you no longer need to do
this.

The
resize2fs(8) program can still fail, in which case it
prints an error message similar to:

Please run
'e2fsck -fy ' to fix the filesystem 
after the aborted resize operation.

You can do this
by calling "guestfs_e2fsck" with the
"forceall" option. However in the context of disk
images, it is usually better to avoid this situation, eg. by
rolling back to an earlier snapshot, or by copying and
resizing and on failure going back to the original.

USING
LIBGUESTFS WITH OTHER PROGRAMMING LANGUAGES 
Although we don&rsquo;t want to discourage you from using
the C API, we will mention here that the same API is also
available in other languages.

The API is
broadly identical in all supported languages. This means
that the C call "guestfs_add_drive_ro(g,file)" is
"$g->add_drive_ro($file)" in Perl,
"g.add_drive_ro(file)" in Python, and
"g#add_drive_ro file" in OCaml. In other words, a
straightforward, predictable isomorphism between each
language.

Error messages
are automatically transformed into exceptions if the
language supports it.

We don&rsquo;t
try to "object orientify" parts of the API in OO
languages, although contributors are welcome to write higher
level APIs above what we provide in their favourite
languages if they wish.

C++

You can use the guestfs.h
header file from C++ programs. The C++ API is identical to
the C API. C++ classes and exceptions are not used.

C#

The C# bindings are highly experimental. Please read the
warnings at the top of csharp/Libguestfs.cs.

Erlang

See
guestfs-erlang(3).

GObject

Experimental GObject bindings
(with GObject Introspection support) are available.

See
guestfs-gobject(3).

Go

See guestfs-golang(3).

Haskell

This language binding is
working but incomplete:

&bull;

Functions with optional arguments are not bound.
Implementing optional arguments in Haskell seems to be very
complex. 

&bull;

Events are not bound.

&bull;

Functions with the following return types are not
bound: 

&bull;

Any function returning a
struct. 

&bull;

Any function returning a list of structs.

&bull;

A few functions that return fixed length buffers
(specifically ones declared "RBufferOut" in the
generator). 

&bull;

A tiny number of obscure functions that return constant
strings (specifically ones declared
"RConstOptString" in the generator).

Java

Full documentation is contained
in the Javadoc which is distributed with libguestfs. For
examples, see guestfs-java(3).

Lua

See guestfs-lua(3).

OCaml

See
guestfs-ocaml(3).

Perl

See guestfs-perl(3) and
Sys::Guestfs(3).

PHP

For documentation see "README-PHP" supplied
with libguestfs sources or in the php-libguestfs package for
your distribution.

The PHP binding
only works correctly on 64 bit machines.

Python

See
guestfs-python(3).

Ruby

See guestfs-ruby(3).

For JRuby, use
the Java bindings.

shell scripts

See guestfish(1).

LIBGUESTFS
GOTCHAS 
http://en.wikipedia.org/wiki/Gotcha_(programming): "A
feature of a system [...] that works in the way it is
documented but is counterintuitive and almost invites
mistakes."

Since we
developed libguestfs and the associated tools, there are
several things we would have designed differently, but are
now stuck with for backwards compatibility or other reasons.
If there is ever a libguestfs 2.0 release, you can expect
these to change. Beware of them. 
Read-only should be the default.

In guestfish(3),
--ro should be the default, and you should have to
specify --rw if you want to make changes to the
image.

This would
reduce the potential to corrupt live VM images.

Note that many
filesystems change the disk when you just mount and unmount,
even if you didn&rsquo;t perform any writes. You need to use
"guestfs_add_drive_ro" to guarantee that the disk
is not changed.

guestfish command line is hard
to use.

guestfish disk.img
doesn&rsquo;t do what people expect (open disk.img
for examination). It tries to run a guestfish command
disk.img which doesn&rsquo;t exist, so it fails. In
earlier versions of guestfish the error message was also
unintuitive, but we have corrected this since. Like the
Bourne shell, we should have used "guestfish -c
command" to run commands.

guestfish megabyte modifiers
don&rsquo;t work right on all commands

In recent guestfish you can use
"1M" to mean 1 megabyte (and similarly for other
modifiers). What guestfish actually does is to multiply the
number part by the modifier part and pass the result to the
C API. However this doesn&rsquo;t work for a few APIs which
aren&rsquo;t expecting bytes, but are already expecting some
other unit (eg. megabytes).

The most common
is "guestfs_lvcreate". The guestfish command:

lvcreate LV VG
100M

does not do
what you might expect. Instead because
"guestfs_lvcreate" is already expecting megabytes,
this tries to create a 100 terabyte (100 megabytes *
megabytes) logical volume. The error message you get from
this is also a little obscure.

This could be
fixed in the generator by specially marking parameters and
return values which take bytes or other units.

Ambiguity between devices and
paths

There is a subtle ambiguity in
the API between a device name (eg. /dev/sdb2) and a
similar pathname. A file might just happen to be called
"sdb2" in the directory /dev (consider some
non-Unix VM image).

In the current
API we usually resolve this ambiguity by having two separate
calls, for example "guestfs_checksum" and
"guestfs_checksum_device". Some API calls are
ambiguous and (incorrectly) resolve the problem by detecting
if the path supplied begins with /dev/.

To avoid both
the ambiguity and the need to duplicate some calls, we could
make paths/devices into structured names. One way to do this
would be to use a notation like grub ("hd(0,0)"),
although nobody really likes this aspect of grub. Another
way would be to use a structured type, equivalent to this
OCaml type:

type path =
Path of string | Device of int | Partition of int * int

which would
allow you to pass arguments like:

Path
"/foo/bar" 
Device 1 (* /dev/sdb, or perhaps /dev/sda *) 
Partition (1, 2) (* /dev/sdb2 (or is it /dev/sda2 or
/dev/sdb3?) *) 
Path "/dev/sdb2" (* not a device *)

As you can see
there are still problems to resolve even with this
representation. Also consider how it might work in
guestfish.

KEYS AND
PASSPHRASES 
Certain libguestfs calls take a parameter that contains
sensitive key material, passed in as a C string.

In the future
we would hope to change the libguestfs implementation so
that keys are mlock(2)-ed into physical RAM, and thus
can never end up in swap. However this is not done at
the moment, because of the complexity of such an
implementation.

Therefore you
should be aware that any key parameter you pass to
libguestfs might end up being written out to the swap
partition. If this is a concern, scrub the swap partition or
don&rsquo;t use libguestfs on encrypted devices.

MULTIPLE
HANDLES AND MULTIPLE THREADS 
All high-level libguestfs actions are synchronous. If you
want to use libguestfs asynchronously then you must create a
thread.

Threads in
libguestfs &ge; 1.38

In libguestfs
&ge; 1.38, each handle ("guestfs_h") contains a
lock which is acquired automatically when you call a
libguestfs function. The practical effect of this is you can
call libguestfs functions with the same handle from multiple
threads without needing to do any locking.

Also in
libguestfs &ge; 1.38, the last error on the handle
("guestfs_last_error",
"guestfs_last_errno") is stored in thread-local
storage, so it is safe to write code like:

if
(guestfs_add_drive_ro (g, drive) == -1) 
fprintf (stderr, "error was: %s\n",
guestfs_last_error (g));

even when other
threads may be concurrently using the same handle
"g".

Threads in
libguestfs 

In libguestfs
not safe to be called from multiple threads without a
mutex in libguestfs 

Use
"guestfs_set_identifier" to make it simpler to
identify threads in trace output.

PATH

Libguestfs needs a supermin appliance, which it finds by
looking along an internal path.

By default it
looks for these in the directory "$libdir/guestfs"
(eg. /usr/local/lib/guestfs or
/usr/lib64/guestfs).

Use
"guestfs_set_path" or set the environment variable
"LIBGUESTFS_PATH" to change the directories that
libguestfs will search in. The value is a colon-separated
list of paths. The current directory is not searched
unless the path contains an empty element or ".".
For example "LIBGUESTFS_PATH=:/usr/lib/guestfs"
would search the current directory and then
/usr/lib/guestfs.

QEMU
WRAPPERS 
If you want to compile your own qemu, run qemu from a
non-standard location, or pass extra arguments to qemu, then
you can write a shell-script wrapper around qemu.

There is one
important rule to remember: you must "exec
qemu" as the last command in the shell script (so
that qemu replaces the shell and becomes the direct child of
the libguestfs-using program). If you don&rsquo;t do this,
then the qemu process won&rsquo;t be cleaned up
correctly.

Here is an
example of a wrapper, where I have built my own copy of qemu
from source:

#!/bin/sh -

qemudir=/home/rjones/d/qemu 
exec $qemudir/x86_64-softmmu/qemu-system-x86_64 -L
$qemudir/pc-bios "$@"

Save this
script as /tmp/qemu.wrapper (or wherever),
"chmod +x", and then use it by setting the
LIBGUESTFS_HV environment variable. For example:

LIBGUESTFS_HV=/tmp/qemu.wrapper
guestfish

Note that
libguestfs also calls qemu with the -help and -version
options in order to determine features.

Wrappers can
also be used to edit the options passed to qemu. In the
following example, the "-machine ..." option
("-machine" and the following argument) are
removed from the command line and replaced with
"-machine pc,accel=tcg". The while loop iterates
over the options until it finds the right one to remove,
putting the remaining options into the "args"
array.

#!/bin/bash -

i=0 
while [ $# -gt 0 ]; do 
case "$1" in 
-machine) 
shift 2;; 
*) 
args[i]="$1" 
(( i++ )) 
shift ;; 
esac 
done 
exec qemu-kvm -machine pc,accel=tcg
"${args[@]}"

BACKEND

The backend (previously known as the "attach
method") controls how libguestfs creates and/or
connects to the backend daemon, eg. by starting qemu
directly, or using libvirt to manage an appliance, running
User-Mode Linux, or connecting to an already running
daemon.

You can set the
backend by calling "guestfs_set_backend", or by
setting the environment variable
"LIBGUESTFS_BACKEND".

Possible
backends are described below: 
"direct" 
"appliance"

Run qemu directly to launch an
appliance.

"direct"
and "appliance" are synonyms.

This is the
ordinary method and normally the default, but see the note
below.

"libvirt" 
"libvirt:null" 
"libvirt:URI"

Use libvirt to launch and
manage the appliance.

"libvirt"
causes libguestfs to choose a suitable URI for creating
session guests. If using the libvirt backend, you almost
always should use this.

"libvirt:null"
causes libguestfs to use the "NULL" connection
URI, which causes libvirt to try to guess what the user
meant. You probably don&rsquo;t want to use this.

"libvirt:URI"
uses URI as the libvirt connection URI (see
http://libvirt.org/uri.html). The typical libvirt backend
with a URI would be "libvirt:qemu:///session&quot;

The libvirt
backend supports more features, including sVirt.

"direct"
is usually the default backend. However since libguestfs
&ge; 1.19.24, libguestfs can be built with a different
default by doing:

./configure
--with-default-backend=...

To find out if
libguestfs was compiled with a different default backend,
do:

unset
LIBGUESTFS_BACKEND 
guestfish get-backend

BACKEND
SETTINGS 
Each backend can be configured by passing a list of strings.
You can either call "guestfs_set_backend_settings"
with a list of strings, or set the
"LIBGUESTFS_BACKEND_SETTINGS" environment variable
to a colon-separated list of strings (before creating the
handle).

force_tcg

Using:

export
LIBGUESTFS_BACKEND_SETTINGS=force_tcg

will force the
direct and libvirt backends to use TCG (software emulation)
instead of KVM (hardware accelerated virtualization).

force_kvm

Using:

export
LIBGUESTFS_BACKEND_SETTINGS=force_kvm

will force the
direct and libvirt backends to use KVM (hardware accelerated
virtualization) instead of TCG (software emulation).

gdb

The direct
backend supports:

export
LIBGUESTFS_BACKEND_SETTINGS=gdb

When this is
set, qemu will not start running the appliance immediately.
It will wait for you to connect to it using gdb:

$ gdb 
(gdb) symbol-file /path/to/vmlinux 
(gdb) target remote tcp::1234 
(gdb) cont

You can then
debug the appliance kernel, which is useful to debug boot
failures (especially ones where there are no debug messages
printed - tip: look in the kernel "log_buf").

On Fedora,
install "kernel-debuginfo" for the
"vmlinux" file (containing symbols). Make sure the
symbols precisely match the kernel being used.

ABI
GUARANTEE 
We guarantee the libguestfs ABI (binary interface), for
public, high-level actions as outlined in this section.
Although we will deprecate some actions, for example if they
get replaced by newer calls, we will keep the old actions
forever. This allows you the developer to program in
confidence against the libguestfs API.

BLOCK DEVICE
NAMING 
Libguestfs defines /dev/sd* as the standard naming
scheme for devices passed to API calls. So
/dev/sda means "the first device added by
"guestfs_add_drive_opts"", and
/dev/sdb3 means "the third partition on the
second device".

Internally
device names are sometimes translated, but this should not
be visible at the API level.

DISK
LABELS

In libguestfs
&ge; 1.20, you can give a label to a disk when you add it,
using the optional "label" parameter to
"guestfs_add_drive_opts". (Note that disk labels
are different from and not related to filesystem
labels).

Not all
versions of libguestfs support setting a disk label, and
when it is supported, it is limited to 20 ASCII characters
"[a-zA-Z]".

When you add a
disk with a label, it can either be addressed using
/dev/sd*, or using /dev/disk/guestfs/label.
Partitions on the disk can be addressed using
/dev/disk/guestfs/labelpartnum.

Listing devices
("guestfs_list_devices") and partitions
("guestfs_list_partitions") returns the block
device names. However you can use
"guestfs_list_disk_labels" to map disk labels to
block device and partition names.

NULL
DISKS 
When adding a disk using, eg.,
"guestfs_add_drive", you can set the filename to
"/dev/null". This string is treated specially by
libguestfs, causing it to add a "null disk".

A null disk has
the following properties:

&bull;

A null disk will appear as a normal device, eg. in calls
to "guestfs_list_devices".

&bull;

You may add "/dev/null" multiple times.

&bull;

You should not try to access a null disk in any way. For
example, you shouldn&rsquo;t try to read it or mount it.

Null disks are
used for three main purposes:

1.

Performance testing of
libguestfs (see guestfs-performance(1)).

2.

The internal test suite.

3.

If you want to use libguestfs APIs that don&rsquo;t
refer to disks, since libguestfs requires that at least one
disk is added, you should add a null disk.

For example, to
test if a feature is available, use code like this:

guestfs_h *g;

char **groups = [ "btrfs", NULL ]; 
g = guestfs_create (); 
guestfs_add_drive (g, "/dev/null"); 
guestfs_launch (g); 
if (guestfs_available (g, groups) == 0) { 
// group(s) are available 
} else { 
// group(s) are not available 
} 
guestfs_close (g);

DISK IMAGE
FORMATS 
Virtual disks come in a variety of formats. Some common
formats are listed below.

Note that
libguestfs itself is not responsible for handling the disk
format: this is done using qemu(1). If support for a
particular format is missing or broken, this has to be fixed
in qemu.

COMMON
VIRTUAL DISK IMAGE FORMATS

raw

Raw format is simply a dump of
the sequential bytes of the virtual hard disk. There is no
header, container, compression or processing of any
sort. 

Since raw
format requires no translation to read or write, it is both
fast and very well supported by qemu and all other
hypervisors. You can consider it to be a universal format
that any hypervisor can access.

Raw format
files are not compressed and so take up the full space of
the original disk image even when they are empty. A
variation (on Linux/Unix at least) is to not store ranges of
all-zero bytes by storing the file as a sparse file. This
"variant format" is sometimes called raw
sparse. Many utilities, including
virt-sparsify(1), can make raw disk images
sparse.

qcow2

Qcow2 is the native disk image
format used by qemu. Internally it uses a two-level
directory structure so that only blocks containing data are
stored in the file. It also has many other features such as
compression, snapshots and backing files.

There are at
least two distinct variants of this format, although qemu
(and hence libguestfs) handles both transparently to the
user.

vmdk

VMDK is VMware&rsquo;s native
disk image format. There are many variations. Modern qemu
(hence libguestfs) supports most variations, but you should
be aware that older versions of qemu had some very bad
data-corrupting bugs in this area.

Note that
VMware ESX exposes files with the name
guest-flat.vmdk. These are not VMDK. They are raw
format files which happen to have a ".vmdk"
extension.

vdi

VDI is VirtualBox&rsquo;s native disk image format. Qemu
(hence libguestfs) has generally good support for this.

vpc

vhd

VPC (old) and VHD (modern) are the native disk image
format of Microsoft (and previously, Connectix) Virtual PC
and Hyper-V.

Obsolete formats

The following formats are
obsolete and should not be used: qcow (aka
qcow1), cow, bochs.

DETECTING
THE FORMAT OF A DISK IMAGE

Firstly note
there is a security issue with auto-detecting the format of
a disk image. It may or may not apply in your use case. Read
"CVE-2010-3851" below.

Libguestfs
offers an API to get the format of a disk image
("guestfs_disk_format"), and it is safest to use
this.

Don&rsquo;t
be tempted to try parsing the text / human-readable output
of "qemu-img" since it cannot be parsed reliably
and securely. Also do not use the "file" command
since the output of that changes over time.

CONNECTION MANAGEMENT

guestfs_h
* 
"guestfs_h" is the opaque type representing a
connection handle. Create a handle by calling
"guestfs_create" or
"guestfs_create_flags". Call
"guestfs_close" to free the handle and release all
resources used.

For information
on using multiple handles and threads, see the section
"MULTIPLE HANDLES AND MULTIPLE THREADS" above.

guestfs_create

guestfs_h *guestfs_create (void);

Create a
connection handle.

On success this
returns a non-NULL pointer to a handle. On error it returns
NULL.

You have to
"configure" the handle after creating it. This
includes calling "guestfs_add_drive_opts" (or one
of the equivalent calls) on the handle at least once.

After
configuring the handle, you have to call
"guestfs_launch".

You may also
want to configure error handling for the handle. See the
"ERROR HANDLING" section below.

guestfs_create_flags

guestfs_h *guestfs_create_flags (unsigned flags [,
...]);

Create a
connection handle, supplying extra flags and extra arguments
to control how the handle is created.

On success this
returns a non-NULL pointer to a handle. On error it returns
NULL.

"guestfs_create"
is equivalent to calling guestfs_create_flags(0).

The following
flags may be logically ORed together. (Currently no extra
arguments are used). 
"GUESTFS_CREATE_NO_ENVIRONMENT"

Don&rsquo;t parse any
environment variables (such as "LIBGUESTFS_DEBUG"
etc).

You can call
"guestfs_parse_environment" or
"guestfs_parse_environment_list" afterwards to
parse environment variables. Alternately, don&rsquo;t
call these functions if you want the handle to be unaffected
by environment variables. See the example below.

The default (if
this flag is not given) is to implicitly call
"guestfs_parse_environment".

"GUESTFS_CREATE_NO_CLOSE_ON_EXIT"

Don&rsquo;t try to close the
handle in an atexit(3) handler if the program exits
without explicitly closing the handle.

The default (if
this flag is not given) is to install such an atexit
handler.

USING
"GUESTFS_CREATE_NO_ENVIRONMENT"

You might use
"GUESTFS_CREATE_NO_ENVIRONMENT" and an explicit
call to "guestfs_parse_environment" like this:

guestfs_h *g;

int r; 
g = guestfs_create_flags (GUESTFS_CREATE_NO_ENVIRONMENT);

if (!g) { 
perror ("guestfs_create_flags"); 
exit (EXIT_FAILURE); 
} 
r = guestfs_parse_environment (g); 
if (r == -1) 
exit (EXIT_FAILURE);

Or to create a
handle which is unaffected by environment variables, omit
the call to "guestfs_parse_environment" from the
above code.

The above code
has another advantage which is that any errors from parsing
the environment are passed through the error handler,
whereas "guestfs_create" prints errors on stderr
and ignores them.

guestfs_close

void guestfs_close (guestfs_h *g);

This closes the
connection handle and frees up all resources used. If a
close callback was set on the handle, then it is called.

The correct way
to close the handle is:

if
(guestfs_shutdown (g) == -1) { 
/* handle write errors here */ 
} 
guestfs_close (g);

"guestfs_shutdown"
is only needed if all of the following are true:

1.

one or more disks were added in read-write mode,
and 

2.

guestfs_launch was called, and

3.

you made some changes, and

4.

you have a way to handle write errors (eg. by exiting
with an error code or reporting something to the user).

ERROR HANDLING

API functions
can return errors. For example, almost all functions that
return "int" will return -1 to indicate an
error.

Additional
information is available for errors: an error message string
and optionally an error number (errno) if the thing that
failed was a system call.

You can get at
the additional information about the last error on the
handle by calling "guestfs_last_error",
"guestfs_last_errno", and/or by setting up an
error handler with
"guestfs_set_error_handler".

When the handle
is created, a default error handler is installed which
prints the error message string to "stderr". For
small short-running command line programs it is sufficient
to do:

if
(guestfs_launch (g) == -1) 
exit (EXIT_FAILURE);

since the
default error handler will ensure that an error message has
been printed to "stderr" before the program
exits.

For other
programs the caller will almost certainly want to install an
alternate error handler or do error handling in-line as in
the example below. The non-C language bindings all install
NULL error handlers and turn errors into exceptions using
code similar to this:

const char
*msg; 
int errnum; 
/* This disables the default behaviour of printing errors

on stderr. */ 
guestfs_set_error_handler (g, NULL, NULL); 
if (guestfs_launch (g) == -1) { 
/* Examine the error message and print it, throw it, 
etc. */ 
msg = guestfs_last_error (g); 
errnum = guestfs_last_errno (g); 
fprintf (stderr, "%s", msg); 
if (errnum != 0) 
fprintf (stderr, ": %s", strerror (errnum)); 
fprintf (stderr, "\n"); 
/* ... */ 
}

"guestfs_create"
returns "NULL" if the handle cannot be created,
and because there is no handle if this happens there is no
way to get additional error information. Since libguestfs
&ge; 1.20, you can use "guestfs_create_flags" to
properly deal with errors during handle creation, although
the vast majority of programs can continue to use
"guestfs_create" and not worry about this
situation.

Out of memory
errors are handled differently. The default action is to
call abort(3). If this is undesirable, then you can
set a handler using
"guestfs_set_out_of_memory_handler".

guestfs_last_error

const char *guestfs_last_error (guestfs_h *g);

This returns
the last error message that happened on "g". If
there has not been an error since the handle was created,
then this returns "NULL".

Note the
returned string does not have a newline character at
the end. Most error messages are single lines. Some are
split over multiple lines and contain "\n"
characters within the string but not at the end.

The lifetime of
the returned string is until the next error occurs on the
same handle, or "guestfs_close" is called. If you
need to keep it longer, copy it.

guestfs_last_errno

int guestfs_last_errno (guestfs_h *g);

This returns
the last error number (errno) that happened on
"g".

If successful,
an errno integer not equal to zero is returned.

In many cases
the special errno "ENOTSUP" is returned if you
tried to call a function or use a feature which is not
supported.

If no error
number is available, this returns 0. This call can return 0
in three situations:

1.

There has not been any error on
the handle.

2.

There has been an error but the errno was meaningless.
This corresponds to the case where the error did not come
from a failed system call, but for some other reason.

3.

There was an error from a failed system call, but for
some reason the errno was not captured and returned. This
usually indicates a bug in libguestfs.

Libguestfs
tries to convert the errno from inside the appliance into a
corresponding errno for the caller (not entirely trivial:
the appliance might be running a completely different
operating system from the library and error numbers are not
standardized across Un*xen). If this could not be done, then
the error is translated to "EINVAL". In practice
this should only happen in very rare circumstances.

guestfs_set_error_handler

typedef void (*guestfs_error_handler_cb) (guestfs_h *g, 
void *opaque, 
const char *msg); 
void guestfs_set_error_handler (guestfs_h *g, 
guestfs_error_handler_cb cb, 
void *opaque);

The callback
"cb" will be called if there is an error. The
parameters passed to the callback are an opaque data pointer
and the error message string.

"errno"
is not passed to the callback. To get that the callback must
call "guestfs_last_errno".

Note that the
message string "msg" is freed as soon as the
callback function returns, so if you want to stash it
somewhere you must make your own copy.

The default
handler prints messages on "stderr".

If you set
"cb" to "NULL" then no handler is
called.

guestfs_get_error_handler

guestfs_error_handler_cb guestfs_get_error_handler
(guestfs_h *g, 
void **opaque_rtn);

Returns the
current error handler callback.

guestfs_push_error_handler

void guestfs_push_error_handler (guestfs_h *g, 
guestfs_error_handler_cb cb, 
void *opaque);

This is the
same as "guestfs_set_error_handler", except that
the old error handler is stashed away in a stack inside the
handle. You can restore the previous error handler by
calling "guestfs_pop_error_handler".

Use the
following code to temporarily disable errors around a
function:

guestfs_push_error_handler
(g, NULL, NULL); 
guestfs_mkdir (g, "/foo"); /* We don't care if
this fails. */ 
guestfs_pop_error_handler (g);

guestfs_pop_error_handler

void guestfs_pop_error_handler (guestfs_h *g);

Restore the
previous error handler (see
"guestfs_push_error_handler").

If you pop the
stack too many times, then the default error handler is
restored.

guestfs_set_out_of_memory_handler

typedef void (*guestfs_abort_cb) (void); 
void guestfs_set_out_of_memory_handler (guestfs_h *g, 
guestfs_abort_cb);

The callback
"cb" will be called if there is an out of memory
situation. Note this callback must not return.

The default is
to call abort(3).

You cannot set
"cb" to "NULL". You can&rsquo;t ignore
out of memory situations.

guestfs_get_out_of_memory_handler

guestfs_abort_fn guestfs_get_out_of_memory_handler
(guestfs_h *g);

This returns
the current out of memory handler.

API CALLS

guestfs_acl_delete_def_file

int 
guestfs_acl_delete_def_file (guestfs_h *g, 
const char *dir);

This function
deletes the default POSIX Access Control List (ACL) attached
to directory "dir".

This function
returns 0 on success or -1 on error.

This function
depends on the feature "acl". See also
"guestfs_feature_available".

(Added in
1.19.63)

guestfs_acl_get_file

char * 
guestfs_acl_get_file (guestfs_h *g, 
const char *path, 
const char *acltype);

This function
returns the POSIX Access Control List (ACL) attached to
"path". The ACL is returned in "long text
form" (see acl(5)).

The
"acltype" parameter may be: 
"access"

Return the ordinary (access)
ACL for any file, directory or other filesystem object.

"default"

Return the default ACL.
Normally this only makes sense if "path" is a
directory.

This function
returns a string, or NULL on error. The caller must free
the returned string after use.

This function
depends on the feature "acl". See also
"guestfs_feature_available".

(Added in
1.19.63)

guestfs_acl_set_file

int 
guestfs_acl_set_file (guestfs_h *g, 
const char *path, 
const char *acltype, 
const char *acl);

This function
sets the POSIX Access Control List (ACL) attached to
"path".

The
"acltype" parameter may be: 
"access"

Set the ordinary (access) ACL
for any file, directory or other filesystem object.

"default"

Set the default ACL. Normally
this only makes sense if "path" is a
directory.

The
"acl" parameter is the new ACL in either
"long text form" or "short text form"
(see acl(5)). The new ACL completely replaces any
previous ACL on the file. The ACL must contain the full Unix
permissions (eg. "u::rwx,g::rx,o::rx").

If you are
specifying individual users or groups, then the mask field
is also required (eg. "m::rwx"), followed by the
"u:ID:..." and/or
"g:ID:..." field(s). A full ACL string
might therefore look like this:

u::rwx,g::rwx,o::rwx,m::rwx,u:500:rwx,g:500:rwx

\ Unix permissions / \mask/ \ ACL /

You should use
numeric UIDs and GIDs. To map usernames and groupnames to
the correct numeric ID in the context of the guest, use the
Augeas functions (see "guestfs_aug_init").

This function
returns 0 on success or -1 on error.

This function
depends on the feature "acl". See also
"guestfs_feature_available".

(Added in
1.19.63)

guestfs_add_cdrom

int 
guestfs_add_cdrom (guestfs_h *g, 
const char *filename);

This
function is deprecated. In new code, use the
"guestfs_add_drive_ro" call instead.

Deprecated
functions will not be removed from the API, but the fact
that they are deprecated indicates that there are problems
with correct use of these functions.

This function
adds a virtual CD-ROM disk image to the guest.

The image is
added as read-only drive, so this function is equivalent of
"guestfs_add_drive_ro".

This function
returns 0 on success or -1 on error.

(Added in
0.3)

guestfs_add_domain

int 
guestfs_add_domain (guestfs_h *g, 
const char *dom, 
...);

You may supply
a list of optional arguments to this call. Use zero or more
of the following pairs of parameters, and terminate the list
with -1 on its own. See "CALLS WITH OPTIONAL
ARGUMENTS".

GUESTFS_ADD_DOMAIN_LIBVIRTURI,
const char *libvirturi, 
GUESTFS_ADD_DOMAIN_READONLY, int readonly, 
GUESTFS_ADD_DOMAIN_IFACE, const char *iface, 
GUESTFS_ADD_DOMAIN_LIVE, int live, 
GUESTFS_ADD_DOMAIN_ALLOWUUID, int allowuuid, 
GUESTFS_ADD_DOMAIN_READONLYDISK, const char *readonlydisk,

GUESTFS_ADD_DOMAIN_CACHEMODE, const char *cachemode, 
GUESTFS_ADD_DOMAIN_DISCARD, const char *discard, 
GUESTFS_ADD_DOMAIN_COPYONREAD, int copyonread,

This function
adds the disk(s) attached to the named libvirt domain
"dom". It works by connecting to libvirt,
requesting the domain and domain XML from libvirt, parsing
it for disks, and calling "guestfs_add_drive_opts"
on each one.

The number of
disks added is returned. This operation is atomic: if an
error is returned, then no disks are added.

This function
does some minimal checks to make sure the libvirt domain is
not running (unless "readonly" is true). In a
future version we will try to acquire the libvirt lock on
each disk.

Disks must be
accessible locally. This often means that adding disks from
a remote libvirt connection (see
https://libvirt.org/remote.html) will fail unless those
disks are accessible via the same device path locally
too.

The optional
"libvirturi" parameter sets the libvirt URI (see
https://libvirt.org/uri.html). If this is not set then we
connect to the default libvirt URI (or one set through an
environment variable, see the libvirt documentation for full
details).

The optional
"live" flag is ignored in libguestfs &ge;
1.48.

If the
"allowuuid" flag is true (default is false) then a
UUID may be passed instead of the domain name. The
"dom" string is treated as a UUID first and looked
up, and if that lookup fails then we treat "dom"
as a name as usual.

The optional
"readonlydisk" parameter controls what we do for
disks which are marked  in the libvirt XML.
Possible values are: 
readonlydisk = "error"

If "readonly" is
false:

The whole call
is aborted with an error if any disk with the
 flag is found.

If
"readonly" is true:

Disks with the
 flag are added read-only.

readonlydisk =
"read"

If "readonly" is
false:

Disks with the
 flag are added read-only. Other disks are
added read/write.

If
"readonly" is true:

Disks with the
 flag are added read-only.

readonlydisk =
"write" (default)

If "readonly" is
false:

Disks with the
 flag are added read/write.

If
"readonly" is true:

Disks with the
 flag are added read-only.

readonlydisk =
"ignore"

If "readonly" is true
or false:

Disks with the
 flag are skipped.

If present, the
value of "logical_block_size" attribute of
 tag in libvirt XML will be passed as
"blocksize" parameter to
"guestfs_add_drive_opts".

The other
optional parameters are passed directly through to
"guestfs_add_drive_opts".

On error this
function returns -1.

(Added in
1.7.4)

guestfs_add_domain_va

int 
guestfs_add_domain_va (guestfs_h *g, 
const char *dom, 
va_list args);

This is the
"va_list variant" of
"guestfs_add_domain".

See "CALLS
WITH OPTIONAL ARGUMENTS".

guestfs_add_domain_argv

int 
guestfs_add_domain_argv (guestfs_h *g, 
const char *dom, 
const struct guestfs_add_domain_argv *optargs);

This is the
"argv variant" of
"guestfs_add_domain".

See "CALLS
WITH OPTIONAL ARGUMENTS".

guestfs_add_drive

int 
guestfs_add_drive (guestfs_h *g, 
const char *filename);

This function
is provided for backwards compatibility with earlier
versions of libguestfs. It simply calls
"guestfs_add_drive_opts" with no optional
arguments.

(Added in
0.3)

guestfs_add_drive_opts

int 
guestfs_add_drive_opts (guestfs_h *g, 
const char *filename, 
...);

You may supply
a list of optional arguments to this call. Use zero or more
of the following pairs of parameters, and terminate the list
with -1 on its own. See "CALLS WITH OPTIONAL
ARGUMENTS".

GUESTFS_ADD_DRIVE_OPTS_READONLY,
int readonly, 
GUESTFS_ADD_DRIVE_OPTS_FORMAT, const char *format, 
GUESTFS_ADD_DRIVE_OPTS_IFACE, const char *iface, 
GUESTFS_ADD_DRIVE_OPTS_NAME, const char *name, 
GUESTFS_ADD_DRIVE_OPTS_LABEL, const char *label, 
GUESTFS_ADD_DRIVE_OPTS_PROTOCOL, const char *protocol, 
GUESTFS_ADD_DRIVE_OPTS_SERVER, char *const *server, 
GUESTFS_ADD_DRIVE_OPTS_USERNAME, const char *username, 
GUESTFS_ADD_DRIVE_OPTS_SECRET, const char *secret, 
GUESTFS_ADD_DRIVE_OPTS_CACHEMODE, const char *cachemode,

GUESTFS_ADD_DRIVE_OPTS_DISCARD, const char *discard, 
GUESTFS_ADD_DRIVE_OPTS_COPYONREAD, int copyonread, 
GUESTFS_ADD_DRIVE_OPTS_BLOCKSIZE, int blocksize,

This function
adds a disk image called filename to the handle.
filename may be a regular host file or a host
device.

When this
function is called before "guestfs_launch" (the
usual case) then the first time you call this function, the
disk appears in the API as /dev/sda, the second time
as /dev/sdb, and so on.

You don&rsquo;t
necessarily need to be root when using libguestfs. However
you obviously do need sufficient permissions to access the
filename for whatever operations you want to perform (ie.
read access if you just want to read the image or write
access if you want to modify the image).

This call
checks that filename exists.

filename
may be the special string "/dev/null". See
"NULL DISKS".

The optional
arguments are: 
"readonly"

If true then the image is
treated as read-only. Writes are still allowed, but they are
stored in a temporary snapshot overlay which is discarded at
the end. The disk that you add is not modified.

"format"

This forces the image format.
If you omit this (or use "guestfs_add_drive" or
"guestfs_add_drive_ro") then the format is
automatically detected. Possible formats include
"raw" and "qcow2".

Automatic
detection of the format opens you up to a potential security
hole when dealing with untrusted raw-format images. See
CVE-2010-3851 and RHBZ#642934. Specifying the format closes
this security hole.

"iface"

This rarely-used option lets
you emulate the behaviour of the deprecated
"guestfs_add_drive_with_if" call (q.v.)

"name"

This field used to be passed as
a hint for guest inspection, but it is no longer used.

"label"

Give the disk a label. The
label should be a unique, short string using only
ASCII characters "[a-zA-Z]". As well as its usual
name in the API (such as /dev/sda), the drive will
also be named /dev/disk/guestfs/label.

See "DISK
LABELS".

"protocol"

The optional protocol argument
can be used to select an alternate source protocol.

See also:
"REMOTE STORAGE". 
"protocol = "file""

filename is interpreted
as a local file or device. This is the default if the
optional protocol parameter is omitted.

"protocol =
"ftp"|"ftps"|"http"|"https"|"tftp""

Connect to a remote FTP, HTTP
or TFTP server. The "server" parameter must also
be supplied - see below.

See also:
"FTP, HTTP AND TFTP"

"protocol =
"gluster""

Connect to the GlusterFS
server. The "server" parameter must also be
supplied - see below.

See also:
"GLUSTER"

"protocol =
"iscsi""

Connect to the iSCSI server.
The "server" parameter must also be supplied - see
below. The "username" parameter may be supplied.
See below. The "secret" parameter may be supplied.
See below.

See also:
"ISCSI".

"protocol =
"nbd""

Connect to the Network Block
Device server. The "server" parameter must also be
supplied - see below.

See also:
"NETWORK BLOCK DEVICE".

"protocol =
"rbd""

Connect to the Ceph
(librbd/RBD) server. The "server" parameter must
also be supplied - see below. The "username"
parameter may be supplied. See below. The "secret"
parameter may be supplied. See below.

See also:
"CEPH".

"protocol =
"sheepdog""

Connect to the Sheepdog server.
The "server" parameter may also be supplied - see
below.

See also:
"SHEEPDOG".

"protocol =
"ssh""

Connect to the Secure Shell
(ssh) server.

The
"server" parameter must be supplied. The
"username" parameter may be supplied. See
below.

See also:
"SSH".

"server"

For protocols which require
access to a remote server, this is a list of server(s).

Protocol Number
of servers required 
-------- -------------------------- 
file List must be empty or param not used at all 
ftp|ftps|http|https|tftp Exactly one 
gluster Exactly one 
iscsi Exactly one 
nbd Exactly one 
rbd Zero or more 
sheepdog Zero or more 
ssh Exactly one

Each list
element is a string specifying a server. The string must be
in one of the following formats:

hostname 
hostname:port 
tcp:hostname 
tcp:hostname:port 
unix:/path/to/socket

If the port
number is omitted, then the standard port number for the
protocol is used (see /etc/services).

"username"

For the "ftp",
"ftps", "http", "https",
"iscsi", "rbd", "ssh" and
"tftp" protocols, this specifies the remote
username.

If not given,
then the local username is used for "ssh", and no
authentication is attempted for ceph. But note this
sometimes may give unexpected results, for example if using
the libvirt backend and if the libvirt backend is configured
to start the qemu appliance as a special user such as
"qemu.qemu". If in doubt, specify the remote
username you want.

"secret"

For the "rbd"
protocol only, this specifies the &rsquo;secret&rsquo; to
use when connecting to the remote device. It must be base64
encoded.

If not given,
then a secret matching the given username will be looked up
in the default keychain locations, or if no username is
given, then no authentication will be used.

"cachemode"

Choose whether or not
libguestfs will obey sync operations (safe but slow) or not
(unsafe but fast). The possible values for this string are:

"cachemode = "writeback""

This is the default.

Write
operations in the API do not return until a write(2)
call has completed in the host [but note this does not imply
that anything gets written to disk].

Sync operations
in the API, including implicit syncs caused by filesystem
journalling, will not return until an fdatasync(2)
call has completed in the host, indicating that data has
been committed to disk.

"cachemode =
"unsafe""

In this mode, there are no
guarantees. Libguestfs may cache anything and ignore sync
requests. This is suitable only for scratch or temporary
disks.

"discard"

Enable or disable discard
(a.k.a. trim or unmap) support on this drive. If enabled,
operations such as "guestfs_fstrim" will be able
to discard / make thin / punch holes in the underlying host
file or device.

Possible
discard settings are: 
"discard = "disable""

Disable discard support. This
is the default.

"discard =
"enable""

Enable discard support. Fail if
discard is not possible.

"discard =
"besteffort""

Enable discard support if
possible, but don&rsquo;t fail if it is not supported.

Since not all
backends and not all underlying systems support discard,
this is a good choice if you want to use discard if
possible, but don&rsquo;t mind if it doesn&rsquo;t work.

"copyonread"

The boolean parameter
"copyonread" enables copy-on-read support. This
only affects disk formats which have backing files, and
causes reads to be stored in the overlay layer, speeding up
multiple reads of the same area of disk.

The default is
false.

"blocksize"

This parameter sets the sector
size of the disk. Possible values are 512 (the default if
the parameter is omitted) or 4096. Use 4096 when handling an
"Advanced Format" disk that uses 4K sector size
(https://en.wikipedia.org/wiki/Advanced_Format).

Only a subset
of the backends support this parameter (currently only the
libvirt and direct backends do).

This function
returns 0 on success or -1 on error.

(Added in
0.3)

guestfs_add_drive_opts_va

int 
guestfs_add_drive_opts_va (guestfs_h *g, 
const char *filename, 
va_list args);

This is the
"va_list variant" of
"guestfs_add_drive_opts".

See "CALLS
WITH OPTIONAL ARGUMENTS".

guestfs_add_drive_opts_argv

int 
guestfs_add_drive_opts_argv (guestfs_h *g, 
const char *filename, 
const struct guestfs_add_drive_opts_argv *optargs);

This is the
"argv variant" of
"guestfs_add_drive_opts".

See "CALLS
WITH OPTIONAL ARGUMENTS".

guestfs_add_drive_ro

int 
guestfs_add_drive_ro (guestfs_h *g, 
const char *filename);

This function
is the equivalent of calling
"guestfs_add_drive_opts" with the optional
parameter "GUESTFS_ADD_DRIVE_OPTS_READONLY" set to
1, so the disk is added read-only, with the format being
detected automatically.

This function
returns 0 on success or -1 on error.

(Added in
1.0.38)

guestfs_add_drive_ro_with_if

int 
guestfs_add_drive_ro_with_if (guestfs_h *g, 
const char *filename, 
const char *iface);

This
function is deprecated. In new code, use the
"guestfs_add_drive" call instead.

Deprecated
functions will not be removed from the API, but the fact
that they are deprecated indicates that there are problems
with correct use of these functions.

This is the
same as "guestfs_add_drive_ro" but it allows you
to specify the QEMU interface emulation to use at run time.
Both the direct and the libvirt backends ignore
"iface".

This function
returns 0 on success or -1 on error.

(Added in
1.0.84)

guestfs_add_drive_scratch

int 
guestfs_add_drive_scratch (guestfs_h *g, 
int64_t size, 
...);

You may supply
a list of optional arguments to this call. Use zero or more
of the following pairs of parameters, and terminate the list
with -1 on its own. See "CALLS WITH OPTIONAL
ARGUMENTS".

GUESTFS_ADD_DRIVE_SCRATCH_NAME,
const char *name, 
GUESTFS_ADD_DRIVE_SCRATCH_LABEL, const char *label, 
GUESTFS_ADD_DRIVE_SCRATCH_BLOCKSIZE, int blocksize,

This command
adds a temporary scratch drive to the handle. The
"size" parameter is the virtual size (in bytes).
The scratch drive is blank initially (all reads return
zeroes until you start writing to it). The drive is deleted
when the handle is closed.

The optional
arguments "name", "label" and
"blocksize" are passed through to
"guestfs_add_drive_opts".

This function
returns 0 on success or -1 on error.

(Added in
1.23.10)

guestfs_add_drive_scratch_va

int 
guestfs_add_drive_scratch_va (guestfs_h *g, 
int64_t size, 
va_list args);

This is the
"va_list variant" of
"guestfs_add_drive_scratch".

See "CALLS
WITH OPTIONAL ARGUMENTS".

guestfs_add_drive_scratch_argv

int 
guestfs_add_drive_scratch_argv (guestfs_h *g, 
int64_t size, 
const struct guestfs_add_drive_scratch_argv *optargs);

This is the
"argv variant" of
"guestfs_add_drive_scratch".

See "CALLS
WITH OPTIONAL ARGUMENTS".

guestfs_add_drive_with_if

int 
guestfs_add_drive_with_if (guestfs_h *g, 
const char *filename, 
const char *iface);

This
function is deprecated. In new code, use the
"guestfs_add_drive" call instead.

Deprecated
functions will not be removed from the API, but the fact
that they are deprecated indicates that there are problems
with correct use of these functions.

This is the
same as "guestfs_add_drive" but it allows you to
specify the QEMU interface emulation to use at run time.
Both the direct and the libvirt backends ignore
"iface".

This function
returns 0 on success or -1 on error.

(Added in
1.0.84)

guestfs_add_libvirt_dom

int 
guestfs_add_libvirt_dom (guestfs_h *g, 
void * /* really virDomainPtr */ dom, 
...);

You may supply
a list of optional arguments to this call. Use zero or more
of the following pairs of parameters, and terminate the list
with -1 on its own. See "CALLS WITH OPTIONAL
ARGUMENTS".

GUESTFS_ADD_LIBVIRT_DOM_READONLY,
int readonly, 
GUESTFS_ADD_LIBVIRT_DOM_IFACE, const char *iface, 
GUESTFS_ADD_LIBVIRT_DOM_LIVE, int live, 
GUESTFS_ADD_LIBVIRT_DOM_READONLYDISK, const char
*readonlydisk, 
GUESTFS_ADD_LIBVIRT_DOM_CACHEMODE, const char *cachemode,

GUESTFS_ADD_LIBVIRT_DOM_DISCARD, const char *discard, 
GUESTFS_ADD_LIBVIRT_DOM_COPYONREAD, int copyonread,

This function
adds the disk(s) attached to the libvirt domain
"dom". It works by requesting the domain XML from
libvirt, parsing it for disks, and calling
"guestfs_add_drive_opts" on each one.

In the C API we
declare "void *dom", but really it has type
"virDomainPtr dom". This is so we don&rsquo;t need
.

The number of
disks added is returned. This operation is atomic: if an
error is returned, then no disks are added.

This function
does some minimal checks to make sure the libvirt domain is
not running (unless "readonly" is true). In a
future version we will try to acquire the libvirt lock on
each disk.

Disks must be
accessible locally. This often means that adding disks from
a remote libvirt connection (see
https://libvirt.org/remote.html) will fail unless those
disks are accessible via the same device path locally
too.

The optional
"live" flag is ignored in libguestfs &ge;
1.48.

The optional
"readonlydisk" parameter controls what we do for
disks which are marked  in the libvirt XML.
See "guestfs_add_domain" for possible values.

If present, the
value of "logical_block_size" attribute of
 tag in libvirt XML will be passed as
"blocksize" parameter to
"guestfs_add_drive_opts".

The other
optional parameters are passed directly through to
"guestfs_add_drive_opts".

On error this
function returns -1.

(Added in
1.29.14)

guestfs_add_libvirt_dom_va

int 
guestfs_add_libvirt_dom_va (guestfs_h *g, 
void * /* really virDomainPtr */ dom, 
va_list args);

This is the
"va_list variant" of
"guestfs_add_libvirt_dom".

See "CALLS
WITH OPTIONAL ARGUMENTS".

guestfs_add_libvirt_dom_argv

int 
guestfs_add_libvirt_dom_argv (guestfs_h *g, 
void * /* really virDomainPtr */ dom, 
const struct guestfs_add_libvirt_dom_argv *optargs);

This is the
"argv variant" of
"guestfs_add_libvirt_dom".

See "CALLS
WITH OPTIONAL ARGUMENTS".

guestfs_aug_clear

int 
guestfs_aug_clear (guestfs_h *g, 
const char *augpath);

Set the value
associated with "path" to "NULL". This
is the same as the augtool(1) "clear"
command.

This function
returns 0 on success or -1 on error.

(Added in
1.3.4)

guestfs_aug_close

int 
guestfs_aug_close (guestfs_h *g);

Close the
current Augeas handle and free up any resources used by it.
After calling this, you have to call
"guestfs_aug_init" again before you can use any
other Augeas functions.

This function
returns 0 on success or -1 on error.

(Added in
0.7)

guestfs_aug_defnode

struct guestfs_int_bool * 
guestfs_aug_defnode (guestfs_h *g, 
const char *name, 
const char *expr, 
const char *val);

Defines a
variable "name" whose value is the result of
evaluating "expr".

If
"expr" evaluates to an empty nodeset, a node is
created, equivalent to calling "guestfs_aug_set"
"expr", "val". "name" will be
the nodeset containing that single node.

On success this
returns a pair containing the number of nodes in the
nodeset, and a boolean flag if a node was created.

This function
returns a "struct guestfs_int_bool *", or NULL if
there was an error. The caller must call
"guestfs_free_int_bool" after use.

(Added in
0.7)

guestfs_aug_defvar

int 
guestfs_aug_defvar (guestfs_h *g, 
const char *name, 
const char *expr);

Defines an
Augeas variable "name" whose value is the result
of evaluating "expr". If "expr" is NULL,
then "name" is undefined.

On success this
returns the number of nodes in "expr", or 0 if
"expr" evaluates to something which is not a
nodeset.

On error this
function returns -1.

(Added in
0.7)

guestfs_aug_get

char * 
guestfs_aug_get (guestfs_h *g, 
const char *augpath);

Look up the
value associated with "path". If "path"
matches exactly one node, the "value" is
returned.

This function
returns a string, or NULL on error. The caller must free
the returned string after use.

(Added in
0.7)

guestfs_aug_init

int 
guestfs_aug_init (guestfs_h *g, 
const char *root, 
int flags);

Create a new
Augeas handle for editing configuration files. If there was
any previous Augeas handle associated with this guestfs
session, then it is closed.

You must call
this before using any other "guestfs_aug_*"
commands.

"root"
is the filesystem root. "root" must not be NULL,
use / instead.

The flags are
the same as the flags defined in , the
logical or of the following integers: 
"AUG_SAVE_BACKUP" = 1

Keep the original file with a
".augsave" extension.

"AUG_SAVE_NEWFILE" =
2

Save changes into a file with
extension ".augnew", and do not overwrite
original. Overrides "AUG_SAVE_BACKUP".

"AUG_TYPE_CHECK" =
4

Typecheck lenses.

This option is
only useful when debugging Augeas lenses. Use of this option
may require additional memory for the libguestfs appliance.
You may need to set the "LIBGUESTFS_MEMSIZE"
environment variable or call
"guestfs_set_memsize".

"AUG_NO_STDINC" =
8

Do not use standard load path
for modules.

"AUG_SAVE_NOOP" =
16

Make save a no-op, just record
what would have been changed.

"AUG_NO_LOAD" =
32

Do not load the tree in
"guestfs_aug_init".

To close the
handle, you can call "guestfs_aug_close".

To find out
more about Augeas, see http://augeas.net/.

This function
returns 0 on success or -1 on error.

(Added in
0.7)

guestfs_aug_insert

int 
guestfs_aug_insert (guestfs_h *g, 
const char *augpath, 
const char *label, 
int before);

Create a new
sibling "label" for "path", inserting it
into the tree before or after "path" (depending on
the boolean flag "before").

"path"
must match exactly one existing node in the tree, and
"label" must be a label, ie. not contain /,
"*" or end with a bracketed index
"[N]".

This function
returns 0 on success or -1 on error.

(Added in
0.7)

guestfs_aug_label

char * 
guestfs_aug_label (guestfs_h *g, 
const char *augpath);

The label (name
of the last element) of the Augeas path expression
"augpath" is returned. "augpath" must
match exactly one node, else this function returns an
error.

This function
returns a string, or NULL on error. The caller must free
the returned string after use.

(Added in
1.23.14)

guestfs_aug_load

int 
guestfs_aug_load (guestfs_h *g);

Load files into
the tree.

See
"aug_load" in the Augeas documentation for the
full gory details.

This function
returns 0 on success or -1 on error.

(Added in
0.7)

guestfs_aug_ls

char ** 
guestfs_aug_ls (guestfs_h *g, 
const char *augpath);

This is just a
shortcut for listing "guestfs_aug_match"
"path/*" and sorting the resulting nodes into
alphabetical order.

This function
returns a NULL-terminated array of strings (like
environ(3)), or NULL if there was an error. The
caller must free the strings and the array after
use.

(Added in
0.8)

guestfs_aug_match

char ** 
guestfs_aug_match (guestfs_h *g, 
const char *augpath);

Returns a list
of paths which match the path expression "path".
The returned paths are sufficiently qualified so that they
match exactly one node in the current tree.

This function
returns a NULL-terminated array of strings (like
environ(3)), or NULL if there was an error. The
caller must free the strings and the array after
use.

(Added in
0.7)

guestfs_aug_mv

int 
guestfs_aug_mv (guestfs_h *g, 
const char *src, 
const char *dest);

Move the node
"src" to "dest". "src" must
match exactly one node. "dest" is overwritten if
it exists.

This function
returns 0 on success or -1 on error.

(Added in
0.7)

guestfs_aug_rm

int 
guestfs_aug_rm (guestfs_h *g, 
const char *augpath);

Remove
"path" and all of its children.

On success this
returns the number of entries which were removed.

On error this
function returns -1.

(Added in
0.7)

guestfs_aug_save

int 
guestfs_aug_save (guestfs_h *g);

This writes all
pending changes to disk.

The flags which
were passed to "guestfs_aug_init" affect exactly
how files are saved.

This function
returns 0 on success or -1 on error.

(Added in
0.7)

guestfs_aug_set

int 
guestfs_aug_set (guestfs_h *g, 
const char *augpath, 
const char *val);

Set the value
associated with "augpath" to "val".

In the Augeas
API, it is possible to clear a node by setting the value to
NULL. Due to an oversight in the libguestfs API you cannot
do that with this call. Instead you must use the
"guestfs_aug_clear" call.

This function
returns 0 on success or -1 on error.

(Added in
0.7)

guestfs_aug_setm

int 
guestfs_aug_setm (guestfs_h *g, 
const char *base, 
const char *sub, 
const char *val);

Change multiple
Augeas nodes in a single operation. "base" is an
expression matching multiple nodes. "sub" is a
path expression relative to "base". All nodes
matching "base" are found, and then for each node,
"sub" is changed to "val".
"sub" may also be "NULL" in which case
the "base" nodes are modified.

This returns
the number of nodes modified.

On error this
function returns -1.

(Added in
1.23.14)

guestfs_aug_transform

int 
guestfs_aug_transform (guestfs_h *g, 
const char *lens, 
const char *file, 
...);

You may supply
a list of optional arguments to this call. Use zero or more
of the following pairs of parameters, and terminate the list
with -1 on its own. See "CALLS WITH OPTIONAL
ARGUMENTS".

GUESTFS_AUG_TRANSFORM_REMOVE,
int remove,

Add an Augeas
transformation for the specified "lens" so it can
handle "file".

If
"remove" is true ("false" by default),
then the transformation is removed.

This function
returns 0 on success or -1 on error.

(Added in
1.35.2)

guestfs_aug_transform_va

int 
guestfs_aug_transform_va (guestfs_h *g, 
const char *lens, 
const char *file, 
va_list args);

This is the
"va_list variant" of
"guestfs_aug_transform".

See "CALLS
WITH OPTIONAL ARGUMENTS".

guestfs_aug_transform_argv

int 
guestfs_aug_transform_argv (guestfs_h *g, 
const char *lens, 
const char *file, 
const struct guestfs_aug_transform_argv *optargs);

This is the
"argv variant" of
"guestfs_aug_transform".

See "CALLS
WITH OPTIONAL ARGUMENTS".

guestfs_available

int 
guestfs_available (guestfs_h *g, 
char *const *groups);

This command is
used to check the availability of some groups of
functionality in the appliance, which not all builds of the
libguestfs appliance will be able to provide.

The libguestfs
groups, and the functions that those groups correspond to,
are listed in "AVAILABILITY". You can also fetch
this list at runtime by calling
"guestfs_available_all_groups".

The argument
"groups" is a list of group names, eg:
"["inotify", "augeas"]" would
check for the availability of the Linux inotify functions
and Augeas (configuration file editing) functions.

The command
returns no error if all requested groups are
available.

It fails with
an error if one or more of the requested groups is
unavailable in the appliance.

If an unknown
group name is included in the list of groups then an error
is always returned.

Notes:

&bull;

"guestfs_feature_available" is the same as
this call, but with a slightly simpler to use API: that call
returns a boolean true/false instead of throwing an
error. 

&bull;

You must call "guestfs_launch" before calling
this function.

The reason is
because we don&rsquo;t know what groups are supported by the
appliance/daemon until it is running and can be queried.

&bull;

If a group of functions is
available, this does not necessarily mean that they will
work. You still have to check for errors when calling
individual API functions even if they are available.

&bull;

It is usually the job of distro packagers to build
complete functionality into the libguestfs appliance.
Upstream libguestfs, if built from source with all
requirements satisfied, will support everything.

&bull;

This call was added in version 1.0.80. In previous
versions of libguestfs all you could do would be to
speculatively execute a command to find out if the daemon
implemented it. See also "guestfs_version".

See also
"guestfs_filesystem_available".

This function
returns 0 on success or -1 on error.

(Added in
1.0.80)

guestfs_available_all_groups

char ** 
guestfs_available_all_groups (guestfs_h *g);

This command
returns a list of all optional groups that this daemon knows
about. Note this returns both supported and unsupported
groups. To find out which ones the daemon can actually
support you have to call "guestfs_available" /
"guestfs_feature_available" on each member of the
returned list.

See also
"guestfs_available",
"guestfs_feature_available" and
"AVAILABILITY".

This function
returns a NULL-terminated array of strings (like
environ(3)), or NULL if there was an error. The
caller must free the strings and the array after
use.

(Added in
1.3.15)

guestfs_base64_in

int 
guestfs_base64_in (guestfs_h *g, 
const char *base64file, 
const char *filename);

This command
uploads base64-encoded data from "base64file" to
filename.

This function
returns 0 on success or -1 on error.

(Added in
1.3.5)

guestfs_base64_out

int 
guestfs_base64_out (guestfs_h *g, 
const char *filename, 
const char *base64file);

This command
downloads the contents of filename, writing it out to
local file "base64file" encoded as base64.

This function
returns 0 on success or -1 on error.

(Added in
1.3.5)

guestfs_blkdiscard

int 
guestfs_blkdiscard (guestfs_h *g, 
const char *device);

This discards
all blocks on the block device "device", giving
the free space back to the host.

This operation
requires support in libguestfs, the host filesystem, qemu
and the host kernel. If this support isn&rsquo;t present it
may give an error or even appear to run but do nothing. You
must also set the "discard" attribute on the
underlying drive (see
"guestfs_add_drive_opts").

This function
returns 0 on success or -1 on error.

This function
depends on the feature "blkdiscard". See also
"guestfs_feature_available".

(Added in
1.25.44)

guestfs_blkdiscardzeroes

int 
guestfs_blkdiscardzeroes (guestfs_h *g, 
const char *device);

This call
returns true if blocks on "device" that have been
discarded by a call to "guestfs_blkdiscard" are
returned as blocks of zero bytes when read the next
time.

If it returns
false, then it may be that discarded blocks are read as
stale or random data.

This function
returns a C truth value on success or -1 on error.

This function
depends on the feature "blkdiscardzeroes". See
also "guestfs_feature_available".

(Added in
1.25.44)

guestfs_blkid

char ** 
guestfs_blkid (guestfs_h *g, 
const char *device);

This command
returns block device attributes for "device". The
following fields are usually present in the returned hash.
Other fields may also be present. 
"UUID"

The uuid of this device.

"LABEL"

The label of this device.

"VERSION"

The version of blkid
command.

"TYPE"

The filesystem type or RAID of
this device.

"USAGE"

The usage of this device, for
example "filesystem" or "raid".

This function
returns a NULL-terminated array of strings, or NULL if there
was an error. The array of strings will always have length
"2n+1", where "n" keys and values
alternate, followed by the trailing NULL entry. The
caller must free the strings and the array after
use.

(Added in
1.15.9)

guestfs_blockdev_flushbufs

int 
guestfs_blockdev_flushbufs (guestfs_h *g, 
const char *device);

This tells the
kernel to flush internal buffers associated with
"device".

This uses the
blockdev(8) command.

This function
returns 0 on success or -1 on error.

(Added in
1.9.3)

guestfs_blockdev_getbsz

int 
guestfs_blockdev_getbsz (guestfs_h *g, 
const char *device);

This returns
the block size of a device.

Note: this is
different from both size in blocks and filesystem
block size. Also this setting is not really used by
anything. You should probably not use it for anything.
Filesystems have their own idea about what block size to
choose.

This uses the
blockdev(8) command.

On error this
function returns -1.

(Added in
1.9.3)

guestfs_blockdev_getro

int 
guestfs_blockdev_getro (guestfs_h *g, 
const char *device);

Returns a
boolean indicating if the block device is read-only (true if
read-only, false if not).

This uses the
blockdev(8) command.

This function
returns a C truth value on success or -1 on error.

(Added in
1.9.3)

guestfs_blockdev_getsize64

int64_t 
guestfs_blockdev_getsize64 (guestfs_h *g, 
const char *device);

This returns
the size of the device in bytes.

See also
"guestfs_blockdev_getsz".

This uses the
blockdev(8) command.

On error this
function returns -1.

(Added in
1.9.3)

guestfs_blockdev_getss

int 
guestfs_blockdev_getss (guestfs_h *g, 
const char *device);

This returns
the size of sectors on a block device. Usually 512, but can
be larger for modern devices.

(Note, this is
not the size in sectors, use
"guestfs_blockdev_getsz" for that).

This uses the
blockdev(8) command.

On error this
function returns -1.

(Added in
1.9.3)

guestfs_blockdev_getsz

int64_t 
guestfs_blockdev_getsz (guestfs_h *g, 
const char *device);

This returns
the size of the device in units of 512-byte sectors (even if
the sectorsize isn&rsquo;t 512 bytes ... weird).

See also
"guestfs_blockdev_getss" for the real sector size
of the device, and "guestfs_blockdev_getsize64"
for the more useful size in bytes.

This uses the
blockdev(8) command.

On error this
function returns -1.

(Added in
1.9.3)

guestfs_blockdev_rereadpt

int 
guestfs_blockdev_rereadpt (guestfs_h *g, 
const char *device);

Reread the
partition table on "device".

This uses the
blockdev(8) command.

This function
returns 0 on success or -1 on error.

(Added in
1.9.3)

guestfs_blockdev_setbsz

int 
guestfs_blockdev_setbsz (guestfs_h *g, 
const char *device, 
int blocksize);

This
function is deprecated. There is no replacement. Consult
the API documentation in guestfs(3) for further
information.

Deprecated
functions will not be removed from the API, but the fact
that they are deprecated indicates that there are problems
with correct use of these functions.

This call does
nothing and has never done anything because of a bug in
blockdev. Do not use it.

If you need to
set the filesystem block size, use the "blocksize"
option of "guestfs_mkfs".

This function
returns 0 on success or -1 on error.

(Added in
1.9.3)

guestfs_blockdev_setra

int 
guestfs_blockdev_setra (guestfs_h *g, 
const char *device, 
int sectors);

Set readahead
(in 512-byte sectors) for the device.

This uses the
blockdev(8) command.

This function
returns 0 on success or -1 on error.

(Added in
1.29.10)

guestfs_blockdev_setro

int 
guestfs_blockdev_setro (guestfs_h *g, 
const char *device);

Sets the block
device named "device" to read-only.

This uses the
blockdev(8) command.

This function
returns 0 on success or -1 on error.

(Added in
1.9.3)

guestfs_blockdev_setrw

int 
guestfs_blockdev_setrw (guestfs_h *g, 
const char *device);

Sets the block
device named "device" to read-write.

This uses the
blockdev(8) command.

This function
returns 0 on success or -1 on error.

(Added in
1.9.3)

guestfs_btrfs_balance_cancel

int 
guestfs_btrfs_balance_cancel (guestfs_h *g, 
const char *path);

Cancel a
running balance on a btrfs filesystem.

This function
returns 0 on success or -1 on error.

This function
depends on the feature "btrfs". See also
"guestfs_feature_available".

(Added in
1.29.22)

guestfs_btrfs_balance_pause

int 
guestfs_btrfs_balance_pause (guestfs_h *g, 
const char *path);

Pause a running
balance on a btrfs filesystem.

This function
returns 0 on success or -1 on error.

This function
depends on the feature "btrfs". See also
"guestfs_feature_available".

(Added in
1.29.22)

guestfs_btrfs_balance_resume

int 
guestfs_btrfs_balance_resume (guestfs_h *g, 
const char *path);

Resume a paused
balance on a btrfs filesystem.

This function
returns 0 on success or -1 on error.

This function
depends on the feature "btrfs". See also
"guestfs_feature_available".

(Added in
1.29.22)

guestfs_btrfs_balance_status

struct guestfs_btrfsbalance * 
guestfs_btrfs_balance_status (guestfs_h *g, 
const char *path);

Show the status
of a running or paused balance on a btrfs filesystem.

This function
returns a "struct guestfs_btrfsbalance *", or NULL
if there was an error. The caller must call
"guestfs_free_btrfsbalance" after use.

This function
depends on the feature "btrfs". See also
"guestfs_feature_available".

(Added in
1.29.26)

guestfs_btrfs_device_add

int 
guestfs_btrfs_device_add (guestfs_h *g, 
char *const *devices, 
const char *fs);

Add the list of
device(s) in "devices" to the btrfs filesystem
mounted at "fs". If "devices" is an
empty list, this does nothing.

This function
returns 0 on success or -1 on error.

This function
depends on the feature "btrfs". See also
"guestfs_feature_available".

(Added in
1.17.35)

guestfs_btrfs_device_delete

int 
guestfs_btrfs_device_delete (guestfs_h *g, 
char *const *devices, 
const char *fs);

Remove the
"devices" from the btrfs filesystem mounted at
"fs". If "devices" is an empty list,
this does nothing.

This function
returns 0 on success or -1 on error.

This function
depends on the feature "btrfs". See also
"guestfs_feature_available".

(Added in
1.17.35)

guestfs_btrfs_filesystem_balance

int 
guestfs_btrfs_filesystem_balance (guestfs_h *g, 
const char *fs);

Balance the
chunks in the btrfs filesystem mounted at "fs"
across the underlying devices.

This function
returns 0 on success or -1 on error.

This function
depends on the feature "btrfs". See also
"guestfs_feature_available".

(Added in
1.17.35)

guestfs_btrfs_filesystem_defragment

int 
guestfs_btrfs_filesystem_defragment (guestfs_h *g, 
const char *path, 
...);

You may supply
a list of optional arguments to this call. Use zero or more
of the following pairs of parameters, and terminate the list
with -1 on its own. See "CALLS WITH OPTIONAL
ARGUMENTS".

GUESTFS_BTRFS_FILESYSTEM_DEFRAGMENT_FLUSH,
int flush, 
GUESTFS_BTRFS_FILESYSTEM_DEFRAGMENT_COMPRESS, const char
*compress,

Defragment a
file or directory on a btrfs filesystem. compress is one of
zlib or lzo.

This function
returns 0 on success or -1 on error.

This function
depends on the feature "btrfs". See also
"guestfs_feature_available".

(Added in
1.29.22)

guestfs_btrfs_filesystem_defragment_va

int 
guestfs_btrfs_filesystem_defragment_va (guestfs_h *g, 
const char *path, 
va_list args);

This is the
"va_list variant" of
"guestfs_btrfs_filesystem_defragment".

See "CALLS
WITH OPTIONAL ARGUMENTS".

guestfs_btrfs_filesystem_defragment_argv

int 
guestfs_btrfs_filesystem_defragment_argv (guestfs_h *g, 
const char *path, 
const struct guestfs_btrfs_filesystem_defragment_argv
*optargs);

This is the
"argv variant" of
"guestfs_btrfs_filesystem_defragment".

See "CALLS
WITH OPTIONAL ARGUMENTS".

guestfs_btrfs_filesystem_resize

int 
guestfs_btrfs_filesystem_resize (guestfs_h *g, 
const char *mountpoint, 
...);

You may supply
a list of optional arguments to this call. Use zero or more
of the following pairs of parameters, and terminate the list
with -1 on its own. See "CALLS WITH OPTIONAL
ARGUMENTS".

GUESTFS_BTRFS_FILESYSTEM_RESIZE_SIZE,
int64_t size,

This command
resizes a btrfs filesystem.

Note that
unlike other resize calls, the filesystem has to be mounted
and the parameter is the mountpoint not the device (this is
a requirement of btrfs itself).

The optional
parameters are: 
"size"

The new size (in bytes) of the
filesystem. If omitted, the filesystem is resized to the
maximum size.

See also
btrfs(8).

This function
returns 0 on success or -1 on error.

This function
depends on the feature "btrfs". See also
"guestfs_feature_available".

(Added in
1.11.17)

guestfs_btrfs_filesystem_resize_va

int 
guestfs_btrfs_filesystem_resize_va (guestfs_h *g, 
const char *mountpoint, 
va_list args);

This is the
"va_list variant" of
"guestfs_btrfs_filesystem_resize".

See "CALLS
WITH OPTIONAL ARGUMENTS".

guestfs_btrfs_filesystem_resize_argv

int 
guestfs_btrfs_filesystem_resize_argv (guestfs_h *g, 
const char *mountpoint, 
const struct guestfs_btrfs_filesystem_resize_argv
*optargs);

This is the
"argv variant" of
"guestfs_btrfs_filesystem_resize".

See "CALLS
WITH OPTIONAL ARGUMENTS".

guestfs_btrfs_filesystem_show

char ** 
guestfs_btrfs_filesystem_show (guestfs_h *g, 
const char *device);

Show all the
devices where the filesystems in "device" is
spanned over.

If not all the
devices for the filesystems are present, then this function
fails and the "errno" is set to
"ENODEV".

This function
returns a NULL-terminated array of strings (like
environ(3)), or NULL if there was an error. The
caller must free the strings and the array after
use.

This function
depends on the feature "btrfs". See also
"guestfs_feature_available".

(Added in
1.33.29)

guestfs_btrfs_filesystem_sync

int 
guestfs_btrfs_filesystem_sync (guestfs_h *g, 
const char *fs);

Force sync on
the btrfs filesystem mounted at "fs".

This function
returns 0 on success or -1 on error.

This function
depends on the feature "btrfs". See also
"guestfs_feature_available".

(Added in
1.17.35)

guestfs_btrfs_fsck

int 
guestfs_btrfs_fsck (guestfs_h *g, 
const char *device, 
...);

You may supply
a list of optional arguments to this call. Use zero or more
of the following pairs of parameters, and terminate the list
with -1 on its own. See "CALLS WITH OPTIONAL
ARGUMENTS".

GUESTFS_BTRFS_FSCK_SUPERBLOCK,
int64_t superblock, 
GUESTFS_BTRFS_FSCK_REPAIR, int repair,

Used to check a
btrfs filesystem, "device" is the device file
where the filesystem is stored.

This function
returns 0 on success or -1 on error.

This function
depends on the feature "btrfs". See also
"guestfs_feature_available".

(Added in
1.17.43)

guestfs_btrfs_fsck_va

int 
guestfs_btrfs_fsck_va (guestfs_h *g, 
const char *device, 
va_list args);

This is the
"va_list variant" of
"guestfs_btrfs_fsck".

See "CALLS
WITH OPTIONAL ARGUMENTS".

guestfs_btrfs_fsck_argv

int 
guestfs_btrfs_fsck_argv (guestfs_h *g, 
const char *device, 
const struct guestfs_btrfs_fsck_argv *optargs);

This is the
"argv variant" of
"guestfs_btrfs_fsck".

See "CALLS
WITH OPTIONAL ARGUMENTS".

guestfs_btrfs_image

int 
guestfs_btrfs_image (guestfs_h *g, 
char *const *source, 
const char *image, 
...);

You may supply
a list of optional arguments to this call. Use zero or more
of the following pairs of parameters, and terminate the list
with -1 on its own. See "CALLS WITH OPTIONAL
ARGUMENTS".

GUESTFS_BTRFS_IMAGE_COMPRESSLEVEL,
int compresslevel,

This is used to
create an image of a btrfs filesystem. All data will be
zeroed, but metadata and the like is preserved.

This function
returns 0 on success or -1 on error.

This function
depends on the feature "btrfs". See also
"guestfs_feature_available".

(Added in
1.29.32)

guestfs_btrfs_image_va

int 
guestfs_btrfs_image_va (guestfs_h *g, 
char *const *source, 
const char *image, 
va_list args);

This is the
"va_list variant" of
"guestfs_btrfs_image".

See "CALLS
WITH OPTIONAL ARGUMENTS".

guestfs_btrfs_image_argv

int 
guestfs_btrfs_image_argv (guestfs_h *g, 
char *const *source, 
const char *image, 
const struct guestfs_btrfs_image_argv *optargs);

This is the
"argv variant" of
"guestfs_btrfs_image".

See "CALLS
WITH OPTIONAL ARGUMENTS".

guestfs_btrfs_qgroup_assign

int 
guestfs_btrfs_qgroup_assign (guestfs_h *g, 
const char *src, 
const char *dst, 
const char *path);

Add qgroup
"src" to parent qgroup "dst". This
command can group several qgroups into a parent qgroup to
share common limit.

This function
returns 0 on success or -1 on error.

This function
depends on the feature "btrfs". See also
"guestfs_feature_available".

(Added in
1.29.17)

guestfs_btrfs_qgroup_create

int 
guestfs_btrfs_qgroup_create (guestfs_h *g, 
const char *qgroupid, 
const char *subvolume);

Create a quota
group (qgroup) for subvolume at "subvolume".

This function
returns 0 on success or -1 on error.

This function
depends on the feature "btrfs". See also
"guestfs_feature_available".

(Added in
1.29.17)

guestfs_btrfs_qgroup_destroy

int 
guestfs_btrfs_qgroup_destroy (guestfs_h *g, 
const char *qgroupid, 
const char *subvolume);

Destroy a quota
group.

This function
returns 0 on success or -1 on error.

This function
depends on the feature "btrfs". See also
"guestfs_feature_available".

(Added in
1.29.17)

guestfs_btrfs_qgroup_limit

int 
guestfs_btrfs_qgroup_limit (guestfs_h *g, 
const char *subvolume, 
int64_t size);

Limit the size
of the subvolume with path "subvolume".

This function
returns 0 on success or -1 on error.

This function
depends on the feature "btrfs". See also
"guestfs_feature_available".

(Added in
1.29.17)

guestfs_btrfs_qgroup_remove

int 
guestfs_btrfs_qgroup_remove (guestfs_h *g, 
const char *src, 
const char *dst, 
const char *path);

Remove qgroup
"src" from the parent qgroup "dst".

This function
returns 0 on success or -1 on error.

This function
depends on the feature "btrfs". See also
"guestfs_feature_available".

(Added in
1.29.17)

guestfs_btrfs_qgroup_show

struct guestfs_btrfsqgroup_list * 
guestfs_btrfs_qgroup_show (guestfs_h *g, 
const char *path);

Show all
subvolume quota groups in a btrfs filesystem, including
their usages.

This function
returns a "struct guestfs_btrfsqgroup_list *", or
NULL if there was an error. The caller must call
"guestfs_free_btrfsqgroup_list" after use.

This function
depends on the feature "btrfs". See also
"guestfs_feature_available".

(Added in
1.29.17)

guestfs_btrfs_quota_enable

int 
guestfs_btrfs_quota_enable (guestfs_h *g, 
const char *fs, 
int enable);

Enable or
disable subvolume quota support for filesystem which
contains "path".

This function
returns 0 on success or -1 on error.

This function
depends on the feature "btrfs". See also
"guestfs_feature_available".

(Added in
1.29.17)

guestfs_btrfs_quota_rescan

int 
guestfs_btrfs_quota_rescan (guestfs_h *g, 
const char *fs);

Trash all
qgroup numbers and scan the metadata again with the current
config.

This function
returns 0 on success or -1 on error.

This function
depends on the feature "btrfs". See also
"guestfs_feature_available".

(Added in
1.29.17)

guestfs_btrfs_replace

int 
guestfs_btrfs_replace (guestfs_h *g, 
const char *srcdev, 
const char *targetdev, 
const char *mntpoint);

Replace device
of a btrfs filesystem. On a live filesystem, duplicate the
data to the target device which is currently stored on the
source device. After completion of the operation, the source
device is wiped out and removed from the filesystem.

The
"targetdev" needs to be same size or larger than
the "srcdev". Devices which are currently mounted
are never allowed to be used as the
"targetdev".

This function
returns 0 on success or -1 on error.

This function
depends on the feature "btrfs". See also
"guestfs_feature_available".

(Added in
1.29.48)

guestfs_btrfs_rescue_chunk_recover

int 
guestfs_btrfs_rescue_chunk_recover (guestfs_h *g, 
const char *device);

Recover the
chunk tree of btrfs filesystem by scanning the devices one
by one.

This function
returns 0 on success or -1 on error.

This function
depends on the feature "btrfs". See also
"guestfs_feature_available".

(Added in
1.29.22)

guestfs_btrfs_rescue_super_recover

int 
guestfs_btrfs_rescue_super_recover (guestfs_h *g, 
const char *device);

Recover bad
superblocks from good copies.

This function
returns 0 on success or -1 on error.

This function
depends on the feature "btrfs". See also
"guestfs_feature_available".

(Added in
1.29.22)

guestfs_btrfs_scrub_cancel

int 
guestfs_btrfs_scrub_cancel (guestfs_h *g, 
const char *path);

Cancel a
running scrub on a btrfs filesystem.

This function
returns 0 on success or -1 on error.

This function
depends on the feature "btrfs". See also
"guestfs_feature_available".

(Added in
1.29.22)

guestfs_btrfs_scrub_resume

int 
guestfs_btrfs_scrub_resume (guestfs_h *g, 
const char *path);

Resume a
previously canceled or interrupted scrub on a btrfs
filesystem.

This function
returns 0 on success or -1 on error.

This function
depends on the feature "btrfs". See also
"guestfs_feature_available".

(Added in
1.29.22)

guestfs_btrfs_scrub_start

int 
guestfs_btrfs_scrub_start (guestfs_h *g, 
const char *path);

Reads all the
data and metadata on the filesystem, and uses checksums and
the duplicate copies from RAID storage to identify and
repair any corrupt data.

This function
returns 0 on success or -1 on error.

This function
depends on the feature "btrfs". See also
"guestfs_feature_available".

(Added in
1.29.22)

guestfs_btrfs_scrub_status

struct guestfs_btrfsscrub * 
guestfs_btrfs_scrub_status (guestfs_h *g, 
const char *path);

Show status of
running or finished scrub on a btrfs filesystem.

This function
returns a "struct guestfs_btrfsscrub *", or NULL
if there was an error. The caller must call
"guestfs_free_btrfsscrub" after use.

This function
depends on the feature "btrfs". See also
"guestfs_feature_available".

(Added in
1.29.26)

guestfs_btrfs_set_seeding

int 
guestfs_btrfs_set_seeding (guestfs_h *g, 
const char *device, 
int seeding);

Enable or
disable the seeding feature of a device that contains a
btrfs filesystem.

This function
returns 0 on success or -1 on error.

This function
depends on the feature "btrfs". See also
"guestfs_feature_available".

(Added in
1.17.43)

guestfs_btrfs_subvolume_create

int 
guestfs_btrfs_subvolume_create (guestfs_h *g, 
const char *dest);

This function
is provided for backwards compatibility with earlier
versions of libguestfs. It simply calls
"guestfs_btrfs_subvolume_create_opts" with no
optional arguments.

(Added in
1.17.35)

guestfs_btrfs_subvolume_create_opts

int 
guestfs_btrfs_subvolume_create_opts (guestfs_h *g, 
const char *dest, 
...);

You may supply
a list of optional arguments to this call. Use zero or more
of the following pairs of parameters, and terminate the list
with -1 on its own. See "CALLS WITH OPTIONAL
ARGUMENTS".

GUESTFS_BTRFS_SUBVOLUME_CREATE_OPTS_QGROUPID,
const char *qgroupid,

Create a btrfs
subvolume. The "dest" argument is the destination
directory and the name of the subvolume, in the form
/path/to/dest/name. The optional parameter
"qgroupid" represents the qgroup which the newly
created subvolume will be added to.

This function
returns 0 on success or -1 on error.

This function
depends on the feature "btrfs". See also
"guestfs_feature_available".

(Added in
1.17.35)

guestfs_btrfs_subvolume_create_opts_va

int 
guestfs_btrfs_subvolume_create_opts_va (guestfs_h *g, 
const char *dest, 
va_list args);

This is the
"va_list variant" of
"guestfs_btrfs_subvolume_create_opts".

See "CALLS
WITH OPTIONAL ARGUMENTS".

guestfs_btrfs_subvolume_create_opts_argv

int 
guestfs_btrfs_subvolume_create_opts_argv (guestfs_h *g, 
const char *dest, 
const struct guestfs_btrfs_subvolume_create_opts_argv
*optargs);

This is the
"argv variant" of
"guestfs_btrfs_subvolume_create_opts".

See "CALLS
WITH OPTIONAL ARGUMENTS".

guestfs_btrfs_subvolume_delete

int 
guestfs_btrfs_subvolume_delete (guestfs_h *g, 
const char *subvolume);

Delete the
named btrfs subvolume or snapshot.

This function
returns 0 on success or -1 on error.

This function
depends on the feature "btrfs". See also
"guestfs_feature_available".

(Added in
1.17.35)

guestfs_btrfs_subvolume_get_default

int64_t 
guestfs_btrfs_subvolume_get_default (guestfs_h *g, 
const char *fs);

Get the default
subvolume or snapshot of a filesystem mounted at
"mountpoint".

On error this
function returns -1.

This function
depends on the feature "btrfs". See also
"guestfs_feature_available".

(Added in
1.29.17)

guestfs_btrfs_subvolume_list

struct guestfs_btrfssubvolume_list * 
guestfs_btrfs_subvolume_list (guestfs_h *g, 
const char *fs);

List the btrfs
snapshots and subvolumes of the btrfs filesystem which is
mounted at "fs".

This function
returns a "struct guestfs_btrfssubvolume_list *",
or NULL if there was an error. The caller must call
"guestfs_free_btrfssubvolume_list" after
use.

This function
depends on the feature "btrfs". See also
"guestfs_feature_available".

(Added in
1.17.35)

guestfs_btrfs_subvolume_set_default

int 
guestfs_btrfs_subvolume_set_default (guestfs_h *g, 
int64_t id, 
const char *fs);

Set the
subvolume of the btrfs filesystem "fs" which will
be mounted by default. See
"guestfs_btrfs_subvolume_list" to get a list of
subvolumes.

This function
returns 0 on success or -1 on error.

This function
depends on the feature "btrfs". See also
"guestfs_feature_available".

(Added in
1.17.35)

guestfs_btrfs_subvolume_show

char ** 
guestfs_btrfs_subvolume_show (guestfs_h *g, 
const char *subvolume);

Return detailed
information of the subvolume.

This function
returns a NULL-terminated array of strings, or NULL if there
was an error. The array of strings will always have length
"2n+1", where "n" keys and values
alternate, followed by the trailing NULL entry. The
caller must free the strings and the array after
use.

This function
depends on the feature "btrfs". See also
"guestfs_feature_available".

(Added in
1.29.17)

guestfs_btrfs_subvolume_snapshot

int 
guestfs_btrfs_subvolume_snapshot (guestfs_h *g, 
const char *source, 
const char *dest);

This function
is provided for backwards compatibility with earlier
versions of libguestfs. It simply calls
"guestfs_btrfs_subvolume_snapshot_opts" with no
optional arguments.

(Added in
1.17.35)

guestfs_btrfs_subvolume_snapshot_opts

int 
guestfs_btrfs_subvolume_snapshot_opts (guestfs_h *g, 
const char *source, 
const char *dest, 
...);

You may supply
a list of optional arguments to this call. Use zero or more
of the following pairs of parameters, and terminate the list
with -1 on its own. See "CALLS WITH OPTIONAL
ARGUMENTS".

GUESTFS_BTRFS_SUBVOLUME_SNAPSHOT_OPTS_RO,
int ro, 
GUESTFS_BTRFS_SUBVOLUME_SNAPSHOT_OPTS_QGROUPID, const char
*qgroupid,

Create a
snapshot of the btrfs subvolume "source". The
"dest" argument is the destination directory and
the name of the snapshot, in the form
/path/to/dest/name. By default the newly created
snapshot is writable, if the value of optional parameter
"ro" is true, then a readonly snapshot is created.
The optional parameter "qgroupid" represents the
qgroup which the newly created snapshot will be added
to.

This function
returns 0 on success or -1 on error.

This function
depends on the feature "btrfs". See also
"guestfs_feature_available".

(Added in
1.17.35)

guestfs_btrfs_subvolume_snapshot_opts_va

int 
guestfs_btrfs_subvolume_snapshot_opts_va (guestfs_h *g, 
const char *source, 
const char *dest, 
va_list args);

This is the
"va_list variant" of
"guestfs_btrfs_subvolume_snapshot_opts".

See "CALLS
WITH OPTIONAL ARGUMENTS".

guestfs_btrfs_subvolume_snapshot_opts_argv

int 
guestfs_btrfs_subvolume_snapshot_opts_argv (guestfs_h *g,

const char *source, 
const char *dest, 
const struct guestfs_btrfs_subvolume_snapshot_opts_argv
*optargs);

This is the
"argv variant" of
"guestfs_btrfs_subvolume_snapshot_opts".

See "CALLS
WITH OPTIONAL ARGUMENTS".

guestfs_btrfstune_enable_extended_inode_refs

int 
guestfs_btrfstune_enable_extended_inode_refs (guestfs_h *g,

const char *device);

This will
Enable extended inode refs.

This function
returns 0 on success or -1 on error.

This function
depends on the feature "btrfs". See also
"guestfs_feature_available".

(Added in
1.29.29)

guestfs_btrfstune_enable_skinny_metadata_extent_refs

int 
guestfs_btrfstune_enable_skinny_metadata_extent_refs
(guestfs_h *g, 
const char *device);

This enable
skinny metadata extent refs.

This function
returns 0 on success or -1 on error.

This function
depends on the feature "btrfs". See also
"guestfs_feature_available".

(Added in
1.29.29)

guestfs_btrfstune_seeding

int 
guestfs_btrfstune_seeding (guestfs_h *g, 
const char *device, 
int seeding);

Enable seeding
of a btrfs device, this will force a fs readonly so that you
can use it to build other filesystems.

This function
returns 0 on success or -1 on error.

This function
depends on the feature "btrfs". See also
"guestfs_feature_available".

(Added in
1.29.29)

guestfs_c_pointer

int64_t 
guestfs_c_pointer (guestfs_h *g);

In non-C
language bindings, this allows you to retrieve the
underlying C pointer to the handle (ie. "guestfs_h
*"). The purpose of this is to allow other libraries to
interwork with libguestfs.

On error this
function returns -1.

(Added in
1.29.17)

guestfs_canonical_device_name

char * 
guestfs_canonical_device_name (guestfs_h *g, 
const char *device);

This utility
function is useful when displaying device names to the user.
It takes a number of irregular device names and returns them
in a consistent format: 
/dev/hdX 
/dev/vdX

These are returned as
/dev/sdX. Note this works for device names and
partition names. This is approximately the reverse of the
algorithm described in "BLOCK DEVICE NAMING".

/dev/mapper/VG-LV 
/dev/dm-N

Converted to /dev/VG/LV
form using "guestfs_lvm_canonical_lv_name".

Other strings
are returned unmodified.

This function
returns a string, or NULL on error. The caller must free
the returned string after use.

(Added in
1.19.7)

guestfs_cap_get_file

char * 
guestfs_cap_get_file (guestfs_h *g, 
const char *path);

This function
returns the Linux capabilities attached to "path".
The capabilities set is returned in text form (see
cap_to_text(3)).

If no
capabilities are attached to a file, an empty string is
returned.

This function
returns a string, or NULL on error. The caller must free
the returned string after use.

This function
depends on the feature "linuxcaps". See also
"guestfs_feature_available".

(Added in
1.19.63)

guestfs_cap_set_file

int 
guestfs_cap_set_file (guestfs_h *g, 
const char *path, 
const char *cap);

This function
sets the Linux capabilities attached to "path".
The capabilities set "cap" should be passed in
text form (see cap_from_text(3)).

This function
returns 0 on success or -1 on error.

This function
depends on the feature "linuxcaps". See also
"guestfs_feature_available".

(Added in
1.19.63)

guestfs_case_sensitive_path

char * 
guestfs_case_sensitive_path (guestfs_h *g, 
const char *path);

This can be
used to resolve case insensitive paths on a filesystem which
is case sensitive. The use case is to resolve paths which
you have read from Windows configuration files or the
Windows Registry, to the true path.

The command
handles a peculiarity of the Linux ntfs-3g filesystem driver
(and probably others), which is that although the underlying
filesystem is case-insensitive, the driver exports the
filesystem to Linux as case-sensitive.

One consequence
of this is that special directories such as
C:\windows may appear as /WINDOWS or
/windows (or other things) depending on the precise
details of how they were created. In Windows itself this
would not be a problem.

Bug or feature?
You decide:
https://www.tuxera.com/community/ntfs-3g-faq/#posixfilenames1

"guestfs_case_sensitive_path"
attempts to resolve the true case of each element in the
path. It will return a resolved path if either the full path
or its parent directory exists. If the parent directory
exists but the full path does not, the case of the parent
directory will be correctly resolved, and the remainder
appended unmodified. For example, if the file
"/Windows/System32/netkvm.sys" exists: 
"guestfs_case_sensitive_path"
("/windows/system32/netkvm.sys")

"Windows/System32/netkvm.sys"

"guestfs_case_sensitive_path"
("/windows/system32/NoSuchFile")

"Windows/System32/NoSuchFile"

"guestfs_case_sensitive_path"
("/windows/system33/netkvm.sys")

ERROR

Note:
Because of the above behaviour,
"guestfs_case_sensitive_path" cannot be used to
check for the existence of a file.

Note:
This function does not handle drive names, backslashes
etc.

See also
"guestfs_realpath".

This function
returns a string, or NULL on error. The caller must free
the returned string after use.

(Added in
1.0.75)

guestfs_cat

char * 
guestfs_cat (guestfs_h *g, 
const char *path);

Return the
contents of the file named "path".

Because, in C,
this function returns a "char *", there is no way
to differentiate between a "\0" character in a
file and end of string. To handle binary files, use the
"guestfs_read_file" or
"guestfs_download" functions.

This function
returns a string, or NULL on error. The caller must free
the returned string after use.

(Added in
0.4)

guestfs_checksum

char * 
guestfs_checksum (guestfs_h *g, 
const char *csumtype, 
const char *path);

This call
computes the MD5, SHAx or CRC checksum of the file named
"path".

The type of
checksum to compute is given by the "csumtype"
parameter which must have one of the following values: 
"crc"

Compute the cyclic redundancy
check (CRC) specified by POSIX for the "cksum"
command.

"md5"

Compute the MD5 hash (using the
md5sum(1) program).

"sha1"

Compute the SHA1 hash (using
the sha1sum(1) program).

"sha224"

Compute the SHA224 hash (using
the sha224sum(1) program).

"sha256"

Compute the SHA256 hash (using
the sha256sum(1) program).

"sha384"

Compute the SHA384 hash (using
the sha384sum(1) program).

"sha512"

Compute the SHA512 hash (using
the sha512sum(1) program).

The checksum is
returned as a printable string.

To get the
checksum for a device, use
"guestfs_checksum_device".

To get the
checksums for many files, use
"guestfs_checksums_out".

This function
returns a string, or NULL on error. The caller must free
the returned string after use.

(Added in
1.0.2)

guestfs_checksum_device

char * 
guestfs_checksum_device (guestfs_h *g, 
const char *csumtype, 
const char *device);

This call
computes the MD5, SHAx or CRC checksum of the contents of
the device named "device". For the types of
checksums supported see the "guestfs_checksum"
command.

This function
returns a string, or NULL on error. The caller must free
the returned string after use.

(Added in
1.3.2)

guestfs_checksums_out

int 
guestfs_checksums_out (guestfs_h *g, 
const char *csumtype, 
const char *directory, 
const char *sumsfile);

This command
computes the checksums of all regular files in
directory and then emits a list of those checksums to
the local output file "sumsfile".

This can be
used for verifying the integrity of a virtual machine.
However to be properly secure you should pay attention to
the output of the checksum command (it uses the ones from
GNU coreutils). In particular when the filename is not
printable, coreutils uses a special backslash syntax. For
more information, see the GNU coreutils info file.

This function
returns 0 on success or -1 on error.

(Added in
1.3.7)

guestfs_chmod

int 
guestfs_chmod (guestfs_h *g, 
int mode, 
const char *path);

Change the mode
(permissions) of "path" to "mode". Only
numeric modes are supported.

Note:
When using this command from guestfish, "mode" by
default would be decimal, unless you prefix it with 0 to get
octal, ie. use 0700 not 700.

The mode
actually set is affected by the umask.

This function
returns 0 on success or -1 on error.

(Added in
0.8)

guestfs_chown

int 
guestfs_chown (guestfs_h *g, 
int owner, 
int group, 
const char *path);

Change the file
owner to "owner" and group to
"group".

Only numeric
uid and gid are supported. If you want to use names, you
will need to locate and parse the password file yourself
(Augeas support makes this relatively easy).

This function
returns 0 on success or -1 on error.

(Added in
0.8)

guestfs_clear_backend_setting

int 
guestfs_clear_backend_setting (guestfs_h *g, 
const char *name);

If there is a
backend setting string matching "name" or
beginning with "name=", then that string is
removed from the backend settings.

This call
returns the number of strings which were removed (which may
be 0, 1 or greater than 1).

See
"BACKEND", "BACKEND SETTINGS".

On error this
function returns -1.

(Added in
1.27.2)

guestfs_clevis_luks_unlock

int 
guestfs_clevis_luks_unlock (guestfs_h *g, 
const char *device, 
const char *mapname);

This command
opens a block device that has been encrypted according to
the Linux Unified Key Setup (LUKS) standard, using
network-bound disk encryption (NBDE).

"device"
is the encrypted block device.

The appliance
will connect to the Tang servers noted in the tree of Clevis
pins that is bound to a keyslot of the LUKS header. The
Clevis pin tree may comprise "sss" (redudancy)
pins as internal nodes (optionally), and "tang"
pins as leaves. "tpm2" pins are not supported. The
appliance unlocks the encrypted block device by combining
responses from the Tang servers with metadata from the LUKS
header; there is no "key" parameter.

This command
will fail if networking has not been enabled for the
appliance. Refer to "guestfs_set_network".

The command
creates a new block device called
/dev/mapper/mapname. Reads and writes to this block
device are decrypted from and encrypted to the underlying
"device" respectively. Close the decrypted block
device with "guestfs_cryptsetup_close".

"mapname"
cannot be "control" because that name is reserved
by device-mapper.

If this block
device contains LVM volume groups, then calling
"guestfs_lvm_scan" with the "activate"
parameter "true" will make them visible.

Use
"guestfs_list_dm_devices" to list all device
mapper devices.

This function
returns 0 on success or -1 on error.

This function
depends on the feature "clevisluks". See also
"guestfs_feature_available".

(Added in
1.49.3)

guestfs_command

char * 
guestfs_command (guestfs_h *g, 
char *const *arguments);

This call runs
a command from the guest filesystem. The filesystem must be
mounted, and must contain a compatible operating system (ie.
something Linux, with the same or compatible processor
architecture).

The single
parameter is an argv-style list of arguments. The first
element is the name of the program to run. Subsequent
elements are parameters. The list must be non-empty (ie.
must contain a program name). Note that the command runs
directly, and is not invoked via the shell (see
"guestfs_sh").

The return
value is anything printed to stdout by the
command.

If the command
returns a non-zero exit status, then this function returns
an error message. The error message string is the content of
stderr from the command.

The $PATH
environment variable will contain at least /usr/bin
and /bin. If you require a program from another
location, you should provide the full path in the first
parameter.

Shared
libraries and data files required by the program must be
available on filesystems which are mounted in the correct
places. It is the caller&rsquo;s responsibility to ensure
all filesystems that are needed are mounted at the right
locations.

This function
returns a string, or NULL on error. The caller must free
the returned string after use.

Because of the
message protocol, there is a transfer limit of somewhere
between 2MB and 4MB. See "PROTOCOL LIMITS".

(Added in
1.9.1)

guestfs_command_lines

char ** 
guestfs_command_lines (guestfs_h *g, 
char *const *arguments);

This is the
same as "guestfs_command", but splits the result
into a list of lines.

See also:
"guestfs_sh_lines"

This function
returns a NULL-terminated array of strings (like
environ(3)), or NULL if there was an error. The
caller must free the strings and the array after
use.

Because of the
message protocol, there is a transfer limit of somewhere
between 2MB and 4MB. See "PROTOCOL LIMITS".

(Added in
1.9.1)

guestfs_compress_device_out

int 
guestfs_compress_device_out (guestfs_h *g, 
const char *ctype, 
const char *device, 
const char *zdevice, 
...);

You may supply
a list of optional arguments to this call. Use zero or more
of the following pairs of parameters, and terminate the list
with -1 on its own. See "CALLS WITH OPTIONAL
ARGUMENTS".

GUESTFS_COMPRESS_DEVICE_OUT_LEVEL,
int level,

This command
compresses "device" and writes it out to the local
file "zdevice".

The
"ctype" and optional "level" parameters
have the same meaning as in
"guestfs_compress_out".

This function
returns 0 on success or -1 on error.

(Added in
1.13.15)

guestfs_compress_device_out_va

int 
guestfs_compress_device_out_va (guestfs_h *g, 
const char *ctype, 
const char *device, 
const char *zdevice, 
va_list args);

This is the
"va_list variant" of
"guestfs_compress_device_out".

See "CALLS
WITH OPTIONAL ARGUMENTS".

guestfs_compress_device_out_argv

int 
guestfs_compress_device_out_argv (guestfs_h *g, 
const char *ctype, 
const char *device, 
const char *zdevice, 
const struct guestfs_compress_device_out_argv *optargs);

This is the
"argv variant" of
"guestfs_compress_device_out".

See "CALLS
WITH OPTIONAL ARGUMENTS".

guestfs_compress_out

int 
guestfs_compress_out (guestfs_h *g, 
const char *ctype, 
const char *file, 
const char *zfile, 
...);

You may supply
a list of optional arguments to this call. Use zero or more
of the following pairs of parameters, and terminate the list
with -1 on its own. See "CALLS WITH OPTIONAL
ARGUMENTS".

GUESTFS_COMPRESS_OUT_LEVEL,
int level,

This command
compresses file and writes it out to the local file
zfile.

The compression
program used is controlled by the "ctype"
parameter. Currently this includes: "compress",
"gzip", "bzip2", "xz" or
"lzop". Some compression types may not be
supported by particular builds of libguestfs, in which case
you will get an error containing the substring "not
supported".

The optional
"level" parameter controls compression level. The
meaning and default for this parameter depends on the
compression program being used.

This function
returns 0 on success or -1 on error.

(Added in
1.13.15)

guestfs_compress_out_va

int 
guestfs_compress_out_va (guestfs_h *g, 
const char *ctype, 
const char *file, 
const char *zfile, 
va_list args);

This is the
"va_list variant" of
"guestfs_compress_out".

See "CALLS
WITH OPTIONAL ARGUMENTS".

guestfs_compress_out_argv

int 
guestfs_compress_out_argv (guestfs_h *g, 
const char *ctype, 
const char *file, 
const char *zfile, 
const struct guestfs_compress_out_argv *optargs);

This is the
"argv variant" of
"guestfs_compress_out".

See "CALLS
WITH OPTIONAL ARGUMENTS".

guestfs_config

int 
guestfs_config (guestfs_h *g, 
const char *hvparam, 
const char *hvvalue);

This can be
used to add arbitrary hypervisor parameters of the form
-param value. Actually it&rsquo;s not quite arbitrary
- we prevent you from setting some parameters which would
interfere with parameters that we use.

The first
character of "hvparam" string must be a
"-" (dash).

"hvvalue"
can be NULL.

This function
returns 0 on success or -1 on error.

(Added in
0.3)

guestfs_copy_attributes

int 
guestfs_copy_attributes (guestfs_h *g, 
const char *src, 
const char *dest, 
...);

You may supply
a list of optional arguments to this call. Use zero or more
of the following pairs of parameters, and terminate the list
with -1 on its own. See "CALLS WITH OPTIONAL
ARGUMENTS".

GUESTFS_COPY_ATTRIBUTES_ALL,
int all, 
GUESTFS_COPY_ATTRIBUTES_MODE, int mode, 
GUESTFS_COPY_ATTRIBUTES_XATTRIBUTES, int xattributes, 
GUESTFS_COPY_ATTRIBUTES_OWNERSHIP, int ownership,

Copy the
attributes of a path (which can be a file or a directory) to
another path.

By default
no attribute is copied, so make sure to specify any
(or "all" to copy everything).

The optional
arguments specify which attributes can be copied: 
"mode"

Copy part of the file mode from
"source" to "destination". Only the UNIX
permissions and the sticky/setuid/setgid bits can be
copied.

"xattributes"

Copy the Linux extended
attributes (xattrs) from "source" to
"destination". This flag does nothing if the
linuxxattrs feature is not available (see
"guestfs_feature_available").

"ownership"

Copy the owner uid and the
group gid of "source" to
"destination".

"all"

Copy all the attributes
from "source" to "destination". Enabling
it enables all the other flags, if they are not specified
already.

This function
returns 0 on success or -1 on error.

(Added in
1.25.21)

guestfs_copy_attributes_va

int 
guestfs_copy_attributes_va (guestfs_h *g, 
const char *src, 
const char *dest, 
va_list args);

This is the
"va_list variant" of
"guestfs_copy_attributes".

See "CALLS
WITH OPTIONAL ARGUMENTS".

guestfs_copy_attributes_argv

int 
guestfs_copy_attributes_argv (guestfs_h *g, 
const char *src, 
const char *dest, 
const struct guestfs_copy_attributes_argv *optargs);

This is the
"argv variant" of
"guestfs_copy_attributes".

See "CALLS
WITH OPTIONAL ARGUMENTS".

guestfs_copy_device_to_device

int 
guestfs_copy_device_to_device (guestfs_h *g, 
const char *src, 
const char *dest, 
...);

You may supply
a list of optional arguments to this call. Use zero or more
of the following pairs of parameters, and terminate the list
with -1 on its own. See "CALLS WITH OPTIONAL
ARGUMENTS".

GUESTFS_COPY_DEVICE_TO_DEVICE_SRCOFFSET,
int64_t srcoffset, 
GUESTFS_COPY_DEVICE_TO_DEVICE_DESTOFFSET, int64_t
destoffset, 
GUESTFS_COPY_DEVICE_TO_DEVICE_SIZE, int64_t size, 
GUESTFS_COPY_DEVICE_TO_DEVICE_SPARSE, int sparse, 
GUESTFS_COPY_DEVICE_TO_DEVICE_APPEND, int append,

The four calls
"guestfs_copy_device_to_device",
"guestfs_copy_device_to_file",
"guestfs_copy_file_to_device", and
"guestfs_copy_file_to_file" let you copy from a
source (device|file) to a destination (device|file).

Partial copies
can be made since you can specify optionally the source
offset, destination offset and size to copy. These values
are all specified in bytes. If not given, the offsets both
default to zero, and the size defaults to copying as much as
possible until we hit the end of the source.

The source and
destination may be the same object. However overlapping
regions may not be copied correctly.

If the
destination is a file, it is created if required. If the
destination file is not large enough, it is extended.

If the
destination is a file and the "append" flag is not
set, then the destination file is truncated. If the
"append" flag is set, then the copy appends to the
destination file. The "append" flag currently
cannot be set for devices.

If the
"sparse" flag is true then the call avoids writing
blocks that contain only zeroes, which can help in some
situations where the backing disk is thin-provisioned. Note
that unless the target is already zeroed, using this option
will result in incorrect copying.

This function
returns 0 on success or -1 on error.

This
long-running command can generate progress notification
messages so that the caller can display a progress bar or
indicator. To receive these messages, the caller must
register a progress event callback. See
"GUESTFS_EVENT_PROGRESS".

(Added in
1.13.25)

guestfs_copy_device_to_device_va

int 
guestfs_copy_device_to_device_va (guestfs_h *g, 
const char *src, 
const char *dest, 
va_list args);

This is the
"va_list variant" of
"guestfs_copy_device_to_device".

See "CALLS
WITH OPTIONAL ARGUMENTS".

guestfs_copy_device_to_device_argv

int 
guestfs_copy_device_to_device_argv (guestfs_h *g, 
const char *src, 
const char *dest, 
const struct guestfs_copy_device_to_device_argv
*optargs);

This is the
"argv variant" of
"guestfs_copy_device_to_device".

See "CALLS
WITH OPTIONAL ARGUMENTS".

guestfs_copy_device_to_file

int 
guestfs_copy_device_to_file (guestfs_h *g, 
const char *src, 
const char *dest, 
...);

You may supply
a list of optional arguments to this call. Use zero or more
of the following pairs of parameters, and terminate the list
with -1 on its own. See "CALLS WITH OPTIONAL
ARGUMENTS".

GUESTFS_COPY_DEVICE_TO_FILE_SRCOFFSET,
int64_t srcoffset, 
GUESTFS_COPY_DEVICE_TO_FILE_DESTOFFSET, int64_t destoffset,

GUESTFS_COPY_DEVICE_TO_FILE_SIZE, int64_t size, 
GUESTFS_COPY_DEVICE_TO_FILE_SPARSE, int sparse, 
GUESTFS_COPY_DEVICE_TO_FILE_APPEND, int append,

See
"guestfs_copy_device_to_device" for a general
overview of this call.

This function
returns 0 on success or -1 on error.

This
long-running command can generate progress notification
messages so that the caller can display a progress bar or
indicator. To receive these messages, the caller must
register a progress event callback. See
"GUESTFS_EVENT_PROGRESS".

(Added in
1.13.25)

guestfs_copy_device_to_file_va

int 
guestfs_copy_device_to_file_va (guestfs_h *g, 
const char *src, 
const char *dest, 
va_list args);

This is the
"va_list variant" of
"guestfs_copy_device_to_file".

See "CALLS
WITH OPTIONAL ARGUMENTS".

guestfs_copy_device_to_file_argv

int 
guestfs_copy_device_to_file_argv (guestfs_h *g, 
const char *src, 
const char *dest, 
const struct guestfs_copy_device_to_file_argv *optargs);

This is the
"argv variant" of
"guestfs_copy_device_to_file".

See "CALLS
WITH OPTIONAL ARGUMENTS".

guestfs_copy_file_to_device

int 
guestfs_copy_file_to_device (guestfs_h *g, 
const char *src, 
const char *dest, 
...);

You may supply
a list of optional arguments to this call. Use zero or more
of the following pairs of parameters, and terminate the list
with -1 on its own. See "CALLS WITH OPTIONAL
ARGUMENTS".

GUESTFS_COPY_FILE_TO_DEVICE_SRCOFFSET,
int64_t srcoffset, 
GUESTFS_COPY_FILE_TO_DEVICE_DESTOFFSET, int64_t destoffset,

GUESTFS_COPY_FILE_TO_DEVICE_SIZE, int64_t size, 
GUESTFS_COPY_FILE_TO_DEVICE_SPARSE, int sparse, 
GUESTFS_COPY_FILE_TO_DEVICE_APPEND, int append,

See
"guestfs_copy_device_to_device" for a general
overview of this call.

This function
returns 0 on success or -1 on error.

This
long-running command can generate progress notification
messages so that the caller can display a progress bar or
indicator. To receive these messages, the caller must
register a progress event callback. See
"GUESTFS_EVENT_PROGRESS".

(Added in
1.13.25)

guestfs_copy_file_to_device_va

int 
guestfs_copy_file_to_device_va (guestfs_h *g, 
const char *src, 
const char *dest, 
va_list args);

This is the
"va_list variant" of
"guestfs_copy_file_to_device".

See "CALLS
WITH OPTIONAL ARGUMENTS".

guestfs_copy_file_to_device_argv

int 
guestfs_copy_file_to_device_argv (guestfs_h *g, 
const char *src, 
const char *dest, 
const struct guestfs_copy_file_to_device_argv *optargs);

This is the
"argv variant" of
"guestfs_copy_file_to_device".

See "CALLS
WITH OPTIONAL ARGUMENTS".

guestfs_copy_file_to_file

int 
guestfs_copy_file_to_file (guestfs_h *g, 
const char *src, 
const char *dest, 
...);

You may supply
a list of optional arguments to this call. Use zero or more
of the following pairs of parameters, and terminate the list
with -1 on its own. See "CALLS WITH OPTIONAL
ARGUMENTS".

GUESTFS_COPY_FILE_TO_FILE_SRCOFFSET,
int64_t srcoffset, 
GUESTFS_COPY_FILE_TO_FILE_DESTOFFSET, int64_t destoffset,

GUESTFS_COPY_FILE_TO_FILE_SIZE, int64_t size, 
GUESTFS_COPY_FILE_TO_FILE_SPARSE, int sparse, 
GUESTFS_COPY_FILE_TO_FILE_APPEND, int append,

See
"guestfs_copy_device_to_device" for a general
overview of this call.

This is
not the function you want for copying files. This is
for copying blocks within existing files. See
"guestfs_cp", "guestfs_cp_a" and
"guestfs_mv" for general file copying and moving
functions.

This function
returns 0 on success or -1 on error.

This
long-running command can generate progress notification
messages so that the caller can display a progress bar or
indicator. To receive these messages, the caller must
register a progress event callback. See
"GUESTFS_EVENT_PROGRESS".

(Added in
1.13.25)

guestfs_copy_file_to_file_va

int 
guestfs_copy_file_to_file_va (guestfs_h *g, 
const char *src, 
const char *dest, 
va_list args);

This is the
"va_list variant" of
"guestfs_copy_file_to_file".

See "CALLS
WITH OPTIONAL ARGUMENTS".

guestfs_copy_file_to_file_argv

int 
guestfs_copy_file_to_file_argv (guestfs_h *g, 
const char *src, 
const char *dest, 
const struct guestfs_copy_file_to_file_argv *optargs);

This is the
"argv variant" of
"guestfs_copy_file_to_file".

See "CALLS
WITH OPTIONAL ARGUMENTS".

guestfs_copy_in

int 
guestfs_copy_in (guestfs_h *g, 
const char *localpath, 
const char *remotedir);

"guestfs_copy_in"
copies local files or directories recursively into the disk
image, placing them in the directory called
"remotedir" (which must exist).

Wildcards
cannot be used.

This function
returns 0 on success or -1 on error.

(Added in
1.29.24)

guestfs_copy_out

int 
guestfs_copy_out (guestfs_h *g, 
const char *remotepath, 
const char *localdir);

"guestfs_copy_out"
copies remote files or directories recursively out of the
disk image, placing them on the host disk in a local
directory called "localdir" (which must
exist).

To download to
the current directory, use "." as in:

C
/home .

Wildcards
cannot be used.

This function
returns 0 on success or -1 on error.

(Added in
1.29.24)

guestfs_copy_size

int 
guestfs_copy_size (guestfs_h *g, 
const char *src, 
const char *dest, 
int64_t size);

This
function is deprecated. In new code, use the
"guestfs_copy_device_to_device" call instead.

Deprecated
functions will not be removed from the API, but the fact
that they are deprecated indicates that there are problems
with correct use of these functions.

This command
copies exactly "size" bytes from one source device
or file "src" to another destination device or
file "dest".

Note this will
fail if the source is too short or if the destination is not
large enough.

This function
returns 0 on success or -1 on error.

This
long-running command can generate progress notification
messages so that the caller can display a progress bar or
indicator. To receive these messages, the caller must
register a progress event callback. See
"GUESTFS_EVENT_PROGRESS".

(Added in
1.0.87)

guestfs_cp

int 
guestfs_cp (guestfs_h *g, 
const char *src, 
const char *dest);

This copies a
file from "src" to "dest" where
"dest" is either a destination filename or
destination directory.

This function
returns 0 on success or -1 on error.

(Added in
1.0.18)

guestfs_cp_a

int 
guestfs_cp_a (guestfs_h *g, 
const char *src, 
const char *dest);

This copies a
file or directory from "src" to "dest"
recursively using the "cp -a" command.

This function
returns 0 on success or -1 on error.

(Added in
1.0.18)

guestfs_cp_r

int 
guestfs_cp_r (guestfs_h *g, 
const char *src, 
const char *dest);

This copies a
file or directory from "src" to "dest"
recursively using the "cp -rP" command.

Most users
should use "guestfs_cp_a" instead. This command is
useful when you don&rsquo;t want to preserve permissions,
because the target filesystem does not support it (primarily
when writing to DOS FAT filesystems).

This function
returns 0 on success or -1 on error.

(Added in
1.21.38)

guestfs_cpio_out

int 
guestfs_cpio_out (guestfs_h *g, 
const char *directory, 
const char *cpiofile, 
...);

You may supply
a list of optional arguments to this call. Use zero or more
of the following pairs of parameters, and terminate the list
with -1 on its own. See "CALLS WITH OPTIONAL
ARGUMENTS".

GUESTFS_CPIO_OUT_FORMAT,
const char *format,

This command
packs the contents of directory and downloads it to
local file "cpiofile".

The optional
"format" parameter can be used to select the
format. Only the following formats are currently permitted:

"newc"

New (SVR4) portable format.
This format happens to be compatible with the cpio-like
format used by the Linux kernel for initramfs.

This is the
default format.

"crc"

New (SVR4) portable format with
a checksum.

This function
returns 0 on success or -1 on error.

(Added in
1.27.9)

guestfs_cpio_out_va

int 
guestfs_cpio_out_va (guestfs_h *g, 
const char *directory, 
const char *cpiofile, 
va_list args);

This is the
"va_list variant" of
"guestfs_cpio_out".

See "CALLS
WITH OPTIONAL ARGUMENTS".

guestfs_cpio_out_argv

int 
guestfs_cpio_out_argv (guestfs_h *g, 
const char *directory, 
const char *cpiofile, 
const struct guestfs_cpio_out_argv *optargs);

This is the
"argv variant" of
"guestfs_cpio_out".

See "CALLS
WITH OPTIONAL ARGUMENTS".

guestfs_cryptsetup_close

int 
guestfs_cryptsetup_close (guestfs_h *g, 
const char *device);

This closes an
encrypted device that was created earlier by
"guestfs_cryptsetup_open". The "device"
parameter must be the name of the mapping device (ie.
/dev/mapper/mapname) and not the name of the
underlying block device.

This function
returns 0 on success or -1 on error.

This function
depends on the feature "luks". See also
"guestfs_feature_available".

(Added in
1.43.2)

guestfs_cryptsetup_open

int 
guestfs_cryptsetup_open (guestfs_h *g, 
const char *device, 
const char *key, 
const char *mapname, 
...);

You may supply
a list of optional arguments to this call. Use zero or more
of the following pairs of parameters, and terminate the list
with -1 on its own. See "CALLS WITH OPTIONAL
ARGUMENTS".

GUESTFS_CRYPTSETUP_OPEN_READONLY,
int readonly, 
GUESTFS_CRYPTSETUP_OPEN_CRYPTTYPE, const char
*crypttype,

This command
opens a block device which has been encrypted according to
the Linux Unified Key Setup (LUKS) standard, Windows
BitLocker, or some other types.

"device"
is the encrypted block device or partition.

The caller must
supply one of the keys associated with the encrypted block
device, in the "key" parameter.

This creates a
new block device called /dev/mapper/mapname. Reads
and writes to this block device are decrypted from and
encrypted to the underlying "device"
respectively.

"mapname"
cannot be "control" because that name is reserved
by device-mapper.

If the optional
"crypttype" parameter is not present then
libguestfs tries to guess the correct type (for example LUKS
or BitLocker). However you can override this by specifying
one of the following types: 
"luks"

A Linux LUKS device.

"bitlk"

A Windows BitLocker device.

The optional
"readonly" flag, if set to true, creates a
read-only mapping.

If this block
device contains LVM volume groups, then calling
"guestfs_lvm_scan" with the "activate"
parameter "true" will make them visible.

Use
"guestfs_list_dm_devices" to list all device
mapper devices.

This function
returns 0 on success or -1 on error.

This function
takes a key or passphrase parameter which could contain
sensitive material. Read the section "KEYS AND
PASSPHRASES" for more information.

This function
depends on the feature "luks". See also
"guestfs_feature_available".

(Added in
1.43.2)

guestfs_cryptsetup_open_va

int 
guestfs_cryptsetup_open_va (guestfs_h *g, 
const char *device, 
const char *key, 
const char *mapname, 
va_list args);

This is the
"va_list variant" of
"guestfs_cryptsetup_open".

See "CALLS
WITH OPTIONAL ARGUMENTS".

guestfs_cryptsetup_open_argv

int 
guestfs_cryptsetup_open_argv (guestfs_h *g, 
const char *device, 
const char *key, 
const char *mapname, 
const struct guestfs_cryptsetup_open_argv *optargs);

This is the
"argv variant" of
"guestfs_cryptsetup_open".

See "CALLS
WITH OPTIONAL ARGUMENTS".

guestfs_dd

int 
guestfs_dd (guestfs_h *g, 
const char *src, 
const char *dest);

This
function is deprecated. In new code, use the
"guestfs_copy_device_to_device" call instead.

Deprecated
functions will not be removed from the API, but the fact
that they are deprecated indicates that there are problems
with correct use of these functions.

This command
copies from one source device or file "src" to
another destination device or file "dest".
Normally you would use this to copy to or from a device or
partition, for example to duplicate a filesystem.

If the
destination is a device, it must be as large or larger than
the source file or device, otherwise the copy will fail.
This command cannot do partial copies (see
"guestfs_copy_device_to_device").

This function
returns 0 on success or -1 on error.

(Added in
1.0.80)

guestfs_device_index

int 
guestfs_device_index (guestfs_h *g, 
const char *device);

This function
takes a device name (eg. "/dev/sdb") and returns
the index of the device in the list of devices.

Index numbers
start from 0. The named device must exist, for example as a
string returned from "guestfs_list_devices".

See also
"guestfs_list_devices",
"guestfs_part_to_dev",
"guestfs_device_name".

On error this
function returns -1.

(Added in
1.19.7)

guestfs_device_name

char * 
guestfs_device_name (guestfs_h *g, 
int index);

This function
takes a device index and returns the device name. For
example index 0 will return the string
"/dev/sda".

The drive index
must have been added to the handle.

See also
"guestfs_list_devices",
"guestfs_part_to_dev",
"guestfs_device_index".

This function
returns a string, or NULL on error. The caller must free
the returned string after use.

(Added in
1.49.1)

guestfs_df

char * 
guestfs_df (guestfs_h *g);

This command
runs the df(1) command to report disk space used.

This command is
mostly useful for interactive sessions. It is not
intended that you try to parse the output string. Use
"guestfs_statvfs" from programs.

This function
returns a string, or NULL on error. The caller must free
the returned string after use.

(Added in
1.0.54)

guestfs_df_h

char * 
guestfs_df_h (guestfs_h *g);

This command
runs the "df -h" command to report disk space used
in human-readable format.

This command is
mostly useful for interactive sessions. It is not
intended that you try to parse the output string. Use
"guestfs_statvfs" from programs.

This function
returns a string, or NULL on error. The caller must free
the returned string after use.

(Added in
1.0.54)

guestfs_disk_create

int 
guestfs_disk_create (guestfs_h *g, 
const char *filename, 
const char *format, 
int64_t size, 
...);

You may supply
a list of optional arguments to this call. Use zero or more
of the following pairs of parameters, and terminate the list
with -1 on its own. See "CALLS WITH OPTIONAL
ARGUMENTS".

GUESTFS_DISK_CREATE_BACKINGFILE,
const char *backingfile, 
GUESTFS_DISK_CREATE_BACKINGFORMAT, const char
*backingformat, 
GUESTFS_DISK_CREATE_PREALLOCATION, const char
*preallocation, 
GUESTFS_DISK_CREATE_COMPAT, const char *compat, 
GUESTFS_DISK_CREATE_CLUSTERSIZE, int clustersize,

Create a blank
disk image called filename (a host file) with format
"format" (usually "raw" or
"qcow2"). The size is "size" bytes.

If used with
the optional "backingfile" parameter, then a
snapshot is created on top of the backing file. In this
case, "size" must be passed as -1. The size of the
snapshot is the same as the size of the backing file, which
is discovered automatically. You are encouraged to also pass
"backingformat" to describe the format of
"backingfile".

If
filename refers to a block device, then the device is
formatted. The "size" is ignored since block
devices have an intrinsic size.

The other
optional parameters are: 
"preallocation"

If format is "raw",
then this can be either "off" (or
"sparse") or "full" to create a sparse
or fully allocated file respectively. The default is
"off".

If format is
"qcow2", then this can be "off" (or
"sparse"), "metadata" or
"full". Preallocating metadata can be faster when
doing lots of writes, but uses more space. The default is
"off".

"compat"

"qcow2" only: Pass
the string 1.1 to use the advanced qcow2 format supported by
qemu &ge; 1.1.

"clustersize"

"qcow2" only: Change
the qcow2 cluster size. The default is 65536 (bytes) and
this setting may be any power of two between 512 and
2097152.

Note that this
call does not add the new disk to the handle. You may need
to call "guestfs_add_drive_opts" separately.

This function
returns 0 on success or -1 on error.

(Added in
1.25.31)

guestfs_disk_create_va

int 
guestfs_disk_create_va (guestfs_h *g, 
const char *filename, 
const char *format, 
int64_t size, 
va_list args);

This is the
"va_list variant" of
"guestfs_disk_create".

See "CALLS
WITH OPTIONAL ARGUMENTS".

guestfs_disk_create_argv

int 
guestfs_disk_create_argv (guestfs_h *g, 
const char *filename, 
const char *format, 
int64_t size, 
const struct guestfs_disk_create_argv *optargs);

This is the
"argv variant" of
"guestfs_disk_create".

See "CALLS
WITH OPTIONAL ARGUMENTS".

guestfs_disk_format

char * 
guestfs_disk_format (guestfs_h *g, 
const char *filename);

Detect and
return the format of the disk image called filename.
filename can also be a host device, etc. If the
format of the image could not be detected, then
"unknown" is returned.

Note that
detecting the disk format can be insecure under some
circumstances. See "CVE-2010-3851".

See also:
"DISK IMAGE FORMATS"

This function
returns a string, or NULL on error. The caller must free
the returned string after use.

(Added in
1.19.38)

guestfs_disk_has_backing_file

int 
guestfs_disk_has_backing_file (guestfs_h *g, 
const char *filename);

Detect and
return whether the disk image filename has a backing
file.

Note that
detecting disk features can be insecure under some
circumstances. See "CVE-2010-3851".

This function
returns a C truth value on success or -1 on error.

(Added in
1.19.39)

guestfs_disk_virtual_size

int64_t 
guestfs_disk_virtual_size (guestfs_h *g, 
const char *filename);

Detect and
return the virtual size in bytes of the disk image called
filename.

Note that
detecting disk features can be insecure under some
circumstances. See "CVE-2010-3851".

On error this
function returns -1.

(Added in
1.19.39)

guestfs_dmesg

char * 
guestfs_dmesg (guestfs_h *g);

This returns
the kernel messages (dmesg(1) output) from the guest
kernel. This is sometimes useful for extended debugging of
problems.

Another way to
get the same information is to enable verbose messages with
"guestfs_set_verbose" or by setting the
environment variable "LIBGUESTFS_DEBUG=1" before
running the program.

This function
returns a string, or NULL on error. The caller must free
the returned string after use.

(Added in
1.0.18)

guestfs_download

int 
guestfs_download (guestfs_h *g, 
const char *remotefilename, 
const char *filename);

Download file
remotefilename and save it as filename on the
local machine.

filename
can also be a named pipe.

See also
"guestfs_upload", "guestfs_cat".

This function
returns 0 on success or -1 on error.

This
long-running command can generate progress notification
messages so that the caller can display a progress bar or
indicator. To receive these messages, the caller must
register a progress event callback. See
"GUESTFS_EVENT_PROGRESS".

(Added in
1.0.2)

guestfs_download_blocks

int 
guestfs_download_blocks (guestfs_h *g, 
const char *device, 
int64_t start, 
int64_t stop, 
const char *filename, 
...);

You may supply
a list of optional arguments to this call. Use zero or more
of the following pairs of parameters, and terminate the list
with -1 on its own. See "CALLS WITH OPTIONAL
ARGUMENTS".

GUESTFS_DOWNLOAD_BLOCKS_UNALLOCATED,
int unallocated,

Download the
data units from start address to stop from the
disk partition (eg. /dev/sda1) and save them as
filename on the local machine.

The use of this
API on sparse disk image formats such as QCOW, may result in
large zero-filled files downloaded on the host.

The size of a
data unit varies across filesystem implementations. On NTFS
filesystems data units are referred as clusters while on
ExtX ones they are referred as fragments.

If the optional
"unallocated" flag is true (default is false),
only the unallocated blocks will be extracted. This is
useful to detect hidden data or to retrieve deleted files
which data units have not been overwritten yet.

This function
returns 0 on success or -1 on error.

This
long-running command can generate progress notification
messages so that the caller can display a progress bar or
indicator. To receive these messages, the caller must
register a progress event callback. See
"GUESTFS_EVENT_PROGRESS".

This function
depends on the feature "sleuthkit". See also
"guestfs_feature_available".

(Added in
1.33.45)

guestfs_download_blocks_va

int 
guestfs_download_blocks_va (guestfs_h *g, 
const char *device, 
int64_t start, 
int64_t stop, 
const char *filename, 
va_list args);

This is the
"va_list variant" of
"guestfs_download_blocks".

See "CALLS
WITH OPTIONAL ARGUMENTS".

guestfs_download_blocks_argv

int 
guestfs_download_blocks_argv (guestfs_h *g, 
const char *device, 
int64_t start, 
int64_t stop, 
const char *filename, 
const struct guestfs_download_blocks_argv *optargs);

This is the
"argv variant" of
"guestfs_download_blocks".

See "CALLS
WITH OPTIONAL ARGUMENTS".

guestfs_download_inode

int 
guestfs_download_inode (guestfs_h *g, 
const char *device, 
int64_t inode, 
const char *filename);

Download a file
given its inode from the disk partition (eg.
/dev/sda1) and save it as filename on the
local machine.

It is not
required to mount the disk to run this command.

The command is
capable of downloading deleted or inaccessible files.

This function
returns 0 on success or -1 on error.

This
long-running command can generate progress notification
messages so that the caller can display a progress bar or
indicator. To receive these messages, the caller must
register a progress event callback. See
"GUESTFS_EVENT_PROGRESS".

This function
depends on the feature "sleuthkit". See also
"guestfs_feature_available".

(Added in
1.33.14)

guestfs_download_offset

int 
guestfs_download_offset (guestfs_h *g, 
const char *remotefilename, 
const char *filename, 
int64_t offset, 
int64_t size);

Download file
remotefilename and save it as filename on the
local machine.

remotefilename
is read for "size" bytes starting at
"offset" (this region must be within the file or
device).

Note that there
is no limit on the amount of data that can be downloaded
with this call, unlike with "guestfs_pread", and
this call always reads the full amount unless an error
occurs.

See also
"guestfs_download", "guestfs_pread".

This function
returns 0 on success or -1 on error.

This
long-running command can generate progress notification
messages so that the caller can display a progress bar or
indicator. To receive these messages, the caller must
register a progress event callback. See
"GUESTFS_EVENT_PROGRESS".

(Added in
1.5.17)

guestfs_drop_caches

int 
guestfs_drop_caches (guestfs_h *g, 
int whattodrop);

This instructs
the guest kernel to drop its page cache, and/or dentries and
inode caches. The parameter "whattodrop" tells the
kernel what precisely to drop, see
https://linux-mm.org/Drop_Caches

Setting
"whattodrop" to 3 should drop everything.

This
automatically calls sync(2) before the operation, so
that the maximum guest memory is freed.

This function
returns 0 on success or -1 on error.

(Added in
1.0.18)

guestfs_du

int64_t 
guestfs_du (guestfs_h *g, 
const char *path);

This command
runs the "du -s" command to estimate file space
usage for "path".

"path"
can be a file or a directory. If "path" is a
directory then the estimate includes the contents of the
directory and all subdirectories (recursively).

The result is
the estimated size in kilobytes (ie. units of 1024
bytes).

On error this
function returns -1.

This
long-running command can generate progress notification
messages so that the caller can display a progress bar or
indicator. To receive these messages, the caller must
register a progress event callback. See
"GUESTFS_EVENT_PROGRESS".

(Added in
1.0.54)

guestfs_e2fsck

int 
guestfs_e2fsck (guestfs_h *g, 
const char *device, 
...);

You may supply
a list of optional arguments to this call. Use zero or more
of the following pairs of parameters, and terminate the list
with -1 on its own. See "CALLS WITH OPTIONAL
ARGUMENTS".

GUESTFS_E2FSCK_CORRECT,
int correct, 
GUESTFS_E2FSCK_FORCEALL, int forceall,

This runs the
ext2/ext3 filesystem checker on "device". It can
take the following optional arguments: 
"correct"

Automatically repair the file
system. This option will cause e2fsck to automatically fix
any filesystem problems that can be safely fixed without
human intervention.

This option may
not be specified at the same time as the
"forceall" option.

"forceall"

Assume an answer of
&rsquo;yes&rsquo; to all questions; allows e2fsck to be used
non-interactively.

This option may
not be specified at the same time as the "correct"
option.

This function
returns 0 on success or -1 on error.

(Added in
1.15.17)

guestfs_e2fsck_va

int 
guestfs_e2fsck_va (guestfs_h *g, 
const char *device, 
va_list args);

This is the
"va_list variant" of
"guestfs_e2fsck".

See "CALLS
WITH OPTIONAL ARGUMENTS".

guestfs_e2fsck_argv

int 
guestfs_e2fsck_argv (guestfs_h *g, 
const char *device, 
const struct guestfs_e2fsck_argv *optargs);

This is the
"argv variant" of "guestfs_e2fsck".

See "CALLS
WITH OPTIONAL ARGUMENTS".

guestfs_e2fsck_f

int 
guestfs_e2fsck_f (guestfs_h *g, 
const char *device);

This
function is deprecated. In new code, use the
"guestfs_e2fsck" call instead.

Deprecated
functions will not be removed from the API, but the fact
that they are deprecated indicates that there are problems
with correct use of these functions.

This runs
"e2fsck -p -f device", ie. runs the ext2/ext3
filesystem checker on "device", noninteractively
(-p), even if the filesystem appears to be clean
(-f).

This function
returns 0 on success or -1 on error.

(Added in
1.0.29)

guestfs_echo_daemon

char * 
guestfs_echo_daemon (guestfs_h *g, 
char *const *words);

This command
concatenates the list of "words" passed with
single spaces between them and returns the resulting
string.

You can use
this command to test the connection through to the
daemon.

See also
"guestfs_ping_daemon".

This function
returns a string, or NULL on error. The caller must free
the returned string after use.

(Added in
1.0.69)

guestfs_egrep

char ** 
guestfs_egrep (guestfs_h *g, 
const char *regex, 
const char *path);

This
function is deprecated. In new code, use the
"guestfs_grep" call instead.

Deprecated
functions will not be removed from the API, but the fact
that they are deprecated indicates that there are problems
with correct use of these functions.

This calls the
external egrep(1) program and returns the matching
lines.

This function
returns a NULL-terminated array of strings (like
environ(3)), or NULL if there was an error. The
caller must free the strings and the array after
use.

Because of the
message protocol, there is a transfer limit of somewhere
between 2MB and 4MB. See "PROTOCOL LIMITS".

(Added in
1.0.66)

guestfs_egrepi

char ** 
guestfs_egrepi (guestfs_h *g, 
const char *regex, 
const char *path);

This
function is deprecated. In new code, use the
"guestfs_grep" call instead.

Deprecated
functions will not be removed from the API, but the fact
that they are deprecated indicates that there are problems
with correct use of these functions.

This calls the
external "egrep -i" program and returns the
matching lines.

This function
returns a NULL-terminated array of strings (like
environ(3)), or NULL if there was an error. The
caller must free the strings and the array after
use.

Because of the
message protocol, there is a transfer limit of somewhere
between 2MB and 4MB. See "PROTOCOL LIMITS".

(Added in
1.0.66)

guestfs_equal

int 
guestfs_equal (guestfs_h *g, 
const char *file1, 
const char *file2);

This compares
the two files file1 and file2 and returns true
if their content is exactly equal, or false otherwise.

The external
cmp(1) program is used for the comparison.

This function
returns a C truth value on success or -1 on error.

(Added in
1.0.18)

guestfs_exists

int 
guestfs_exists (guestfs_h *g, 
const char *path);

This returns
"true" if and only if there is a file, directory
(or anything) with the given "path" name.

See also
"guestfs_is_file", "guestfs_is_dir",
"guestfs_stat".

This function
returns a C truth value on success or -1 on error.

(Added in
0.8)

guestfs_extlinux

int 
guestfs_extlinux (guestfs_h *g, 
const char *directory);

Install the
SYSLINUX bootloader on the device mounted at
directory. Unlike "guestfs_syslinux" which
requires a FAT filesystem, this can be used on an ext2/3/4
or btrfs filesystem.

The
directory parameter can be either a mountpoint, or a
directory within the mountpoint.

You also have
to mark the partition as "active"
("guestfs_part_set_bootable") and a Master Boot
Record must be installed (eg. using
"guestfs_pwrite_device") on the first sector of
the whole disk. The SYSLINUX package comes with some
suitable Master Boot Records. See the extlinux(1) man
page for further information.

Additional
configuration can be supplied to SYSLINUX by placing a file
called extlinux.conf on the filesystem under
directory. For further information about the contents
of this file, see extlinux(1).

See also
"guestfs_syslinux".

This function
returns 0 on success or -1 on error.

This function
depends on the feature "extlinux". See also
"guestfs_feature_available".

(Added in
1.21.27)

guestfs_f2fs_expand

int 
guestfs_f2fs_expand (guestfs_h *g, 
const char *device);

This expands a
f2fs filesystem to match the size of the underlying
device.

This function
returns 0 on success or -1 on error.

This function
depends on the feature "f2fs". See also
"guestfs_feature_available".

(Added in
1.39.3)

guestfs_fallocate

int 
guestfs_fallocate (guestfs_h *g, 
const char *path, 
int len);

This
function is deprecated. In new code, use the
"guestfs_fallocate64" call instead.

Deprecated
functions will not be removed from the API, but the fact
that they are deprecated indicates that there are problems
with correct use of these functions.

This command
preallocates a file (containing zero bytes) named
"path" of size "len" bytes. If the file
exists already, it is overwritten.

Do not confuse
this with the guestfish-specific "alloc" command
which allocates a file in the host and attaches it as a
device.

This function
returns 0 on success or -1 on error.

(Added in
1.0.66)

guestfs_fallocate64

int 
guestfs_fallocate64 (guestfs_h *g, 
const char *path, 
int64_t len);

This command
preallocates a file (containing zero bytes) named
"path" of size "len" bytes. If the file
exists already, it is overwritten.

Note that this
call allocates disk blocks for the file. To create a sparse
file use "guestfs_truncate_size" instead.

The deprecated
call "guestfs_fallocate" does the same, but owing
to an oversight it only allowed 30 bit lengths to be
specified, effectively limiting the maximum size of files
created through that call to 1GB.

Do not confuse
this with the guestfish-specific "alloc" and
"sparse" commands which create a file in the host
and attach it as a device.

This function
returns 0 on success or -1 on error.

(Added in
1.3.17)

guestfs_feature_available

int 
guestfs_feature_available (guestfs_h *g, 
char *const *groups);

This is the
same as "guestfs_available", but unlike that call
it returns a simple true/false boolean result, instead of
throwing an exception if a feature is not found. For other
documentation see "guestfs_available".

This function
returns a C truth value on success or -1 on error.

(Added in
1.21.26)

guestfs_fgrep

char ** 
guestfs_fgrep (guestfs_h *g, 
const char *pattern, 
const char *path);

This
function is deprecated. In new code, use the
"guestfs_grep" call instead.

Deprecated
functions will not be removed from the API, but the fact
that they are deprecated indicates that there are problems
with correct use of these functions.

This calls the
external fgrep(1) program and returns the matching
lines.

This function
returns a NULL-terminated array of strings (like
environ(3)), or NULL if there was an error. The
caller must free the strings and the array after
use.

Because of the
message protocol, there is a transfer limit of somewhere
between 2MB and 4MB. See "PROTOCOL LIMITS".

(Added in
1.0.66)

guestfs_fgrepi

char ** 
guestfs_fgrepi (guestfs_h *g, 
const char *pattern, 
const char *path);

This
function is deprecated. In new code, use the
"guestfs_grep" call instead.

Deprecated
functions will not be removed from the API, but the fact
that they are deprecated indicates that there are problems
with correct use of these functions.

This calls the
external "fgrep -i" program and returns the
matching lines.

This function
returns a NULL-terminated array of strings (like
environ(3)), or NULL if there was an error. The
caller must free the strings and the array after
use.

Because of the
message protocol, there is a transfer limit of somewhere
between 2MB and 4MB. See "PROTOCOL LIMITS".

(Added in
1.0.66)

guestfs_file

char * 
guestfs_file (guestfs_h *g, 
const char *path);

This call uses
the standard file(1) command to determine the type or
contents of the file.

This call will
also transparently look inside various types of compressed
file.

The filename is
not prepended to the output (like the file command -b
option).

The output
depends on the output of the underlying file(1)
command and it can change in future in ways beyond our
control. In other words, the output is not guaranteed by the
ABI.

See also:
file(1), "guestfs_vfs_type",
"guestfs_lstat", "guestfs_is_file",
"guestfs_is_blockdev" (etc),
"guestfs_is_zero".

This function
returns a string, or NULL on error. The caller must free
the returned string after use.

(Added in
1.9.1)

guestfs_file_architecture

char * 
guestfs_file_architecture (guestfs_h *g, 
const char *filename);

This detects
the architecture of the binary filename, and returns
it if known.

Currently
defined architectures are: 
"aarch64"

64 bit ARM.

"arm"

32 bit ARM.

"i386"

This string is returned for all
32 bit i386, i486, i586, i686 binaries irrespective of the
precise processor requirements of the binary.

"ia64"

Intel Itanium.

"ppc"

32 bit Power PC.

"ppc64"

64 bit Power PC (big
endian).

"ppc64le"

64 bit Power PC (little
endian).

"riscv32" 
"riscv64" 
"riscv128"

RISC-V 32-, 64- or 128-bit
variants.

"s390"

31 bit IBM S/390.

"s390x"

64 bit IBM S/390.

"sparc"

32 bit SPARC.

"sparc64"

64 bit SPARC V9 and above.

"x86_64"

64 bit x86-64.

Libguestfs may
return other architecture strings in future.

The function
works on at least the following types of files:

&bull;

many types of Un*x and Linux binary

&bull;

many types of Un*x and Linux shared library

&bull;

Windows Win32 and Win64 binaries

&bull;

Windows Win32 and Win64 DLLs

Win32 binaries
and DLLs return "i386".

Win64 binaries
and DLLs return "x86_64".

&bull;

Linux kernel modules

&bull;

Linux new-style initrd images

&bull;

some non-x86 Linux vmlinuz kernels

What it
can&rsquo;t do currently:

&bull;

static libraries (libfoo.a)

&bull;

Linux old-style initrd as compressed ext2 filesystem
(RHEL 3)

&bull;

x86 Linux vmlinuz kernels

x86 vmlinuz
images (bzImage format) consist of a mix of 16-, 32- and
compressed code, and are horribly hard to unpack. If you
want to find the architecture of a kernel, use the
architecture of the associated initrd or kernel module(s)
instead.

This function
returns a string, or NULL on error. The caller must free
the returned string after use.

(Added in
1.5.3)

guestfs_filesize

int64_t 
guestfs_filesize (guestfs_h *g, 
const char *file);

This command
returns the size of file in bytes.

To get other
stats about a file, use "guestfs_stat",
"guestfs_lstat", "guestfs_is_dir",
"guestfs_is_file" etc. To get the size of block
devices, use "guestfs_blockdev_getsize64".

On error this
function returns -1.

(Added in
1.0.82)

guestfs_filesystem_available

int 
guestfs_filesystem_available (guestfs_h *g, 
const char *filesystem);

Check whether
libguestfs supports the named filesystem. The argument
"filesystem" is a filesystem name, such as
"ext3".

You must call
"guestfs_launch" before using this command.

This is mainly
useful as a negative test. If this returns true, it
doesn&rsquo;t mean that a particular filesystem can be
created or mounted, since filesystems can fail for other
reasons such as it being a later version of the filesystem,
or having incompatible features, or lacking the right
mkfs.fs> tool.

See also
"guestfs_available",
"guestfs_feature_available",
"AVAILABILITY".

This function
returns a C truth value on success or -1 on error.

(Added in
1.19.5)

guestfs_filesystem_walk

struct guestfs_tsk_dirent_list * 
guestfs_filesystem_walk (guestfs_h *g, 
const char *device);

Walk through
the internal structures of a disk partition (eg.
/dev/sda1) in order to return a list of all the files
and directories stored within.

It is not
necessary to mount the disk partition to run this
command.

All entries in
the filesystem are returned. This function can list deleted
or unaccessible files. The entries are not
sorted.

The
"tsk_dirent" structure contains the following
fields. 
"tsk_inode"

Filesystem reference number of
the node. It might be 0 if the node has been deleted.

"tsk_type"

Basic file type information.
See below for a detailed list of values.

"tsk_size"

File size in bytes. It might be
-1 if the node has been deleted.

"tsk_name"

The file path relative to its
directory.

"tsk_flags"

Bitfield containing extra
information regarding the entry. It contains the logical OR
of the following values: 
0x0001

If set to 1, the file is
allocated and visible within the filesystem. Otherwise, the
file has been deleted. Under certain circumstances, the
function "download_inode" can be used to recover
deleted files.

0x0002

Filesystem such as NTFS and
Ext2 or greater, separate the file name from the metadata
structure. The bit is set to 1 when the file name is in an
unallocated state and the metadata structure is in an
allocated one. This generally implies the metadata has been
reallocated to a new file. Therefore, information such as
file type, file size, timestamps, number of links and
symlink target might not correspond with the ones of the
original deleted entry.

0x0004

The bit is set to 1 when the
file is compressed using filesystem native compression
support (NTFS). The API is not able to detect application
level compression.

"tsk_atime_sec" 
"tsk_atime_nsec" 
"tsk_mtime_sec" 
"tsk_mtime_nsec" 
"tsk_ctime_sec" 
"tsk_ctime_nsec" 
"tsk_crtime_sec" 
"tsk_crtime_nsec"

Respectively, access,
modification, last status change and creation time in Unix
format in seconds and nanoseconds.

"tsk_nlink"

Number of file names pointing
to this entry.

"tsk_link"

If the entry is a symbolic
link, this field will contain the path to the target
file.

The
"tsk_type" field will contain one of the following
characters:

&rsquo;b&rsquo;

Block special

&rsquo;c&rsquo;

Char special

&rsquo;d&rsquo;

Directory

&rsquo;f&rsquo;

FIFO (named pipe)

&rsquo;l&rsquo;

Symbolic link

&rsquo;r&rsquo;

Regular file

&rsquo;s&rsquo;

Socket

&rsquo;h&rsquo;

Shadow inode (Solaris)

&rsquo;w&rsquo;

Whiteout inode (BSD)

&rsquo;u&rsquo;

Unknown file type

This function
returns a "struct guestfs_tsk_dirent_list *", or
NULL if there was an error. The caller must call
"guestfs_free_tsk_dirent_list" after use.

This
long-running command can generate progress notification
messages so that the caller can display a progress bar or
indicator. To receive these messages, the caller must
register a progress event callback. See
"GUESTFS_EVENT_PROGRESS".

This function
depends on the feature "libtsk". See also
"guestfs_feature_available".

(Added in
1.33.39)

guestfs_fill

int 
guestfs_fill (guestfs_h *g, 
int c, 
int len, 
const char *path);

This command
creates a new file called "path". The initial
content of the file is "len" octets of
"c", where "c" must be a number in the
range "[0..255]".

To fill a file
with zero bytes (sparsely), it is much more efficient to use
"guestfs_truncate_size". To create a file with a
pattern of repeating bytes use
"guestfs_fill_pattern".

This function
returns 0 on success or -1 on error.

This
long-running command can generate progress notification
messages so that the caller can display a progress bar or
indicator. To receive these messages, the caller must
register a progress event callback. See
"GUESTFS_EVENT_PROGRESS".

(Added in
1.0.79)

guestfs_fill_dir

int 
guestfs_fill_dir (guestfs_h *g, 
const char *dir, 
int nr);

This function,
useful for testing filesystems, creates "nr" empty
files in the directory "dir" with names 00000000
through "nr-1" (ie. each file name is 8 digits
long padded with zeroes).

This function
returns 0 on success or -1 on error.

(Added in
1.19.32)

guestfs_fill_pattern

int 
guestfs_fill_pattern (guestfs_h *g, 
const char *pattern, 
int len, 
const char *path);

This function
is like "guestfs_fill" except that it creates a
new file of length "len" containing the repeating
pattern of bytes in "pattern". The pattern is
truncated if necessary to ensure the length of the file is
exactly "len" bytes.

This function
returns 0 on success or -1 on error.

This
long-running command can generate progress notification
messages so that the caller can display a progress bar or
indicator. To receive these messages, the caller must
register a progress event callback. See
"GUESTFS_EVENT_PROGRESS".

(Added in
1.3.12)

guestfs_find

char ** 
guestfs_find (guestfs_h *g, 
const char *directory);

This command
lists out all files and directories, recursively, starting
at directory. It is essentially equivalent to running
the shell command "find directory -print" but some
post-processing happens on the output, described below.

This returns a
list of strings without any prefix. Thus if the
directory structure was:

/tmp/a 
/tmp/b 
/tmp/c/d

then the
returned list from "guestfs_find" /tmp
would be 4 elements:

a 
b 
c 
c/d

If
directory is not a directory, then this command
returns an error.

The returned
list is sorted.

This function
returns a NULL-terminated array of strings (like
environ(3)), or NULL if there was an error. The
caller must free the strings and the array after
use.

(Added in
1.0.27)

guestfs_find0

int 
guestfs_find0 (guestfs_h *g, 
const char *directory, 
const char *files);

This command
lists out all files and directories, recursively, starting
at directory, placing the resulting list in the
external file called files.

This command
works the same way as "guestfs_find" with the
following exceptions:

&bull;

The resulting list is written to
an external file.

&bull;

Items (filenames) in the result are separated by
"\0" characters. See find(1) option
-print0. 

&bull;

The result list is not sorted.

This function
returns 0 on success or -1 on error.

(Added in
1.0.74)

guestfs_find_inode

struct guestfs_tsk_dirent_list * 
guestfs_find_inode (guestfs_h *g, 
const char *device, 
int64_t inode);

Searches all
the entries associated with the given inode.

For each entry,
a "tsk_dirent" structure is returned. See
"filesystem_walk" for more information about
"tsk_dirent" structures.

This function
returns a "struct guestfs_tsk_dirent_list *", or
NULL if there was an error. The caller must call
"guestfs_free_tsk_dirent_list" after use.

This
long-running command can generate progress notification
messages so that the caller can display a progress bar or
indicator. To receive these messages, the caller must
register a progress event callback. See
"GUESTFS_EVENT_PROGRESS".

This function
depends on the feature "libtsk". See also
"guestfs_feature_available".

(Added in
1.35.6)

guestfs_findfs_label

char * 
guestfs_findfs_label (guestfs_h *g, 
const char *label);

This command
searches the filesystems and returns the one which has the
given label. An error is returned if no such filesystem can
be found.

To find the
label of a filesystem, use
"guestfs_vfs_label".

This function
returns a string, or NULL on error. The caller must free
the returned string after use.

(Added in
1.5.3)

guestfs_findfs_uuid

char * 
guestfs_findfs_uuid (guestfs_h *g, 
const char *uuid);

This command
searches the filesystems and returns the one which has the
given UUID. An error is returned if no such filesystem can
be found.

To find the
UUID of a filesystem, use "guestfs_vfs_uuid".

This function
returns a string, or NULL on error. The caller must free
the returned string after use.

(Added in
1.5.3)

guestfs_fsck

int 
guestfs_fsck (guestfs_h *g, 
const char *fstype, 
const char *device);

This runs the
filesystem checker (fsck) on "device" which should
have filesystem type "fstype".

The returned
integer is the status. See fsck(8) for the list of
status codes from "fsck".

Notes:

&bull;

Multiple status codes can be
summed together.

&bull;

A non-zero return code can mean "success", for
example if errors have been corrected on the filesystem.

&bull;

Checking or repairing NTFS volumes is not supported (by
linux-ntfs). 

This command is
entirely equivalent to running "fsck -a -t fstype
device".

On error this
function returns -1.

(Added in
1.0.16)

guestfs_fstrim

int 
guestfs_fstrim (guestfs_h *g, 
const char *mountpoint, 
...);

You may supply
a list of optional arguments to this call. Use zero or more
of the following pairs of parameters, and terminate the list
with -1 on its own. See "CALLS WITH OPTIONAL
ARGUMENTS".

GUESTFS_FSTRIM_OFFSET,
int64_t offset, 
GUESTFS_FSTRIM_LENGTH, int64_t length, 
GUESTFS_FSTRIM_MINIMUMFREEEXTENT, int64_t
minimumfreeextent,

Trim the free
space in the filesystem mounted on "mountpoint".
The filesystem must be mounted read-write.

The filesystem
contents are not affected, but any free space in the
filesystem is "trimmed", that is, given back to
the host device, thus making disk images more sparse,
allowing unused space in qcow2 files to be reused, etc.

This operation
requires support in libguestfs, the mounted filesystem, the
host filesystem, qemu and the host kernel. If this support
isn&rsquo;t present it may give an error or even appear to
run but do nothing.

In the case
where the kernel vfs driver does not support trimming, this
call will fail with errno set to "ENOTSUP".
Currently this happens when trying to trim FAT
filesystems.

See also
"guestfs_zero_free_space". That is a slightly
different operation that turns free space in the filesystem
into zeroes. It is valid to call "guestfs_fstrim"
either instead of, or after calling
"guestfs_zero_free_space".

This function
returns 0 on success or -1 on error.

This function
depends on the feature "fstrim". See also
"guestfs_feature_available".

(Added in
1.19.6)

guestfs_fstrim_va

int 
guestfs_fstrim_va (guestfs_h *g, 
const char *mountpoint, 
va_list args);

This is the
"va_list variant" of
"guestfs_fstrim".

See "CALLS
WITH OPTIONAL ARGUMENTS".

guestfs_fstrim_argv

int 
guestfs_fstrim_argv (guestfs_h *g, 
const char *mountpoint, 
const struct guestfs_fstrim_argv *optargs);

This is the
"argv variant" of "guestfs_fstrim".

See "CALLS
WITH OPTIONAL ARGUMENTS".

guestfs_get_append

const char * 
guestfs_get_append (guestfs_h *g);

Return the
additional kernel options which are added to the libguestfs
appliance kernel command line.

If
"NULL" then no options are added.

This function
returns a string which may be NULL. There is no way to
return an error from this function. The string is owned by
the guest handle and must not be freed.

(Added in
1.0.26)

guestfs_get_attach_method

char * 
guestfs_get_attach_method (guestfs_h *g);

This
function is deprecated. In new code, use the
"guestfs_get_backend" call instead.

Deprecated
functions will not be removed from the API, but the fact
that they are deprecated indicates that there are problems
with correct use of these functions.

Return the
current backend.

See
"guestfs_set_backend" and "BACKEND".

This function
returns a string, or NULL on error. The caller must free
the returned string after use.

(Added in
1.9.8)

guestfs_get_autosync

int 
guestfs_get_autosync (guestfs_h *g);

Get the
autosync flag.

This function
returns a C truth value on success or -1 on error.

(Added in
0.3)

guestfs_get_backend

char * 
guestfs_get_backend (guestfs_h *g);

Return the
current backend.

This handle
property was previously called the "attach
method".

See
"guestfs_set_backend" and "BACKEND".

This function
returns a string, or NULL on error. The caller must free
the returned string after use.

(Added in
1.21.26)

guestfs_get_backend_setting

char * 
guestfs_get_backend_setting (guestfs_h *g, 
const char *name);

Find a backend
setting string which is either "name" or begins
with "name=". If "name", this returns
the string "1". If "name=", this returns
the part after the equals sign (which may be an empty
string).

If no such
setting is found, this function throws an error. The errno
(see "guestfs_last_errno") will be
"ESRCH" in this case.

See
"BACKEND", "BACKEND SETTINGS".

This function
returns a string, or NULL on error. The caller must free
the returned string after use.

(Added in
1.27.2)

guestfs_get_backend_settings

char ** 
guestfs_get_backend_settings (guestfs_h *g);

Return the
current backend settings.

This call
returns all backend settings strings. If you want to find a
single backend setting, see
"guestfs_get_backend_setting".

See
"BACKEND", "BACKEND SETTINGS".

This function
returns a NULL-terminated array of strings (like
environ(3)), or NULL if there was an error. The
caller must free the strings and the array after
use.

(Added in
1.25.24)

guestfs_get_cachedir

char * 
guestfs_get_cachedir (guestfs_h *g);

Get the
directory used by the handle to store the appliance
cache.

This function
returns a string, or NULL on error. The caller must free
the returned string after use.

(Added in
1.19.58)

guestfs_get_direct

int 
guestfs_get_direct (guestfs_h *g);

This
function is deprecated. In new code, use the
"guestfs_internal_get_console_socket" call
instead.

Deprecated
functions will not be removed from the API, but the fact
that they are deprecated indicates that there are problems
with correct use of these functions.

Return the
direct appliance mode flag.

This function
returns a C truth value on success or -1 on error.

(Added in
1.0.72)

guestfs_get_e2attrs

char * 
guestfs_get_e2attrs (guestfs_h *g, 
const char *file);

This returns
the file attributes associated with file.

The attributes
are a set of bits associated with each inode which affect
the behaviour of the file. The attributes are returned as a
string of letters (described below). The string may be
empty, indicating that no file attributes are set for this
file.

These
attributes are only present when the file is located on an
ext2/3/4 filesystem. Using this call on other filesystem
types will result in an error.

The characters
(file attributes) in the returned string are currently:

&rsquo;A&rsquo;

When the file is accessed, its
atime is not modified.

&rsquo;a&rsquo;

The file is append-only.

&rsquo;c&rsquo;

The file is compressed on-disk.

&rsquo;D&rsquo;

(Directories only.) Changes to this directory are
written synchronously to disk.

&rsquo;d&rsquo;

The file is not a candidate for backup (see
dump(8)). 

&rsquo;E&rsquo;

The file has compression errors.

&rsquo;e&rsquo;

The file is using extents.

&rsquo;h&rsquo;

The file is storing its blocks in units of the
filesystem blocksize instead of sectors.

&rsquo;I&rsquo;

(Directories only.) The directory is using hashed
trees. 

&rsquo;i&rsquo;

The file is immutable. It cannot be modified, deleted or
renamed. No link can be created to this file.

&rsquo;j&rsquo;

The file is data-journaled.

&rsquo;s&rsquo;

When the file is deleted, all its blocks will be
zeroed. 

&rsquo;S&rsquo;

Changes to this file are written synchronously to
disk. 

&rsquo;T&rsquo;

(Directories only.) This is a hint to the block
allocator that subdirectories contained in this directory
should be spread across blocks. If not present, the block
allocator will try to group subdirectories together.

&rsquo;t&rsquo;

For a file, this disables tail-merging. (Not used by
upstream implementations of ext2.)

&rsquo;u&rsquo;

When the file is deleted, its blocks will be saved,
allowing the file to be undeleted.

&rsquo;X&rsquo;

The raw contents of the compressed file may be
accessed. 

&rsquo;Z&rsquo;

The compressed file is dirty.

More file
attributes may be added to this list later. Not all file
attributes may be set for all kinds of files. For detailed
information, consult the chattr(1) man page.

See also
"guestfs_set_e2attrs".

Don&rsquo;t
confuse these attributes with extended attributes (see
"guestfs_getxattr").

This function
returns a string, or NULL on error. The caller must free
the returned string after use.

(Added in
1.17.31)

guestfs_get_e2generation

int64_t 
guestfs_get_e2generation (guestfs_h *g, 
const char *file);

This returns
the ext2 file generation of a file. The generation (which
used to be called the "version") is a number
associated with an inode. This is most commonly used by NFS
servers.

The generation
is only present when the file is located on an ext2/3/4
filesystem. Using this call on other filesystem types will
result in an error.

See
"guestfs_set_e2generation".

On error this
function returns -1.

(Added in
1.17.31)

guestfs_get_e2label

char * 
guestfs_get_e2label (guestfs_h *g, 
const char *device);

This
function is deprecated. In new code, use the
"guestfs_vfs_label" call instead.

Deprecated
functions will not be removed from the API, but the fact
that they are deprecated indicates that there are problems
with correct use of these functions.

This returns
the ext2/3/4 filesystem label of the filesystem on
"device".

This function
returns a string, or NULL on error. The caller must free
the returned string after use.

(Added in
1.0.15)

guestfs_get_e2uuid

char * 
guestfs_get_e2uuid (guestfs_h *g, 
const char *device);

This
function is deprecated. In new code, use the
"guestfs_vfs_uuid" call instead.

Deprecated
functions will not be removed from the API, but the fact
that they are deprecated indicates that there are problems
with correct use of these functions.

This returns
the ext2/3/4 filesystem UUID of the filesystem on
"device".

This function
returns a string, or NULL on error. The caller must free
the returned string after use.

(Added in
1.0.15)

guestfs_get_hv

char * 
guestfs_get_hv (guestfs_h *g);

Return the
current hypervisor binary.

This is always
non-NULL. If it wasn&rsquo;t set already, then this will
return the default qemu binary name.

This function
returns a string, or NULL on error. The caller must free
the returned string after use.

(Added in
1.23.17)

guestfs_get_identifier

const char * 
guestfs_get_identifier (guestfs_h *g);

Get the handle
identifier. See "guestfs_set_identifier".

This function
returns a string, or NULL on error. The string is owned by
the guest handle and must not be freed.

(Added in
1.31.14)

guestfs_get_libvirt_requested_credential_challenge

char * 
guestfs_get_libvirt_requested_credential_challenge
(guestfs_h *g, 
int index);

Get the
challenge (provided by libvirt) for the
"index"&rsquo;th requested credential. If libvirt
did not provide a challenge, this returns the empty string
"".

See
"LIBVIRT AUTHENTICATION" for documentation and
example code.

This function
returns a string, or NULL on error. The caller must free
the returned string after use.

(Added in
1.19.52)

guestfs_get_libvirt_requested_credential_defresult

char * 
guestfs_get_libvirt_requested_credential_defresult
(guestfs_h *g, 
int index);

Get the default
result (provided by libvirt) for the
"index"&rsquo;th requested credential. If libvirt
did not provide a default result, this returns the empty
string "".

See
"LIBVIRT AUTHENTICATION" for documentation and
example code.

This function
returns a string, or NULL on error. The caller must free
the returned string after use.

(Added in
1.19.52)

guestfs_get_libvirt_requested_credential_prompt

char * 
guestfs_get_libvirt_requested_credential_prompt (guestfs_h
*g, 
int index);

Get the prompt
(provided by libvirt) for the "index"&rsquo;th
requested credential. If libvirt did not provide a prompt,
this returns the empty string "".

See
"LIBVIRT AUTHENTICATION" for documentation and
example code.

This function
returns a string, or NULL on error. The caller must free
the returned string after use.

(Added in
1.19.52)

guestfs_get_libvirt_requested_credentials

char ** 
guestfs_get_libvirt_requested_credentials (guestfs_h
*g);

This should
only be called during the event callback for events of type
"GUESTFS_EVENT_LIBVIRT_AUTH".

Return the list
of credentials requested by libvirt. Possible values are a
subset of the strings provided when you called
"guestfs_set_libvirt_supported_credentials".

See
"LIBVIRT AUTHENTICATION" for documentation and
example code.

This function
returns a NULL-terminated array of strings (like
environ(3)), or NULL if there was an error. The
caller must free the strings and the array after
use.

(Added in
1.19.52)

guestfs_get_memsize

int 
guestfs_get_memsize (guestfs_h *g);

This gets the
memory size in megabytes allocated to the hypervisor.

If
"guestfs_set_memsize" was not called on this
handle, and if "LIBGUESTFS_MEMSIZE" was not set,
then this returns the compiled-in default value for
memsize.

For more
information on the architecture of libguestfs, see
guestfs(3).

On error this
function returns -1.

(Added in
1.0.55)

guestfs_get_network

int 
guestfs_get_network (guestfs_h *g);

This returns
the enable network flag.

This function
returns a C truth value on success or -1 on error.

(Added in
1.5.4)

guestfs_get_path

const char * 
guestfs_get_path (guestfs_h *g);

Return the
current search path.

This is always
non-NULL. If it wasn&rsquo;t set already, then this will
return the default path.

This function
returns a string, or NULL on error. The string is owned by
the guest handle and must not be freed.

(Added in
0.3)

guestfs_get_pgroup

int 
guestfs_get_pgroup (guestfs_h *g);

This returns
the process group flag.

This function
returns a C truth value on success or -1 on error.

(Added in
1.11.18)

guestfs_get_pid

int 
guestfs_get_pid (guestfs_h *g);

Return the
process ID of the hypervisor. If there is no hypervisor
running, then this will return an error.

This is an
internal call used for debugging and testing.

On error this
function returns -1.

(Added in
1.0.56)

guestfs_get_program

const char * 
guestfs_get_program (guestfs_h *g);

Get the program
name. See "guestfs_set_program".

This function
returns a string, or NULL on error. The string is owned by
the guest handle and must not be freed.

(Added in
1.21.29)

guestfs_get_qemu

const char * 
guestfs_get_qemu (guestfs_h *g);

This
function is deprecated. In new code, use the
"guestfs_get_hv" call instead.

Deprecated
functions will not be removed from the API, but the fact
that they are deprecated indicates that there are problems
with correct use of these functions.

Return the
current hypervisor binary (usually qemu).

This is always
non-NULL. If it wasn&rsquo;t set already, then this will
return the default qemu binary name.

This function
returns a string, or NULL on error. The string is owned by
the guest handle and must not be freed.

(Added in
1.0.6)

guestfs_get_recovery_proc

int 
guestfs_get_recovery_proc (guestfs_h *g);

Return the
recovery process enabled flag.

This function
returns a C truth value on success or -1 on error.

(Added in
1.0.77)

guestfs_get_selinux

int 
guestfs_get_selinux (guestfs_h *g);

This
function is deprecated. In new code, use the
"guestfs_selinux_relabel" call instead.

Deprecated
functions will not be removed from the API, but the fact
that they are deprecated indicates that there are problems
with correct use of these functions.

This returns
the current setting of the selinux flag which is passed to
the appliance at boot time. See
"guestfs_set_selinux".

For more
information on the architecture of libguestfs, see
guestfs(3).

This function
returns a C truth value on success or -1 on error.

(Added in
1.0.67)

guestfs_get_smp

int 
guestfs_get_smp (guestfs_h *g);

This returns
the number of virtual CPUs assigned to the appliance.

On error this
function returns -1.

(Added in
1.13.15)

guestfs_get_sockdir

char * 
guestfs_get_sockdir (guestfs_h *g);

Get the
directory used by the handle to store temporary socket and
PID files.

This is
different from "guestfs_get_tmpdir", as we need
shorter paths for sockets (due to the limited buffers of
filenames for UNIX sockets), and
"guestfs_get_tmpdir" may be too long for them.
Furthermore, sockets and PID files must be accessible to
such background services started by libguestfs that may not
have permission to access the temporary directory returned
by "guestfs_get_tmpdir".

The environment
variable "XDG_RUNTIME_DIR" controls the default
value: If "XDG_RUNTIME_DIR" is set, then that is
the default. Else /tmp is the default.

This function
returns a string, or NULL on error. The caller must free
the returned string after use.

(Added in
1.33.8)

guestfs_get_state

int 
guestfs_get_state (guestfs_h *g);

This returns
the current state as an opaque integer. This is only useful
for printing debug and internal error messages.

For more
information on states, see guestfs(3).

On error this
function returns -1.

(Added in
1.0.2)

guestfs_get_tmpdir

char * 
guestfs_get_tmpdir (guestfs_h *g);

Get the
directory used by the handle to store temporary files.

This function
returns a string, or NULL on error. The caller must free
the returned string after use.

(Added in
1.19.58)

guestfs_get_trace

int 
guestfs_get_trace (guestfs_h *g);

Return the
command trace flag.

This function
returns a C truth value on success or -1 on error.

(Added in
1.0.69)

guestfs_get_umask

int 
guestfs_get_umask (guestfs_h *g);

Return the
current umask. By default the umask is 022 unless it has
been set by calling "guestfs_umask".

On error this
function returns -1.

(Added in
1.3.4)

guestfs_get_verbose

int 
guestfs_get_verbose (guestfs_h *g);

This returns
the verbose messages flag.

This function
returns a C truth value on success or -1 on error.

(Added in
0.3)

guestfs_getcon

char * 
guestfs_getcon (guestfs_h *g);

This
function is deprecated. In new code, use the
"guestfs_selinux_relabel" call instead.

Deprecated
functions will not be removed from the API, but the fact
that they are deprecated indicates that there are problems
with correct use of these functions.

This gets the
SELinux security context of the daemon.

See the
documentation about SELINUX in guestfs(3), and
"guestfs_setcon"

This function
returns a string, or NULL on error. The caller must free
the returned string after use.

This function
depends on the feature "selinux". See also
"guestfs_feature_available".

(Added in
1.0.67)

guestfs_getxattr

char * 
guestfs_getxattr (guestfs_h *g, 
const char *path, 
const char *name, 
size_t *size_r);

Get a single
extended attribute from file "path" named
"name". This call follows symlinks. If you want to
lookup an extended attribute for the symlink itself, use
"guestfs_lgetxattr".

Normally it is
better to get all extended attributes from a file in one go
by calling "guestfs_getxattrs". However some Linux
filesystem implementations are buggy and do not provide a
way to list out attributes. For these filesystems (notably
ntfs-3g) you have to know the names of the extended
attributes you want in advance and call this function.

Extended
attribute values are blobs of binary data. If there is no
extended attribute named "name", this returns an
error.

See also:
"guestfs_getxattrs",
"guestfs_lgetxattr", attr(5).

This function
returns a buffer, or NULL on error. The size of the returned
buffer is written to *size_r. The caller must free the
returned buffer after use.

This function
depends on the feature "linuxxattrs". See also
"guestfs_feature_available".

(Added in
1.7.24)

guestfs_getxattrs

struct guestfs_xattr_list * 
guestfs_getxattrs (guestfs_h *g, 
const char *path);

This call lists
the extended attributes of the file or directory
"path".

At the system
call level, this is a combination of the listxattr(2)
and getxattr(2) calls.

See also:
"guestfs_lgetxattrs", attr(5).

This function
returns a "struct guestfs_xattr_list *", or NULL
if there was an error. The caller must call
"guestfs_free_xattr_list" after use.

This function
depends on the feature "linuxxattrs". See also
"guestfs_feature_available".

(Added in
1.0.59)

guestfs_glob_expand

char ** 
guestfs_glob_expand (guestfs_h *g, 
const char *pattern);

This function
is provided for backwards compatibility with earlier
versions of libguestfs. It simply calls
"guestfs_glob_expand_opts" with no optional
arguments.

(Added in
1.0.50)

guestfs_glob_expand_opts

char ** 
guestfs_glob_expand_opts (guestfs_h *g, 
const char *pattern, 
...);

You may supply
a list of optional arguments to this call. Use zero or more
of the following pairs of parameters, and terminate the list
with -1 on its own. See "CALLS WITH OPTIONAL
ARGUMENTS".

GUESTFS_GLOB_EXPAND_OPTS_DIRECTORYSLASH,
int directoryslash,

This command
searches for all the pathnames matching "pattern"
according to the wildcard expansion rules used by the
shell.

If no paths
match, then this returns an empty list (note: not an
error).

It is just a
wrapper around the C glob(3) function with flags
"GLOB_MARK|GLOB_BRACE". See that manual page for
more details.

"directoryslash"
controls whether use the "GLOB_MARK" flag for
glob(3), and it defaults to true. It can be
explicitly set as off to return no trailing slashes in
filenames of directories.

Notice that
there is no equivalent command for expanding a device name
(eg. /dev/sd*). Use "guestfs_list_devices",
"guestfs_list_partitions" etc functions
instead.

This function
returns a NULL-terminated array of strings (like
environ(3)), or NULL if there was an error. The
caller must free the strings and the array after
use.

(Added in
1.0.50)

guestfs_glob_expand_opts_va

char ** 
guestfs_glob_expand_opts_va (guestfs_h *g, 
const char *pattern, 
va_list args);

This is the
"va_list variant" of
"guestfs_glob_expand_opts".

See "CALLS
WITH OPTIONAL ARGUMENTS".

guestfs_glob_expand_opts_argv

char ** 
guestfs_glob_expand_opts_argv (guestfs_h *g, 
const char *pattern, 
const struct guestfs_glob_expand_opts_argv *optargs);

This is the
"argv variant" of
"guestfs_glob_expand_opts".

See "CALLS
WITH OPTIONAL ARGUMENTS".

guestfs_grep

char ** 
guestfs_grep (guestfs_h *g, 
const char *regex, 
const char *path);

This function
is provided for backwards compatibility with earlier
versions of libguestfs. It simply calls
"guestfs_grep_opts" with no optional
arguments.

(Added in
1.0.66)

guestfs_grep_opts

char ** 
guestfs_grep_opts (guestfs_h *g, 
const char *regex, 
const char *path, 
...);

You may supply
a list of optional arguments to this call. Use zero or more
of the following pairs of parameters, and terminate the list
with -1 on its own. See "CALLS WITH OPTIONAL
ARGUMENTS".

GUESTFS_GREP_OPTS_EXTENDED,
int extended, 
GUESTFS_GREP_OPTS_FIXED, int fixed, 
GUESTFS_GREP_OPTS_INSENSITIVE, int insensitive, 
GUESTFS_GREP_OPTS_COMPRESSED, int compressed,

This calls the
external grep(1) program and returns the matching
lines.

The optional
flags are: 
"extended"

Use extended regular
expressions. This is the same as using the -E
flag.

"fixed"

Match fixed (don&rsquo;t use
regular expressions). This is the same as using the
-F flag.

"insensitive"

Match case-insensitive. This is
the same as using the -i flag.

"compressed"

Use zgrep(1) instead of
grep(1). This allows the input to be compress- or
gzip-compressed.

This function
returns a NULL-terminated array of strings (like
environ(3)), or NULL if there was an error. The
caller must free the strings and the array after
use.

Because of the
message protocol, there is a transfer limit of somewhere
between 2MB and 4MB. See "PROTOCOL LIMITS".

(Added in
1.0.66)

guestfs_grep_opts_va

char ** 
guestfs_grep_opts_va (guestfs_h *g, 
const char *regex, 
const char *path, 
va_list args);

This is the
"va_list variant" of
"guestfs_grep_opts".

See "CALLS
WITH OPTIONAL ARGUMENTS".

guestfs_grep_opts_argv

char ** 
guestfs_grep_opts_argv (guestfs_h *g, 
const char *regex, 
const char *path, 
const struct guestfs_grep_opts_argv *optargs);

This is the
"argv variant" of
"guestfs_grep_opts".

See "CALLS
WITH OPTIONAL ARGUMENTS".

guestfs_grepi

char ** 
guestfs_grepi (guestfs_h *g, 
const char *regex, 
const char *path);

This
function is deprecated. In new code, use the
"guestfs_grep" call instead.

Deprecated
functions will not be removed from the API, but the fact
that they are deprecated indicates that there are problems
with correct use of these functions.

This calls the
external "grep -i" program and returns the
matching lines.

This function
returns a NULL-terminated array of strings (like
environ(3)), or NULL if there was an error. The
caller must free the strings and the array after
use.

Because of the
message protocol, there is a transfer limit of somewhere
between 2MB and 4MB. See "PROTOCOL LIMITS".

(Added in
1.0.66)

guestfs_grub_install

int 
guestfs_grub_install (guestfs_h *g, 
const char *root, 
const char *device);

This command
installs GRUB 1 (the Grand Unified Bootloader) on
"device", with the root directory being
"root".

Notes:

&bull;

There is currently no way in the API to install grub2,
which is used by most modern Linux guests. It is possible to
run the grub2 command from the guest, although see the
caveats in "RUNNING COMMANDS".

&bull;

This uses grub-install(8) from the host.
Unfortunately grub is not always compatible with itself, so
this only works in rather narrow circumstances. Careful
testing with each guest version is advisable.

&bull;

If grub-install reports the error "No suitable
drive was found in the generated device map." it may be
that you need to create a /boot/grub/device.map file
first that contains the mapping between grub device names
and Linux device names. It is usually sufficient to create a
file containing:

(hd0)
/dev/vda

replacing
/dev/vda with the name of the installation
device.

This function
returns 0 on success or -1 on error.

This function
depends on the feature "grub". See also
"guestfs_feature_available".

(Added in
1.0.17)

guestfs_head

char ** 
guestfs_head (guestfs_h *g, 
const char *path);

This command
returns up to the first 10 lines of a file as a list of
strings.

This function
returns a NULL-terminated array of strings (like
environ(3)), or NULL if there was an error. The
caller must free the strings and the array after
use.

Because of the
message protocol, there is a transfer limit of somewhere
between 2MB and 4MB. See "PROTOCOL LIMITS".

(Added in
1.0.54)

guestfs_head_n

char ** 
guestfs_head_n (guestfs_h *g, 
int nrlines, 
const char *path);

If the
parameter "nrlines" is a positive number, this
returns the first "nrlines" lines of the file
"path".

If the
parameter "nrlines" is a negative number, this
returns lines from the file "path", excluding the
last "nrlines" lines.

If the
parameter "nrlines" is zero, this returns an empty
list.

This function
returns a NULL-terminated array of strings (like
environ(3)), or NULL if there was an error. The
caller must free the strings and the array after
use.

Because of the
message protocol, there is a transfer limit of somewhere
between 2MB and 4MB. See "PROTOCOL LIMITS".

(Added in
1.0.54)

guestfs_hexdump

char * 
guestfs_hexdump (guestfs_h *g, 
const char *path);

This runs
"hexdump -C" on the given "path". The
result is the human-readable, canonical hex dump of the
file.

This function
returns a string, or NULL on error. The caller must free
the returned string after use.

Because of the
message protocol, there is a transfer limit of somewhere
between 2MB and 4MB. See "PROTOCOL LIMITS".

(Added in
1.0.22)

guestfs_hivex_close

int 
guestfs_hivex_close (guestfs_h *g);

Close the
current hivex handle.

This is a
wrapper around the hivex(3) call of the same
name.

This function
returns 0 on success or -1 on error.

This function
depends on the feature "hivex". See also
"guestfs_feature_available".

(Added in
1.19.35)

guestfs_hivex_commit

int 
guestfs_hivex_commit (guestfs_h *g, 
const char *filename);

Commit (write)
changes to the hive.

If the optional
filename parameter is null, then the changes are
written back to the same hive that was opened. If this is
not null then they are written to the alternate filename
given and the original hive is left untouched.

This is a
wrapper around the hivex(3) call of the same
name.

This function
returns 0 on success or -1 on error.

This function
depends on the feature "hivex". See also
"guestfs_feature_available".

(Added in
1.19.35)

guestfs_hivex_node_add_child

int64_t 
guestfs_hivex_node_add_child (guestfs_h *g, 
int64_t parent, 
const char *name);

Add a child
node to "parent" named "name".

This is a
wrapper around the hivex(3) call of the same
name.

On error this
function returns -1.

This function
depends on the feature "hivex". See also
"guestfs_feature_available".

(Added in
1.19.35)

guestfs_hivex_node_children

struct guestfs_hivex_node_list * 
guestfs_hivex_node_children (guestfs_h *g, 
int64_t nodeh);

Return the list
of nodes which are subkeys of "nodeh".

This is a
wrapper around the hivex(3) call of the same
name.

This function
returns a "struct guestfs_hivex_node_list *", or
NULL if there was an error. The caller must call
"guestfs_free_hivex_node_list" after use.

This function
depends on the feature "hivex". See also
"guestfs_feature_available".

(Added in
1.19.35)

guestfs_hivex_node_delete_child

int 
guestfs_hivex_node_delete_child (guestfs_h *g, 
int64_t nodeh);

Delete
"nodeh", recursively if necessary.

This is a
wrapper around the hivex(3) call of the same
name.

This function
returns 0 on success or -1 on error.

This function
depends on the feature "hivex". See also
"guestfs_feature_available".

(Added in
1.19.35)

guestfs_hivex_node_get_child

int64_t 
guestfs_hivex_node_get_child (guestfs_h *g, 
int64_t nodeh, 
const char *name);

Return the
child of "nodeh" with the name "name",
if it exists. This can return 0 meaning the name was not
found.

This is a
wrapper around the hivex(3) call of the same
name.

On error this
function returns -1.

This function
depends on the feature "hivex". See also
"guestfs_feature_available".

(Added in
1.19.35)

guestfs_hivex_node_get_value

int64_t 
guestfs_hivex_node_get_value (guestfs_h *g, 
int64_t nodeh, 
const char *key);

Return the
value attached to "nodeh" which has the name
"key", if it exists. This can return 0 meaning the
key was not found.

This is a
wrapper around the hivex(3) call of the same
name.

On error this
function returns -1.

This function
depends on the feature "hivex". See also
"guestfs_feature_available".

(Added in
1.19.35)

guestfs_hivex_node_name

char * 
guestfs_hivex_node_name (guestfs_h *g, 
int64_t nodeh);

Return the name
of "nodeh".

This is a
wrapper around the hivex(3) call of the same
name.

This function
returns a string, or NULL on error. The caller must free
the returned string after use.

This function
depends on the feature "hivex". See also
"guestfs_feature_available".

(Added in
1.19.35)

guestfs_hivex_node_parent

int64_t 
guestfs_hivex_node_parent (guestfs_h *g, 
int64_t nodeh);

Return the
parent node of "nodeh".

This is a
wrapper around the hivex(3) call of the same
name.

On error this
function returns -1.

This function
depends on the feature "hivex". See also
"guestfs_feature_available".

(Added in
1.19.35)

guestfs_hivex_node_set_value

int 
guestfs_hivex_node_set_value (guestfs_h *g, 
int64_t nodeh, 
const char *key, 
int64_t t, 
const char *val, 
size_t val_size);

Set or replace
a single value under the node "nodeh". The
"key" is the name, "t" is the type, and
"val" is the data.

This is a
wrapper around the hivex(3) call of the same
name.

This function
returns 0 on success or -1 on error.

This function
depends on the feature "hivex". See also
"guestfs_feature_available".

(Added in
1.19.35)

guestfs_hivex_node_values

struct guestfs_hivex_value_list * 
guestfs_hivex_node_values (guestfs_h *g, 
int64_t nodeh);

Return the
array of (key, datatype, data) tuples attached to
"nodeh".

This is a
wrapper around the hivex(3) call of the same
name.

This function
returns a "struct guestfs_hivex_value_list *", or
NULL if there was an error. The caller must call
"guestfs_free_hivex_value_list" after use.

This function
depends on the feature "hivex". See also
"guestfs_feature_available".

(Added in
1.19.35)

guestfs_hivex_open

int 
guestfs_hivex_open (guestfs_h *g, 
const char *filename, 
...);

You may supply
a list of optional arguments to this call. Use zero or more
of the following pairs of parameters, and terminate the list
with -1 on its own. See "CALLS WITH OPTIONAL
ARGUMENTS".

GUESTFS_HIVEX_OPEN_VERBOSE,
int verbose, 
GUESTFS_HIVEX_OPEN_DEBUG, int debug, 
GUESTFS_HIVEX_OPEN_WRITE, int write, 
GUESTFS_HIVEX_OPEN_UNSAFE, int unsafe,

Open the
Windows Registry hive file named filename. If there
was any previous hivex handle associated with this guestfs
session, then it is closed.

This is a
wrapper around the hivex(3) call of the same
name.

This function
returns 0 on success or -1 on error.

This function
depends on the feature "hivex". See also
"guestfs_feature_available".

(Added in
1.19.35)

guestfs_hivex_open_va

int 
guestfs_hivex_open_va (guestfs_h *g, 
const char *filename, 
va_list args);

This is the
"va_list variant" of
"guestfs_hivex_open".

See "CALLS
WITH OPTIONAL ARGUMENTS".

guestfs_hivex_open_argv

int 
guestfs_hivex_open_argv (guestfs_h *g, 
const char *filename, 
const struct guestfs_hivex_open_argv *optargs);

This is the
"argv variant" of
"guestfs_hivex_open".

See "CALLS
WITH OPTIONAL ARGUMENTS".

guestfs_hivex_root

int64_t 
guestfs_hivex_root (guestfs_h *g);

Return the root
node of the hive.

This is a
wrapper around the hivex(3) call of the same
name.

On error this
function returns -1.

This function
depends on the feature "hivex". See also
"guestfs_feature_available".

(Added in
1.19.35)

guestfs_hivex_value_key

char * 
guestfs_hivex_value_key (guestfs_h *g, 
int64_t valueh);

Return the key
(name) field of a (key, datatype, data) tuple.

This is a
wrapper around the hivex(3) call of the same
name.

This function
returns a string, or NULL on error. The caller must free
the returned string after use.

This function
depends on the feature "hivex". See also
"guestfs_feature_available".

(Added in
1.19.35)

guestfs_hivex_value_string

char * 
guestfs_hivex_value_string (guestfs_h *g, 
int64_t valueh);

This calls
"guestfs_hivex_value_value" (which returns the
data field from a hivex value tuple). It then assumes that
the field is a UTF-16LE string and converts the result to
UTF-8 (or if this is not possible, it returns an error).

This is useful
for reading strings out of the Windows registry. However it
is not foolproof because the registry is not strongly-typed
and fields can contain arbitrary or unexpected data.

This function
returns a string, or NULL on error. The caller must free
the returned string after use.

This function
depends on the feature "hivex". See also
"guestfs_feature_available".

(Added in
1.37.22)

guestfs_hivex_value_type

int64_t 
guestfs_hivex_value_type (guestfs_h *g, 
int64_t valueh);

Return the data
type field from a (key, datatype, data) tuple.

This is a
wrapper around the hivex(3) call of the same
name.

On error this
function returns -1.

This function
depends on the feature "hivex". See also
"guestfs_feature_available".

(Added in
1.19.35)

guestfs_hivex_value_utf8

char * 
guestfs_hivex_value_utf8 (guestfs_h *g, 
int64_t valueh);

This
function is deprecated. In new code, use the
"guestfs_hivex_value_string" call instead.

Deprecated
functions will not be removed from the API, but the fact
that they are deprecated indicates that there are problems
with correct use of these functions.

This calls
"guestfs_hivex_value_value" (which returns the
data field from a hivex value tuple). It then assumes that
the field is a UTF-16LE string and converts the result to
UTF-8 (or if this is not possible, it returns an error).

This is useful
for reading strings out of the Windows registry. However it
is not foolproof because the registry is not strongly-typed
and fields can contain arbitrary or unexpected data.

This function
returns a string, or NULL on error. The caller must free
the returned string after use.

This function
depends on the feature "hivex". See also
"guestfs_feature_available".

(Added in
1.19.35)

guestfs_hivex_value_value

char * 
guestfs_hivex_value_value (guestfs_h *g, 
int64_t valueh, 
size_t *size_r);

Return the data
field of a (key, datatype, data) tuple.

This is a
wrapper around the hivex(3) call of the same
name.

See also:
"guestfs_hivex_value_utf8".

This function
returns a buffer, or NULL on error. The size of the returned
buffer is written to *size_r. The caller must free the
returned buffer after use.

This function
depends on the feature "hivex". See also
"guestfs_feature_available".

(Added in
1.19.35)

guestfs_initrd_cat

char * 
guestfs_initrd_cat (guestfs_h *g, 
const char *initrdpath, 
const char *filename, 
size_t *size_r);

This command
unpacks the file filename from the initrd file called
initrdpath. The filename must be given without
the initial / character.

For example, in
guestfish you could use the following command to examine the
boot script (usually called /init) contained in a
Linux initrd or initramfs image:

initrd-cat
/boot/initrd-.img init

See also
"guestfs_initrd_list".

This function
returns a buffer, or NULL on error. The size of the returned
buffer is written to *size_r. The caller must free the
returned buffer after use.

Because of the
message protocol, there is a transfer limit of somewhere
between 2MB and 4MB. See "PROTOCOL LIMITS".

(Added in
1.0.84)

guestfs_initrd_list

char ** 
guestfs_initrd_list (guestfs_h *g, 
const char *path);

This command
lists out files contained in an initrd.

The files are
listed without any initial / character. The files are
listed in the order they appear (not necessarily
alphabetical). Directory names are listed as separate
items.

Old Linux
kernels (2.4 and earlier) used a compressed ext2 filesystem
as initrd. We only support the newer initramfs format
(compressed cpio files).

This function
returns a NULL-terminated array of strings (like
environ(3)), or NULL if there was an error. The
caller must free the strings and the array after
use.

(Added in
1.0.54)

guestfs_inotify_add_watch

int64_t 
guestfs_inotify_add_watch (guestfs_h *g, 
const char *path, 
int mask);

Watch
"path" for the events listed in
"mask".

Note that if
"path" is a directory then events within that
directory are watched, but this does not happen
recursively (in subdirectories).

Note for non-C
or non-Linux callers: the inotify events are defined by the
Linux kernel ABI and are listed in
/usr/include/sys/inotify.h.

On error this
function returns -1.

This function
depends on the feature "inotify". See also
"guestfs_feature_available".

(Added in
1.0.66)

guestfs_inotify_close

int 
guestfs_inotify_close (guestfs_h *g);

This closes the
inotify handle which was previously opened by inotify_init.
It removes all watches, throws away any pending events, and
deallocates all resources.

This function
returns 0 on success or -1 on error.

This function
depends on the feature "inotify". See also
"guestfs_feature_available".

(Added in
1.0.66)

guestfs_inotify_files

char ** 
guestfs_inotify_files (guestfs_h *g);

This function
is a helpful wrapper around "guestfs_inotify_read"
which just returns a list of pathnames of objects that were
touched. The returned pathnames are sorted and
deduplicated.

This function
returns a NULL-terminated array of strings (like
environ(3)), or NULL if there was an error. The
caller must free the strings and the array after
use.

This function
depends on the feature "inotify". See also
"guestfs_feature_available".

(Added in
1.0.66)

guestfs_inotify_init

int 
guestfs_inotify_init (guestfs_h *g, 
int maxevents);

This command
creates a new inotify handle. The inotify subsystem can be
used to notify events which happen to objects in the guest
filesystem.

"maxevents"
is the maximum number of events which will be queued up
between calls to "guestfs_inotify_read" or
"guestfs_inotify_files". If this is passed as 0,
then the kernel (or previously set) default is used. For
Linux 2.6.29 the default was 16384 events. Beyond this
limit, the kernel throws away events, but records the fact
that it threw them away by setting a flag
"IN_Q_OVERFLOW" in the returned structure list
(see "guestfs_inotify_read").

Before any
events are generated, you have to add some watches to the
internal watch list. See:
"guestfs_inotify_add_watch" and
"guestfs_inotify_rm_watch".

Queued up
events should be read periodically by calling
"guestfs_inotify_read" (or
"guestfs_inotify_files" which is just a helpful
wrapper around "guestfs_inotify_read"). If you
don&rsquo;t read the events out often enough then you risk
the internal queue overflowing.

The handle
should be closed after use by calling
"guestfs_inotify_close". This also removes any
watches automatically.

See also
inotify(7) for an overview of the inotify interface
as exposed by the Linux kernel, which is roughly what we
expose via libguestfs. Note that there is one global inotify
handle per libguestfs instance.

This function
returns 0 on success or -1 on error.

This function
depends on the feature "inotify". See also
"guestfs_feature_available".

(Added in
1.0.66)

guestfs_inotify_read

struct guestfs_inotify_event_list * 
guestfs_inotify_read (guestfs_h *g);

Return the
complete queue of events that have happened since the
previous read call.

If no events
have happened, this returns an empty list.

Note: In
order to make sure that all events have been read, you must
call this function repeatedly until it returns an empty
list. The reason is that the call will read events up to the
maximum appliance-to-host message size and leave remaining
events in the queue.

This function
returns a "struct guestfs_inotify_event_list *",
or NULL if there was an error. The caller must call
"guestfs_free_inotify_event_list" after
use.

This function
depends on the feature "inotify". See also
"guestfs_feature_available".

(Added in
1.0.66)

guestfs_inotify_rm_watch

int 
guestfs_inotify_rm_watch (guestfs_h *g, 
int wd);

Remove a
previously defined inotify watch. See
"guestfs_inotify_add_watch".

This function
returns 0 on success or -1 on error.

This function
depends on the feature "inotify". See also
"guestfs_feature_available".

(Added in
1.0.66)

guestfs_inspect_get_arch

char * 
guestfs_inspect_get_arch (guestfs_h *g, 
const char *root);

This returns
the architecture of the inspected operating system. The
possible return values are listed under
"guestfs_file_architecture".

If the
architecture could not be determined, then the string
"unknown" is returned.

Please read
"INSPECTION" for more details.

This function
returns a string, or NULL on error. The caller must free
the returned string after use.

(Added in
1.5.3)

guestfs_inspect_get_build_id

char * 
guestfs_inspect_get_build_id (guestfs_h *g, 
const char *root);

This returns
the build ID of the system, or the string
"unknown" if the system does not have a build
ID.

For Windows,
this gets the build number. Although it is returned as a
string, it is (so far) always a number. See
https://en.wikipedia.org/wiki/List_of_Microsoft_Windows_versions
for some possible values.

For Linux, this
returns the "BUILD_ID" string from
/etc/os-release, although this is not often used.

Please read
"INSPECTION" for more details.

This function
returns a string, or NULL on error. The caller must free
the returned string after use.

(Added in
1.49.8)

guestfs_inspect_get_distro

char * 
guestfs_inspect_get_distro (guestfs_h *g, 
const char *root);

This returns
the distro (distribution) of the inspected operating
system.

Currently
defined distros are: 
"alpinelinux"

Alpine Linux.

"altlinux"

ALT Linux.

"archlinux"

Arch Linux.

"buildroot"

Buildroot-derived distro, but
not one we specifically recognize.

"centos"

CentOS.

"cirros"

Cirros.

"coreos"

CoreOS.

"debian"

Debian.

"fedora"

Fedora.

"freebsd"

FreeBSD.

"freedos"

FreeDOS.

"frugalware"

Frugalware.

"gentoo"

Gentoo.

"kalilinux"

Kali Linux.

"kylin"

Kylin.

"linuxmint"

Linux Mint.

"mageia"

Mageia.

"mandriva"

Mandriva.

"meego"

MeeGo.

"msdos"

Microsoft DOS.

"neokylin"

NeoKylin.

"netbsd"

NetBSD.

"openbsd"

OpenBSD.

"openmandriva"

OpenMandriva Lx.

"opensuse"

OpenSUSE.

"oraclelinux"

Oracle Linux.

"pardus"

Pardus.

"pldlinux"

PLD Linux.

"redhat-based"

Some Red Hat-derived
distro.

"rhel"

Red Hat Enterprise Linux.

"rocky"

Rocky Linux.

"scientificlinux"

Scientific Linux.

"slackware"

Slackware.

"sles"

SuSE Linux Enterprise Server or
Desktop.

"suse-based"

Some openSuSE-derived
distro.

"ttylinux"

ttylinux.

"ubuntu"

Ubuntu.

"unknown"

The distro could not be
determined.

"voidlinux"

Void Linux.

"windows"

Windows does not have
distributions. This string is returned if the OS type is
Windows.

Future versions
of libguestfs may return other strings here. The caller
should be prepared to handle any string.

Please read
"INSPECTION" for more details.

This function
returns a string, or NULL on error. The caller must free
the returned string after use.

(Added in
1.5.3)

guestfs_inspect_get_drive_mappings

char ** 
guestfs_inspect_get_drive_mappings (guestfs_h *g, 
const char *root);

This call is
useful for Windows which uses a primitive system of
assigning drive letters (like C:\) to partitions.
This inspection API examines the Windows Registry to find
out how disks/partitions are mapped to drive letters, and
returns a hash table as in the example below:

C =>
/dev/vda2 
E => /dev/vdb1 
F => /dev/vdc1

Note that keys
are drive letters. For Windows, the key is case insensitive
and just contains the drive letter, without the customary
colon separator character.

In future we
may support other operating systems that also used drive
letters, but the keys for those might not be case
insensitive and might be longer than 1 character. For
example in OS-9, hard drives were named "h0",
"h1" etc.

For Windows
guests, currently only hard drive mappings are returned.
Removable disks (eg. DVD-ROMs) are ignored.

For guests that
do not use drive mappings, or if the drive mappings could
not be determined, this returns an empty hash table.

Please read
"INSPECTION" for more details. See also
"guestfs_inspect_get_mountpoints",
"guestfs_inspect_get_filesystems".

This function
returns a NULL-terminated array of strings, or NULL if there
was an error. The array of strings will always have length
"2n+1", where "n" keys and values
alternate, followed by the trailing NULL entry. The
caller must free the strings and the array after
use.

(Added in
1.9.17)

guestfs_inspect_get_filesystems

char ** 
guestfs_inspect_get_filesystems (guestfs_h *g, 
const char *root);

This returns a
list of all the filesystems that we think are associated
with this operating system. This includes the root
filesystem, other ordinary filesystems, and non-mounted
devices like swap partitions.

In the case of
a multi-boot virtual machine, it is possible for a
filesystem to be shared between operating systems.

Please read
"INSPECTION" for more details. See also
"guestfs_inspect_get_mountpoints".

This function
returns a NULL-terminated array of strings (like
environ(3)), or NULL if there was an error. The
caller must free the strings and the array after
use.

(Added in
1.5.3)

guestfs_inspect_get_format

char * 
guestfs_inspect_get_format (guestfs_h *g, 
const char *root);

This
function is deprecated. There is no replacement. Consult
the API documentation in guestfs(3) for further
information.

Deprecated
functions will not be removed from the API, but the fact
that they are deprecated indicates that there are problems
with correct use of these functions.

Before
libguestfs 1.38, there was some unreliable support for
detecting installer CDs. This API would return: 
"installed"

This is an installed operating
system.

"installer"

The disk image being inspected
is not an installed operating system, but a bootable
install disk, live CD, or similar.

"unknown"

The format of this disk image
is not known.

In libguestfs
&ge; 1.38, this only returns "installed". Use
libosinfo directly to detect installer CDs.

Please read
"INSPECTION" for more details.

This function
returns a string, or NULL on error. The caller must free
the returned string after use.

(Added in
1.9.4)

guestfs_inspect_get_hostname

char * 
guestfs_inspect_get_hostname (guestfs_h *g, 
const char *root);

This function
returns the hostname of the operating system as found by
inspection of the guest&rsquo;s configuration files.

If the hostname
could not be determined, then the string "unknown"
is returned.

Please read
"INSPECTION" for more details.

This function
returns a string, or NULL on error. The caller must free
the returned string after use.

(Added in
1.7.9)

guestfs_inspect_get_icon

char * 
guestfs_inspect_get_icon (guestfs_h *g, 
const char *root, 
size_t *size_r, 
...);

You may supply
a list of optional arguments to this call. Use zero or more
of the following pairs of parameters, and terminate the list
with -1 on its own. See "CALLS WITH OPTIONAL
ARGUMENTS".

GUESTFS_INSPECT_GET_ICON_FAVICON,
int favicon, 
GUESTFS_INSPECT_GET_ICON_HIGHQUALITY, int highquality,

This function
returns an icon corresponding to the inspected operating
system. The icon is returned as a buffer containing a PNG
image (re-encoded to PNG if necessary).

If it was not
possible to get an icon this function returns a zero-length
(non-NULL) buffer. Callers must check for this
case.

Libguestfs will
start by looking for a file called /etc/favicon.png
or C:\etc\favicon.png and if it has the correct
format, the contents of this file will be returned. You can
disable favicons by passing the optional "favicon"
boolean as false (default is true).

If finding the
favicon fails, then we look in other places in the guest for
a suitable icon.

If the optional
"highquality" boolean is true then only high
quality icons are returned, which means only icons of high
resolution with an alpha channel. The default (false) is to
return any icon we can, even if it is of substandard
quality.

Notes:

&bull;

Unlike most other inspection API calls, the
guest&rsquo;s disks must be mounted up before you call this,
since it needs to read information from the guest filesystem
during the call.

&bull;

Security: The icon data comes from the untrusted
guest, and should be treated with caution. PNG files have
been known to contain exploits. Ensure that libpng (or other
relevant libraries) are fully up to date before trying to
process or display the icon.

&bull;

The PNG image returned can be any size. It might not be
square. Libguestfs tries to return the largest, highest
quality icon available. The application must scale the icon
to the required size.

&bull;

Extracting icons from Windows guests requires the
external wrestool(1) program from the
"icoutils" package, and several programs
(bmptopnm(1), pnmtopng(1), pamcut(1))
from the "netpbm" package. These must be installed
separately. 

&bull;

Operating system icons are usually trademarks. Seek
legal advice before using trademarks in applications.

This function
returns a buffer, or NULL on error. The size of the returned
buffer is written to *size_r. The caller must free the
returned buffer after use.

(Added in
1.11.12)

guestfs_inspect_get_icon_va

char * 
guestfs_inspect_get_icon_va (guestfs_h *g, 
const char *root, 
size_t *size_r, 
va_list args);

This is the
"va_list variant" of
"guestfs_inspect_get_icon".

See "CALLS
WITH OPTIONAL ARGUMENTS".

guestfs_inspect_get_icon_argv

char * 
guestfs_inspect_get_icon_argv (guestfs_h *g, 
const char *root, 
size_t *size_r, 
const struct guestfs_inspect_get_icon_argv *optargs);

This is the
"argv variant" of
"guestfs_inspect_get_icon".

See "CALLS
WITH OPTIONAL ARGUMENTS".

guestfs_inspect_get_major_version

int 
guestfs_inspect_get_major_version (guestfs_h *g, 
const char *root);

This returns
the major version number of the inspected operating
system.

Windows uses a
consistent versioning scheme which is not reflected
in the popular public names used by the operating system.
Notably the operating system known as "Windows 7"
is really version 6.1 (ie. major = 6, minor = 1). You can
find out the real versions corresponding to releases of
Windows by consulting Wikipedia or MSDN.

If the version
could not be determined, then 0 is returned.

Please read
"INSPECTION" for more details.

On error this
function returns -1.

(Added in
1.5.3)

guestfs_inspect_get_minor_version

int 
guestfs_inspect_get_minor_version (guestfs_h *g, 
const char *root);

This returns
the minor version number of the inspected operating
system.

If the version
could not be determined, then 0 is returned.

Please read
"INSPECTION" for more details. See also
"guestfs_inspect_get_major_version".

On error this
function returns -1.

(Added in
1.5.3)

guestfs_inspect_get_mountpoints

char ** 
guestfs_inspect_get_mountpoints (guestfs_h *g, 
const char *root);

This returns a
hash of where we think the filesystems associated with this
operating system should be mounted. Callers should note that
this is at best an educated guess made by reading
configuration files such as /etc/fstab. In
particular note that this may return filesystems which
are non-existent or not mountable and callers should be
prepared to handle or ignore failures if they try to mount
them.

Each element in
the returned hashtable has a key which is the path of the
mountpoint (eg. /boot) and a value which is the
filesystem that would be mounted there (eg.
/dev/sda1).

Non-mounted
devices such as swap devices are not returned in this
list.

For operating
systems like Windows which still use drive letters, this
call will only return an entry for the first drive
"mounted on" /. For information about the
mapping of drive letters to partitions, see
"guestfs_inspect_get_drive_mappings".

Please read
"INSPECTION" for more details. See also
"guestfs_inspect_get_filesystems".

This function
returns a NULL-terminated array of strings, or NULL if there
was an error. The array of strings will always have length
"2n+1", where "n" keys and values
alternate, followed by the trailing NULL entry. The
caller must free the strings and the array after
use.

(Added in
1.5.3)

guestfs_inspect_get_osinfo

char * 
guestfs_inspect_get_osinfo (guestfs_h *g, 
const char *root);

This function
returns a possible short ID for libosinfo corresponding to
the guest.

Note:
The returned ID is only a guess by libguestfs, and nothing
ensures that it actually exists in osinfo-db.

If no ID could
not be determined, then the string "unknown" is
returned.

This function
returns a string, or NULL on error. The caller must free
the returned string after use.

(Added in
1.39.1)

guestfs_inspect_get_package_format

char * 
guestfs_inspect_get_package_format (guestfs_h *g, 
const char *root);

This function
and "guestfs_inspect_get_package_management"
return the package format and package management tool used
by the inspected operating system. For example for Fedora
these functions would return "rpm" (package
format), and "yum" or "dnf" (package
management).

This returns
the string "unknown" if we could not determine the
package format or if the operating system does not
have a real packaging system (eg. Windows).

Possible
strings include: "rpm", "deb",
"ebuild", "pisi", "pacman",
"pkgsrc", "apk", "xbps".
Future versions of libguestfs may return other strings.

Please read
"INSPECTION" for more details.

This function
returns a string, or NULL on error. The caller must free
the returned string after use.

(Added in
1.7.5)

guestfs_inspect_get_package_management

char * 
guestfs_inspect_get_package_management (guestfs_h *g, 
const char *root);

"guestfs_inspect_get_package_format"
and this function return the package format and package
management tool used by the inspected operating system. For
example for Fedora these functions would return
"rpm" (package format), and "yum" or
"dnf" (package management).

This returns
the string "unknown" if we could not determine the
package management tool or if the operating system
does not have a real packaging system (eg. Windows).

Possible
strings include: "yum", "dnf",
"up2date", "apt" (for all Debian
derivatives), "portage", "pisi",
"pacman", "urpmi", "zypper",
"apk", "xbps". Future versions of
libguestfs may return other strings.

Please read
"INSPECTION" for more details.

This function
returns a string, or NULL on error. The caller must free
the returned string after use.

(Added in
1.7.5)

guestfs_inspect_get_product_name

char * 
guestfs_inspect_get_product_name (guestfs_h *g, 
const char *root);

This returns
the product name of the inspected operating system. The
product name is generally some freeform string which can be
displayed to the user, but should not be parsed by
programs.

If the product
name could not be determined, then the string
"unknown" is returned.

Please read
"INSPECTION" for more details.

This function
returns a string, or NULL on error. The caller must free
the returned string after use.

(Added in
1.5.3)

guestfs_inspect_get_product_variant

char * 
guestfs_inspect_get_product_variant (guestfs_h *g, 
const char *root);

This returns
the product variant of the inspected operating system.

For Windows
guests, this returns the contents of the Registry key
"HKLM\Software\Microsoft\Windows
NT\CurrentVersion" "InstallationType" which
is usually a string such as "Client" or
"Server" (other values are possible). This can be
used to distinguish consumer and enterprise versions of
Windows that have the same version number (for example,
Windows 7 and Windows 2008 Server are both version 6.1, but
the former is "Client" and the latter is
"Server").

For enterprise
Linux guests, in future we intend this to return the product
variant such as "Desktop", "Server" and
so on. But this is not implemented at present.

If the product
variant could not be determined, then the string
"unknown" is returned.

Please read
"INSPECTION" for more details. See also
"guestfs_inspect_get_product_name",
"guestfs_inspect_get_major_version".

This function
returns a string, or NULL on error. The caller must free
the returned string after use.

(Added in
1.9.13)

guestfs_inspect_get_roots

char ** 
guestfs_inspect_get_roots (guestfs_h *g);

This function
is a convenient way to get the list of root devices, as
returned from a previous call to
"guestfs_inspect_os", but without redoing the
whole inspection process.

This returns an
empty list if either no root devices were found or the
caller has not called "guestfs_inspect_os".

Please read
"INSPECTION" for more details.

This function
returns a NULL-terminated array of strings (like
environ(3)), or NULL if there was an error. The
caller must free the strings and the array after
use.

(Added in
1.7.3)

guestfs_inspect_get_type

char * 
guestfs_inspect_get_type (guestfs_h *g, 
const char *root);

This returns
the type of the inspected operating system. Currently
defined types are: 
"linux"

Any Linux-based operating
system.

"windows"

Any Microsoft Windows operating
system.

"freebsd"

FreeBSD.

"netbsd"

NetBSD.

"openbsd"

OpenBSD.

"hurd"

GNU/Hurd.

"dos"

MS-DOS, FreeDOS and others.

"minix"

MINIX.

"unknown"

The operating system type could
not be determined.

Future versions
of libguestfs may return other strings here. The caller
should be prepared to handle any string.

Please read
"INSPECTION" for more details.

This function
returns a string, or NULL on error. The caller must free
the returned string after use.

(Added in
1.5.3)

guestfs_inspect_get_windows_current_control_set

char * 
guestfs_inspect_get_windows_current_control_set (guestfs_h
*g, 
const char *root);

This returns
the Windows CurrentControlSet of the inspected guest. The
CurrentControlSet is a registry key name such as
"ControlSet001".

This call
assumes that the guest is Windows and that the Registry
could be examined by inspection. If this is not the case
then an error is returned.

Please read
"INSPECTION" for more details.

This function
returns a string, or NULL on error. The caller must free
the returned string after use.

(Added in
1.9.17)

guestfs_inspect_get_windows_software_hive

char * 
guestfs_inspect_get_windows_software_hive (guestfs_h *g,

const char *root);

This returns
the path to the hive (binary Windows Registry file)
corresponding to HKLM\SOFTWARE.

This call
assumes that the guest is Windows and that the guest has a
software hive file with the right name. If this is not the
case then an error is returned. This call does not check
that the hive is a valid Windows Registry hive.

You can use
"guestfs_hivex_open" to read or write to the
hive.

Please read
"INSPECTION" for more details.

This function
returns a string, or NULL on error. The caller must free
the returned string after use.

(Added in
1.35.26)

guestfs_inspect_get_windows_system_hive

char * 
guestfs_inspect_get_windows_system_hive (guestfs_h *g, 
const char *root);

This returns
the path to the hive (binary Windows Registry file)
corresponding to HKLM\SYSTEM.

This call
assumes that the guest is Windows and that the guest has a
system hive file with the right name. If this is not the
case then an error is returned. This call does not check
that the hive is a valid Windows Registry hive.

You can use
"guestfs_hivex_open" to read or write to the
hive.

Please read
"INSPECTION" for more details.

This function
returns a string, or NULL on error. The caller must free
the returned string after use.

(Added in
1.35.26)

guestfs_inspect_get_windows_systemroot

char * 
guestfs_inspect_get_windows_systemroot (guestfs_h *g, 
const char *root);

This returns
the Windows systemroot of the inspected guest. The
systemroot is a directory path such as /WINDOWS.

This call
assumes that the guest is Windows and that the systemroot
could be determined by inspection. If this is not the case
then an error is returned.

Please read
"INSPECTION" for more details.

This function
returns a string, or NULL on error. The caller must free
the returned string after use.

(Added in
1.5.25)

guestfs_inspect_is_live

int 
guestfs_inspect_is_live (guestfs_h *g, 
const char *root);

This
function is deprecated. There is no replacement. Consult
the API documentation in guestfs(3) for further
information.

Deprecated
functions will not be removed from the API, but the fact
that they are deprecated indicates that there are problems
with correct use of these functions.

This is
deprecated and always returns "false".

Please read
"INSPECTION" for more details.

This function
returns a C truth value on success or -1 on error.

(Added in
1.9.4)

guestfs_inspect_is_multipart

int 
guestfs_inspect_is_multipart (guestfs_h *g, 
const char *root);

This
function is deprecated. There is no replacement. Consult
the API documentation in guestfs(3) for further
information.

Deprecated
functions will not be removed from the API, but the fact
that they are deprecated indicates that there are problems
with correct use of these functions.

This is
deprecated and always returns "false".

Please read
"INSPECTION" for more details.

This function
returns a C truth value on success or -1 on error.

(Added in
1.9.4)

guestfs_inspect_is_netinst

int 
guestfs_inspect_is_netinst (guestfs_h *g, 
const char *root);

This
function is deprecated. There is no replacement. Consult
the API documentation in guestfs(3) for further
information.

Deprecated
functions will not be removed from the API, but the fact
that they are deprecated indicates that there are problems
with correct use of these functions.

This is
deprecated and always returns "false".

Please read
"INSPECTION" for more details.

This function
returns a C truth value on success or -1 on error.

(Added in
1.9.4)

guestfs_inspect_list_applications

struct guestfs_application_list * 
guestfs_inspect_list_applications (guestfs_h *g, 
const char *root);

This
function is deprecated. In new code, use the
"guestfs_inspect_list_applications2" call
instead.

Deprecated
functions will not be removed from the API, but the fact
that they are deprecated indicates that there are problems
with correct use of these functions.

Return the list
of applications installed in the operating system.

Note:
This call works differently from other parts of the
inspection API. You have to call
"guestfs_inspect_os", then
"guestfs_inspect_get_mountpoints", then mount up
the disks, before calling this. Listing applications is a
significantly more difficult operation which requires access
to the full filesystem. Also note that unlike the other
"guestfs_inspect_get_*" calls which are just
returning data cached in the libguestfs handle, this call
actually reads parts of the mounted filesystems during the
call.

This returns an
empty list if the inspection code was not able to determine
the list of applications.

The application
structure contains the following fields: 
"app_name"

The name of the application.
For Linux guests, this is the package name.

"app_display_name"

The display name of the
application, sometimes localized to the install language of
the guest operating system.

If unavailable
this is returned as an empty string "". Callers
needing to display something can use "app_name"
instead.

"app_epoch"

For package managers which use
epochs, this contains the epoch of the package (an integer).
If unavailable, this is returned as 0.

"app_version"

The version string of the
application or package. If unavailable this is returned as
an empty string "".

"app_release"

The release string of the
application or package, for package managers that use this.
If unavailable this is returned as an empty string
"".

"app_install_path"

The installation path of the
application (on operating systems such as Windows which use
installation paths). This path is in the format used by the
guest operating system, it is not a libguestfs path.

If unavailable
this is returned as an empty string "".

"app_trans_path"

The install path translated
into a libguestfs path. If unavailable this is returned as
an empty string "".

"app_publisher"

The name of the publisher of
the application, for package managers that use this. If
unavailable this is returned as an empty string
"".

"app_url"

The URL (eg. upstream URL) of
the application. If unavailable this is returned as an empty
string "".

"app_source_package"

For packaging systems which
support this, the name of the source package. If unavailable
this is returned as an empty string "".

"app_summary"

A short (usually one line)
description of the application or package. If unavailable
this is returned as an empty string "".

"app_description"

A longer description of the
application or package. If unavailable this is returned as
an empty string "".

Please read
"INSPECTION" for more details.

This function
returns a "struct guestfs_application_list *", or
NULL if there was an error. The caller must call
"guestfs_free_application_list" after use.

(Added in
1.7.8)

guestfs_inspect_list_applications2

struct guestfs_application2_list * 
guestfs_inspect_list_applications2 (guestfs_h *g, 
const char *root);

Return the list
of applications installed in the operating system.

Note:
This call works differently from other parts of the
inspection API. You have to call
"guestfs_inspect_os", then
"guestfs_inspect_get_mountpoints", then mount up
the disks, before calling this. Listing applications is a
significantly more difficult operation which requires access
to the full filesystem. Also note that unlike the other
"guestfs_inspect_get_*" calls which are just
returning data cached in the libguestfs handle, this call
actually reads parts of the mounted filesystems during the
call.

This returns an
empty list if the inspection code was not able to determine
the list of applications.

The application
structure contains the following fields: 
"app2_name"

The name of the application.
For Linux guests, this is the package name.

"app2_display_name"

The display name of the
application, sometimes localized to the install language of
the guest operating system.

If unavailable
this is returned as an empty string "". Callers
needing to display something can use "app2_name"
instead.

"app2_epoch"

For package managers which use
epochs, this contains the epoch of the package (an integer).
If unavailable, this is returned as 0.

"app2_version"

The version string of the
application or package. If unavailable this is returned as
an empty string "".

"app2_release"

The release string of the
application or package, for package managers that use this.
If unavailable this is returned as an empty string
"".

"app2_arch"

The architecture string of the
application or package, for package managers that use this.
If unavailable this is returned as an empty string
"".

"app2_install_path"

The installation path of the
application (on operating systems such as Windows which use
installation paths). This path is in the format used by the
guest operating system, it is not a libguestfs path.

If unavailable
this is returned as an empty string "".

"app2_trans_path"

The install path translated
into a libguestfs path. If unavailable this is returned as
an empty string "".

"app2_publisher"

The name of the publisher of
the application, for package managers that use this. If
unavailable this is returned as an empty string
"".

"app2_url"

The URL (eg. upstream URL) of
the application. If unavailable this is returned as an empty
string "".

"app2_source_package"

For packaging systems which
support this, the name of the source package. If unavailable
this is returned as an empty string "".

"app2_summary"

A short (usually one line)
description of the application or package. If unavailable
this is returned as an empty string "".

"app2_description"

A longer description of the
application or package. If unavailable this is returned as
an empty string "".

Please read
"INSPECTION" for more details.

This function
returns a "struct guestfs_application2_list *", or
NULL if there was an error. The caller must call
"guestfs_free_application2_list" after
use.

(Added in
1.19.56)

guestfs_inspect_os

char ** 
guestfs_inspect_os (guestfs_h *g);

This function
uses other libguestfs functions and certain heuristics to
inspect the disk(s) (usually disks belonging to a virtual
machine), looking for operating systems.

The list
returned is empty if no operating systems were found.

If one
operating system was found, then this returns a list with a
single element, which is the name of the root filesystem of
this operating system. It is also possible for this function
to return a list containing more than one element,
indicating a dual-boot or multi-boot virtual machine, with
each element being the root filesystem of one of the
operating systems.

You can pass
the root string(s) returned to other
"guestfs_inspect_get_*" functions in order to
query further information about each operating system, such
as the name and version.

This function
uses other libguestfs features such as
"guestfs_mount_ro" and
"guestfs_umount_all" in order to mount and unmount
filesystems and look at the contents. This should be called
with no disks currently mounted. The function may also use
Augeas, so any existing Augeas handle will be closed.

This function
cannot decrypt encrypted disks. The caller must do that
first (supplying the necessary keys) if the disk is
encrypted.

Please read
"INSPECTION" for more details.

See also
"guestfs_list_filesystems".

This function
returns a NULL-terminated array of strings (like
environ(3)), or NULL if there was an error. The
caller must free the strings and the array after
use.

(Added in
1.5.3)

guestfs_is_blockdev

int 
guestfs_is_blockdev (guestfs_h *g, 
const char *path);

This function
is provided for backwards compatibility with earlier
versions of libguestfs. It simply calls
"guestfs_is_blockdev_opts" with no optional
arguments.

(Added in
1.5.10)

guestfs_is_blockdev_opts

int 
guestfs_is_blockdev_opts (guestfs_h *g, 
const char *path, 
...);

You may supply
a list of optional arguments to this call. Use zero or more
of the following pairs of parameters, and terminate the list
with -1 on its own. See "CALLS WITH OPTIONAL
ARGUMENTS".

GUESTFS_IS_BLOCKDEV_OPTS_FOLLOWSYMLINKS,
int followsymlinks,

This returns
"true" if and only if there is a block device with
the given "path" name.

If the optional
flag "followsymlinks" is true, then a symlink (or
chain of symlinks) that ends with a block device also causes
the function to return true.

This call only
looks at files within the guest filesystem. Libguestfs
partitions and block devices (eg. /dev/sda) cannot be
used as the "path" parameter of this call.

See also
"guestfs_stat".

This function
returns a C truth value on success or -1 on error.

(Added in
1.5.10)

guestfs_is_blockdev_opts_va

int 
guestfs_is_blockdev_opts_va (guestfs_h *g, 
const char *path, 
va_list args);

This is the
"va_list variant" of
"guestfs_is_blockdev_opts".

See "CALLS
WITH OPTIONAL ARGUMENTS".

guestfs_is_blockdev_opts_argv

int 
guestfs_is_blockdev_opts_argv (guestfs_h *g, 
const char *path, 
const struct guestfs_is_blockdev_opts_argv *optargs);

This is the
"argv variant" of
"guestfs_is_blockdev_opts".

See "CALLS
WITH OPTIONAL ARGUMENTS".

guestfs_is_busy

int 
guestfs_is_busy (guestfs_h *g);

This always
returns false. This function is deprecated with no
replacement. Do not use this function.

For more
information on states, see guestfs(3).

This function
returns a C truth value on success or -1 on error.

(Added in
1.0.2)

guestfs_is_chardev

int 
guestfs_is_chardev (guestfs_h *g, 
const char *path);

This function
is provided for backwards compatibility with earlier
versions of libguestfs. It simply calls
"guestfs_is_chardev_opts" with no optional
arguments.

(Added in
1.5.10)

guestfs_is_chardev_opts

int 
guestfs_is_chardev_opts (guestfs_h *g, 
const char *path, 
...);

You may supply
a list of optional arguments to this call. Use zero or more
of the following pairs of parameters, and terminate the list
with -1 on its own. See "CALLS WITH OPTIONAL
ARGUMENTS".

GUESTFS_IS_CHARDEV_OPTS_FOLLOWSYMLINKS,
int followsymlinks,

This returns
"true" if and only if there is a character device
with the given "path" name.

If the optional
flag "followsymlinks" is true, then a symlink (or
chain of symlinks) that ends with a chardev also causes the
function to return true.

See also
"guestfs_stat".

This function
returns a C truth value on success or -1 on error.

(Added in
1.5.10)

guestfs_is_chardev_opts_va

int 
guestfs_is_chardev_opts_va (guestfs_h *g, 
const char *path, 
va_list args);

This is the
"va_list variant" of
"guestfs_is_chardev_opts".

See "CALLS
WITH OPTIONAL ARGUMENTS".

guestfs_is_chardev_opts_argv

int 
guestfs_is_chardev_opts_argv (guestfs_h *g, 
const char *path, 
const struct guestfs_is_chardev_opts_argv *optargs);

This is the
"argv variant" of
"guestfs_is_chardev_opts".

See "CALLS
WITH OPTIONAL ARGUMENTS".

guestfs_is_config

int 
guestfs_is_config (guestfs_h *g);

This returns
true iff this handle is being configured (in the
"CONFIG" state).

For more
information on states, see guestfs(3).

This function
returns a C truth value on success or -1 on error.

(Added in
1.0.2)

guestfs_is_dir

int 
guestfs_is_dir (guestfs_h *g, 
const char *path);

This function
is provided for backwards compatibility with earlier
versions of libguestfs. It simply calls
"guestfs_is_dir_opts" with no optional
arguments.

(Added in
0.8)

guestfs_is_dir_opts

int 
guestfs_is_dir_opts (guestfs_h *g, 
const char *path, 
...);

You may supply
a list of optional arguments to this call. Use zero or more
of the following pairs of parameters, and terminate the list
with -1 on its own. See "CALLS WITH OPTIONAL
ARGUMENTS".

GUESTFS_IS_DIR_OPTS_FOLLOWSYMLINKS,
int followsymlinks,

This returns
"true" if and only if there is a directory with
the given "path" name. Note that it returns false
for other objects like files.

If the optional
flag "followsymlinks" is true, then a symlink (or
chain of symlinks) that ends with a directory also causes
the function to return true.

See also
"guestfs_stat".

This function
returns a C truth value on success or -1 on error.

(Added in
0.8)

guestfs_is_dir_opts_va

int 
guestfs_is_dir_opts_va (guestfs_h *g, 
const char *path, 
va_list args);

This is the
"va_list variant" of
"guestfs_is_dir_opts".

See "CALLS
WITH OPTIONAL ARGUMENTS".

guestfs_is_dir_opts_argv

int 
guestfs_is_dir_opts_argv (guestfs_h *g, 
const char *path, 
const struct guestfs_is_dir_opts_argv *optargs);

This is the
"argv variant" of
"guestfs_is_dir_opts".

See "CALLS
WITH OPTIONAL ARGUMENTS".

guestfs_is_fifo

int 
guestfs_is_fifo (guestfs_h *g, 
const char *path);

This function
is provided for backwards compatibility with earlier
versions of libguestfs. It simply calls
"guestfs_is_fifo_opts" with no optional
arguments.

(Added in
1.5.10)

guestfs_is_fifo_opts

int 
guestfs_is_fifo_opts (guestfs_h *g, 
const char *path, 
...);

You may supply
a list of optional arguments to this call. Use zero or more
of the following pairs of parameters, and terminate the list
with -1 on its own. See "CALLS WITH OPTIONAL
ARGUMENTS".

GUESTFS_IS_FIFO_OPTS_FOLLOWSYMLINKS,
int followsymlinks,

This returns
"true" if and only if there is a FIFO (named pipe)
with the given "path" name.

If the optional
flag "followsymlinks" is true, then a symlink (or
chain of symlinks) that ends with a FIFO also causes the
function to return true.

See also
"guestfs_stat".

This function
returns a C truth value on success or -1 on error.

(Added in
1.5.10)

guestfs_is_fifo_opts_va

int 
guestfs_is_fifo_opts_va (guestfs_h *g, 
const char *path, 
va_list args);

This is the
"va_list variant" of
"guestfs_is_fifo_opts".

See "CALLS
WITH OPTIONAL ARGUMENTS".

guestfs_is_fifo_opts_argv

int 
guestfs_is_fifo_opts_argv (guestfs_h *g, 
const char *path, 
const struct guestfs_is_fifo_opts_argv *optargs);

This is the
"argv variant" of
"guestfs_is_fifo_opts".

See "CALLS
WITH OPTIONAL ARGUMENTS".

guestfs_is_file

int 
guestfs_is_file (guestfs_h *g, 
const char *path);

This function
is provided for backwards compatibility with earlier
versions of libguestfs. It simply calls
"guestfs_is_file_opts" with no optional
arguments.

(Added in
0.8)

guestfs_is_file_opts

int 
guestfs_is_file_opts (guestfs_h *g, 
const char *path, 
...);

You may supply
a list of optional arguments to this call. Use zero or more
of the following pairs of parameters, and terminate the list
with -1 on its own. See "CALLS WITH OPTIONAL
ARGUMENTS".

GUESTFS_IS_FILE_OPTS_FOLLOWSYMLINKS,
int followsymlinks,

This returns
"true" if and only if there is a regular file with
the given "path" name. Note that it returns false
for other objects like directories.

If the optional
flag "followsymlinks" is true, then a symlink (or
chain of symlinks) that ends with a file also causes the
function to return true.

See also
"guestfs_stat".

This function
returns a C truth value on success or -1 on error.

(Added in
0.8)

guestfs_is_file_opts_va

int 
guestfs_is_file_opts_va (guestfs_h *g, 
const char *path, 
va_list args);

This is the
"va_list variant" of
"guestfs_is_file_opts".

See "CALLS
WITH OPTIONAL ARGUMENTS".

guestfs_is_file_opts_argv

int 
guestfs_is_file_opts_argv (guestfs_h *g, 
const char *path, 
const struct guestfs_is_file_opts_argv *optargs);

This is the
"argv variant" of
"guestfs_is_file_opts".

See "CALLS
WITH OPTIONAL ARGUMENTS".

guestfs_is_launching

int 
guestfs_is_launching (guestfs_h *g);

This returns
true iff this handle is launching the subprocess (in the
"LAUNCHING" state).

For more
information on states, see guestfs(3).

This function
returns a C truth value on success or -1 on error.

(Added in
1.0.2)

guestfs_is_lv

int 
guestfs_is_lv (guestfs_h *g, 
const char *mountable);

This command
tests whether "mountable" is a logical volume, and
returns true iff this is the case.

This function
returns a C truth value on success or -1 on error.

(Added in
1.5.3)

guestfs_is_ready

int 
guestfs_is_ready (guestfs_h *g);

This returns
true iff this handle is ready to accept commands (in the
"READY" state).

For more
information on states, see guestfs(3).

This function
returns a C truth value on success or -1 on error.

(Added in
1.0.2)

guestfs_is_socket

int 
guestfs_is_socket (guestfs_h *g, 
const char *path);

This function
is provided for backwards compatibility with earlier
versions of libguestfs. It simply calls
"guestfs_is_socket_opts" with no optional
arguments.

(Added in
1.5.10)

guestfs_is_socket_opts

int 
guestfs_is_socket_opts (guestfs_h *g, 
const char *path, 
...);

You may supply
a list of optional arguments to this call. Use zero or more
of the following pairs of parameters, and terminate the list
with -1 on its own. See "CALLS WITH OPTIONAL
ARGUMENTS".

GUESTFS_IS_SOCKET_OPTS_FOLLOWSYMLINKS,
int followsymlinks,

This returns
"true" if and only if there is a Unix domain
socket with the given "path" name.

If the optional
flag "followsymlinks" is true, then a symlink (or
chain of symlinks) that ends with a socket also causes the
function to return true.

See also
"guestfs_stat".

This function
returns a C truth value on success or -1 on error.

(Added in
1.5.10)

guestfs_is_socket_opts_va

int 
guestfs_is_socket_opts_va (guestfs_h *g, 
const char *path, 
va_list args);

This is the
"va_list variant" of
"guestfs_is_socket_opts".

See "CALLS
WITH OPTIONAL ARGUMENTS".

guestfs_is_socket_opts_argv

int 
guestfs_is_socket_opts_argv (guestfs_h *g, 
const char *path, 
const struct guestfs_is_socket_opts_argv *optargs);

This is the
"argv variant" of
"guestfs_is_socket_opts".

See "CALLS
WITH OPTIONAL ARGUMENTS".

guestfs_is_symlink

int 
guestfs_is_symlink (guestfs_h *g, 
const char *path);

This returns
"true" if and only if there is a symbolic link
with the given "path" name.

See also
"guestfs_stat".

This function
returns a C truth value on success or -1 on error.

(Added in
1.5.10)

guestfs_is_whole_device

int 
guestfs_is_whole_device (guestfs_h *g, 
const char *device);

This returns
"true" if and only if "device" refers to
a whole block device. That is, not a partition or a logical
device.

This function
returns a C truth value on success or -1 on error.

(Added in
1.21.9)

guestfs_is_zero

int 
guestfs_is_zero (guestfs_h *g, 
const char *path);

This returns
true iff the file exists and the file is empty or it
contains all zero bytes.

This function
returns a C truth value on success or -1 on error.

(Added in
1.11.8)

guestfs_is_zero_device

int 
guestfs_is_zero_device (guestfs_h *g, 
const char *device);

This returns
true iff the device exists and contains all zero bytes.

Note that for
large devices this can take a long time to run.

This function
returns a C truth value on success or -1 on error.

(Added in
1.11.8)

guestfs_isoinfo

struct guestfs_isoinfo * 
guestfs_isoinfo (guestfs_h *g, 
const char *isofile);

This is the
same as "guestfs_isoinfo_device" except that it
works for an ISO file located inside some other mounted
filesystem. Note that in the common case where you have
added an ISO file as a libguestfs device, you would
not call this. Instead you would call
"guestfs_isoinfo_device".

This function
returns a "struct guestfs_isoinfo *", or NULL if
there was an error. The caller must call
"guestfs_free_isoinfo" after use.

(Added in
1.17.19)

guestfs_isoinfo_device

struct guestfs_isoinfo * 
guestfs_isoinfo_device (guestfs_h *g, 
const char *device);

"device"
is an ISO device. This returns a struct of information read
from the primary volume descriptor (the ISO equivalent of
the superblock) of the device.

Usually it is
more efficient to use the isoinfo(1) command with the
-d option on the host to analyze ISO files, instead
of going through libguestfs.

For information
on the primary volume descriptor fields, see
https://wiki.osdev.org/ISO_9660#The_Primary_Volume_Descriptor

This function
returns a "struct guestfs_isoinfo *", or NULL if
there was an error. The caller must call
"guestfs_free_isoinfo" after use.

(Added in
1.17.19)

guestfs_journal_close

int 
guestfs_journal_close (guestfs_h *g);

Close the
journal handle.

This function
returns 0 on success or -1 on error.

This function
depends on the feature "journal". See also
"guestfs_feature_available".

(Added in
1.23.11)

guestfs_journal_get

struct guestfs_xattr_list * 
guestfs_journal_get (guestfs_h *g);

Read the
current journal entry. This returns all the fields in the
journal as a set of "(attrname, attrval)" pairs.
The "attrname" is the field name (a string).

The
"attrval" is the field value (a binary blob, often
but not always a string). Please note that
"attrval" is a byte array, not a
\0-terminated C string.

The length of
data may be truncated to the data threshold (see:
"guestfs_journal_set_data_threshold",
"guestfs_journal_get_data_threshold").

If you set the
data threshold to unlimited (0) then this call can read a
journal entry of any size, ie. it is not limited by the
libguestfs protocol.

This function
returns a "struct guestfs_xattr_list *", or NULL
if there was an error. The caller must call
"guestfs_free_xattr_list" after use.

This function
depends on the feature "journal". See also
"guestfs_feature_available".

(Added in
1.23.11)

guestfs_journal_get_data_threshold

int64_t 
guestfs_journal_get_data_threshold (guestfs_h *g);

Get the current
data threshold for reading journal entries. This is a hint
to the journal that it may truncate data fields to this size
when reading them (note also that it may not truncate them).
If this returns 0, then the threshold is unlimited.

See also
"guestfs_journal_set_data_threshold".

On error this
function returns -1.

This function
depends on the feature "journal". See also
"guestfs_feature_available".

(Added in
1.23.11)

guestfs_journal_get_realtime_usec

int64_t 
guestfs_journal_get_realtime_usec (guestfs_h *g);

Get the
realtime (wallclock) timestamp of the current journal
entry.

On error this
function returns -1.

This function
depends on the feature "journal". See also
"guestfs_feature_available".

(Added in
1.27.18)

guestfs_journal_next

int 
guestfs_journal_next (guestfs_h *g);

Move to the
next journal entry. You have to call this at least once
after opening the handle before you are able to read
data.

The returned
boolean tells you if there are any more journal records to
read. "true" means you can read the next record
(eg. using "guestfs_journal_get"), and
"false" means you have reached the end of the
journal.

This function
returns a C truth value on success or -1 on error.

This function
depends on the feature "journal". See also
"guestfs_feature_available".

(Added in
1.23.11)

guestfs_journal_open

int 
guestfs_journal_open (guestfs_h *g, 
const char *directory);

Open the
systemd journal located in directory. Any previously
opened journal handle is closed.

The contents of
the journal can be read using
"guestfs_journal_next" and
"guestfs_journal_get".

After you have
finished using the journal, you should close the handle by
calling "guestfs_journal_close".

This function
returns 0 on success or -1 on error.

This function
depends on the feature "journal". See also
"guestfs_feature_available".

(Added in
1.23.11)

guestfs_journal_set_data_threshold

int 
guestfs_journal_set_data_threshold (guestfs_h *g, 
int64_t threshold);

Set the data
threshold for reading journal entries. This is a hint to the
journal that it may truncate data fields to this size when
reading them (note also that it may not truncate them). If
you set this to 0, then the threshold is unlimited.

See also
"guestfs_journal_get_data_threshold".

This function
returns 0 on success or -1 on error.

This function
depends on the feature "journal". See also
"guestfs_feature_available".

(Added in
1.23.11)

guestfs_journal_skip

int64_t 
guestfs_journal_skip (guestfs_h *g, 
int64_t skip);

Skip forwards
("skip &ge; 0") or backwards ("skip 

The number of
entries actually skipped is returned (note
"rskip &ge; 0"). If this is not the same
as the absolute value of the skip parameter
("|skip|") you passed in then it means you have
reached the end or the start of the journal.

On error this
function returns -1.

This function
depends on the feature "journal". See also
"guestfs_feature_available".

(Added in
1.23.11)

guestfs_kill_subprocess

int 
guestfs_kill_subprocess (guestfs_h *g);

This
function is deprecated. In new code, use the
"guestfs_shutdown" call instead.

Deprecated
functions will not be removed from the API, but the fact
that they are deprecated indicates that there are problems
with correct use of these functions.

This kills the
hypervisor.

Do not call
this. See: "guestfs_shutdown" instead.

This function
returns 0 on success or -1 on error.

(Added in
0.3)

guestfs_launch

int 
guestfs_launch (guestfs_h *g);

You should call
this after configuring the handle (eg. adding drives) but
before performing any actions.

Do not call
"guestfs_launch" twice on the same handle.
Although it will not give an error (for historical reasons),
the precise behaviour when you do this is not well defined.
Handles are very cheap to create, so create a new one for
each launch.

This function
returns 0 on success or -1 on error.

This
long-running command can generate progress notification
messages so that the caller can display a progress bar or
indicator. To receive these messages, the caller must
register a progress event callback. See
"GUESTFS_EVENT_PROGRESS".

(Added in
0.3)

guestfs_lchown

int 
guestfs_lchown (guestfs_h *g, 
int owner, 
int group, 
const char *path);

Change the file
owner to "owner" and group to "group".
This is like "guestfs_chown" but if
"path" is a symlink then the link itself is
changed, not the target.

Only numeric
uid and gid are supported. If you want to use names, you
will need to locate and parse the password file yourself
(Augeas support makes this relatively easy).

This function
returns 0 on success or -1 on error.

(Added in
1.0.77)

guestfs_ldmtool_create_all

int 
guestfs_ldmtool_create_all (guestfs_h *g);

This function
scans all block devices looking for Windows dynamic disk
volumes and partitions, and creates devices for any that
were found.

Call
"guestfs_list_ldm_volumes" and
"guestfs_list_ldm_partitions" to return all
devices.

Note that you
don&rsquo;t normally need to call this explicitly,
since it is done automatically at "guestfs_launch"
time.

This function
returns 0 on success or -1 on error.

This function
depends on the feature "ldm". See also
"guestfs_feature_available".

(Added in
1.20.0)

guestfs_ldmtool_diskgroup_disks

char ** 
guestfs_ldmtool_diskgroup_disks (guestfs_h *g, 
const char *diskgroup);

Return the
disks in a Windows dynamic disk group. The
"diskgroup" parameter should be the GUID of a disk
group, one element from the list returned by
"guestfs_ldmtool_scan".

This function
returns a NULL-terminated array of strings (like
environ(3)), or NULL if there was an error. The
caller must free the strings and the array after
use.

This function
depends on the feature "ldm". See also
"guestfs_feature_available".

(Added in
1.20.0)

guestfs_ldmtool_diskgroup_name

char * 
guestfs_ldmtool_diskgroup_name (guestfs_h *g, 
const char *diskgroup);

Return the name
of a Windows dynamic disk group. The "diskgroup"
parameter should be the GUID of a disk group, one element
from the list returned by
"guestfs_ldmtool_scan".

This function
returns a string, or NULL on error. The caller must free
the returned string after use.

This function
depends on the feature "ldm". See also
"guestfs_feature_available".

(Added in
1.20.0)

guestfs_ldmtool_diskgroup_volumes

char ** 
guestfs_ldmtool_diskgroup_volumes (guestfs_h *g, 
const char *diskgroup);

Return the
volumes in a Windows dynamic disk group. The
"diskgroup" parameter should be the GUID of a disk
group, one element from the list returned by
"guestfs_ldmtool_scan".

This function
returns a NULL-terminated array of strings (like
environ(3)), or NULL if there was an error. The
caller must free the strings and the array after
use.

This function
depends on the feature "ldm". See also
"guestfs_feature_available".

(Added in
1.20.0)

guestfs_ldmtool_remove_all

int 
guestfs_ldmtool_remove_all (guestfs_h *g);

This is
essentially the opposite of
"guestfs_ldmtool_create_all". It removes the
device mapper mappings for all Windows dynamic disk
volumes

This function
returns 0 on success or -1 on error.

This function
depends on the feature "ldm". See also
"guestfs_feature_available".

(Added in
1.20.0)

guestfs_ldmtool_scan

char ** 
guestfs_ldmtool_scan (guestfs_h *g);

This function
scans for Windows dynamic disks. It returns a list of
identifiers (GUIDs) for all disk groups that were found.
These identifiers can be passed to other
"guestfs_ldmtool_*" functions.

This function
scans all block devices. To scan a subset of block devices,
call "guestfs_ldmtool_scan_devices" instead.

This function
returns a NULL-terminated array of strings (like
environ(3)), or NULL if there was an error. The
caller must free the strings and the array after
use.

This function
depends on the feature "ldm". See also
"guestfs_feature_available".

(Added in
1.20.0)

guestfs_ldmtool_scan_devices

char ** 
guestfs_ldmtool_scan_devices (guestfs_h *g, 
char *const *devices);

This function
scans for Windows dynamic disks. It returns a list of
identifiers (GUIDs) for all disk groups that were found.
These identifiers can be passed to other
"guestfs_ldmtool_*" functions.

The parameter
"devices" is a list of block devices which are
scanned. If this list is empty, all block devices are
scanned.

This function
returns a NULL-terminated array of strings (like
environ(3)), or NULL if there was an error. The
caller must free the strings and the array after
use.

This function
depends on the feature "ldm". See also
"guestfs_feature_available".

(Added in
1.20.0)

guestfs_ldmtool_volume_hint

char * 
guestfs_ldmtool_volume_hint (guestfs_h *g, 
const char *diskgroup, 
const char *volume);

Return the hint
field of the volume named "volume" in the disk
group with GUID "diskgroup". This may not be
defined, in which case the empty string is returned. The
hint field is often, though not always, the name of a
Windows drive, eg. "E:".

This function
returns a string, or NULL on error. The caller must free
the returned string after use.

This function
depends on the feature "ldm". See also
"guestfs_feature_available".

(Added in
1.20.0)

guestfs_ldmtool_volume_partitions

char ** 
guestfs_ldmtool_volume_partitions (guestfs_h *g, 
const char *diskgroup, 
const char *volume);

Return the list
of partitions in the volume named "volume" in the
disk group with GUID "diskgroup".

This function
returns a NULL-terminated array of strings (like
environ(3)), or NULL if there was an error. The
caller must free the strings and the array after
use.

This function
depends on the feature "ldm". See also
"guestfs_feature_available".

(Added in
1.20.0)

guestfs_ldmtool_volume_type

char * 
guestfs_ldmtool_volume_type (guestfs_h *g, 
const char *diskgroup, 
const char *volume);

Return the type
of the volume named "volume" in the disk group
with GUID "diskgroup".

Possible volume
types that can be returned here include: "simple",
"spanned", "striped",
"mirrored", "raid5". Other types may
also be returned.

This function
returns a string, or NULL on error. The caller must free
the returned string after use.

This function
depends on the feature "ldm". See also
"guestfs_feature_available".

(Added in
1.20.0)

guestfs_lgetxattr

char * 
guestfs_lgetxattr (guestfs_h *g, 
const char *path, 
const char *name, 
size_t *size_r);

Get a single
extended attribute from file "path" named
"name". If "path" is a symlink, then
this call returns an extended attribute from the
symlink.

Normally it is
better to get all extended attributes from a file in one go
by calling "guestfs_getxattrs". However some Linux
filesystem implementations are buggy and do not provide a
way to list out attributes. For these filesystems (notably
ntfs-3g) you have to know the names of the extended
attributes you want in advance and call this function.

Extended
attribute values are blobs of binary data. If there is no
extended attribute named "name", this returns an
error.

See also:
"guestfs_lgetxattrs",
"guestfs_getxattr", attr(5).

This function
returns a buffer, or NULL on error. The size of the returned
buffer is written to *size_r. The caller must free the
returned buffer after use.

This function
depends on the feature "linuxxattrs". See also
"guestfs_feature_available".

(Added in
1.7.24)

guestfs_lgetxattrs

struct guestfs_xattr_list * 
guestfs_lgetxattrs (guestfs_h *g, 
const char *path);

This is the
same as "guestfs_getxattrs", but if
"path" is a symbolic link, then it returns the
extended attributes of the link itself.

This function
returns a "struct guestfs_xattr_list *", or NULL
if there was an error. The caller must call
"guestfs_free_xattr_list" after use.

This function
depends on the feature "linuxxattrs". See also
"guestfs_feature_available".

(Added in
1.0.59)

guestfs_list_9p

char ** 
guestfs_list_9p (guestfs_h *g);

This
function is deprecated. There is no replacement. Consult
the API documentation in guestfs(3) for further
information.

Deprecated
functions will not be removed from the API, but the fact
that they are deprecated indicates that there are problems
with correct use of these functions.

This call does
nothing and returns an error.

This function
returns a NULL-terminated array of strings (like
environ(3)), or NULL if there was an error. The
caller must free the strings and the array after
use.

(Added in
1.11.12)

guestfs_list_devices

char ** 
guestfs_list_devices (guestfs_h *g);

List all the
block devices.

The full block
device names are returned, eg. /dev/sda.

See also
"guestfs_list_filesystems".

This function
returns a NULL-terminated array of strings (like
environ(3)), or NULL if there was an error. The
caller must free the strings and the array after
use.

(Added in
0.4)

guestfs_list_disk_labels

char ** 
guestfs_list_disk_labels (guestfs_h *g);

If you add
drives using the optional "label" parameter of
"guestfs_add_drive_opts", you can use this call to
map between disk labels, and raw block device and partition
names (like /dev/sda and /dev/sda1).

This returns a
hashtable, where keys are the disk labels (without
the /dev/disk/guestfs prefix), and the values are the
full raw block device and partition names (eg.
/dev/sda and /dev/sda1).

This function
returns a NULL-terminated array of strings, or NULL if there
was an error. The array of strings will always have length
"2n+1", where "n" keys and values
alternate, followed by the trailing NULL entry. The
caller must free the strings and the array after
use.

(Added in
1.19.49)

guestfs_list_dm_devices

char ** 
guestfs_list_dm_devices (guestfs_h *g);

List all device
mapper devices.

The returned
list contains /dev/mapper/* devices, eg. ones created
by a previous call to "guestfs_luks_open".

Device mapper
devices which correspond to logical volumes are not
returned in this list. Call "guestfs_lvs" if you
want to list logical volumes.

This function
returns a NULL-terminated array of strings (like
environ(3)), or NULL if there was an error. The
caller must free the strings and the array after
use.

(Added in
1.11.15)

guestfs_list_filesystems

char ** 
guestfs_list_filesystems (guestfs_h *g);

This inspection
command looks for filesystems on partitions, block devices
and logical volumes, returning a list of
"mountables" containing filesystems and their
type.

The return
value is a hash, where the keys are the devices containing
filesystems, and the values are the filesystem types. For
example:

"/dev/sda1"
=> "ntfs" 
"/dev/sda2" => "ext2" 
"/dev/vg_guest/lv_root" => "ext4"

"/dev/vg_guest/lv_swap" => "swap"

The key is not
necessarily a block device. It may also be an opaque
&rsquo;mountable&rsquo; string which can be passed to
"guestfs_mount".

The value can
have the special value "unknown", meaning the
content of the device is undetermined or empty.
"swap" means a Linux swap partition.

In libguestfs
&le; 1.36 this command ran other libguestfs commands, which
might have included "guestfs_mount" and
"guestfs_umount", and therefore you had to use
this soon after launch and only when nothing else was
mounted. This restriction is removed in libguestfs &ge;
1.38.

Not all of the
filesystems returned will be mountable. In particular, swap
partitions are returned in the list. Also this command does
not check that each filesystem found is valid and mountable,
and some filesystems might be mountable but require special
options. Filesystems may not all belong to a single logical
operating system (use "guestfs_inspect_os" to look
for OSes).

This function
returns a NULL-terminated array of strings, or NULL if there
was an error. The array of strings will always have length
"2n+1", where "n" keys and values
alternate, followed by the trailing NULL entry. The
caller must free the strings and the array after
use.

(Added in
1.5.15)

guestfs_list_ldm_partitions

char ** 
guestfs_list_ldm_partitions (guestfs_h *g);

This function
returns all Windows dynamic disk partitions that were found
at launch time. It returns a list of device names.

This function
returns a NULL-terminated array of strings (like
environ(3)), or NULL if there was an error. The
caller must free the strings and the array after
use.

This function
depends on the feature "ldm". See also
"guestfs_feature_available".

(Added in
1.20.0)

guestfs_list_ldm_volumes

char ** 
guestfs_list_ldm_volumes (guestfs_h *g);

This function
returns all Windows dynamic disk volumes that were found at
launch time. It returns a list of device names.

This function
returns a NULL-terminated array of strings (like
environ(3)), or NULL if there was an error. The
caller must free the strings and the array after
use.

This function
depends on the feature "ldm". See also
"guestfs_feature_available".

(Added in
1.20.0)

guestfs_list_md_devices

char ** 
guestfs_list_md_devices (guestfs_h *g);

List all Linux
md devices.

This function
returns a NULL-terminated array of strings (like
environ(3)), or NULL if there was an error. The
caller must free the strings and the array after
use.

(Added in
1.15.4)

guestfs_list_partitions

char ** 
guestfs_list_partitions (guestfs_h *g);

List all the
partitions detected on all block devices.

The full
partition device names are returned, eg.
/dev/sda1

This does not
return logical volumes. For that you will need to call
"guestfs_lvs".

See also
"guestfs_list_filesystems".

This function
returns a NULL-terminated array of strings (like
environ(3)), or NULL if there was an error. The
caller must free the strings and the array after
use.

(Added in
0.4)

guestfs_ll

char * 
guestfs_ll (guestfs_h *g, 
const char *directory);

List the files
in directory (relative to the root directory, there
is no cwd) in the format of "ls -la".

This command is
mostly useful for interactive sessions. It is not
intended that you try to parse the output string.

This function
returns a string, or NULL on error. The caller must free
the returned string after use.

(Added in
0.4)

guestfs_llz

char * 
guestfs_llz (guestfs_h *g, 
const char *directory);

This
function is deprecated. In new code, use the
"guestfs_lgetxattrs" call instead.

Deprecated
functions will not be removed from the API, but the fact
that they are deprecated indicates that there are problems
with correct use of these functions.

List the files
in directory in the format of "ls
-laZ".

This command is
mostly useful for interactive sessions. It is not
intended that you try to parse the output string.

This function
returns a string, or NULL on error. The caller must free
the returned string after use.

(Added in
1.17.6)

guestfs_ln

int 
guestfs_ln (guestfs_h *g, 
const char *target, 
const char *linkname);

This command
creates a hard link.

This function
returns 0 on success or -1 on error.

(Added in
1.0.66)

guestfs_ln_f

int 
guestfs_ln_f (guestfs_h *g, 
const char *target, 
const char *linkname);

This command
creates a hard link, removing the link "linkname"
if it exists already.

This function
returns 0 on success or -1 on error.

(Added in
1.0.66)

guestfs_ln_s

int 
guestfs_ln_s (guestfs_h *g, 
const char *target, 
const char *linkname);

This command
creates a symbolic link using the "ln -s"
command.

This function
returns 0 on success or -1 on error.

(Added in
1.0.66)

guestfs_ln_sf

int 
guestfs_ln_sf (guestfs_h *g, 
const char *target, 
const char *linkname);

This command
creates a symbolic link using the "ln -sf"
command, The -f option removes the link
("linkname") if it exists already.

This function
returns 0 on success or -1 on error.

(Added in
1.0.66)

guestfs_lremovexattr

int 
guestfs_lremovexattr (guestfs_h *g, 
const char *xattr, 
const char *path);

This is the
same as "guestfs_removexattr", but if
"path" is a symbolic link, then it removes an
extended attribute of the link itself.

This function
returns 0 on success or -1 on error.

This function
depends on the feature "linuxxattrs". See also
"guestfs_feature_available".

(Added in
1.0.59)

guestfs_ls

char ** 
guestfs_ls (guestfs_h *g, 
const char *directory);

List the files
in directory (relative to the root directory, there
is no cwd). The "." and ".." entries are
not returned, but hidden files are shown.

This function
returns a NULL-terminated array of strings (like
environ(3)), or NULL if there was an error. The
caller must free the strings and the array after
use.

(Added in
0.4)

guestfs_ls0

int 
guestfs_ls0 (guestfs_h *g, 
const char *dir, 
const char *filenames);

This
specialized command is used to get a listing of the
filenames in the directory "dir". The list of
filenames is written to the local file filenames (on
the host).

In the output
file, the filenames are separated by "\0"
characters.

"."
and ".." are not returned. The filenames are not
sorted.

This function
returns 0 on success or -1 on error.

(Added in
1.19.32)

guestfs_lsetxattr

int 
guestfs_lsetxattr (guestfs_h *g, 
const char *xattr, 
const char *val, 
int vallen, 
const char *path);

This is the
same as "guestfs_setxattr", but if
"path" is a symbolic link, then it sets an
extended attribute of the link itself.

This function
returns 0 on success or -1 on error.

This function
depends on the feature "linuxxattrs". See also
"guestfs_feature_available".

(Added in
1.0.59)

guestfs_lstat

struct guestfs_stat * 
guestfs_lstat (guestfs_h *g, 
const char *path);

This
function is deprecated. In new code, use the
"guestfs_lstatns" call instead.

Deprecated
functions will not be removed from the API, but the fact
that they are deprecated indicates that there are problems
with correct use of these functions.

Returns file
information for the given "path".

This is the
same as "guestfs_stat" except that if
"path" is a symbolic link, then the link is
stat-ed, not the file it refers to.

This is the
same as the lstat(2) system call.

This function
returns a "struct guestfs_stat *", or NULL if
there was an error. The caller must call
"guestfs_free_stat" after use.

(Added in
1.9.2)

guestfs_lstatlist

struct guestfs_stat_list * 
guestfs_lstatlist (guestfs_h *g, 
const char *path, 
char *const *names);

This
function is deprecated. In new code, use the
"guestfs_lstatnslist" call instead.

Deprecated
functions will not be removed from the API, but the fact
that they are deprecated indicates that there are problems
with correct use of these functions.

This call
allows you to perform the "guestfs_lstat"
operation on multiple files, where all files are in the
directory "path". "names" is the list of
files from this directory.

On return you
get a list of stat structs, with a one-to-one correspondence
to the "names" list. If any name did not exist or
could not be lstat&rsquo;d, then the "st_ino"
field of that structure is set to -1.

This call is
intended for programs that want to efficiently list a
directory contents without making many round-trips. See also
"guestfs_lxattrlist" for a similarly efficient
call for getting extended attributes.

This function
returns a "struct guestfs_stat_list *", or NULL if
there was an error. The caller must call
"guestfs_free_stat_list" after use.

(Added in
1.0.77)

guestfs_lstatns

struct guestfs_statns * 
guestfs_lstatns (guestfs_h *g, 
const char *path);

Returns file
information for the given "path".

This is the
same as "guestfs_statns" except that if
"path" is a symbolic link, then the link is
stat-ed, not the file it refers to.

This is the
same as the lstat(2) system call.

This function
returns a "struct guestfs_statns *", or NULL if
there was an error. The caller must call
"guestfs_free_statns" after use.

(Added in
1.27.53)

guestfs_lstatnslist

struct guestfs_statns_list * 
guestfs_lstatnslist (guestfs_h *g, 
const char *path, 
char *const *names);

This call
allows you to perform the "guestfs_lstatns"
operation on multiple files, where all files are in the
directory "path". "names" is the list of
files from this directory.

On return you
get a list of stat structs, with a one-to-one correspondence
to the "names" list. If any name did not exist or
could not be lstat&rsquo;d, then the "st_ino"
field of that structure is set to -1.

This call is
intended for programs that want to efficiently list a
directory contents without making many round-trips. See also
"guestfs_lxattrlist" for a similarly efficient
call for getting extended attributes.

This function
returns a "struct guestfs_statns_list *", or NULL
if there was an error. The caller must call
"guestfs_free_statns_list" after use.

(Added in
1.27.53)

guestfs_luks_add_key

int 
guestfs_luks_add_key (guestfs_h *g, 
const char *device, 
const char *key, 
const char *newkey, 
int keyslot);

This command
adds a new key on LUKS device "device".
"key" is any existing key, and is used to access
the device. "newkey" is the new key to add.
"keyslot" is the key slot that will be
replaced.

Note that if
"keyslot" already contains a key, then this
command will fail. You have to use
"guestfs_luks_kill_slot" first to remove that
key.

This function
returns 0 on success or -1 on error.

This function
takes a key or passphrase parameter which could contain
sensitive material. Read the section "KEYS AND
PASSPHRASES" for more information.

This function
depends on the feature "luks". See also
"guestfs_feature_available".

(Added in
1.5.2)

guestfs_luks_close

int 
guestfs_luks_close (guestfs_h *g, 
const char *device);

This
function is deprecated. In new code, use the
"guestfs_cryptsetup_close" call instead.

Deprecated
functions will not be removed from the API, but the fact
that they are deprecated indicates that there are problems
with correct use of these functions.

This closes a
LUKS device that was created earlier by
"guestfs_luks_open" or
"guestfs_luks_open_ro". The "device"
parameter must be the name of the LUKS mapping device (ie.
/dev/mapper/mapname) and not the name of the
underlying block device.

This function
returns 0 on success or -1 on error.

This function
depends on the feature "luks". See also
"guestfs_feature_available".

(Added in
1.5.1)

guestfs_luks_format

int 
guestfs_luks_format (guestfs_h *g, 
const char *device, 
const char *key, 
int keyslot);

This command
erases existing data on "device" and formats the
device as a LUKS encrypted device. "key" is the
initial key, which is added to key slot "keyslot".
(LUKS supports 8 key slots, numbered 0-7).

This function
returns 0 on success or -1 on error.

This function
takes a key or passphrase parameter which could contain
sensitive material. Read the section "KEYS AND
PASSPHRASES" for more information.

This function
depends on the feature "luks". See also
"guestfs_feature_available".

(Added in
1.5.2)

guestfs_luks_format_cipher

int 
guestfs_luks_format_cipher (guestfs_h *g, 
const char *device, 
const char *key, 
int keyslot, 
const char *cipher);

This command is
the same as "guestfs_luks_format" but it also
allows you to set the "cipher" used.

This function
returns 0 on success or -1 on error.

This function
takes a key or passphrase parameter which could contain
sensitive material. Read the section "KEYS AND
PASSPHRASES" for more information.

This function
depends on the feature "luks". See also
"guestfs_feature_available".

(Added in
1.5.2)

guestfs_luks_kill_slot

int 
guestfs_luks_kill_slot (guestfs_h *g, 
const char *device, 
const char *key, 
int keyslot);

This command
deletes the key in key slot "keyslot" from the
encrypted LUKS device "device". "key"
must be one of the other keys.

This function
returns 0 on success or -1 on error.

This function
takes a key or passphrase parameter which could contain
sensitive material. Read the section "KEYS AND
PASSPHRASES" for more information.

This function
depends on the feature "luks". See also
"guestfs_feature_available".

(Added in
1.5.2)

guestfs_luks_open

int 
guestfs_luks_open (guestfs_h *g, 
const char *device, 
const char *key, 
const char *mapname);

This
function is deprecated. In new code, use the
"guestfs_cryptsetup_open" call instead.

Deprecated
functions will not be removed from the API, but the fact
that they are deprecated indicates that there are problems
with correct use of these functions.

This command
opens a block device which has been encrypted according to
the Linux Unified Key Setup (LUKS) standard.

"device"
is the encrypted block device or partition.

The caller must
supply one of the keys associated with the LUKS block
device, in the "key" parameter.

This creates a
new block device called /dev/mapper/mapname. Reads
and writes to this block device are decrypted from and
encrypted to the underlying "device"
respectively.

If this block
device contains LVM volume groups, then calling
"guestfs_lvm_scan" with the "activate"
parameter "true" will make them visible.

Use
"guestfs_list_dm_devices" to list all device
mapper devices.

This function
returns 0 on success or -1 on error.

This function
takes a key or passphrase parameter which could contain
sensitive material. Read the section "KEYS AND
PASSPHRASES" for more information.

This function
depends on the feature "luks". See also
"guestfs_feature_available".

(Added in
1.5.1)

guestfs_luks_open_ro

int 
guestfs_luks_open_ro (guestfs_h *g, 
const char *device, 
const char *key, 
const char *mapname);

This
function is deprecated. In new code, use the
"guestfs_cryptsetup_open" call instead.

Deprecated
functions will not be removed from the API, but the fact
that they are deprecated indicates that there are problems
with correct use of these functions.

This is the
same as "guestfs_luks_open" except that a
read-only mapping is created.

This function
returns 0 on success or -1 on error.

This function
takes a key or passphrase parameter which could contain
sensitive material. Read the section "KEYS AND
PASSPHRASES" for more information.

This function
depends on the feature "luks". See also
"guestfs_feature_available".

(Added in
1.5.1)

guestfs_luks_uuid

char * 
guestfs_luks_uuid (guestfs_h *g, 
const char *device);

This returns
the UUID of the LUKS device "device".

This function
returns a string, or NULL on error. The caller must free
the returned string after use.

This function
depends on the feature "luks". See also
"guestfs_feature_available".

(Added in
1.41.9)

guestfs_lvcreate

int 
guestfs_lvcreate (guestfs_h *g, 
const char *logvol, 
const char *volgroup, 
int mbytes);

This creates an
LVM logical volume called "logvol" on the volume
group "volgroup", with "size"
megabytes.

This function
returns 0 on success or -1 on error.

This function
depends on the feature "lvm2". See also
"guestfs_feature_available".

(Added in
0.8)

guestfs_lvcreate_free

int 
guestfs_lvcreate_free (guestfs_h *g, 
const char *logvol, 
const char *volgroup, 
int percent);

Create an LVM
logical volume called /dev/volgroup/logvol, using
approximately "percent" % of the free space
remaining in the volume group. Most usefully, when
"percent" is 100 this will create the largest
possible LV.

This function
returns 0 on success or -1 on error.

This function
depends on the feature "lvm2". See also
"guestfs_feature_available".

(Added in
1.17.18)

guestfs_lvm_canonical_lv_name

char * 
guestfs_lvm_canonical_lv_name (guestfs_h *g, 
const char *lvname);

This converts
alternative naming schemes for LVs that you might find to
the canonical name. For example, /dev/mapper/VG-LV is
converted to /dev/VG/LV.

This command
returns an error if the "lvname" parameter does
not refer to a logical volume. In this case errno will be
set to "EINVAL".

See also
"guestfs_is_lv",
"guestfs_canonical_device_name".

This function
returns a string, or NULL on error. The caller must free
the returned string after use.

(Added in
1.5.24)

guestfs_lvm_clear_filter

int 
guestfs_lvm_clear_filter (guestfs_h *g);

This undoes the
effect of "guestfs_lvm_set_filter". LVM will be
able to see every block device.

This command
also clears the LVM cache and performs a volume group
scan.

This function
returns 0 on success or -1 on error.

(Added in
1.5.1)

guestfs_lvm_remove_all

int 
guestfs_lvm_remove_all (guestfs_h *g);

This command
removes all LVM logical volumes, volume groups and physical
volumes.

This function
returns 0 on success or -1 on error.

This function
depends on the feature "lvm2". See also
"guestfs_feature_available".

(Added in
0.8)

guestfs_lvm_scan

int 
guestfs_lvm_scan (guestfs_h *g, 
int activate);

This scans all
block devices and rebuilds the list of LVM physical volumes,
volume groups and logical volumes.

If the
"activate" parameter is "true" then
newly found volume groups and logical volumes are activated,
meaning the LV /dev/VG/LV devices become visible.

When a
libguestfs handle is launched it scans for existing devices,
so you do not normally need to use this API. However it is
useful when you have added a new device or deleted an
existing device (such as when the
"guestfs_luks_open" API is used).

This function
returns 0 on success or -1 on error.

(Added in
1.39.8)

guestfs_lvm_set_filter

int 
guestfs_lvm_set_filter (guestfs_h *g, 
char *const *devices);

This sets the
LVM device filter so that LVM will only be able to
"see" the block devices in the list
"devices", and will ignore all other attached
block devices.

Where disk
image(s) contain duplicate PVs or VGs, this command is
useful to get LVM to ignore the duplicates, otherwise LVM
can get confused. Note also there are two types of
duplication possible: either cloned PVs/VGs which have
identical UUIDs; or VGs that are not cloned but just happen
to have the same name. In normal operation you cannot create
this situation, but you can do it outside LVM, eg. by
cloning disk images or by bit twiddling inside the LVM
metadata.

This command
also clears the LVM cache and performs a volume group
scan.

You can filter
whole block devices or individual partitions.

You cannot use
this if any VG is currently in use (eg. contains a mounted
filesystem), even if you are not filtering out that VG.

This function
returns 0 on success or -1 on error.

This function
depends on the feature "lvm2". See also
"guestfs_feature_available".

(Added in
1.5.1)

guestfs_lvremove

int 
guestfs_lvremove (guestfs_h *g, 
const char *device);

Remove an LVM
logical volume "device", where "device"
is the path to the LV, such as /dev/VG/LV.

You can also
remove all LVs in a volume group by specifying the VG name,
/dev/VG.

This function
returns 0 on success or -1 on error.

This function
depends on the feature "lvm2". See also
"guestfs_feature_available".

(Added in
1.0.13)

guestfs_lvrename

int 
guestfs_lvrename (guestfs_h *g, 
const char *logvol, 
const char *newlogvol);

Rename a
logical volume "logvol" with the new name
"newlogvol".

This function
returns 0 on success or -1 on error.

(Added in
1.0.83)

guestfs_lvresize

int 
guestfs_lvresize (guestfs_h *g, 
const char *device, 
int mbytes);

This resizes
(expands or shrinks) an existing LVM logical volume to
"mbytes". When reducing, data in the reduced part
is lost.

This function
returns 0 on success or -1 on error.

This function
depends on the feature "lvm2". See also
"guestfs_feature_available".

(Added in
1.0.27)

guestfs_lvresize_free

int 
guestfs_lvresize_free (guestfs_h *g, 
const char *lv, 
int percent);

This expands an
existing logical volume "lv" so that it fills
"pc" % of the remaining free space in the volume
group. Commonly you would call this with pc = 100 which
expands the logical volume as much as possible, using all
remaining free space in the volume group.

This function
returns 0 on success or -1 on error.

This function
depends on the feature "lvm2". See also
"guestfs_feature_available".

(Added in
1.3.3)

guestfs_lvs

char ** 
guestfs_lvs (guestfs_h *g);

List all the
logical volumes detected. This is the equivalent of the
lvs(8) command.

This returns a
list of the logical volume device names (eg.
/dev/VolGroup00/LogVol00).

See also
"guestfs_lvs_full",
"guestfs_list_filesystems".

This function
returns a NULL-terminated array of strings (like
environ(3)), or NULL if there was an error. The
caller must free the strings and the array after
use.

This function
depends on the feature "lvm2". See also
"guestfs_feature_available".

(Added in
0.4)

guestfs_lvs_full

struct guestfs_lvm_lv_list * 
guestfs_lvs_full (guestfs_h *g);

List all the
logical volumes detected. This is the equivalent of the
lvs(8) command. The "full" version includes
all fields.

This function
returns a "struct guestfs_lvm_lv_list *", or NULL
if there was an error. The caller must call
"guestfs_free_lvm_lv_list" after use.

This function
depends on the feature "lvm2". See also
"guestfs_feature_available".

(Added in
0.4)

guestfs_lvuuid

char * 
guestfs_lvuuid (guestfs_h *g, 
const char *device);

This command
returns the UUID of the LVM LV "device".

This function
returns a string, or NULL on error. The caller must free
the returned string after use.

(Added in
1.0.87)

guestfs_lxattrlist

struct guestfs_xattr_list * 
guestfs_lxattrlist (guestfs_h *g, 
const char *path, 
char *const *names);

This call
allows you to get the extended attributes of multiple files,
where all files are in the directory "path".
"names" is the list of files from this
directory.

On return you
get a flat list of xattr structs which must be interpreted
sequentially. The first xattr struct always has a
zero-length "attrname". "attrval" in
this struct is zero-length to indicate there was an error
doing "guestfs_lgetxattr" for this file, or
is a C string which is a decimal number (the number of
following attributes for this file, which could be
"0"). Then after the first xattr struct are the
zero or more attributes for the first named file. This
repeats for the second and subsequent files.

This call is
intended for programs that want to efficiently list a
directory contents without making many round-trips. See also
"guestfs_lstatlist" for a similarly efficient call
for getting standard stats.

This function
returns a "struct guestfs_xattr_list *", or NULL
if there was an error. The caller must call
"guestfs_free_xattr_list" after use.

This function
depends on the feature "linuxxattrs". See also
"guestfs_feature_available".

(Added in
1.0.77)

guestfs_max_disks

int 
guestfs_max_disks (guestfs_h *g);

Return the
maximum number of disks that may be added to a handle (eg.
by "guestfs_add_drive_opts" and similar
calls).

This function
was added in libguestfs 1.19.7. In previous versions of
libguestfs the limit was 25.

See
"MAXIMUM NUMBER OF DISKS" for additional
information on this topic.

On error this
function returns -1.

(Added in
1.19.7)

guestfs_md_create

int 
guestfs_md_create (guestfs_h *g, 
const char *name, 
char *const *devices, 
...);

You may supply
a list of optional arguments to this call. Use zero or more
of the following pairs of parameters, and terminate the list
with -1 on its own. See "CALLS WITH OPTIONAL
ARGUMENTS".

GUESTFS_MD_CREATE_MISSINGBITMAP,
int64_t missingbitmap, 
GUESTFS_MD_CREATE_NRDEVICES, int nrdevices, 
GUESTFS_MD_CREATE_SPARE, int spare, 
GUESTFS_MD_CREATE_CHUNK, int64_t chunk, 
GUESTFS_MD_CREATE_LEVEL, const char *level,

Create a Linux
md (RAID) device named "name" on the devices in
the list "devices".

The optional
parameters are: 
"missingbitmap"

A bitmap of missing devices. If
a bit is set it means that a missing device is added to the
array. The least significant bit corresponds to the first
device in the array.

As
examples:

If
"devices = ["/dev/sda"]" and
"missingbitmap = 0x1" then the resulting array
would be "[,
"/dev/sda"]".

If
"devices = ["/dev/sda"]" and
"missingbitmap = 0x2" then the resulting array
would be "["/dev/sda",
]".

This defaults
to 0 (no missing devices).

The length of
"devices" + the number of bits set in
"missingbitmap" must equal "nrdevices" +
"spare".

"nrdevices"

The number of active RAID
devices.

If not set,
this defaults to the length of "devices" plus the
number of bits set in "missingbitmap".

"spare"

The number of spare
devices.

If not set,
this defaults to 0.

"chunk"

The chunk size in bytes.

The
"chunk" parameter does not make sense, and should
not be specified, when "level" is
"raid1" (which is the default; see below).

"level"

The RAID level, which can be
one of: "linear", "raid0", 0,
"stripe", "raid1", 1,
"mirror", "raid4", 4, "raid5",
5, "raid6", 6, "raid10", 10. Some of
these are synonymous, and more levels may be added in
future.

If not set,
this defaults to "raid1".

This function
returns 0 on success or -1 on error.

This function
depends on the feature "mdadm". See also
"guestfs_feature_available".

(Added in
1.15.6)

guestfs_md_create_va

int 
guestfs_md_create_va (guestfs_h *g, 
const char *name, 
char *const *devices, 
va_list args);

This is the
"va_list variant" of
"guestfs_md_create".

See "CALLS
WITH OPTIONAL ARGUMENTS".

guestfs_md_create_argv

int 
guestfs_md_create_argv (guestfs_h *g, 
const char *name, 
char *const *devices, 
const struct guestfs_md_create_argv *optargs);

This is the
"argv variant" of
"guestfs_md_create".

See "CALLS
WITH OPTIONAL ARGUMENTS".

guestfs_md_detail

char ** 
guestfs_md_detail (guestfs_h *g, 
const char *md);

This command
exposes the output of "mdadm -DY ". The
following fields are usually present in the returned hash.
Other fields may also be present. 
"level"

The raid level of the MD
device.

"devices"

The number of underlying
devices in the MD device.

"metadata"

The metadata version used.

"uuid"

The UUID of the MD device.

"name"

The name of the MD device.

This function
returns a NULL-terminated array of strings, or NULL if there
was an error. The array of strings will always have length
"2n+1", where "n" keys and values
alternate, followed by the trailing NULL entry. The
caller must free the strings and the array after
use.

This function
depends on the feature "mdadm". See also
"guestfs_feature_available".

(Added in
1.15.6)

guestfs_md_stat

struct guestfs_mdstat_list * 
guestfs_md_stat (guestfs_h *g, 
const char *md);

This call
returns a list of the underlying devices which make up the
single software RAID array device "md".

To get a list
of software RAID devices, call
"guestfs_list_md_devices".

Each structure
returned corresponds to one device along with additional
status information: 
"mdstat_device"

The name of the underlying
device.

"mdstat_index"

The index of this device within
the array.

"mdstat_flags"

Flags associated with this
device. This is a string containing (in no specific order)
zero or more of the following flags:

"W"

write-mostly

"F"

device is faulty

"S"

device is a RAID spare

"R"

replacement

This function
returns a "struct guestfs_mdstat_list *", or NULL
if there was an error. The caller must call
"guestfs_free_mdstat_list" after use.

This function
depends on the feature "mdadm". See also
"guestfs_feature_available".

(Added in
1.17.21)

guestfs_md_stop

int 
guestfs_md_stop (guestfs_h *g, 
const char *md);

This command
deactivates the MD array named "md". The device is
stopped, but it is not destroyed or zeroed.

This function
returns 0 on success or -1 on error.

This function
depends on the feature "mdadm". See also
"guestfs_feature_available".

(Added in
1.15.6)

guestfs_mkdir

int 
guestfs_mkdir (guestfs_h *g, 
const char *path);

Create a
directory named "path".

This function
returns 0 on success or -1 on error.

(Added in
0.8)

guestfs_mkdir_mode

int 
guestfs_mkdir_mode (guestfs_h *g, 
const char *path, 
int mode);

This command
creates a directory, setting the initial permissions of the
directory to "mode".

For common
Linux filesystems, the actual mode which is set will be
"mode & ~umask & 01777". Non-native-Linux
filesystems may interpret the mode in other ways.

See also
"guestfs_mkdir", "guestfs_umask"

This function
returns 0 on success or -1 on error.

(Added in
1.0.77)

guestfs_mkdir_p

int 
guestfs_mkdir_p (guestfs_h *g, 
const char *path);

Create a
directory named "path", creating any parent
directories as necessary. This is like the "mkdir
-p" shell command.

This function
returns 0 on success or -1 on error.

(Added in
0.8)

guestfs_mkdtemp

char * 
guestfs_mkdtemp (guestfs_h *g, 
const char *tmpl);

This command
creates a temporary directory. The "tmpl"
parameter should be a full pathname for the temporary
directory name with the final six characters being
"XXXXXX".

For example:
"/tmp/myprogXXXXXX" or
"/Temp/myprogXXXXXX", the second one being
suitable for Windows filesystems.

The name of the
temporary directory that was created is returned.

The temporary
directory is created with mode 0700 and is owned by
root.

The caller is
responsible for deleting the temporary directory and its
contents after use.

See also:
mkdtemp(3)

This function
returns a string, or NULL on error. The caller must free
the returned string after use.

(Added in
1.0.54)

guestfs_mke2fs

int 
guestfs_mke2fs (guestfs_h *g, 
const char *device, 
...);

You may supply
a list of optional arguments to this call. Use zero or more
of the following pairs of parameters, and terminate the list
with -1 on its own. See "CALLS WITH OPTIONAL
ARGUMENTS".

GUESTFS_MKE2FS_BLOCKSCOUNT,
int64_t blockscount, 
GUESTFS_MKE2FS_BLOCKSIZE, int64_t blocksize, 
GUESTFS_MKE2FS_FRAGSIZE, int64_t fragsize, 
GUESTFS_MKE2FS_BLOCKSPERGROUP, int64_t blockspergroup, 
GUESTFS_MKE2FS_NUMBEROFGROUPS, int64_t numberofgroups, 
GUESTFS_MKE2FS_BYTESPERINODE, int64_t bytesperinode, 
GUESTFS_MKE2FS_INODESIZE, int64_t inodesize, 
GUESTFS_MKE2FS_JOURNALSIZE, int64_t journalsize, 
GUESTFS_MKE2FS_NUMBEROFINODES, int64_t numberofinodes, 
GUESTFS_MKE2FS_STRIDESIZE, int64_t stridesize, 
GUESTFS_MKE2FS_STRIPEWIDTH, int64_t stripewidth, 
GUESTFS_MKE2FS_MAXONLINERESIZE, int64_t maxonlineresize,

GUESTFS_MKE2FS_RESERVEDBLOCKSPERCENTAGE, int
reservedblockspercentage, 
GUESTFS_MKE2FS_MMPUPDATEINTERVAL, int mmpupdateinterval,

GUESTFS_MKE2FS_JOURNALDEVICE, const char *journaldevice,

GUESTFS_MKE2FS_LABEL, const char *label, 
GUESTFS_MKE2FS_LASTMOUNTEDDIR, const char *lastmounteddir,

GUESTFS_MKE2FS_CREATOROS, const char *creatoros, 
GUESTFS_MKE2FS_FSTYPE, const char *fstype, 
GUESTFS_MKE2FS_USAGETYPE, const char *usagetype, 
GUESTFS_MKE2FS_UUID, const char *uuid, 
GUESTFS_MKE2FS_FORCECREATE, int forcecreate, 
GUESTFS_MKE2FS_WRITESBANDGROUPONLY, int writesbandgrouponly,

GUESTFS_MKE2FS_LAZYITABLEINIT, int lazyitableinit, 
GUESTFS_MKE2FS_LAZYJOURNALINIT, int lazyjournalinit, 
GUESTFS_MKE2FS_TESTFS, int testfs, 
GUESTFS_MKE2FS_DISCARD, int discard, 
GUESTFS_MKE2FS_QUOTATYPE, int quotatype, 
GUESTFS_MKE2FS_EXTENT, int extent, 
GUESTFS_MKE2FS_FILETYPE, int filetype, 
GUESTFS_MKE2FS_FLEXBG, int flexbg, 
GUESTFS_MKE2FS_HASJOURNAL, int hasjournal, 
GUESTFS_MKE2FS_JOURNALDEV, int journaldev, 
GUESTFS_MKE2FS_LARGEFILE, int largefile, 
GUESTFS_MKE2FS_QUOTA, int quota, 
GUESTFS_MKE2FS_RESIZEINODE, int resizeinode, 
GUESTFS_MKE2FS_SPARSESUPER, int sparsesuper, 
GUESTFS_MKE2FS_UNINITBG, int uninitbg,

"mke2fs"
is used to create an ext2, ext3, or ext4 filesystem on
"device".

The optional
"blockscount" is the size of the filesystem in
blocks. If omitted it defaults to the size of
"device". Note if the filesystem is too small to
contain a journal, "mke2fs" will silently create
an ext2 filesystem instead.

This function
returns 0 on success or -1 on error.

(Added in
1.19.44)

guestfs_mke2fs_va

int 
guestfs_mke2fs_va (guestfs_h *g, 
const char *device, 
va_list args);

This is the
"va_list variant" of
"guestfs_mke2fs".

See "CALLS
WITH OPTIONAL ARGUMENTS".

guestfs_mke2fs_argv

int 
guestfs_mke2fs_argv (guestfs_h *g, 
const char *device, 
const struct guestfs_mke2fs_argv *optargs);

This is the
"argv variant" of "guestfs_mke2fs".

See "CALLS
WITH OPTIONAL ARGUMENTS".

guestfs_mke2fs_J

int 
guestfs_mke2fs_J (guestfs_h *g, 
const char *fstype, 
int blocksize, 
const char *device, 
const char *journal);

This
function is deprecated. In new code, use the
"guestfs_mke2fs" call instead.

Deprecated
functions will not be removed from the API, but the fact
that they are deprecated indicates that there are problems
with correct use of these functions.

This creates an
ext2/3/4 filesystem on "device" with an external
journal on "journal". It is equivalent to the
command:

mke2fs -t
fstype -b blocksize -J device=

See also
"guestfs_mke2journal".

This function
returns 0 on success or -1 on error.

(Added in
1.0.68)

guestfs_mke2fs_JL

int 
guestfs_mke2fs_JL (guestfs_h *g, 
const char *fstype, 
int blocksize, 
const char *device, 
const char *label);

This
function is deprecated. In new code, use the
"guestfs_mke2fs" call instead.

Deprecated
functions will not be removed from the API, but the fact
that they are deprecated indicates that there are problems
with correct use of these functions.

This creates an
ext2/3/4 filesystem on "device" with an external
journal on the journal labeled "label".

See also
"guestfs_mke2journal_L".

This function
returns 0 on success or -1 on error.

(Added in
1.0.68)

guestfs_mke2fs_JU

int 
guestfs_mke2fs_JU (guestfs_h *g, 
const char *fstype, 
int blocksize, 
const char *device, 
const char *uuid);

This
function is deprecated. In new code, use the
"guestfs_mke2fs" call instead.

Deprecated
functions will not be removed from the API, but the fact
that they are deprecated indicates that there are problems
with correct use of these functions.

This creates an
ext2/3/4 filesystem on "device" with an external
journal on the journal with UUID "uuid".

See also
"guestfs_mke2journal_U".

This function
returns 0 on success or -1 on error.

This function
depends on the feature "linuxfsuuid". See also
"guestfs_feature_available".

(Added in
1.0.68)

guestfs_mke2journal

int 
guestfs_mke2journal (guestfs_h *g, 
int blocksize, 
const char *device);

This
function is deprecated. In new code, use the
"guestfs_mke2fs" call instead.

Deprecated
functions will not be removed from the API, but the fact
that they are deprecated indicates that there are problems
with correct use of these functions.

This creates an
ext2 external journal on "device". It is
equivalent to the command:

mke2fs -O
journal_dev -b blocksize device

This function
returns 0 on success or -1 on error.

(Added in
1.0.68)

guestfs_mke2journal_L

int 
guestfs_mke2journal_L (guestfs_h *g, 
int blocksize, 
const char *label, 
const char *device);

This
function is deprecated. In new code, use the
"guestfs_mke2fs" call instead.

Deprecated
functions will not be removed from the API, but the fact
that they are deprecated indicates that there are problems
with correct use of these functions.

This creates an
ext2 external journal on "device" with label
"label".

This function
returns 0 on success or -1 on error.

(Added in
1.0.68)

guestfs_mke2journal_U

int 
guestfs_mke2journal_U (guestfs_h *g, 
int blocksize, 
const char *uuid, 
const char *device);

This
function is deprecated. In new code, use the
"guestfs_mke2fs" call instead.

Deprecated
functions will not be removed from the API, but the fact
that they are deprecated indicates that there are problems
with correct use of these functions.

This creates an
ext2 external journal on "device" with UUID
"uuid".

This function
returns 0 on success or -1 on error.

This function
depends on the feature "linuxfsuuid". See also
"guestfs_feature_available".

(Added in
1.0.68)

guestfs_mkfifo

int 
guestfs_mkfifo (guestfs_h *g, 
int mode, 
const char *path);

This call
creates a FIFO (named pipe) called "path" with
mode "mode". It is just a convenient wrapper
around "guestfs_mknod".

Unlike with
"guestfs_mknod", "mode" must
contain only permissions bits.

The mode
actually set is affected by the umask.

This function
returns 0 on success or -1 on error.

This function
depends on the feature "mknod". See also
"guestfs_feature_available".

(Added in
1.0.55)

guestfs_mkfs

int 
guestfs_mkfs (guestfs_h *g, 
const char *fstype, 
const char *device);

This function
is provided for backwards compatibility with earlier
versions of libguestfs. It simply calls
"guestfs_mkfs_opts" with no optional
arguments.

(Added in
0.8)

guestfs_mkfs_opts

int 
guestfs_mkfs_opts (guestfs_h *g, 
const char *fstype, 
const char *device, 
...);

You may supply
a list of optional arguments to this call. Use zero or more
of the following pairs of parameters, and terminate the list
with -1 on its own. See "CALLS WITH OPTIONAL
ARGUMENTS".

GUESTFS_MKFS_OPTS_BLOCKSIZE,
int blocksize, 
GUESTFS_MKFS_OPTS_FEATURES, const char *features, 
GUESTFS_MKFS_OPTS_INODE, int inode, 
GUESTFS_MKFS_OPTS_SECTORSIZE, int sectorsize, 
GUESTFS_MKFS_OPTS_LABEL, const char *label,

This function
creates a filesystem on "device". The filesystem
type is "fstype", for example
"ext3".

The optional
arguments are: 
"blocksize"

The filesystem block size.
Supported block sizes depend on the filesystem type, but
typically they are 1024, 2048 or 4096 for Linux ext2/3
filesystems.

For VFAT and
NTFS the "blocksize" parameter is treated as the
requested cluster size.

For UFS block
sizes, please see mkfs.ufs(8).

"features"

This passes the -O
parameter to the external mkfs program.

For certain
filesystem types, this allows extra filesystem features to
be selected. See mke2fs(8) and mkfs.ufs(8) for
more details.

You cannot use
this optional parameter with the "gfs" or
"gfs2" filesystem type.

"inode"

This passes the -I
parameter to the external mke2fs(8) program which
sets the inode size (only for ext2/3/4 filesystems at
present).

"sectorsize"

This passes the -S
parameter to external mkfs.ufs(8) program, which sets
sector size for ufs filesystem.

This function
returns 0 on success or -1 on error.

(Added in
0.8)

guestfs_mkfs_opts_va

int 
guestfs_mkfs_opts_va (guestfs_h *g, 
const char *fstype, 
const char *device, 
va_list args);

This is the
"va_list variant" of
"guestfs_mkfs_opts".

See "CALLS
WITH OPTIONAL ARGUMENTS".

guestfs_mkfs_opts_argv

int 
guestfs_mkfs_opts_argv (guestfs_h *g, 
const char *fstype, 
const char *device, 
const struct guestfs_mkfs_opts_argv *optargs);

This is the
"argv variant" of
"guestfs_mkfs_opts".

See "CALLS
WITH OPTIONAL ARGUMENTS".

guestfs_mkfs_b

int 
guestfs_mkfs_b (guestfs_h *g, 
const char *fstype, 
int blocksize, 
const char *device);

This
function is deprecated. In new code, use the
"guestfs_mkfs" call instead.

Deprecated
functions will not be removed from the API, but the fact
that they are deprecated indicates that there are problems
with correct use of these functions.

This call is
similar to "guestfs_mkfs", but it allows you to
control the block size of the resulting filesystem.
Supported block sizes depend on the filesystem type, but
typically they are 1024, 2048 or 4096 only.

For VFAT and
NTFS the "blocksize" parameter is treated as the
requested cluster size.

This function
returns 0 on success or -1 on error.

(Added in
1.0.68)

guestfs_mkfs_btrfs

int 
guestfs_mkfs_btrfs (guestfs_h *g, 
char *const *devices, 
...);

You may supply
a list of optional arguments to this call. Use zero or more
of the following pairs of parameters, and terminate the list
with -1 on its own. See "CALLS WITH OPTIONAL
ARGUMENTS".

GUESTFS_MKFS_BTRFS_ALLOCSTART,
int64_t allocstart, 
GUESTFS_MKFS_BTRFS_BYTECOUNT, int64_t bytecount, 
GUESTFS_MKFS_BTRFS_DATATYPE, const char *datatype, 
GUESTFS_MKFS_BTRFS_LEAFSIZE, int leafsize, 
GUESTFS_MKFS_BTRFS_LABEL, const char *label, 
GUESTFS_MKFS_BTRFS_METADATA, const char *metadata, 
GUESTFS_MKFS_BTRFS_NODESIZE, int nodesize, 
GUESTFS_MKFS_BTRFS_SECTORSIZE, int sectorsize,

Create a btrfs
filesystem, allowing all configurables to be set. For more
information on the optional arguments, see
mkfs.btrfs(8).

Since btrfs
filesystems can span multiple devices, this takes a
non-empty list of devices.

To create
general filesystems, use "guestfs_mkfs".

This function
returns 0 on success or -1 on error.

This function
depends on the feature "btrfs". See also
"guestfs_feature_available".

(Added in
1.17.25)

guestfs_mkfs_btrfs_va

int 
guestfs_mkfs_btrfs_va (guestfs_h *g, 
char *const *devices, 
va_list args);

This is the
"va_list variant" of
"guestfs_mkfs_btrfs".

See "CALLS
WITH OPTIONAL ARGUMENTS".

guestfs_mkfs_btrfs_argv

int 
guestfs_mkfs_btrfs_argv (guestfs_h *g, 
char *const *devices, 
const struct guestfs_mkfs_btrfs_argv *optargs);

This is the
"argv variant" of
"guestfs_mkfs_btrfs".

See "CALLS
WITH OPTIONAL ARGUMENTS".

guestfs_mklost_and_found

int 
guestfs_mklost_and_found (guestfs_h *g, 
const char *mountpoint);

Make the
"lost+found" directory, normally in the root
directory of an ext2/3/4 filesystem. "mountpoint"
is the directory under which we try to create the
"lost+found" directory.

This function
returns 0 on success or -1 on error.

(Added in
1.19.56)

guestfs_mkmountpoint

int 
guestfs_mkmountpoint (guestfs_h *g, 
const char *exemptpath);

"guestfs_mkmountpoint"
and "guestfs_rmmountpoint" are specialized calls
that can be used to create extra mountpoints before mounting
the first filesystem.

These calls are
only necessary in some very limited circumstances,
mainly the case where you want to mount a mix of unrelated
and/or read-only filesystems together.

For example,
live CDs often contain a "Russian doll" nest of
filesystems, an ISO outer layer, with a squashfs image
inside, with an ext2/3 image inside that. You can unpack
this as follows in guestfish:

add-ro
Fedora-11-i686-Live.iso 
run 
mkmountpoint /cd 
mkmountpoint /sqsh 
mkmountpoint /ext3fs 
mount /dev/sda /cd 
mount-loop /cd/LiveOS/squashfs.img /sqsh 
mount-loop /sqsh/LiveOS/ext3fs.img /ext3fs

The inner
filesystem is now unpacked under the /ext3fs mountpoint.

"guestfs_mkmountpoint"
is not compatible with "guestfs_umount_all". You
may get unexpected errors if you try to mix these calls. It
is safest to manually unmount filesystems and remove
mountpoints after use.

"guestfs_umount_all"
unmounts filesystems by sorting the paths longest first, so
for this to work for manual mountpoints, you must ensure
that the innermost mountpoints have the longest pathnames,
as in the example code above.

For more
details see
https://bugzilla.redhat.com/show_bug.cgi?id=599503

Autosync [see
"guestfs_set_autosync", this is set by default on
handles] can cause "guestfs_umount_all" to be
called when the handle is closed which can also trigger
these issues.

This function
returns 0 on success or -1 on error.

(Added in
1.0.62)

guestfs_mknod

int 
guestfs_mknod (guestfs_h *g, 
int mode, 
int devmajor, 
int devminor, 
const char *path);

This call
creates block or character special devices, or named pipes
(FIFOs).

The
"mode" parameter should be the mode, using the
standard constants. "devmajor" and
"devminor" are the device major and minor numbers,
only used when creating block and character special
devices.

Note that, just
like mknod(2), the mode must be bitwise OR&rsquo;d
with S_IFBLK, S_IFCHR, S_IFIFO or S_IFSOCK (otherwise this
call just creates a regular file). These constants are
available in the standard Linux header files, or you can use
"guestfs_mknod_b", "guestfs_mknod_c" or
"guestfs_mkfifo" which are wrappers around this
command which bitwise OR in the appropriate constant for
you.

The mode
actually set is affected by the umask.

This function
returns 0 on success or -1 on error.

This function
depends on the feature "mknod". See also
"guestfs_feature_available".

(Added in
1.0.55)

guestfs_mknod_b

int 
guestfs_mknod_b (guestfs_h *g, 
int mode, 
int devmajor, 
int devminor, 
const char *path);

This call
creates a block device node called "path" with
mode "mode" and device major/minor
"devmajor" and "devminor". It is just a
convenient wrapper around "guestfs_mknod".

Unlike with
"guestfs_mknod", "mode" must
contain only permissions bits.

The mode
actually set is affected by the umask.

This function
returns 0 on success or -1 on error.

This function
depends on the feature "mknod". See also
"guestfs_feature_available".

(Added in
1.0.55)

guestfs_mknod_c

int 
guestfs_mknod_c (guestfs_h *g, 
int mode, 
int devmajor, 
int devminor, 
const char *path);

This call
creates a char device node called "path" with mode
"mode" and device major/minor "devmajor"
and "devminor". It is just a convenient wrapper
around "guestfs_mknod".

Unlike with
"guestfs_mknod", "mode" must
contain only permissions bits.

The mode
actually set is affected by the umask.

This function
returns 0 on success or -1 on error.

This function
depends on the feature "mknod". See also
"guestfs_feature_available".

(Added in
1.0.55)

guestfs_mksquashfs

int 
guestfs_mksquashfs (guestfs_h *g, 
const char *path, 
const char *filename, 
...);

You may supply
a list of optional arguments to this call. Use zero or more
of the following pairs of parameters, and terminate the list
with -1 on its own. See "CALLS WITH OPTIONAL
ARGUMENTS".

GUESTFS_MKSQUASHFS_COMPRESS,
const char *compress, 
GUESTFS_MKSQUASHFS_EXCLUDES, char *const *excludes,

Create a
squashfs filesystem for the specified "path".

The optional
"compress" flag controls compression. If not
given, then the output compressed using "gzip".
Otherwise one of the following strings may be given to
select the compression type of the squashfs:
"gzip", "lzma", "lzo",
"lz4", "xz".

The other
optional arguments are: 
"excludes"

A list of wildcards. Files are
excluded if they match any of the wildcards.

Please note
that this API may fail when used to compress directories
with large files, such as the resulting squashfs will be
over 3GB big.

This function
returns 0 on success or -1 on error.

This function
depends on the feature "squashfs". See also
"guestfs_feature_available".

(Added in
1.35.25)

guestfs_mksquashfs_va

int 
guestfs_mksquashfs_va (guestfs_h *g, 
const char *path, 
const char *filename, 
va_list args);

This is the
"va_list variant" of
"guestfs_mksquashfs".

See "CALLS
WITH OPTIONAL ARGUMENTS".

guestfs_mksquashfs_argv

int 
guestfs_mksquashfs_argv (guestfs_h *g, 
const char *path, 
const char *filename, 
const struct guestfs_mksquashfs_argv *optargs);

This is the
"argv variant" of
"guestfs_mksquashfs".

See "CALLS
WITH OPTIONAL ARGUMENTS".

guestfs_mkswap

int 
guestfs_mkswap (guestfs_h *g, 
const char *device);

This function
is provided for backwards compatibility with earlier
versions of libguestfs. It simply calls
"guestfs_mkswap_opts" with no optional
arguments.

(Added in
1.0.55)

guestfs_mkswap_opts

int 
guestfs_mkswap_opts (guestfs_h *g, 
const char *device, 
...);

You may supply
a list of optional arguments to this call. Use zero or more
of the following pairs of parameters, and terminate the list
with -1 on its own. See "CALLS WITH OPTIONAL
ARGUMENTS".

GUESTFS_MKSWAP_OPTS_LABEL,
const char *label, 
GUESTFS_MKSWAP_OPTS_UUID, const char *uuid,

Create a Linux
swap partition on "device".

The option
arguments "label" and "uuid" allow you
to set the label and/or UUID of the new swap partition.

This function
returns 0 on success or -1 on error.

(Added in
1.0.55)

guestfs_mkswap_opts_va

int 
guestfs_mkswap_opts_va (guestfs_h *g, 
const char *device, 
va_list args);

This is the
"va_list variant" of
"guestfs_mkswap_opts".

See "CALLS
WITH OPTIONAL ARGUMENTS".

guestfs_mkswap_opts_argv

int 
guestfs_mkswap_opts_argv (guestfs_h *g, 
const char *device, 
const struct guestfs_mkswap_opts_argv *optargs);

This is the
"argv variant" of
"guestfs_mkswap_opts".

See "CALLS
WITH OPTIONAL ARGUMENTS".

guestfs_mkswap_L

int 
guestfs_mkswap_L (guestfs_h *g, 
const char *label, 
const char *device);

This
function is deprecated. In new code, use the
"guestfs_mkswap" call instead.

Deprecated
functions will not be removed from the API, but the fact
that they are deprecated indicates that there are problems
with correct use of these functions.

Create a swap
partition on "device" with label
"label".

Note that you
cannot attach a swap label to a block device (eg.
/dev/sda), just to a partition. This appears to be a
limitation of the kernel or swap tools.

This function
returns 0 on success or -1 on error.

(Added in
1.0.55)

guestfs_mkswap_U

int 
guestfs_mkswap_U (guestfs_h *g, 
const char *uuid, 
const char *device);

This
function is deprecated. In new code, use the
"guestfs_mkswap" call instead.

Deprecated
functions will not be removed from the API, but the fact
that they are deprecated indicates that there are problems
with correct use of these functions.

Create a swap
partition on "device" with UUID
"uuid".

This function
returns 0 on success or -1 on error.

This function
depends on the feature "linuxfsuuid". See also
"guestfs_feature_available".

(Added in
1.0.55)

guestfs_mkswap_file

int 
guestfs_mkswap_file (guestfs_h *g, 
const char *path);

Create a swap
file.

This command
just writes a swap file signature to an existing file. To
create the file itself, use something like
"guestfs_fallocate".

This function
returns 0 on success or -1 on error.

(Added in
1.0.66)

guestfs_mktemp

char * 
guestfs_mktemp (guestfs_h *g, 
const char *tmpl, 
...);

You may supply
a list of optional arguments to this call. Use zero or more
of the following pairs of parameters, and terminate the list
with -1 on its own. See "CALLS WITH OPTIONAL
ARGUMENTS".

GUESTFS_MKTEMP_SUFFIX,
const char *suffix,

This command
creates a temporary file. The "tmpl" parameter
should be a full pathname for the temporary directory name
with the final six characters being "XXXXXX".

For example:
"/tmp/myprogXXXXXX" or
"/Temp/myprogXXXXXX", the second one being
suitable for Windows filesystems.

The name of the
temporary file that was created is returned.

The temporary
file is created with mode 0600 and is owned by root.

The caller is
responsible for deleting the temporary file after use.

If the optional
"suffix" parameter is given, then the suffix (eg.
".txt") is appended to the temporary name.

See also:
"guestfs_mkdtemp".

This function
returns a string, or NULL on error. The caller must free
the returned string after use.

(Added in
1.19.53)

guestfs_mktemp_va

char * 
guestfs_mktemp_va (guestfs_h *g, 
const char *tmpl, 
va_list args);

This is the
"va_list variant" of
"guestfs_mktemp".

See "CALLS
WITH OPTIONAL ARGUMENTS".

guestfs_mktemp_argv

char * 
guestfs_mktemp_argv (guestfs_h *g, 
const char *tmpl, 
const struct guestfs_mktemp_argv *optargs);

This is the
"argv variant" of "guestfs_mktemp".

See "CALLS
WITH OPTIONAL ARGUMENTS".

guestfs_modprobe

int 
guestfs_modprobe (guestfs_h *g, 
const char *modulename);

This loads a
kernel module in the appliance.

This function
returns 0 on success or -1 on error.

This function
depends on the feature "linuxmodules". See also
"guestfs_feature_available".

(Added in
1.0.68)

guestfs_mount

int 
guestfs_mount (guestfs_h *g, 
const char *mountable, 
const char *mountpoint);

Mount a guest
disk at a position in the filesystem. Block devices are
named /dev/sda, /dev/sdb and so on, as they
were added to the guest. If those block devices contain
partitions, they will have the usual names (eg.
/dev/sda1). Also LVM /dev/VG/LV-style names
can be used, or &rsquo;mountable&rsquo; strings returned by
"guestfs_list_filesystems" or
"guestfs_inspect_get_mountpoints".

The rules are
the same as for mount(2): A filesystem must first be
mounted on / before others can be mounted. Other
filesystems can only be mounted on directories which already
exist.

The mounted
filesystem is writable, if we have sufficient permissions on
the underlying device.

Before
libguestfs 1.13.16, this call implicitly added the options
"sync" and "noatime". The
"sync" option greatly slowed writes and caused
many problems for users. If your program might need to work
with older versions of libguestfs, use
"guestfs_mount_options" instead (using an empty
string for the first parameter if you don&rsquo;t want any
options).

This function
returns 0 on success or -1 on error.

(Added in
0.3)

guestfs_mount_9p

int 
guestfs_mount_9p (guestfs_h *g, 
const char *mounttag, 
const char *mountpoint, 
...);

This
function is deprecated. There is no replacement. Consult
the API documentation in guestfs(3) for further
information.

Deprecated
functions will not be removed from the API, but the fact
that they are deprecated indicates that there are problems
with correct use of these functions.

You may supply
a list of optional arguments to this call. Use zero or more
of the following pairs of parameters, and terminate the list
with -1 on its own. See "CALLS WITH OPTIONAL
ARGUMENTS".

GUESTFS_MOUNT_9P_OPTIONS,
const char *options,

This call does
nothing and returns an error.

This function
returns 0 on success or -1 on error.

(Added in
1.11.12)

guestfs_mount_9p_va

int 
guestfs_mount_9p_va (guestfs_h *g, 
const char *mounttag, 
const char *mountpoint, 
va_list args);

This is the
"va_list variant" of
"guestfs_mount_9p".

See "CALLS
WITH OPTIONAL ARGUMENTS".

guestfs_mount_9p_argv

int 
guestfs_mount_9p_argv (guestfs_h *g, 
const char *mounttag, 
const char *mountpoint, 
const struct guestfs_mount_9p_argv *optargs);

This is the
"argv variant" of
"guestfs_mount_9p".

See "CALLS
WITH OPTIONAL ARGUMENTS".

guestfs_mount_local

int 
guestfs_mount_local (guestfs_h *g, 
const char *localmountpoint, 
...);

You may supply
a list of optional arguments to this call. Use zero or more
of the following pairs of parameters, and terminate the list
with -1 on its own. See "CALLS WITH OPTIONAL
ARGUMENTS".

GUESTFS_MOUNT_LOCAL_READONLY,
int readonly, 
GUESTFS_MOUNT_LOCAL_OPTIONS, const char *options, 
GUESTFS_MOUNT_LOCAL_CACHETIMEOUT, int cachetimeout, 
GUESTFS_MOUNT_LOCAL_DEBUGCALLS, int debugcalls,

This call
exports the libguestfs-accessible filesystem to a local
mountpoint (directory) called "localmountpoint".
Ordinary reads and writes to files and directories under
"localmountpoint" are redirected through
libguestfs.

If the optional
"readonly" flag is set to true, then writes to the
filesystem return error "EROFS".

"options"
is a comma-separated list of mount options. See
guestmount(1) for some useful options.

"cachetimeout"
sets the timeout (in seconds) for cached directory entries.
The default is 60 seconds. See guestmount(1) for
further information.

If
"debugcalls" is set to true, then additional
debugging information is generated for every FUSE call.

When
"guestfs_mount_local" returns, the filesystem is
ready, but is not processing requests (access to it will
block). You have to call "guestfs_mount_local_run"
to run the main loop.

See "MOUNT
LOCAL" for full documentation.

This function
returns 0 on success or -1 on error.

(Added in
1.17.22)

guestfs_mount_local_va

int 
guestfs_mount_local_va (guestfs_h *g, 
const char *localmountpoint, 
va_list args);

This is the
"va_list variant" of
"guestfs_mount_local".

See "CALLS
WITH OPTIONAL ARGUMENTS".

guestfs_mount_local_argv

int 
guestfs_mount_local_argv (guestfs_h *g, 
const char *localmountpoint, 
const struct guestfs_mount_local_argv *optargs);

This is the
"argv variant" of
"guestfs_mount_local".

See "CALLS
WITH OPTIONAL ARGUMENTS".

guestfs_mount_local_run

int 
guestfs_mount_local_run (guestfs_h *g);

Run the main
loop which translates kernel calls to libguestfs calls.

This should
only be called after "guestfs_mount_local" returns
successfully. The call will not return until the filesystem
is unmounted.

Note you
must not make concurrent libguestfs calls on the same
handle from another thread.

You may call
this from a different thread than the one which called
"guestfs_mount_local", subject to the usual rules
for threads and libguestfs (see "MULTIPLE HANDLES AND
MULTIPLE THREADS").

See "MOUNT
LOCAL" for full documentation.

This function
returns 0 on success or -1 on error.

(Added in
1.17.22)

guestfs_mount_loop

int 
guestfs_mount_loop (guestfs_h *g, 
const char *file, 
const char *mountpoint);

This command
lets you mount file (a filesystem image in a file) on
a mount point. It is entirely equivalent to the command
"mount -o loop file mountpoint".

This function
returns 0 on success or -1 on error.

(Added in
1.0.54)

guestfs_mount_options

int 
guestfs_mount_options (guestfs_h *g, 
const char *options, 
const char *mountable, 
const char *mountpoint);

This is the
same as the "guestfs_mount" command, but it allows
you to set the mount options as for the mount(8)
-o flag.

If the
"options" parameter is an empty string, then no
options are passed (all options default to whatever the
filesystem uses).

This function
returns 0 on success or -1 on error.

(Added in
1.0.10)

guestfs_mount_ro

int 
guestfs_mount_ro (guestfs_h *g, 
const char *mountable, 
const char *mountpoint);

This is the
same as the "guestfs_mount" command, but it mounts
the filesystem with the read-only (-o ro) flag.

This function
returns 0 on success or -1 on error.

(Added in
1.0.10)

guestfs_mount_vfs

int 
guestfs_mount_vfs (guestfs_h *g, 
const char *options, 
const char *vfstype, 
const char *mountable, 
const char *mountpoint);

This is the
same as the "guestfs_mount" command, but it allows
you to set both the mount options and the vfstype as for the
mount(8) -o and -t flags.

This function
returns 0 on success or -1 on error.

(Added in
1.0.10)

guestfs_mountable_device

char * 
guestfs_mountable_device (guestfs_h *g, 
const char *mountable);

Returns the
device name of a mountable. In quite a lot of cases, the
mountable is the device name.

However this
doesn&rsquo;t apply for btrfs subvolumes, where the
mountable is a combination of both the device name and the
subvolume path (see also
"guestfs_mountable_subvolume" to extract the
subvolume path of the mountable if any).

This function
returns a string, or NULL on error. The caller must free
the returned string after use.

(Added in
1.33.15)

guestfs_mountable_subvolume

char * 
guestfs_mountable_subvolume (guestfs_h *g, 
const char *mountable);

Returns the
subvolume path of a mountable. Btrfs subvolumes mountables
are a combination of both the device name and the subvolume
path (see also "guestfs_mountable_device" to
extract the device of the mountable).

If the
mountable does not represent a btrfs subvolume, then this
function fails and the "errno" is set to
"EINVAL".

This function
returns a string, or NULL on error. The caller must free
the returned string after use.

(Added in
1.33.15)

guestfs_mountpoints

char ** 
guestfs_mountpoints (guestfs_h *g);

This call is
similar to "guestfs_mounts". That call returns a
list of devices. This one returns a hash table (map) of
device name to directory where the device is mounted.

This function
returns a NULL-terminated array of strings, or NULL if there
was an error. The array of strings will always have length
"2n+1", where "n" keys and values
alternate, followed by the trailing NULL entry. The
caller must free the strings and the array after
use.

(Added in
1.0.62)

guestfs_mounts

char ** 
guestfs_mounts (guestfs_h *g);

This returns
the list of currently mounted filesystems. It returns the
list of devices (eg. /dev/sda1,
/dev/VG/LV).

Some internal
mounts are not shown.

See also:
"guestfs_mountpoints"

This function
returns a NULL-terminated array of strings (like
environ(3)), or NULL if there was an error. The
caller must free the strings and the array after
use.

(Added in
0.8)

guestfs_mv

int 
guestfs_mv (guestfs_h *g, 
const char *src, 
const char *dest);

This moves a
file from "src" to "dest" where
"dest" is either a destination filename or
destination directory.

See also:
"guestfs_rename".

This function
returns 0 on success or -1 on error.

(Added in
1.0.18)

guestfs_nr_devices

int 
guestfs_nr_devices (guestfs_h *g);

This returns
the number of whole block devices that were added. This is
the same as the number of devices that would be returned if
you called "guestfs_list_devices".

To find out the
maximum number of devices that could be added, call
"guestfs_max_disks".

On error this
function returns -1.

(Added in
1.19.15)

guestfs_ntfs_3g_probe

int 
guestfs_ntfs_3g_probe (guestfs_h *g, 
int rw, 
const char *device);

This command
runs the ntfs-3g.probe(8) command which probes an
NTFS "device" for mountability. (Not all NTFS
volumes can be mounted read-write, and some cannot be
mounted at all).

"rw"
is a boolean flag. Set it to true if you want to test if the
volume can be mounted read-write. Set it to false if you
want to test if the volume can be mounted read-only.

The return
value is an integer which 0 if the operation would succeed,
or some non-zero value documented in the
ntfs-3g.probe(8) manual page.

On error this
function returns -1.

This function
depends on the feature "ntfs3g". See also
"guestfs_feature_available".

(Added in
1.0.43)

guestfs_ntfscat_i

int 
guestfs_ntfscat_i (guestfs_h *g, 
const char *device, 
int64_t inode, 
const char *filename);

Download a file
given its inode from a NTFS filesystem and save it as
filename on the local machine.

This allows to
download some otherwise inaccessible files such as the ones
within the $Extend folder.

The filesystem
from which to extract the file must be unmounted, otherwise
the call will fail.

This function
returns 0 on success or -1 on error.

This
long-running command can generate progress notification
messages so that the caller can display a progress bar or
indicator. To receive these messages, the caller must
register a progress event callback. See
"GUESTFS_EVENT_PROGRESS".

(Added in
1.33.14)

guestfs_ntfsclone_in

int 
guestfs_ntfsclone_in (guestfs_h *g, 
const char *backupfile, 
const char *device);

Restore the
"backupfile" (from a previous call to
"guestfs_ntfsclone_out") to "device",
overwriting any existing contents of this device.

This function
returns 0 on success or -1 on error.

This function
depends on the feature "ntfs3g". See also
"guestfs_feature_available".

(Added in
1.17.9)

guestfs_ntfsclone_out

int 
guestfs_ntfsclone_out (guestfs_h *g, 
const char *device, 
const char *backupfile, 
...);

You may supply
a list of optional arguments to this call. Use zero or more
of the following pairs of parameters, and terminate the list
with -1 on its own. See "CALLS WITH OPTIONAL
ARGUMENTS".

GUESTFS_NTFSCLONE_OUT_METADATAONLY,
int metadataonly, 
GUESTFS_NTFSCLONE_OUT_RESCUE, int rescue, 
GUESTFS_NTFSCLONE_OUT_IGNOREFSCHECK, int ignorefscheck, 
GUESTFS_NTFSCLONE_OUT_PRESERVETIMESTAMPS, int
preservetimestamps, 
GUESTFS_NTFSCLONE_OUT_FORCE, int force,

Stream the NTFS
filesystem "device" to the local file
"backupfile". The format used for the backup file
is a special format used by the ntfsclone(8)
tool.

If the optional
"metadataonly" flag is true, then only the
metadata is saved, losing all the user data (this is useful
for diagnosing some filesystem problems).

The optional
"rescue", "ignorefscheck",
"preservetimestamps" and "force" flags
have precise meanings detailed in the ntfsclone(8)
man page.

Use
"guestfs_ntfsclone_in" to restore the file back to
a libguestfs device.

This function
returns 0 on success or -1 on error.

This function
depends on the feature "ntfs3g". See also
"guestfs_feature_available".

(Added in
1.17.9)

guestfs_ntfsclone_out_va

int 
guestfs_ntfsclone_out_va (guestfs_h *g, 
const char *device, 
const char *backupfile, 
va_list args);

This is the
"va_list variant" of
"guestfs_ntfsclone_out".

See "CALLS
WITH OPTIONAL ARGUMENTS".

guestfs_ntfsclone_out_argv

int 
guestfs_ntfsclone_out_argv (guestfs_h *g, 
const char *device, 
const char *backupfile, 
const struct guestfs_ntfsclone_out_argv *optargs);

This is the
"argv variant" of
"guestfs_ntfsclone_out".

See "CALLS
WITH OPTIONAL ARGUMENTS".

guestfs_ntfsfix

int 
guestfs_ntfsfix (guestfs_h *g, 
const char *device, 
...);

You may supply
a list of optional arguments to this call. Use zero or more
of the following pairs of parameters, and terminate the list
with -1 on its own. See "CALLS WITH OPTIONAL
ARGUMENTS".

GUESTFS_NTFSFIX_CLEARBADSECTORS,
int clearbadsectors,

This command
repairs some fundamental NTFS inconsistencies, resets the
NTFS journal file, and schedules an NTFS consistency check
for the first boot into Windows.

This is
not an equivalent of Windows "chkdsk". It
does not scan the filesystem for inconsistencies.

The optional
"clearbadsectors" flag clears the list of bad
sectors. This is useful after cloning a disk with bad
sectors to a new disk.

This function
returns 0 on success or -1 on error.

This function
depends on the feature "ntfs3g". See also
"guestfs_feature_available".

(Added in
1.17.9)

guestfs_ntfsfix_va

int 
guestfs_ntfsfix_va (guestfs_h *g, 
const char *device, 
va_list args);

This is the
"va_list variant" of
"guestfs_ntfsfix".

See "CALLS
WITH OPTIONAL ARGUMENTS".

guestfs_ntfsfix_argv

int 
guestfs_ntfsfix_argv (guestfs_h *g, 
const char *device, 
const struct guestfs_ntfsfix_argv *optargs);

This is the
"argv variant" of "guestfs_ntfsfix".

See "CALLS
WITH OPTIONAL ARGUMENTS".

guestfs_ntfsresize

int 
guestfs_ntfsresize (guestfs_h *g, 
const char *device);

This function
is provided for backwards compatibility with earlier
versions of libguestfs. It simply calls
"guestfs_ntfsresize_opts" with no optional
arguments.

(Added in
1.3.2)

guestfs_ntfsresize_opts

int 
guestfs_ntfsresize_opts (guestfs_h *g, 
const char *device, 
...);

You may supply
a list of optional arguments to this call. Use zero or more
of the following pairs of parameters, and terminate the list
with -1 on its own. See "CALLS WITH OPTIONAL
ARGUMENTS".

GUESTFS_NTFSRESIZE_OPTS_SIZE,
int64_t size, 
GUESTFS_NTFSRESIZE_OPTS_FORCE, int force,

This command
resizes an NTFS filesystem, expanding or shrinking it to the
size of the underlying device.

The optional
parameters are: 
"size"

The new size (in bytes) of the
filesystem. If omitted, the filesystem is resized to fit the
container (eg. partition).

"force"

If this option is true, then
force the resize of the filesystem even if the filesystem is
marked as requiring a consistency check.

After the
resize operation, the filesystem is always marked as
requiring a consistency check (for safety). You have to boot
into Windows to perform this check and clear this condition.
If you don&rsquo;t set the "force" option
then it is not possible to call
"guestfs_ntfsresize" multiple times on a single
filesystem without booting into Windows between each
resize.

See also
ntfsresize(8).

This function
returns 0 on success or -1 on error.

This function
depends on the feature "ntfsprogs". See also
"guestfs_feature_available".

(Added in
1.3.2)

guestfs_ntfsresize_opts_va

int 
guestfs_ntfsresize_opts_va (guestfs_h *g, 
const char *device, 
va_list args);

This is the
"va_list variant" of
"guestfs_ntfsresize_opts".

See "CALLS
WITH OPTIONAL ARGUMENTS".

guestfs_ntfsresize_opts_argv

int 
guestfs_ntfsresize_opts_argv (guestfs_h *g, 
const char *device, 
const struct guestfs_ntfsresize_opts_argv *optargs);

This is the
"argv variant" of
"guestfs_ntfsresize_opts".

See "CALLS
WITH OPTIONAL ARGUMENTS".

guestfs_ntfsresize_size

int 
guestfs_ntfsresize_size (guestfs_h *g, 
const char *device, 
int64_t size);

This
function is deprecated. In new code, use the
"guestfs_ntfsresize" call instead.

Deprecated
functions will not be removed from the API, but the fact
that they are deprecated indicates that there are problems
with correct use of these functions.

This command is
the same as "guestfs_ntfsresize" except that it
allows you to specify the new size (in bytes)
explicitly.

This function
returns 0 on success or -1 on error.

This function
depends on the feature "ntfsprogs". See also
"guestfs_feature_available".

(Added in
1.3.14)

guestfs_parse_environment

int 
guestfs_parse_environment (guestfs_h *g);

Parse the
program&rsquo;s environment and set flags in the handle
accordingly. For example if "LIBGUESTFS_DEBUG=1"
then the &rsquo;verbose&rsquo; flag is set in the
handle.

Most
programs do not need to call this. It is done implicitly
when you call "guestfs_create".

See
"ENVIRONMENT VARIABLES" for a list of environment
variables that can affect libguestfs handles. See also
"guestfs_create_flags", and
"guestfs_parse_environment_list".

This function
returns 0 on success or -1 on error.

(Added in
1.19.53)

guestfs_parse_environment_list

int 
guestfs_parse_environment_list (guestfs_h *g, 
char *const *environment);

Parse the list
of strings in the argument "environment" and set
flags in the handle accordingly. For example if
"LIBGUESTFS_DEBUG=1" is a string in the list, then
the &rsquo;verbose&rsquo; flag is set in the handle.

This is the
same as "guestfs_parse_environment" except that it
parses an explicit list of strings instead of the
program&rsquo;s environment.

This function
returns 0 on success or -1 on error.

(Added in
1.19.53)

guestfs_part_add

int 
guestfs_part_add (guestfs_h *g, 
const char *device, 
const char *prlogex, 
int64_t startsect, 
int64_t endsect);

This command
adds a partition to "device". If there is no
partition table on the device, call
"guestfs_part_init" first.

The
"prlogex" parameter is the type of partition.
Normally you should pass "p" or
"primary" here, but MBR partition tables also
support "l" (or "logical") and
"e" (or "extended") partition types.

"startsect"
and "endsect" are the start and end of the
partition in sectors. "endsect" may be
negative, which means it counts backwards from the end of
the disk (-1 is the last sector).

Creating a
partition which covers the whole disk is not so easy. Use
"guestfs_part_disk" to do that.

This function
returns 0 on success or -1 on error.

(Added in
1.0.78)

guestfs_part_del

int 
guestfs_part_del (guestfs_h *g, 
const char *device, 
int partnum);

This command
deletes the partition numbered "partnum" on
"device".

Note that in
the case of MBR partitioning, deleting an extended partition
also deletes any logical partitions it contains.

This function
returns 0 on success or -1 on error.

(Added in
1.3.2)

guestfs_part_disk

int 
guestfs_part_disk (guestfs_h *g, 
const char *device, 
const char *parttype);

This command is
simply a combination of "guestfs_part_init"
followed by "guestfs_part_add" to create a single
primary partition covering the whole disk.

"parttype"
is the partition table type, usually "mbr" or
"gpt", but other possible values are described in
"guestfs_part_init".

This function
returns 0 on success or -1 on error.

(Added in
1.0.78)

guestfs_part_expand_gpt

int 
guestfs_part_expand_gpt (guestfs_h *g, 
const char *device);

Move backup GPT
data structures to the end of the disk. This is useful in
case of in-place image expand since disk space after backup
GPT header is not usable. This is equivalent to "sgdisk
-e".

See also
sgdisk(8).

This function
returns 0 on success or -1 on error.

This function
depends on the feature "gdisk". See also
"guestfs_feature_available".

(Added in
1.33.2)

guestfs_part_get_bootable

int 
guestfs_part_get_bootable (guestfs_h *g, 
const char *device, 
int partnum);

This command
returns true if the partition "partnum" on
"device" has the bootable flag set.

See also
"guestfs_part_set_bootable".

This function
returns a C truth value on success or -1 on error.

(Added in
1.3.2)

guestfs_part_get_disk_guid

char * 
guestfs_part_get_disk_guid (guestfs_h *g, 
const char *device);

Return the disk
identifier (GUID) of a GPT-partitioned "device".
Behaviour is undefined for other partition types.

This function
returns a string, or NULL on error. The caller must free
the returned string after use.

This function
depends on the feature "gdisk". See also
"guestfs_feature_available".

(Added in
1.33.2)

guestfs_part_get_gpt_attributes

int64_t 
guestfs_part_get_gpt_attributes (guestfs_h *g, 
const char *device, 
int partnum);

Return the
attribute flags of numbered GPT partition
"partnum". An error is returned for MBR
partitions.

On error this
function returns -1.

This function
depends on the feature "gdisk". See also
"guestfs_feature_available".

(Added in
1.21.1)

guestfs_part_get_gpt_guid

char * 
guestfs_part_get_gpt_guid (guestfs_h *g, 
const char *device, 
int partnum);

Return the GUID
of numbered GPT partition "partnum".

This function
returns a string, or NULL on error. The caller must free
the returned string after use.

This function
depends on the feature "gdisk". See also
"guestfs_feature_available".

(Added in
1.29.25)

guestfs_part_get_gpt_type

char * 
guestfs_part_get_gpt_type (guestfs_h *g, 
const char *device, 
int partnum);

Return the type
GUID of numbered GPT partition "partnum".

This function
returns a string, or NULL on error. The caller must free
the returned string after use.

This function
depends on the feature "gdisk". See also
"guestfs_feature_available".

(Added in
1.21.1)

guestfs_part_get_mbr_id

int 
guestfs_part_get_mbr_id (guestfs_h *g, 
const char *device, 
int partnum);

Returns the MBR
type byte (also known as the ID byte) from the numbered
partition "partnum".

Note that only
MBR (old DOS-style) partitions have type bytes. You will get
undefined results for other partition table types (see
"guestfs_part_get_parttype").

On error this
function returns -1.

(Added in
1.3.2)

guestfs_part_get_mbr_part_type

char * 
guestfs_part_get_mbr_part_type (guestfs_h *g, 
const char *device, 
int partnum);

This returns
the partition type of an MBR partition numbered
"partnum" on device "device".

It returns
"primary", "logical", or
"extended".

This function
returns a string, or NULL on error. The caller must free
the returned string after use.

(Added in
1.29.32)

guestfs_part_get_name

char * 
guestfs_part_get_name (guestfs_h *g, 
const char *device, 
int partnum);

This gets the
partition name on partition numbered "partnum" on
device "device". Note that partitions are numbered
from 1.

The partition
name can only be read on certain types of partition table.
This works on "gpt" but not on "mbr"
partitions.

This function
returns a string, or NULL on error. The caller must free
the returned string after use.

(Added in
1.25.33)

guestfs_part_get_parttype

char * 
guestfs_part_get_parttype (guestfs_h *g, 
const char *device);

This command
examines the partition table on "device" and
returns the partition table type (format) being used.

Common return
values include: "msdos" (a DOS/Windows style MBR
partition table), "gpt" (a GPT/EFI-style partition
table). Other values are possible, although unusual. See
"guestfs_part_init" for a full list.

This function
returns a string, or NULL on error. The caller must free
the returned string after use.

(Added in
1.0.78)

guestfs_part_init

int 
guestfs_part_init (guestfs_h *g, 
const char *device, 
const char *parttype);

This creates an
empty partition table on "device" of one of the
partition types listed below. Usually "parttype"
should be either "msdos" or "gpt" (for
large disks).

Initially there
are no partitions. Following this, you should call
"guestfs_part_add" for each partition
required.

Possible values
for "parttype" are: 
"efi" 
"gpt"

Intel EFI / GPT partition
table.

This is
recommended for >= 2 TB partitions that will be accessed
from Linux and Intel-based Mac OS X. It also has limited
backwards compatibility with the "mbr" format.

"mbr" 
"msdos"

The standard PC "Master
Boot Record" (MBR) format used by MS-DOS and Windows.
This partition type will only work for device sizes
up to 2 TB. For large disks we recommend using
"gpt".

Other partition
table types that may work but are not supported include:

"aix"

AIX disk labels.

"amiga" 
"rdb"

Amiga "Rigid Disk
Block" format.

"bsd"

BSD disk labels.

"dasd"

DASD, used on IBM
mainframes.

"dvh"

MIPS/SGI volumes.

"mac"

Old Mac partition format.
Modern Macs use "gpt".

"pc98"

NEC PC-98 format, common in
Japan apparently.

"sun"

Sun disk labels.

This function
returns 0 on success or -1 on error.

(Added in
1.0.78)

guestfs_part_list

struct guestfs_partition_list * 
guestfs_part_list (guestfs_h *g, 
const char *device);

This command
parses the partition table on "device" and returns
the list of partitions found.

The fields in
the returned structure are: 
"part_num"

Partition number, counting from
1.

"part_start"

Start of the partition in
bytes. To get sectors you have to divide by the
device&rsquo;s sector size, see
"guestfs_blockdev_getss".

"part_end"

End of the partition in
bytes.

"part_size"

Size of the partition in
bytes.

This function
returns a "struct guestfs_partition_list *", or
NULL if there was an error. The caller must call
"guestfs_free_partition_list" after use.

(Added in
1.0.78)

guestfs_part_resize

int 
guestfs_part_resize (guestfs_h *g, 
const char *device, 
int partnum, 
int64_t endsect);

This command
resizes the partition numbered "partnum" on
"device" by moving the end position.

Note that this
does not modify any filesystem present in the partition. If
you wish to do this, you will need to use filesystem
resizing commands like "guestfs_resize2fs".

When growing a
partition you will want to grow the filesystem afterwards,
but when shrinking, you need to shrink the filesystem before
the partition.

This function
returns 0 on success or -1 on error.

(Added in
1.37.20)

guestfs_part_set_bootable

int 
guestfs_part_set_bootable (guestfs_h *g, 
const char *device, 
int partnum, 
int bootable);

This sets the
bootable flag on partition numbered "partnum" on
device "device". Note that partitions are numbered
from 1.

The bootable
flag is used by some operating systems (notably Windows) to
determine which partition to boot from. It is by no means
universally recognized.

This function
returns 0 on success or -1 on error.

(Added in
1.0.78)

guestfs_part_set_disk_guid

int 
guestfs_part_set_disk_guid (guestfs_h *g, 
const char *device, 
const char *guid);

Set the disk
identifier (GUID) of a GPT-partitioned "device" to
"guid". Return an error if the partition table of
"device" isn&rsquo;t GPT, or if "guid"
is not a valid GUID.

This function
returns 0 on success or -1 on error.

This function
depends on the feature "gdisk". See also
"guestfs_feature_available".

(Added in
1.33.2)

guestfs_part_set_disk_guid_random

int 
guestfs_part_set_disk_guid_random (guestfs_h *g, 
const char *device);

Set the disk
identifier (GUID) of a GPT-partitioned "device" to
a randomly generated value. Return an error if the partition
table of "device" isn&rsquo;t GPT.

This function
returns 0 on success or -1 on error.

This function
depends on the feature "gdisk". See also
"guestfs_feature_available".

(Added in
1.33.2)

guestfs_part_set_gpt_attributes

int 
guestfs_part_set_gpt_attributes (guestfs_h *g, 
const char *device, 
int partnum, 
int64_t attributes);

Set the
attribute flags of numbered GPT partition
"partnum" to "attributes". Return an
error if the partition table of "device"
isn&rsquo;t GPT.

See
https://en.wikipedia.org/wiki/GUID_Partition_Table#Partition_entries
for a useful list of partition attributes.

This function
returns 0 on success or -1 on error.

This function
depends on the feature "gdisk". See also
"guestfs_feature_available".

(Added in
1.21.1)

guestfs_part_set_gpt_guid

int 
guestfs_part_set_gpt_guid (guestfs_h *g, 
const char *device, 
int partnum, 
const char *guid);

Set the GUID of
numbered GPT partition "partnum" to
"guid". Return an error if the partition table of
"device" isn&rsquo;t GPT, or if "guid"
is not a valid GUID.

This function
returns 0 on success or -1 on error.

This function
depends on the feature "gdisk". See also
"guestfs_feature_available".

(Added in
1.29.25)

guestfs_part_set_gpt_type

int 
guestfs_part_set_gpt_type (guestfs_h *g, 
const char *device, 
int partnum, 
const char *guid);

Set the type
GUID of numbered GPT partition "partnum" to
"guid". Return an error if the partition table of
"device" isn&rsquo;t GPT, or if "guid"
is not a valid GUID.

See
https://en.wikipedia.org/wiki/GUID_Partition_Table#Partition_type_GUIDs
for a useful list of type GUIDs.

This function
returns 0 on success or -1 on error.

This function
depends on the feature "gdisk". See also
"guestfs_feature_available".

(Added in
1.21.1)

guestfs_part_set_mbr_id

int 
guestfs_part_set_mbr_id (guestfs_h *g, 
const char *device, 
int partnum, 
int idbyte);

Sets the MBR
type byte (also known as the ID byte) of the numbered
partition "partnum" to "idbyte". Note
that the type bytes quoted in most documentation are in fact
hexadecimal numbers, but usually documented without any
leading "0x" which might be confusing.

Note that only
MBR (old DOS-style) partitions have type bytes. You will get
undefined results for other partition table types (see
"guestfs_part_get_parttype").

This function
returns 0 on success or -1 on error.

(Added in
1.3.2)

guestfs_part_set_name

int 
guestfs_part_set_name (guestfs_h *g, 
const char *device, 
int partnum, 
const char *name);

This sets the
partition name on partition numbered "partnum" on
device "device". Note that partitions are numbered
from 1.

The partition
name can only be set on certain types of partition table.
This works on "gpt" but not on "mbr"
partitions.

This function
returns 0 on success or -1 on error.

(Added in
1.0.78)

guestfs_part_to_dev

char * 
guestfs_part_to_dev (guestfs_h *g, 
const char *partition);

This function
takes a partition name (eg. "/dev/sdb1") and
removes the partition number, returning the device name (eg.
"/dev/sdb").

The named
partition must exist, for example as a string returned from
"guestfs_list_partitions".

See also
"guestfs_part_to_partnum",
"guestfs_device_index".

This function
returns a string, or NULL on error. The caller must free
the returned string after use.

(Added in
1.5.15)

guestfs_part_to_partnum

int 
guestfs_part_to_partnum (guestfs_h *g, 
const char *partition);

This function
takes a partition name (eg. "/dev/sdb1") and
returns the partition number (eg. 1).

The named
partition must exist, for example as a string returned from
"guestfs_list_partitions".

See also
"guestfs_part_to_dev".

On error this
function returns -1.

(Added in
1.13.25)

guestfs_ping_daemon

int 
guestfs_ping_daemon (guestfs_h *g);

This is a test
probe into the guestfs daemon running inside the libguestfs
appliance. Calling this function checks that the daemon
responds to the ping message, without affecting the daemon
or attached block device(s) in any other way.

This function
returns 0 on success or -1 on error.

(Added in
1.0.18)

guestfs_pread

char * 
guestfs_pread (guestfs_h *g, 
const char *path, 
int count, 
int64_t offset, 
size_t *size_r);

This command
lets you read part of a file. It reads "count"
bytes of the file, starting at "offset", from file
"path".

This may read
fewer bytes than requested. For further details see the
pread(2) system call.

See also
"guestfs_pwrite",
"guestfs_pread_device".

This function
returns a buffer, or NULL on error. The size of the returned
buffer is written to *size_r. The caller must free the
returned buffer after use.

Because of the
message protocol, there is a transfer limit of somewhere
between 2MB and 4MB. See "PROTOCOL LIMITS".

(Added in
1.0.77)

guestfs_pread_device

char * 
guestfs_pread_device (guestfs_h *g, 
const char *device, 
int count, 
int64_t offset, 
size_t *size_r);

This command
lets you read part of a block device. It reads
"count" bytes of "device", starting at
"offset".

This may read
fewer bytes than requested. For further details see the
pread(2) system call.

See also
"guestfs_pread".

This function
returns a buffer, or NULL on error. The size of the returned
buffer is written to *size_r. The caller must free the
returned buffer after use.

Because of the
message protocol, there is a transfer limit of somewhere
between 2MB and 4MB. See "PROTOCOL LIMITS".

(Added in
1.5.21)

guestfs_pvchange_uuid

int 
guestfs_pvchange_uuid (guestfs_h *g, 
const char *device);

Generate a new
random UUID for the physical volume "device".

This function
returns 0 on success or -1 on error.

This function
depends on the feature "lvm2". See also
"guestfs_feature_available".

(Added in
1.19.26)

guestfs_pvchange_uuid_all

int 
guestfs_pvchange_uuid_all (guestfs_h *g);

Generate new
random UUIDs for all physical volumes.

This function
returns 0 on success or -1 on error.

This function
depends on the feature "lvm2". See also
"guestfs_feature_available".

(Added in
1.19.26)

guestfs_pvcreate

int 
guestfs_pvcreate (guestfs_h *g, 
const char *device);

This creates an
LVM physical volume on the named "device", where
"device" should usually be a partition name such
as /dev/sda1.

This function
returns 0 on success or -1 on error.

This function
depends on the feature "lvm2". See also
"guestfs_feature_available".

(Added in
0.8)

guestfs_pvremove

int 
guestfs_pvremove (guestfs_h *g, 
const char *device);

This wipes a
physical volume "device" so that LVM will no
longer recognise it.

The
implementation uses the pvremove(8) command which
refuses to wipe physical volumes that contain any volume
groups, so you have to remove those first.

This function
returns 0 on success or -1 on error.

This function
depends on the feature "lvm2". See also
"guestfs_feature_available".

(Added in
1.0.13)

guestfs_pvresize

int 
guestfs_pvresize (guestfs_h *g, 
const char *device);

This resizes
(expands or shrinks) an existing LVM physical volume to
match the new size of the underlying device.

This function
returns 0 on success or -1 on error.

This function
depends on the feature "lvm2". See also
"guestfs_feature_available".

(Added in
1.0.26)

guestfs_pvresize_size

int 
guestfs_pvresize_size (guestfs_h *g, 
const char *device, 
int64_t size);

This command is
the same as "guestfs_pvresize" except that it
allows you to specify the new size (in bytes)
explicitly.

This function
returns 0 on success or -1 on error.

This function
depends on the feature "lvm2". See also
"guestfs_feature_available".

(Added in
1.3.14)

guestfs_pvs

char ** 
guestfs_pvs (guestfs_h *g);

List all the
physical volumes detected. This is the equivalent of the
pvs(8) command.

This returns a
list of just the device names that contain PVs (eg.
/dev/sda2).

See also
"guestfs_pvs_full".

This function
returns a NULL-terminated array of strings (like
environ(3)), or NULL if there was an error. The
caller must free the strings and the array after
use.

This function
depends on the feature "lvm2". See also
"guestfs_feature_available".

(Added in
0.4)

guestfs_pvs_full

struct guestfs_lvm_pv_list * 
guestfs_pvs_full (guestfs_h *g);

List all the
physical volumes detected. This is the equivalent of the
pvs(8) command. The "full" version includes
all fields.

This function
returns a "struct guestfs_lvm_pv_list *", or NULL
if there was an error. The caller must call
"guestfs_free_lvm_pv_list" after use.

This function
depends on the feature "lvm2". See also
"guestfs_feature_available".

(Added in
0.4)

guestfs_pvuuid

char * 
guestfs_pvuuid (guestfs_h *g, 
const char *device);

This command
returns the UUID of the LVM PV "device".

This function
returns a string, or NULL on error. The caller must free
the returned string after use.

(Added in
1.0.87)

guestfs_pwrite

int 
guestfs_pwrite (guestfs_h *g, 
const char *path, 
const char *content, 
size_t content_size, 
int64_t offset);

This command
writes to part of a file. It writes the data buffer
"content" to the file "path" starting at
offset "offset".

This command
implements the pwrite(2) system call, and like that
system call it may not write the full data requested. The
return value is the number of bytes that were actually
written to the file. This could even be 0, although short
writes are unlikely for regular files in ordinary
circumstances.

See also
"guestfs_pread",
"guestfs_pwrite_device".

On error this
function returns -1.

Because of the
message protocol, there is a transfer limit of somewhere
between 2MB and 4MB. See "PROTOCOL LIMITS".

(Added in
1.3.14)

guestfs_pwrite_device

int 
guestfs_pwrite_device (guestfs_h *g, 
const char *device, 
const char *content, 
size_t content_size, 
int64_t offset);

This command
writes to part of a device. It writes the data buffer
"content" to "device" starting at offset
"offset".

This command
implements the pwrite(2) system call, and like that
system call it may not write the full data requested
(although short writes to disk devices and partitions are
probably impossible with standard Linux kernels).

See also
"guestfs_pwrite".

On error this
function returns -1.

Because of the
message protocol, there is a transfer limit of somewhere
between 2MB and 4MB. See "PROTOCOL LIMITS".

(Added in
1.5.20)

guestfs_read_file

char * 
guestfs_read_file (guestfs_h *g, 
const char *path, 
size_t *size_r);

This calls
returns the contents of the file "path" as a
buffer.

Unlike
"guestfs_cat", this function can correctly handle
files that contain embedded ASCII NUL characters.

This function
returns a buffer, or NULL on error. The size of the returned
buffer is written to *size_r. The caller must free the
returned buffer after use.

(Added in
1.0.63)

guestfs_read_lines

char ** 
guestfs_read_lines (guestfs_h *g, 
const char *path);

Return the
contents of the file named "path".

The file
contents are returned as a list of lines. Trailing
"LF" and "CRLF" character sequences are
not returned.

Note that this
function cannot correctly handle binary files (specifically,
files containing "\0" character which is treated
as end of string). For those you need to use the
"guestfs_read_file" function and split the buffer
into lines yourself.

This function
returns a NULL-terminated array of strings (like
environ(3)), or NULL if there was an error. The
caller must free the strings and the array after
use.

(Added in
0.7)

guestfs_readdir

struct guestfs_dirent_list * 
guestfs_readdir (guestfs_h *g, 
const char *dir);

This returns
the list of directory entries in directory
"dir".

All entries in
the directory are returned, including "." and
"..". The entries are not sorted, but
returned in the same order as the underlying filesystem.

Also this call
returns basic file type information about each file. The
"ftyp" field will contain one of the following
characters:

&rsquo;b&rsquo;

Block special

&rsquo;c&rsquo;

Char special

&rsquo;d&rsquo;

Directory

&rsquo;f&rsquo;

FIFO (named pipe)

&rsquo;l&rsquo;

Symbolic link

&rsquo;r&rsquo;

Regular file

&rsquo;s&rsquo;

Socket

&rsquo;u&rsquo;

Unknown file type

&rsquo;?&rsquo;

The readdir(3) call returned a "d_type"
field with an unexpected value

This function
is primarily intended for use by programs. To get a simple
list of names, use "guestfs_ls". To get a
printable directory for human consumption, use
"guestfs_ll".

This function
returns a "struct guestfs_dirent_list *", or NULL
if there was an error. The caller must call
"guestfs_free_dirent_list" after use.

This
long-running command can generate progress notification
messages so that the caller can display a progress bar or
indicator. To receive these messages, the caller must
register a progress event callback. See
"GUESTFS_EVENT_PROGRESS".

(Added in
1.0.55)

guestfs_readlink

char * 
guestfs_readlink (guestfs_h *g, 
const char *path);

This command
reads the target of a symbolic link.

This function
returns a string, or NULL on error. The caller must free
the returned string after use.

(Added in
1.0.66)

guestfs_readlinklist

char ** 
guestfs_readlinklist (guestfs_h *g, 
const char *path, 
char *const *names);

This call
allows you to do a "readlink" operation on
multiple files, where all files are in the directory
"path". "names" is the list of files
from this directory.

On return you
get a list of strings, with a one-to-one correspondence to
the "names" list. Each string is the value of the
symbolic link.

If the
readlink(2) operation fails on any name, then the
corresponding result string is the empty string
"". However the whole operation is completed even
if there were readlink(2) errors, and so you can call
this function with names where you don&rsquo;t know if they
are symbolic links already (albeit slightly less
efficient).

This call is
intended for programs that want to efficiently list a
directory contents without making many round-trips.

This function
returns a NULL-terminated array of strings (like
environ(3)), or NULL if there was an error. The
caller must free the strings and the array after
use.

(Added in
1.0.77)

guestfs_realpath

char * 
guestfs_realpath (guestfs_h *g, 
const char *path);

Return the
canonicalized absolute pathname of "path". The
returned path has no ".", ".." or
symbolic link path elements.

This function
returns a string, or NULL on error. The caller must free
the returned string after use.

(Added in
1.0.66)

guestfs_remount

int 
guestfs_remount (guestfs_h *g, 
const char *mountpoint, 
...);

You may supply
a list of optional arguments to this call. Use zero or more
of the following pairs of parameters, and terminate the list
with -1 on its own. See "CALLS WITH OPTIONAL
ARGUMENTS".

GUESTFS_REMOUNT_RW,
int rw,

This call
allows you to change the "rw"
(readonly/read-write) flag on an already mounted filesystem
at "mountpoint", converting a readonly filesystem
to be read-write, or vice-versa.

Note that at
the moment you must supply the "optional"
"rw" parameter. In future we may allow other flags
to be adjusted.

This function
returns 0 on success or -1 on error.

(Added in
1.23.2)

guestfs_remount_va

int 
guestfs_remount_va (guestfs_h *g, 
const char *mountpoint, 
va_list args);

This is the
"va_list variant" of
"guestfs_remount".

See "CALLS
WITH OPTIONAL ARGUMENTS".

guestfs_remount_argv

int 
guestfs_remount_argv (guestfs_h *g, 
const char *mountpoint, 
const struct guestfs_remount_argv *optargs);

This is the
"argv variant" of "guestfs_remount".

See "CALLS
WITH OPTIONAL ARGUMENTS".

guestfs_remove_drive

int 
guestfs_remove_drive (guestfs_h *g, 
const char *label);

This
function is deprecated. There is no replacement. Consult
the API documentation in guestfs(3) for further
information.

Deprecated
functions will not be removed from the API, but the fact
that they are deprecated indicates that there are problems
with correct use of these functions.

This call does
nothing and returns an error.

This function
returns 0 on success or -1 on error.

(Added in
1.19.49)

guestfs_removexattr

int 
guestfs_removexattr (guestfs_h *g, 
const char *xattr, 
const char *path);

This call
removes the extended attribute named "xattr" of
the file "path".

See also:
"guestfs_lremovexattr", attr(5).

This function
returns 0 on success or -1 on error.

This function
depends on the feature "linuxxattrs". See also
"guestfs_feature_available".

(Added in
1.0.59)

guestfs_rename

int 
guestfs_rename (guestfs_h *g, 
const char *oldpath, 
const char *newpath);

Rename a file
to a new place on the same filesystem. This is the same as
the Linux rename(2) system call. In most cases you
are better to use "guestfs_mv" instead.

This function
returns 0 on success or -1 on error.

(Added in
1.21.5)

guestfs_resize2fs

int 
guestfs_resize2fs (guestfs_h *g, 
const char *device);

This resizes an
ext2, ext3 or ext4 filesystem to match the size of the
underlying device.

See also
"RESIZE2FS ERRORS".

This function
returns 0 on success or -1 on error.

(Added in
1.0.27)

guestfs_resize2fs_M

int 
guestfs_resize2fs_M (guestfs_h *g, 
const char *device);

This command is
the same as "guestfs_resize2fs", but the
filesystem is resized to its minimum size. This works like
the -M option to the resize2fs(8) command.

To get the
resulting size of the filesystem you should call
"guestfs_tune2fs_l" and read the "Block
size" and "Block count" values. These two
numbers, multiplied together, give the resulting size of the
minimal filesystem in bytes.

See also
"RESIZE2FS ERRORS".

This function
returns 0 on success or -1 on error.

(Added in
1.9.4)

guestfs_resize2fs_size

int 
guestfs_resize2fs_size (guestfs_h *g, 
const char *device, 
int64_t size);

This command is
the same as "guestfs_resize2fs" except that it
allows you to specify the new size (in bytes)
explicitly.

See also
"RESIZE2FS ERRORS".

This function
returns 0 on success or -1 on error.

(Added in
1.3.14)

guestfs_rm

int 
guestfs_rm (guestfs_h *g, 
const char *path);

Remove the
single file "path".

This function
returns 0 on success or -1 on error.

(Added in
0.8)

guestfs_rm_f

int 
guestfs_rm_f (guestfs_h *g, 
const char *path);

Remove the file
"path".

If the file
doesn&rsquo;t exist, that error is ignored. (Other errors,
eg. I/O errors or bad paths, are not ignored)

This call
cannot remove directories. Use "guestfs_rmdir" to
remove an empty directory, or "guestfs_rm_rf" to
remove directories recursively.

This function
returns 0 on success or -1 on error.

(Added in
1.19.42)

guestfs_rm_rf

int 
guestfs_rm_rf (guestfs_h *g, 
const char *path);

Remove the file
or directory "path", recursively removing the
contents if its a directory. This is like the "rm
-rf" shell command.

This function
returns 0 on success or -1 on error.

(Added in
0.8)

guestfs_rmdir

int 
guestfs_rmdir (guestfs_h *g, 
const char *path);

Remove the
single directory "path".

This function
returns 0 on success or -1 on error.

(Added in
0.8)

guestfs_rmmountpoint

int 
guestfs_rmmountpoint (guestfs_h *g, 
const char *exemptpath);

This call
removes a mountpoint that was previously created with
"guestfs_mkmountpoint". See
"guestfs_mkmountpoint" for full details.

This function
returns 0 on success or -1 on error.

(Added in
1.0.62)

guestfs_rsync

int 
guestfs_rsync (guestfs_h *g, 
const char *src, 
const char *dest, 
...);

You may supply
a list of optional arguments to this call. Use zero or more
of the following pairs of parameters, and terminate the list
with -1 on its own. See "CALLS WITH OPTIONAL
ARGUMENTS".

GUESTFS_RSYNC_ARCHIVE,
int archive, 
GUESTFS_RSYNC_DELETEDEST, int deletedest,

This call may
be used to copy or synchronize two directories under the
same libguestfs handle. This uses the rsync(1)
program which uses a fast algorithm that avoids copying
files unnecessarily.

"src"
and "dest" are the source and destination
directories. Files are copied from "src" to
"dest".

The optional
arguments are: 
"archive"

Turns on archive mode. This is
the same as passing the --archive flag to
"rsync".

"deletedest"

Delete files at the destination
that do not exist at the source.

This function
returns 0 on success or -1 on error.

This function
depends on the feature "rsync". See also
"guestfs_feature_available".

(Added in
1.19.29)

guestfs_rsync_va

int 
guestfs_rsync_va (guestfs_h *g, 
const char *src, 
const char *dest, 
va_list args);

This is the
"va_list variant" of
"guestfs_rsync".

See "CALLS
WITH OPTIONAL ARGUMENTS".

guestfs_rsync_argv

int 
guestfs_rsync_argv (guestfs_h *g, 
const char *src, 
const char *dest, 
const struct guestfs_rsync_argv *optargs);

This is the
"argv variant" of "guestfs_rsync".

See "CALLS
WITH OPTIONAL ARGUMENTS".

guestfs_rsync_in

int 
guestfs_rsync_in (guestfs_h *g, 
const char *remote, 
const char *dest, 
...);

You may supply
a list of optional arguments to this call. Use zero or more
of the following pairs of parameters, and terminate the list
with -1 on its own. See "CALLS WITH OPTIONAL
ARGUMENTS".

GUESTFS_RSYNC_IN_ARCHIVE,
int archive, 
GUESTFS_RSYNC_IN_DELETEDEST, int deletedest,

This call may
be used to copy or synchronize the filesystem on the host or
on a remote computer with the filesystem within libguestfs.
This uses the rsync(1) program which uses a fast
algorithm that avoids copying files unnecessarily.

This call only
works if the network is enabled. See
"guestfs_set_network" or the --network
option to various tools like guestfish(1).

Files are
copied from the remote server and directory specified by
"remote" to the destination directory
"dest".

The format of
the remote server string is defined by rsync(1). Note
that there is no way to supply a password or passphrase so
the target must be set up not to require one.

The optional
arguments are the same as those of
"guestfs_rsync".

This function
returns 0 on success or -1 on error.

This function
depends on the feature "rsync". See also
"guestfs_feature_available".

(Added in
1.19.29)

guestfs_rsync_in_va

int 
guestfs_rsync_in_va (guestfs_h *g, 
const char *remote, 
const char *dest, 
va_list args);

This is the
"va_list variant" of
"guestfs_rsync_in".

See "CALLS
WITH OPTIONAL ARGUMENTS".

guestfs_rsync_in_argv

int 
guestfs_rsync_in_argv (guestfs_h *g, 
const char *remote, 
const char *dest, 
const struct guestfs_rsync_in_argv *optargs);

This is the
"argv variant" of
"guestfs_rsync_in".

See "CALLS
WITH OPTIONAL ARGUMENTS".

guestfs_rsync_out

int 
guestfs_rsync_out (guestfs_h *g, 
const char *src, 
const char *remote, 
...);

You may supply
a list of optional arguments to this call. Use zero or more
of the following pairs of parameters, and terminate the list
with -1 on its own. See "CALLS WITH OPTIONAL
ARGUMENTS".

GUESTFS_RSYNC_OUT_ARCHIVE,
int archive, 
GUESTFS_RSYNC_OUT_DELETEDEST, int deletedest,

This call may
be used to copy or synchronize the filesystem within
libguestfs with a filesystem on the host or on a remote
computer. This uses the rsync(1) program which uses a
fast algorithm that avoids copying files unnecessarily.

This call only
works if the network is enabled. See
"guestfs_set_network" or the --network
option to various tools like guestfish(1).

Files are
copied from the source directory "src" to the
remote server and directory specified by
"remote".

The format of
the remote server string is defined by rsync(1). Note
that there is no way to supply a password or passphrase so
the target must be set up not to require one.

The optional
arguments are the same as those of
"guestfs_rsync".

Globbing does
not happen on the "src" parameter. In programs
which use the API directly you have to expand wildcards
yourself (see "guestfs_glob_expand"). In guestfish
you can use the "glob" command (see
"glob" in guestfish(1)), for example:

>
glob rsync-out /* rsync://remote/

This function
returns 0 on success or -1 on error.

This function
depends on the feature "rsync". See also
"guestfs_feature_available".

(Added in
1.19.29)

guestfs_rsync_out_va

int 
guestfs_rsync_out_va (guestfs_h *g, 
const char *src, 
const char *remote, 
va_list args);

This is the
"va_list variant" of
"guestfs_rsync_out".

See "CALLS
WITH OPTIONAL ARGUMENTS".

guestfs_rsync_out_argv

int 
guestfs_rsync_out_argv (guestfs_h *g, 
const char *src, 
const char *remote, 
const struct guestfs_rsync_out_argv *optargs);

This is the
"argv variant" of
"guestfs_rsync_out".

See "CALLS
WITH OPTIONAL ARGUMENTS".

guestfs_scrub_device

int 
guestfs_scrub_device (guestfs_h *g, 
const char *device);

This command
writes patterns over "device" to make data
retrieval more difficult.

It is an
interface to the scrub(1) program. See that manual
page for more details.

This function
returns 0 on success or -1 on error.

This function
depends on the feature "scrub". See also
"guestfs_feature_available".

(Added in
1.0.52)

guestfs_scrub_file

int 
guestfs_scrub_file (guestfs_h *g, 
const char *file);

This command
writes patterns over a file to make data retrieval more
difficult.

The file is
removed after scrubbing.

It is an
interface to the scrub(1) program. See that manual
page for more details.

This function
returns 0 on success or -1 on error.

This function
depends on the feature "scrub". See also
"guestfs_feature_available".

(Added in
1.0.52)

guestfs_scrub_freespace

int 
guestfs_scrub_freespace (guestfs_h *g, 
const char *dir);

This command
creates the directory "dir" and then fills it with
files until the filesystem is full, and scrubs the files as
for "guestfs_scrub_file", and deletes them. The
intention is to scrub any free space on the partition
containing "dir".

It is an
interface to the scrub(1) program. See that manual
page for more details.

This function
returns 0 on success or -1 on error.

This function
depends on the feature "scrub". See also
"guestfs_feature_available".

(Added in
1.0.52)

guestfs_selinux_relabel

int 
guestfs_selinux_relabel (guestfs_h *g, 
const char *specfile, 
const char *path, 
...);

You may supply
a list of optional arguments to this call. Use zero or more
of the following pairs of parameters, and terminate the list
with -1 on its own. See "CALLS WITH OPTIONAL
ARGUMENTS".

GUESTFS_SELINUX_RELABEL_FORCE,
int force,

SELinux relabel
parts of the filesystem.

The
"specfile" parameter controls the policy spec file
used. You have to parse "/etc/selinux/config" to
find the correct SELinux policy and then pass the spec file,
usually: "/etc/selinux/" + selinuxtype +
"/contexts/files/file_contexts".

The required
"path" parameter is the top level directory where
relabelling starts. Normally you should pass
"path" as "/" to relabel the whole guest
filesystem.

The optional
"force" boolean controls whether the context is
reset for customizable files, and also whether the user,
role and range parts of the file context is changed.

This function
returns 0 on success or -1 on error.

This function
depends on the feature "selinuxrelabel". See also
"guestfs_feature_available".

(Added in
1.33.43)

guestfs_selinux_relabel_va

int 
guestfs_selinux_relabel_va (guestfs_h *g, 
const char *specfile, 
const char *path, 
va_list args);

This is the
"va_list variant" of
"guestfs_selinux_relabel".

See "CALLS
WITH OPTIONAL ARGUMENTS".

guestfs_selinux_relabel_argv

int 
guestfs_selinux_relabel_argv (guestfs_h *g, 
const char *specfile, 
const char *path, 
const struct guestfs_selinux_relabel_argv *optargs);

This is the
"argv variant" of
"guestfs_selinux_relabel".

See "CALLS
WITH OPTIONAL ARGUMENTS".

guestfs_set_append

int 
guestfs_set_append (guestfs_h *g, 
const char *append);

This function
is used to add additional options to the libguestfs
appliance kernel command line.

The default is
"NULL" unless overridden by setting
"LIBGUESTFS_APPEND" environment variable.

Setting
"append" to "NULL" means no
additional options are passed (libguestfs always adds a few
of its own).

This function
returns 0 on success or -1 on error.

(Added in
1.0.26)

guestfs_set_attach_method

int 
guestfs_set_attach_method (guestfs_h *g, 
const char *backend);

This
function is deprecated. In new code, use the
"guestfs_set_backend" call instead.

Deprecated
functions will not be removed from the API, but the fact
that they are deprecated indicates that there are problems
with correct use of these functions.

Set the method
that libguestfs uses to connect to the backend guestfsd
daemon.

See
"BACKEND".

This function
returns 0 on success or -1 on error.

(Added in
1.9.8)

guestfs_set_autosync

int 
guestfs_set_autosync (guestfs_h *g, 
int autosync);

If
"autosync" is true, this enables autosync.
Libguestfs will make a best effort attempt to make
filesystems consistent and synchronized when the handle is
closed (also if the program exits without closing
handles).

This is enabled
by default (since libguestfs 1.5.24, previously it was
disabled by default).

This function
returns 0 on success or -1 on error.

(Added in
0.3)

guestfs_set_backend

int 
guestfs_set_backend (guestfs_h *g, 
const char *backend);

Set the method
that libguestfs uses to connect to the backend guestfsd
daemon.

This handle
property was previously called the "attach
method".

See
"BACKEND".

This function
returns 0 on success or -1 on error.

(Added in
1.21.26)

guestfs_set_backend_setting

int 
guestfs_set_backend_setting (guestfs_h *g, 
const char *name, 
const char *val);

Append
"name=value" to the backend settings string list.
However if a string already exists matching "name"
or beginning with "name=", then that setting is
replaced.

See
"BACKEND", "BACKEND SETTINGS".

This function
returns 0 on success or -1 on error.

(Added in
1.27.2)

guestfs_set_backend_settings

int 
guestfs_set_backend_settings (guestfs_h *g, 
char *const *settings);

Set a list of
zero or more settings which are passed through to the
current backend. Each setting is a string which is
interpreted in a backend-specific way, or ignored if not
understood by the backend.

The default
value is an empty list, unless the environment variable
"LIBGUESTFS_BACKEND_SETTINGS" was set when the
handle was created. This environment variable contains a
colon-separated list of settings.

This call
replaces all backend settings. If you want to replace a
single backend setting, see
"guestfs_set_backend_setting". If you want to
clear a single backend setting, see
"guestfs_clear_backend_setting".

See
"BACKEND", "BACKEND SETTINGS".

This function
returns 0 on success or -1 on error.

(Added in
1.25.24)

guestfs_set_cachedir

int 
guestfs_set_cachedir (guestfs_h *g, 
const char *cachedir);

Set the
directory used by the handle to store the appliance cache,
when using a supermin appliance. The appliance is cached and
shared between all handles which have the same effective
user ID.

The environment
variables "LIBGUESTFS_CACHEDIR" and
"TMPDIR" control the default value: If
"LIBGUESTFS_CACHEDIR" is set, then that is the
default. Else if "TMPDIR" is set, then that is the
default. Else /var/tmp is the default.

This function
returns 0 on success or -1 on error.

(Added in
1.19.58)

guestfs_set_direct

int 
guestfs_set_direct (guestfs_h *g, 
int direct);

This
function is deprecated. In new code, use the
"guestfs_internal_get_console_socket" call
instead.

Deprecated
functions will not be removed from the API, but the fact
that they are deprecated indicates that there are problems
with correct use of these functions.

If the direct
appliance mode flag is enabled, then stdin and stdout are
passed directly through to the appliance once it is
launched.

One consequence
of this is that log messages aren&rsquo;t caught by the
library and handled by
"guestfs_set_log_message_callback", but go
straight to stdout.

You probably
don&rsquo;t want to use this unless you know what you are
doing.

The default is
disabled.

This function
returns 0 on success or -1 on error.

(Added in
1.0.72)

guestfs_set_e2attrs

int 
guestfs_set_e2attrs (guestfs_h *g, 
const char *file, 
const char *attrs, 
...);

You may supply
a list of optional arguments to this call. Use zero or more
of the following pairs of parameters, and terminate the list
with -1 on its own. See "CALLS WITH OPTIONAL
ARGUMENTS".

GUESTFS_SET_E2ATTRS_CLEAR,
int clear,

This sets or
clears the file attributes "attrs" associated with
the inode file.

"attrs"
is a string of characters representing file attributes. See
"guestfs_get_e2attrs" for a list of possible
attributes. Not all attributes can be changed.

If optional
boolean "clear" is not present or false, then the
"attrs" listed are set in the inode.

If
"clear" is true, then the "attrs" listed
are cleared in the inode.

In both cases,
other attributes not present in the "attrs" string
are left unchanged.

These
attributes are only present when the file is located on an
ext2/3/4 filesystem. Using this call on other filesystem
types will result in an error.

This function
returns 0 on success or -1 on error.

(Added in
1.17.31)

guestfs_set_e2attrs_va

int 
guestfs_set_e2attrs_va (guestfs_h *g, 
const char *file, 
const char *attrs, 
va_list args);

This is the
"va_list variant" of
"guestfs_set_e2attrs".

See "CALLS
WITH OPTIONAL ARGUMENTS".

guestfs_set_e2attrs_argv

int 
guestfs_set_e2attrs_argv (guestfs_h *g, 
const char *file, 
const char *attrs, 
const struct guestfs_set_e2attrs_argv *optargs);

This is the
"argv variant" of
"guestfs_set_e2attrs".

See "CALLS
WITH OPTIONAL ARGUMENTS".

guestfs_set_e2generation

int 
guestfs_set_e2generation (guestfs_h *g, 
const char *file, 
int64_t generation);

This sets the
ext2 file generation of a file.

See
"guestfs_get_e2generation".

This function
returns 0 on success or -1 on error.

(Added in
1.17.31)

guestfs_set_e2label

int 
guestfs_set_e2label (guestfs_h *g, 
const char *device, 
const char *label);

This
function is deprecated. In new code, use the
"guestfs_set_label" call instead.

Deprecated
functions will not be removed from the API, but the fact
that they are deprecated indicates that there are problems
with correct use of these functions.

This sets the
ext2/3/4 filesystem label of the filesystem on
"device" to "label". Filesystem labels
are limited to 16 characters.

You can use
either "guestfs_tune2fs_l" or
"guestfs_get_e2label" to return the existing label
on a filesystem.

This function
returns 0 on success or -1 on error.

(Added in
1.0.15)

guestfs_set_e2uuid

int 
guestfs_set_e2uuid (guestfs_h *g, 
const char *device, 
const char *uuid);

This
function is deprecated. In new code, use the
"guestfs_set_uuid" call instead.

Deprecated
functions will not be removed from the API, but the fact
that they are deprecated indicates that there are problems
with correct use of these functions.

This sets the
ext2/3/4 filesystem UUID of the filesystem on
"device" to "uuid". The format of the
UUID and alternatives such as "clear",
"random" and "time" are described in the
tune2fs(8) manpage.

You can use
"guestfs_vfs_uuid" to return the existing UUID of
a filesystem.

This function
returns 0 on success or -1 on error.

(Added in
1.0.15)

guestfs_set_hv

int 
guestfs_set_hv (guestfs_h *g, 
const char *hv);

Set the
hypervisor binary that we will use. The hypervisor depends
on the backend, but is usually the location of the qemu/KVM
hypervisor.

The default is
chosen when the library was compiled by the configure
script.

You can also
override this by setting the "LIBGUESTFS_HV"
environment variable.

Note that you
should call this function as early as possible after
creating the handle. This is because some pre-launch
operations depend on testing qemu features (by running
"qemu -help"). If the qemu binary changes, we
don&rsquo;t retest features, and so you might see
inconsistent results. Using the environment variable
"LIBGUESTFS_HV" is safest of all since that picks
the qemu binary at the same time as the handle is
created.

This function
returns 0 on success or -1 on error.

(Added in
1.23.17)

guestfs_set_identifier

int 
guestfs_set_identifier (guestfs_h *g, 
const char *identifier);

This is an
informative string which the caller may optionally set in
the handle. It is printed in various places, allowing the
current handle to be identified in debugging output.

One important
place is when tracing is enabled. If the identifier string
is not an empty string, then trace messages change from
this:

libguestfs:
trace: get_tmpdir 
libguestfs: trace: get_tmpdir = "/tmp"

to this:

libguestfs:
trace: ID: get_tmpdir 
libguestfs: trace: ID: get_tmpdir = "/tmp"

where
"ID" is the identifier string set by this
call.

The identifier
must only contain alphanumeric ASCII characters, underscore
and minus sign. The default is the empty string.

See also
"guestfs_set_program",
"guestfs_set_trace",
"guestfs_get_identifier".

This function
returns 0 on success or -1 on error.

(Added in
1.31.14)

guestfs_set_label

int 
guestfs_set_label (guestfs_h *g, 
const char *mountable, 
const char *label);

Set the
filesystem label on "mountable" to
"label".

Only some
filesystem types support labels, and libguestfs supports
setting labels on only a subset of these. 
ext2, ext3, ext4

Labels are limited to 16
bytes.

NTFS

Labels are limited to 128
unicode characters.

XFS

The label is limited to 12 bytes. The filesystem must
not be mounted when trying to set the label.

btrfs

The label is limited to 255
bytes and some characters are not allowed. Setting the label
on a btrfs subvolume will set the label on its parent
filesystem. The filesystem must not be mounted when trying
to set the label.

fat

The label is limited to 11 bytes.

swap

The label is limited to 16
bytes.

If there is no
support for changing the label for the type of the specified
filesystem, set_label will fail and set errno as
ENOTSUP.

To read the
label on a filesystem, call
"guestfs_vfs_label".

This function
returns 0 on success or -1 on error.

(Added in
1.17.9)

guestfs_set_libvirt_requested_credential

int 
guestfs_set_libvirt_requested_credential (guestfs_h *g, 
int index, 
const char *cred, 
size_t cred_size);

After
requesting the "index"&rsquo;th credential from
the user, call this function to pass the answer back to
libvirt.

See
"LIBVIRT AUTHENTICATION" for documentation and
example code.

This function
returns 0 on success or -1 on error.

(Added in
1.19.52)

guestfs_set_libvirt_supported_credentials

int 
guestfs_set_libvirt_supported_credentials (guestfs_h *g,

char *const *creds);

Call this
function before setting an event handler for
"GUESTFS_EVENT_LIBVIRT_AUTH", to supply the list
of credential types that the program knows how to
process.

The
"creds" list must be a non-empty list of strings.
Possible strings are: 
"username" 
"authname" 
"language" 
"cnonce" 
"passphrase" 
"echoprompt" 
"noechoprompt" 
"realm" 
"external"

See libvirt
documentation for the meaning of these credential types.

See
"LIBVIRT AUTHENTICATION" for documentation and
example code.

This function
returns 0 on success or -1 on error.

(Added in
1.19.52)

guestfs_set_memsize

int 
guestfs_set_memsize (guestfs_h *g, 
int memsize);

This sets the
memory size in megabytes allocated to the hypervisor. This
only has any effect if called before
"guestfs_launch".

You can also
change this by setting the environment variable
"LIBGUESTFS_MEMSIZE" before the handle is
created.

For more
information on the architecture of libguestfs, see
guestfs(3).

This function
returns 0 on success or -1 on error.

(Added in
1.0.55)

guestfs_set_network

int 
guestfs_set_network (guestfs_h *g, 
int network);

If
"network" is true, then the network is enabled in
the libguestfs appliance. The default is false.

This affects
whether commands are able to access the network (see
"RUNNING COMMANDS").

You must call
this before calling "guestfs_launch", otherwise it
has no effect.

This function
returns 0 on success or -1 on error.

(Added in
1.5.4)

guestfs_set_path

int 
guestfs_set_path (guestfs_h *g, 
const char *searchpath);

Set the path
that libguestfs searches for kernel and initrd.img.

The default is
"$libdir/guestfs" unless overridden by setting
"LIBGUESTFS_PATH" environment variable.

Setting
"path" to "NULL" restores the default
path.

This function
returns 0 on success or -1 on error.

(Added in
0.3)

guestfs_set_pgroup

int 
guestfs_set_pgroup (guestfs_h *g, 
int pgroup);

If
"pgroup" is true, child processes are placed into
their own process group.

The practical
upshot of this is that signals like "SIGINT" (from
users pressing "^C") won&rsquo;t be received by
the child process.

The default for
this flag is false, because usually you want "^C"
to kill the subprocess. Guestfish sets this flag to true
when used interactively, so that "^C" can cancel
long-running commands gracefully (see
"guestfs_user_cancel").

This function
returns 0 on success or -1 on error.

(Added in
1.11.18)

guestfs_set_program

int 
guestfs_set_program (guestfs_h *g, 
const char *program);

Set the program
name. This is an informative string which the main program
may optionally set in the handle.

When the handle
is created, the program name in the handle is set to the
basename from "argv[0]". The program name can
never be "NULL".

This function
returns 0 on success or -1 on error.

(Added in
1.21.29)

guestfs_set_qemu

int 
guestfs_set_qemu (guestfs_h *g, 
const char *hv);

This
function is deprecated. In new code, use the
"guestfs_set_hv" call instead.

Deprecated
functions will not be removed from the API, but the fact
that they are deprecated indicates that there are problems
with correct use of these functions.

Set the
hypervisor binary (usually qemu) that we will use.

The default is
chosen when the library was compiled by the configure
script.

You can also
override this by setting the "LIBGUESTFS_HV"
environment variable.

Setting
"hv" to "NULL" restores the default qemu
binary.

Note that you
should call this function as early as possible after
creating the handle. This is because some pre-launch
operations depend on testing qemu features (by running
"qemu -help"). If the qemu binary changes, we
don&rsquo;t retest features, and so you might see
inconsistent results. Using the environment variable
"LIBGUESTFS_HV" is safest of all since that picks
the qemu binary at the same time as the handle is
created.

This function
returns 0 on success or -1 on error.

(Added in
1.0.6)

guestfs_set_recovery_proc

int 
guestfs_set_recovery_proc (guestfs_h *g, 
int recoveryproc);

If this is
called with the parameter "false" then
"guestfs_launch" does not create a recovery
process. The purpose of the recovery process is to stop
runaway hypervisor processes in the case where the main
program aborts abruptly.

This only has
any effect if called before "guestfs_launch", and
the default is true.

About the only
time when you would want to disable this is if the main
process will fork itself into the background
("daemonize" itself). In this case the recovery
process thinks that the main program has disappeared and so
kills the hypervisor, which is not very helpful.

This function
returns 0 on success or -1 on error.

(Added in
1.0.77)

guestfs_set_selinux

int 
guestfs_set_selinux (guestfs_h *g, 
int selinux);

This
function is deprecated. In new code, use the
"guestfs_selinux_relabel" call instead.

Deprecated
functions will not be removed from the API, but the fact
that they are deprecated indicates that there are problems
with correct use of these functions.

This sets the
selinux flag that is passed to the appliance at boot time.
The default is "selinux=0" (disabled).

Note that if
SELinux is enabled, it is always in Permissive mode
("enforcing=0").

For more
information on the architecture of libguestfs, see
guestfs(3).

This function
returns 0 on success or -1 on error.

(Added in
1.0.67)

guestfs_set_smp

int 
guestfs_set_smp (guestfs_h *g, 
int smp);

Change the
number of virtual CPUs assigned to the appliance. The
default is 1. Increasing this may improve performance,
though often it has no effect.

This function
must be called before "guestfs_launch".

This function
returns 0 on success or -1 on error.

(Added in
1.13.15)

guestfs_set_tmpdir

int 
guestfs_set_tmpdir (guestfs_h *g, 
const char *tmpdir);

Set the
directory used by the handle to store temporary files.

The environment
variables "LIBGUESTFS_TMPDIR" and
"TMPDIR" control the default value: If
"LIBGUESTFS_TMPDIR" is set, then that is the
default. Else if "TMPDIR" is set, then that is the
default. Else /tmp is the default.

This function
returns 0 on success or -1 on error.

(Added in
1.19.58)

guestfs_set_trace

int 
guestfs_set_trace (guestfs_h *g, 
int trace);

If the command
trace flag is set to 1, then libguestfs calls, parameters
and return values are traced.

If you want to
trace C API calls into libguestfs (and other libraries) then
possibly a better way is to use the external
ltrace(1) command.

Command traces
are disabled unless the environment variable
"LIBGUESTFS_TRACE" is defined and set to 1.

Trace messages
are normally sent to "stderr", unless you register
a callback to send them somewhere else (see
"guestfs_set_event_callback").

This function
returns 0 on success or -1 on error.

(Added in
1.0.69)

guestfs_set_uuid

int 
guestfs_set_uuid (guestfs_h *g, 
const char *device, 
const char *uuid);

Set the
filesystem UUID on "device" to "uuid".
If this fails and the errno is ENOTSUP, means that there is
no support for changing the UUID for the type of the
specified filesystem.

Only some
filesystem types support setting UUIDs.

To read the
UUID on a filesystem, call "guestfs_vfs_uuid".

This function
returns 0 on success or -1 on error.

(Added in
1.23.10)

guestfs_set_uuid_random

int 
guestfs_set_uuid_random (guestfs_h *g, 
const char *device);

Set the
filesystem UUID on "device" to a random UUID. If
this fails and the errno is ENOTSUP, means that there is no
support for changing the UUID for the type of the specified
filesystem.

Only some
filesystem types support setting UUIDs.

To read the
UUID on a filesystem, call "guestfs_vfs_uuid".

This function
returns 0 on success or -1 on error.

(Added in
1.29.50)

guestfs_set_verbose

int 
guestfs_set_verbose (guestfs_h *g, 
int verbose);

If
"verbose" is true, this turns on verbose
messages.

Verbose
messages are disabled unless the environment variable
"LIBGUESTFS_DEBUG" is defined and set to 1.

Verbose
messages are normally sent to "stderr", unless you
register a callback to send them somewhere else (see
"guestfs_set_event_callback").

This function
returns 0 on success or -1 on error.

(Added in
0.3)

guestfs_setcon

int 
guestfs_setcon (guestfs_h *g, 
const char *context);

This
function is deprecated. In new code, use the
"guestfs_selinux_relabel" call instead.

Deprecated
functions will not be removed from the API, but the fact
that they are deprecated indicates that there are problems
with correct use of these functions.

This sets the
SELinux security context of the daemon to the string
"context".

See the
documentation about SELINUX in guestfs(3).

This function
returns 0 on success or -1 on error.

This function
depends on the feature "selinux". See also
"guestfs_feature_available".

(Added in
1.0.67)

guestfs_setxattr

int 
guestfs_setxattr (guestfs_h *g, 
const char *xattr, 
const char *val, 
int vallen, 
const char *path);

This call sets
the extended attribute named "xattr" of the file
"path" to the value "val" (of length
"vallen"). The value is arbitrary 8 bit data.

See also:
"guestfs_lsetxattr", attr(5).

This function
returns 0 on success or -1 on error.

This function
depends on the feature "linuxxattrs". See also
"guestfs_feature_available".

(Added in
1.0.59)

guestfs_sfdisk

int 
guestfs_sfdisk (guestfs_h *g, 
const char *device, 
int cyls, 
int heads, 
int sectors, 
char *const *lines);

This
function is deprecated. In new code, use the
"guestfs_part_add" call instead.

Deprecated
functions will not be removed from the API, but the fact
that they are deprecated indicates that there are problems
with correct use of these functions.

This is a
direct interface to the sfdisk(8) program for
creating partitions on block devices.

"device"
should be a block device, for example /dev/sda.

"cyls",
"heads" and "sectors" are the number of
cylinders, heads and sectors on the device, which are passed
directly to sfdisk(8) as the -C, -H and
-S parameters. If you pass 0 for any of these, then
the corresponding parameter is omitted. Usually for
&rsquo;large&rsquo; disks, you can just pass 0 for these,
but for small (floppy-sized) disks, sfdisk(8) (or
rather, the kernel) cannot work out the right geometry and
you will need to tell it.

"lines"
is a list of lines that we feed to sfdisk(8). For
more information refer to the sfdisk(8) manpage.

To create a
single partition occupying the whole disk, you would pass
"lines" as a single element list, when the single
element being the string "," (comma).

See also:
"guestfs_sfdisk_l", "guestfs_sfdisk_N",
"guestfs_part_init"

This function
returns 0 on success or -1 on error.

(Added in
0.8)

guestfs_sfdiskM

int 
guestfs_sfdiskM (guestfs_h *g, 
const char *device, 
char *const *lines);

This
function is deprecated. In new code, use the
"guestfs_part_add" call instead.

Deprecated
functions will not be removed from the API, but the fact
that they are deprecated indicates that there are problems
with correct use of these functions.

This is a
simplified interface to the "guestfs_sfdisk"
command, where partition sizes are specified in megabytes
only (rounded to the nearest cylinder) and you don&rsquo;t
need to specify the cyls, heads and sectors parameters which
were rarely if ever used anyway.

See also:
"guestfs_sfdisk", the sfdisk(8) manpage and
"guestfs_part_disk"

This function
returns 0 on success or -1 on error.

(Added in
1.0.55)

guestfs_sfdisk_N

int 
guestfs_sfdisk_N (guestfs_h *g, 
const char *device, 
int partnum, 
int cyls, 
int heads, 
int sectors, 
const char *line);

This
function is deprecated. In new code, use the
"guestfs_part_add" call instead.

Deprecated
functions will not be removed from the API, but the fact
that they are deprecated indicates that there are problems
with correct use of these functions.

This runs
sfdisk(8) option to modify just the single partition
"n" (note: "n" counts from 1).

For other
parameters, see "guestfs_sfdisk". You should
usually pass 0 for the cyls/heads/sectors parameters.

See also:
"guestfs_part_add"

This function
returns 0 on success or -1 on error.

(Added in
1.0.26)

guestfs_sfdisk_disk_geometry

char * 
guestfs_sfdisk_disk_geometry (guestfs_h *g, 
const char *device);

This displays
the disk geometry of "device" read from the
partition table. Especially in the case where the underlying
block device has been resized, this can be different from
the kernel&rsquo;s idea of the geometry (see
"guestfs_sfdisk_kernel_geometry").

The result is
in human-readable format, and not designed to be parsed.

This function
returns a string, or NULL on error. The caller must free
the returned string after use.

(Added in
1.0.26)

guestfs_sfdisk_kernel_geometry

char * 
guestfs_sfdisk_kernel_geometry (guestfs_h *g, 
const char *device);

This displays
the kernel&rsquo;s idea of the geometry of
"device".

The result is
in human-readable format, and not designed to be parsed.

This function
returns a string, or NULL on error. The caller must free
the returned string after use.

(Added in
1.0.26)

guestfs_sfdisk_l

char * 
guestfs_sfdisk_l (guestfs_h *g, 
const char *device);

This
function is deprecated. In new code, use the
"guestfs_part_list" call instead.

Deprecated
functions will not be removed from the API, but the fact
that they are deprecated indicates that there are problems
with correct use of these functions.

This displays
the partition table on "device", in the
human-readable output of the sfdisk(8) command. It is
not intended to be parsed.

See also:
"guestfs_part_list"

This function
returns a string, or NULL on error. The caller must free
the returned string after use.

(Added in
1.0.26)

guestfs_sh

char * 
guestfs_sh (guestfs_h *g, 
const char *command);

This call runs
a command from the guest filesystem via the guest&rsquo;s
/bin/sh.

This is like
"guestfs_command", but passes the command to:

/bin/sh -c
"command"

Depending on
the guest&rsquo;s shell, this usually results in wildcards
being expanded, shell expressions being interpolated and so
on.

All the
provisos about "guestfs_command" apply to this
call.

This function
returns a string, or NULL on error. The caller must free
the returned string after use.

(Added in
1.0.50)

guestfs_sh_lines

char ** 
guestfs_sh_lines (guestfs_h *g, 
const char *command);

This is the
same as "guestfs_sh", but splits the result into a
list of lines.

See also:
"guestfs_command_lines"

This function
returns a NULL-terminated array of strings (like
environ(3)), or NULL if there was an error. The
caller must free the strings and the array after
use.

(Added in
1.0.50)

guestfs_shutdown

int 
guestfs_shutdown (guestfs_h *g);

This is the
opposite of "guestfs_launch". It performs an
orderly shutdown of the backend process(es). If the autosync
flag is set (which is the default) then the disk image is
synchronized.

If the
subprocess exits with an error then this function will
return an error, which should not be ignored (it may
indicate that the disk image could not be written out
properly).

It is safe to
call this multiple times. Extra calls are ignored.

This call does
not close or free up the handle. You still need to
call "guestfs_close" afterwards.

"guestfs_close"
will call this if you don&rsquo;t do it explicitly, but note
that any errors are ignored in that case.

This function
returns 0 on success or -1 on error.

(Added in
1.19.16)

guestfs_sleep

int 
guestfs_sleep (guestfs_h *g, 
int secs);

Sleep for
"secs" seconds.

This function
returns 0 on success or -1 on error.

(Added in
1.0.41)

guestfs_stat

struct guestfs_stat * 
guestfs_stat (guestfs_h *g, 
const char *path);

This
function is deprecated. In new code, use the
"guestfs_statns" call instead.

Deprecated
functions will not be removed from the API, but the fact
that they are deprecated indicates that there are problems
with correct use of these functions.

Returns file
information for the given "path".

This is the
same as the stat(2) system call.

This function
returns a "struct guestfs_stat *", or NULL if
there was an error. The caller must call
"guestfs_free_stat" after use.

(Added in
1.9.2)

guestfs_statns

struct guestfs_statns * 
guestfs_statns (guestfs_h *g, 
const char *path);

Returns file
information for the given "path".

This is the
same as the stat(2) system call.

This function
returns a "struct guestfs_statns *", or NULL if
there was an error. The caller must call
"guestfs_free_statns" after use.

(Added in
1.27.53)

guestfs_statvfs

struct guestfs_statvfs * 
guestfs_statvfs (guestfs_h *g, 
const char *path);

Returns file
system statistics for any mounted file system.
"path" should be a file or directory in the
mounted file system (typically it is the mount point itself,
but it doesn&rsquo;t need to be).

This is the
same as the statvfs(2) system call.

This function
returns a "struct guestfs_statvfs *", or NULL if
there was an error. The caller must call
"guestfs_free_statvfs" after use.

(Added in
1.9.2)

guestfs_strings

char ** 
guestfs_strings (guestfs_h *g, 
const char *path);

This runs the
strings(1) command on a file and returns the list of
printable strings found.

The
"strings" command has, in the past, had problems
with parsing untrusted files. These are mitigated in the
current version of libguestfs, but see
"CVE-2014-8484".

This function
returns a NULL-terminated array of strings (like
environ(3)), or NULL if there was an error. The
caller must free the strings and the array after
use.

Because of the
message protocol, there is a transfer limit of somewhere
between 2MB and 4MB. See "PROTOCOL LIMITS".

(Added in
1.0.22)

guestfs_strings_e

char ** 
guestfs_strings_e (guestfs_h *g, 
const char *encoding, 
const char *path);

This is like
the "guestfs_strings" command, but allows you to
specify the encoding of strings that are looked for in the
source file "path".

Allowed
encodings are:

s

Single 7-bit-byte characters like ASCII and the
ASCII-compatible parts of ISO-8859-X (this is what
"guestfs_strings" uses).

S

Single 8-bit-byte characters.

b

16-bit big endian strings such as those encoded in
UTF-16BE or UCS-2BE.

l (lower case letter L)

16-bit little endian such as
UTF-16LE and UCS-2LE. This is useful for examining binaries
in Windows guests.

B

32-bit big endian such as UCS-4BE.

L

32-bit little endian such as UCS-4LE.

The returned
strings are transcoded to UTF-8.

The
"strings" command has, in the past, had problems
with parsing untrusted files. These are mitigated in the
current version of libguestfs, but see
"CVE-2014-8484".

This function
returns a NULL-terminated array of strings (like
environ(3)), or NULL if there was an error. The
caller must free the strings and the array after
use.

Because of the
message protocol, there is a transfer limit of somewhere
between 2MB and 4MB. See "PROTOCOL LIMITS".

(Added in
1.0.22)

guestfs_swapoff_device

int 
guestfs_swapoff_device (guestfs_h *g, 
const char *device);

This command
disables the libguestfs appliance swap device or partition
named "device". See
"guestfs_swapon_device".

This function
returns 0 on success or -1 on error.

(Added in
1.0.66)

guestfs_swapoff_file

int 
guestfs_swapoff_file (guestfs_h *g, 
const char *file);

This command
disables the libguestfs appliance swap on file.

This function
returns 0 on success or -1 on error.

(Added in
1.0.66)

guestfs_swapoff_label

int 
guestfs_swapoff_label (guestfs_h *g, 
const char *label);

This command
disables the libguestfs appliance swap on labeled swap
partition.

This function
returns 0 on success or -1 on error.

(Added in
1.0.66)

guestfs_swapoff_uuid

int 
guestfs_swapoff_uuid (guestfs_h *g, 
const char *uuid);

This command
disables the libguestfs appliance swap partition with the
given UUID.

This function
returns 0 on success or -1 on error.

This function
depends on the feature "linuxfsuuid". See also
"guestfs_feature_available".

(Added in
1.0.66)

guestfs_swapon_device

int 
guestfs_swapon_device (guestfs_h *g, 
const char *device);

This command
enables the libguestfs appliance to use the swap device or
partition named "device". The increased memory is
made available for all commands, for example those run using
"guestfs_command" or "guestfs_sh".

Note that you
should not swap to existing guest swap partitions unless you
know what you are doing. They may contain hibernation
information, or other information that the guest
doesn&rsquo;t want you to trash. You also risk leaking
information about the host to the guest this way. Instead,
attach a new host device to the guest and swap on that.

This function
returns 0 on success or -1 on error.

(Added in
1.0.66)

guestfs_swapon_file

int 
guestfs_swapon_file (guestfs_h *g, 
const char *file);

This command
enables swap to a file. See
"guestfs_swapon_device" for other notes.

This function
returns 0 on success or -1 on error.

(Added in
1.0.66)

guestfs_swapon_label

int 
guestfs_swapon_label (guestfs_h *g, 
const char *label);

This command
enables swap to a labeled swap partition. See
"guestfs_swapon_device" for other notes.

This function
returns 0 on success or -1 on error.

(Added in
1.0.66)

guestfs_swapon_uuid

int 
guestfs_swapon_uuid (guestfs_h *g, 
const char *uuid);

This command
enables swap to a swap partition with the given UUID. See
"guestfs_swapon_device" for other notes.

This function
returns 0 on success or -1 on error.

This function
depends on the feature "linuxfsuuid". See also
"guestfs_feature_available".

(Added in
1.0.66)

guestfs_sync

int 
guestfs_sync (guestfs_h *g);

This syncs the
disk, so that any writes are flushed through to the
underlying disk image.

You should
always call this if you have modified a disk image, before
closing the handle.

This function
returns 0 on success or -1 on error.

(Added in
0.3)

guestfs_syslinux

int 
guestfs_syslinux (guestfs_h *g, 
const char *device, 
...);

You may supply
a list of optional arguments to this call. Use zero or more
of the following pairs of parameters, and terminate the list
with -1 on its own. See "CALLS WITH OPTIONAL
ARGUMENTS".

GUESTFS_SYSLINUX_DIRECTORY,
const char *directory,

Install the
SYSLINUX bootloader on "device".

The device
parameter must be either a whole disk formatted as a FAT
filesystem, or a partition formatted as a FAT filesystem. In
the latter case, the partition should be marked as
"active" ("guestfs_part_set_bootable")
and a Master Boot Record must be installed (eg. using
"guestfs_pwrite_device") on the first sector of
the whole disk. The SYSLINUX package comes with some
suitable Master Boot Records. See the syslinux(1) man
page for further information.

The optional
arguments are: 
directory

Install SYSLINUX in the named
subdirectory, instead of in the root directory of the FAT
filesystem.

Additional
configuration can be supplied to SYSLINUX by placing a file
called syslinux.cfg on the FAT filesystem, either in
the root directory, or under directory if that
optional argument is being used. For further information
about the contents of this file, see syslinux(1).

See also
"guestfs_extlinux".

This function
returns 0 on success or -1 on error.

This function
depends on the feature "syslinux". See also
"guestfs_feature_available".

(Added in
1.21.27)

guestfs_syslinux_va

int 
guestfs_syslinux_va (guestfs_h *g, 
const char *device, 
va_list args);

This is the
"va_list variant" of
"guestfs_syslinux".

See "CALLS
WITH OPTIONAL ARGUMENTS".

guestfs_syslinux_argv

int 
guestfs_syslinux_argv (guestfs_h *g, 
const char *device, 
const struct guestfs_syslinux_argv *optargs);

This is the
"argv variant" of
"guestfs_syslinux".

See "CALLS
WITH OPTIONAL ARGUMENTS".

guestfs_tail

char ** 
guestfs_tail (guestfs_h *g, 
const char *path);

This command
returns up to the last 10 lines of a file as a list of
strings.

This function
returns a NULL-terminated array of strings (like
environ(3)), or NULL if there was an error. The
caller must free the strings and the array after
use.

Because of the
message protocol, there is a transfer limit of somewhere
between 2MB and 4MB. See "PROTOCOL LIMITS".

(Added in
1.0.54)

guestfs_tail_n

char ** 
guestfs_tail_n (guestfs_h *g, 
int nrlines, 
const char *path);

If the
parameter "nrlines" is a positive number, this
returns the last "nrlines" lines of the file
"path".

If the
parameter "nrlines" is a negative number, this
returns lines from the file "path", starting with
the "-nrlines"&rsquo;th line.

If the
parameter "nrlines" is zero, this returns an empty
list.

This function
returns a NULL-terminated array of strings (like
environ(3)), or NULL if there was an error. The
caller must free the strings and the array after
use.

Because of the
message protocol, there is a transfer limit of somewhere
between 2MB and 4MB. See "PROTOCOL LIMITS".

(Added in
1.0.54)

guestfs_tar_in

int 
guestfs_tar_in (guestfs_h *g, 
const char *tarfile, 
const char *directory);

This function
is provided for backwards compatibility with earlier
versions of libguestfs. It simply calls
"guestfs_tar_in_opts" with no optional
arguments.

(Added in
1.0.3)

guestfs_tar_in_opts

int 
guestfs_tar_in_opts (guestfs_h *g, 
const char *tarfile, 
const char *directory, 
...);

You may supply
a list of optional arguments to this call. Use zero or more
of the following pairs of parameters, and terminate the list
with -1 on its own. See "CALLS WITH OPTIONAL
ARGUMENTS".

GUESTFS_TAR_IN_OPTS_COMPRESS,
const char *compress, 
GUESTFS_TAR_IN_OPTS_XATTRS, int xattrs, 
GUESTFS_TAR_IN_OPTS_SELINUX, int selinux, 
GUESTFS_TAR_IN_OPTS_ACLS, int acls,

This command
uploads and unpacks local file "tarfile" into
directory.

The optional
"compress" flag controls compression. If not
given, then the input should be an uncompressed tar file.
Otherwise one of the following strings may be given to
select the compression type of the input file:
"compress", "gzip", "bzip2",
"xz", "lzop", "lzma",
"zstd". (Note that not all builds of libguestfs
will support all of these compression types).

The other
optional arguments are: 
"xattrs"

If set to true, extended
attributes are restored from the tar file.

"selinux"

If set to true, SELinux
contexts are restored from the tar file.

"acls"

If set to true, POSIX ACLs are
restored from the tar file.

This function
returns 0 on success or -1 on error.

(Added in
1.0.3)

guestfs_tar_in_opts_va

int 
guestfs_tar_in_opts_va (guestfs_h *g, 
const char *tarfile, 
const char *directory, 
va_list args);

This is the
"va_list variant" of
"guestfs_tar_in_opts".

See "CALLS
WITH OPTIONAL ARGUMENTS".

guestfs_tar_in_opts_argv

int 
guestfs_tar_in_opts_argv (guestfs_h *g, 
const char *tarfile, 
const char *directory, 
const struct guestfs_tar_in_opts_argv *optargs);

This is the
"argv variant" of
"guestfs_tar_in_opts".

See "CALLS
WITH OPTIONAL ARGUMENTS".

guestfs_tar_out

int 
guestfs_tar_out (guestfs_h *g, 
const char *directory, 
const char *tarfile);

This function
is provided for backwards compatibility with earlier
versions of libguestfs. It simply calls
"guestfs_tar_out_opts" with no optional
arguments.

(Added in
1.0.3)

guestfs_tar_out_opts

int 
guestfs_tar_out_opts (guestfs_h *g, 
const char *directory, 
const char *tarfile, 
...);

You may supply
a list of optional arguments to this call. Use zero or more
of the following pairs of parameters, and terminate the list
with -1 on its own. See "CALLS WITH OPTIONAL
ARGUMENTS".

GUESTFS_TAR_OUT_OPTS_COMPRESS,
const char *compress, 
GUESTFS_TAR_OUT_OPTS_NUMERICOWNER, int numericowner, 
GUESTFS_TAR_OUT_OPTS_EXCLUDES, char *const *excludes, 
GUESTFS_TAR_OUT_OPTS_XATTRS, int xattrs, 
GUESTFS_TAR_OUT_OPTS_SELINUX, int selinux, 
GUESTFS_TAR_OUT_OPTS_ACLS, int acls,

This command
packs the contents of directory and downloads it to
local file "tarfile".

The optional
"compress" flag controls compression. If not
given, then the output will be an uncompressed tar file.
Otherwise one of the following strings may be given to
select the compression type of the output file:
"compress", "gzip", "bzip2",
"xz", "lzop", "lzma",
"zstd". (Note that not all builds of libguestfs
will support all of these compression types).

The other
optional arguments are: 
"excludes"

A list of wildcards. Files are
excluded if they match any of the wildcards.

"numericowner"

If set to true, the output tar
file will contain UID/GID numbers instead of user/group
names.

"xattrs"

If set to true, extended
attributes are saved in the output tar.

"selinux"

If set to true, SELinux
contexts are saved in the output tar.

"acls"

If set to true, POSIX ACLs are
saved in the output tar.

This function
returns 0 on success or -1 on error.

(Added in
1.0.3)

guestfs_tar_out_opts_va

int 
guestfs_tar_out_opts_va (guestfs_h *g, 
const char *directory, 
const char *tarfile, 
va_list args);

This is the
"va_list variant" of
"guestfs_tar_out_opts".

See "CALLS
WITH OPTIONAL ARGUMENTS".

guestfs_tar_out_opts_argv

int 
guestfs_tar_out_opts_argv (guestfs_h *g, 
const char *directory, 
const char *tarfile, 
const struct guestfs_tar_out_opts_argv *optargs);

This is the
"argv variant" of
"guestfs_tar_out_opts".

See "CALLS
WITH OPTIONAL ARGUMENTS".

guestfs_tgz_in

int 
guestfs_tgz_in (guestfs_h *g, 
const char *tarball, 
const char *directory);

This
function is deprecated. In new code, use the
"guestfs_tar_in" call instead.

Deprecated
functions will not be removed from the API, but the fact
that they are deprecated indicates that there are problems
with correct use of these functions.

This command
uploads and unpacks local file "tarball" (a
gzip compressed tar file) into directory.

This function
returns 0 on success or -1 on error.

(Added in
1.0.3)

guestfs_tgz_out

int 
guestfs_tgz_out (guestfs_h *g, 
const char *directory, 
const char *tarball);

This
function is deprecated. In new code, use the
"guestfs_tar_out" call instead.

Deprecated
functions will not be removed from the API, but the fact
that they are deprecated indicates that there are problems
with correct use of these functions.

This command
packs the contents of directory and downloads it to
local file "tarball".

This function
returns 0 on success or -1 on error.

(Added in
1.0.3)

guestfs_touch

int 
guestfs_touch (guestfs_h *g, 
const char *path);

Touch acts like
the touch(1) command. It can be used to update the
timestamps on a file, or, if the file does not exist, to
create a new zero-length file.

This command
only works on regular files, and will fail on other file
types such as directories, symbolic links, block special
etc.

This function
returns 0 on success or -1 on error.

(Added in
0.3)

guestfs_truncate

int 
guestfs_truncate (guestfs_h *g, 
const char *path);

This command
truncates "path" to a zero-length file. The file
must exist already.

This function
returns 0 on success or -1 on error.

(Added in
1.0.77)

guestfs_truncate_size

int 
guestfs_truncate_size (guestfs_h *g, 
const char *path, 
int64_t size);

This command
truncates "path" to size "size" bytes.
The file must exist already.

If the current
file size is less than "size" then the file is
extended to the required size with zero bytes. This creates
a sparse file (ie. disk blocks are not allocated for the
file until you write to it). To create a non-sparse file of
zeroes, use "guestfs_fallocate64" instead.

This function
returns 0 on success or -1 on error.

(Added in
1.0.77)

guestfs_tune2fs

int 
guestfs_tune2fs (guestfs_h *g, 
const char *device, 
...);

You may supply
a list of optional arguments to this call. Use zero or more
of the following pairs of parameters, and terminate the list
with -1 on its own. See "CALLS WITH OPTIONAL
ARGUMENTS".

GUESTFS_TUNE2FS_FORCE,
int force, 
GUESTFS_TUNE2FS_MAXMOUNTCOUNT, int maxmountcount, 
GUESTFS_TUNE2FS_MOUNTCOUNT, int mountcount, 
GUESTFS_TUNE2FS_ERRORBEHAVIOR, const char *errorbehavior,

GUESTFS_TUNE2FS_GROUP, int64_t group, 
GUESTFS_TUNE2FS_INTERVALBETWEENCHECKS, int
intervalbetweenchecks, 
GUESTFS_TUNE2FS_RESERVEDBLOCKSPERCENTAGE, int
reservedblockspercentage, 
GUESTFS_TUNE2FS_LASTMOUNTEDDIRECTORY, const char
*lastmounteddirectory, 
GUESTFS_TUNE2FS_RESERVEDBLOCKSCOUNT, int64_t
reservedblockscount, 
GUESTFS_TUNE2FS_USER, int64_t user,

This call
allows you to adjust various filesystem parameters of an
ext2/ext3/ext4 filesystem called "device".

The optional
parameters are: 
"force"

Force tune2fs to complete the
operation even in the face of errors. This is the same as
the tune2fs(8) "-f" option.

"maxmountcount"

Set the number of mounts after
which the filesystem is checked by e2fsck(8). If this
is 0 then the number of mounts is disregarded. This is the
same as the tune2fs(8) "-c" option.

"mountcount"

Set the number of times the
filesystem has been mounted. This is the same as the
tune2fs(8) "-C" option.

"errorbehavior"

Change the behavior of the
kernel code when errors are detected. Possible values
currently are: "continue", "remount-ro",
"panic". In practice these options don&rsquo;t
really make any difference, particularly for write
errors.

This is the
same as the tune2fs(8) "-e" option.

"group"

Set the group which can use
reserved filesystem blocks. This is the same as the
tune2fs(8) "-g" option except that it can
only be specified as a number.

"intervalbetweenchecks"

Adjust the maximal time between
two filesystem checks (in seconds). If the option is passed
as 0 then time-dependent checking is disabled.

This is the
same as the tune2fs(8) "-i" option.

"reservedblockspercentage"

Set the percentage of the
filesystem which may only be allocated by privileged
processes. This is the same as the tune2fs(8)
"-m" option.

"lastmounteddirectory"

Set the last mounted directory.
This is the same as the tune2fs(8) "-M"
option.

"reservedblockscount"
Set the number of reserved filesystem blocks. 
This is the same as the tune2fs(8) "-r"
option. 
"user"

Set the user who can use the
reserved filesystem blocks. This is the same as the
tune2fs(8) "-u" option except that it can
only be specified as a number.

To get the
current values of filesystem parameters, see
"guestfs_tune2fs_l". For precise details of how
tune2fs works, see the tune2fs(8) man page.

This function
returns 0 on success or -1 on error.

(Added in
1.15.4)

guestfs_tune2fs_va

int 
guestfs_tune2fs_va (guestfs_h *g, 
const char *device, 
va_list args);

This is the
"va_list variant" of
"guestfs_tune2fs".

See "CALLS
WITH OPTIONAL ARGUMENTS".

guestfs_tune2fs_argv

int 
guestfs_tune2fs_argv (guestfs_h *g, 
const char *device, 
const struct guestfs_tune2fs_argv *optargs);

This is the
"argv variant" of "guestfs_tune2fs".

See "CALLS
WITH OPTIONAL ARGUMENTS".

guestfs_tune2fs_l

char ** 
guestfs_tune2fs_l (guestfs_h *g, 
const char *device);

This returns
the contents of the ext2, ext3 or ext4 filesystem superblock
on "device".

It is the same
as running "tune2fs -l device". See
tune2fs(8) manpage for more details. The list of
fields returned isn&rsquo;t clearly defined, and depends on
both the version of "tune2fs" that libguestfs was
built against, and the filesystem itself.

This function
returns a NULL-terminated array of strings, or NULL if there
was an error. The array of strings will always have length
"2n+1", where "n" keys and values
alternate, followed by the trailing NULL entry. The
caller must free the strings and the array after
use.

(Added in
1.9.2)

guestfs_txz_in

int 
guestfs_txz_in (guestfs_h *g, 
const char *tarball, 
const char *directory);

This
function is deprecated. In new code, use the
"guestfs_tar_in" call instead.

Deprecated
functions will not be removed from the API, but the fact
that they are deprecated indicates that there are problems
with correct use of these functions.

This command
uploads and unpacks local file "tarball" (an xz
compressed tar file) into directory.

This function
returns 0 on success or -1 on error.

This function
depends on the feature "xz". See also
"guestfs_feature_available".

(Added in
1.3.2)

guestfs_txz_out

int 
guestfs_txz_out (guestfs_h *g, 
const char *directory, 
const char *tarball);

This
function is deprecated. In new code, use the
"guestfs_tar_out" call instead.

Deprecated
functions will not be removed from the API, but the fact
that they are deprecated indicates that there are problems
with correct use of these functions.

This command
packs the contents of directory and downloads it to
local file "tarball" (as an xz compressed tar
archive).

This function
returns 0 on success or -1 on error.

This function
depends on the feature "xz". See also
"guestfs_feature_available".

(Added in
1.3.2)

guestfs_umask

int 
guestfs_umask (guestfs_h *g, 
int mask);

This function
sets the mask used for creating new files and device nodes
to "mask & 0777".

Typical umask
values would be 022 which creates new files with permissions
like "-rw-r--r--" or "-rwxr-xr-x", and
002 which creates new files with permissions like
"-rw-rw-r--" or "-rwxrwxr-x".

The default
umask is 022. This is important because it means that
directories and device nodes will be created with 0644 or
0755 mode even if you specify 0777.

See also
"guestfs_get_umask", umask(2),
"guestfs_mknod", "guestfs_mkdir".

This call
returns the previous umask.

On error this
function returns -1.

(Added in
1.0.55)

guestfs_umount

int 
guestfs_umount (guestfs_h *g, 
const char *pathordevice);

This function
is provided for backwards compatibility with earlier
versions of libguestfs. It simply calls
"guestfs_umount_opts" with no optional
arguments.

(Added in
0.8)

guestfs_umount_opts

int 
guestfs_umount_opts (guestfs_h *g, 
const char *pathordevice, 
...);

You may supply
a list of optional arguments to this call. Use zero or more
of the following pairs of parameters, and terminate the list
with -1 on its own. See "CALLS WITH OPTIONAL
ARGUMENTS".

GUESTFS_UMOUNT_OPTS_FORCE,
int force, 
GUESTFS_UMOUNT_OPTS_LAZYUNMOUNT, int lazyunmount,

This unmounts
the given filesystem. The filesystem may be specified either
by its mountpoint (path) or the device which contains the
filesystem.

This function
returns 0 on success or -1 on error.

(Added in
0.8)

guestfs_umount_opts_va

int 
guestfs_umount_opts_va (guestfs_h *g, 
const char *pathordevice, 
va_list args);

This is the
"va_list variant" of
"guestfs_umount_opts".

See "CALLS
WITH OPTIONAL ARGUMENTS".

guestfs_umount_opts_argv

int 
guestfs_umount_opts_argv (guestfs_h *g, 
const char *pathordevice, 
const struct guestfs_umount_opts_argv *optargs);

This is the
"argv variant" of
"guestfs_umount_opts".

See "CALLS
WITH OPTIONAL ARGUMENTS".

guestfs_umount_all

int 
guestfs_umount_all (guestfs_h *g);

This unmounts
all mounted filesystems.

Some internal
mounts are not unmounted by this call.

This function
returns 0 on success or -1 on error.

(Added in
0.8)

guestfs_umount_local

int 
guestfs_umount_local (guestfs_h *g, 
...);

You may supply
a list of optional arguments to this call. Use zero or more
of the following pairs of parameters, and terminate the list
with -1 on its own. See "CALLS WITH OPTIONAL
ARGUMENTS".

GUESTFS_UMOUNT_LOCAL_RETRY,
int retry,

If libguestfs
is exporting the filesystem on a local mountpoint, then this
unmounts it.

See "MOUNT
LOCAL" for full documentation.

This function
returns 0 on success or -1 on error.

(Added in
1.17.22)

guestfs_umount_local_va

int 
guestfs_umount_local_va (guestfs_h *g, 
va_list args);

This is the
"va_list variant" of
"guestfs_umount_local".

See "CALLS
WITH OPTIONAL ARGUMENTS".

guestfs_umount_local_argv

int 
guestfs_umount_local_argv (guestfs_h *g, 
const struct guestfs_umount_local_argv *optargs);

This is the
"argv variant" of
"guestfs_umount_local".

See "CALLS
WITH OPTIONAL ARGUMENTS".

guestfs_upload

int 
guestfs_upload (guestfs_h *g, 
const char *filename, 
const char *remotefilename);

Upload local
file filename to remotefilename on the
filesystem.

filename
can also be a named pipe.

See also
"guestfs_download".

This function
returns 0 on success or -1 on error.

This
long-running command can generate progress notification
messages so that the caller can display a progress bar or
indicator. To receive these messages, the caller must
register a progress event callback. See
"GUESTFS_EVENT_PROGRESS".

(Added in
1.0.2)

guestfs_upload_offset

int 
guestfs_upload_offset (guestfs_h *g, 
const char *filename, 
const char *remotefilename, 
int64_t offset);

Upload local
file filename to remotefilename on the
filesystem.

remotefilename
is overwritten starting at the byte "offset"
specified. The intention is to overwrite parts of existing
files or devices, although if a non-existent file is
specified then it is created with a "hole" before
"offset". The size of the data written is implicit
in the size of the source filename.

Note that there
is no limit on the amount of data that can be uploaded with
this call, unlike with "guestfs_pwrite", and this
call always writes the full amount unless an error
occurs.

See also
"guestfs_upload", "guestfs_pwrite".

This function
returns 0 on success or -1 on error.

This
long-running command can generate progress notification
messages so that the caller can display a progress bar or
indicator. To receive these messages, the caller must
register a progress event callback. See
"GUESTFS_EVENT_PROGRESS".

(Added in
1.5.17)

guestfs_user_cancel

int 
guestfs_user_cancel (guestfs_h *g);

This function
cancels the current upload or download operation.

Unlike most
other libguestfs calls, this function is signal safe and
thread safe. You can call it from a signal handler or from
another thread, without needing to do any locking.

The transfer
that was in progress (if there is one) will stop shortly
afterwards, and will return an error. The errno (see
"guestfs_last_errno") is set to "EINTR",
so you can test for this to find out if the operation was
cancelled or failed because of another error.

No cleanup is
performed: for example, if a file was being uploaded then
after cancellation there may be a partially uploaded file.
It is the caller&rsquo;s responsibility to clean up if
necessary.

There are two
common places that you might call
"guestfs_user_cancel":

In an
interactive text-based program, you might call it from a
"SIGINT" signal handler so that pressing
"^C" cancels the current operation. (You also need
to call "guestfs_set_pgroup" so that child
processes don&rsquo;t receive the "^C"
signal).

In a graphical
program, when the main thread is displaying a progress bar
with a cancel button, wire up the cancel button to call this
function.

This function
returns 0 on success or -1 on error.

(Added in
1.11.18)

guestfs_utimens

int 
guestfs_utimens (guestfs_h *g, 
const char *path, 
int64_t atsecs, 
int64_t atnsecs, 
int64_t mtsecs, 
int64_t mtnsecs);

This command
sets the timestamps of a file with nanosecond precision.

"atsecs",
"atnsecs" are the last access time (atime) in secs
and nanoseconds from the epoch.

"mtsecs",
"mtnsecs" are the last modification time (mtime)
in secs and nanoseconds from the epoch.

If the *nsecs
field contains the special value -1 then the corresponding
timestamp is set to the current time. (The *secs field is
ignored in this case).

If the *nsecs
field contains the special value -2 then the corresponding
timestamp is left unchanged. (The *secs field is ignored in
this case).

This function
returns 0 on success or -1 on error.

(Added in
1.0.77)

guestfs_utsname

struct guestfs_utsname * 
guestfs_utsname (guestfs_h *g);

This returns
the kernel version of the appliance, where this is
available. This information is only useful for debugging.
Nothing in the returned structure is defined by the API.

This function
returns a "struct guestfs_utsname *", or NULL if
there was an error. The caller must call
"guestfs_free_utsname" after use.

(Added in
1.19.27)

guestfs_version

struct guestfs_version * 
guestfs_version (guestfs_h *g);

Return the
libguestfs version number that the program is linked
against.

Note that
because of dynamic linking this is not necessarily the
version of libguestfs that you compiled against. You can
compile the program, and then at runtime dynamically link
against a completely different libguestfs.so
library.

This call was
added in version 1.0.58. In previous versions of libguestfs
there was no way to get the version number. From C code you
can use dynamic linker functions to find out if this symbol
exists (if it doesn&rsquo;t, then it&rsquo;s an earlier
version).

The call
returns a structure with four elements. The first three
("major", "minor" and
"release") are numbers and correspond to the usual
version triplet. The fourth element ("extra") is a
string and is normally empty, but may be used for
distro-specific information.

To construct
the original version string:
"$major.$minor.$release$extra"

See also:
"LIBGUESTFS VERSION NUMBERS".

Note:
Don&rsquo;t use this call to test for availability of
features. In enterprise distributions we backport features
from later versions into earlier versions, making this an
unreliable way to test for features. Use
"guestfs_available" or
"guestfs_feature_available" instead.

This function
returns a "struct guestfs_version *", or NULL if
there was an error. The caller must call
"guestfs_free_version" after use.

(Added in
1.0.58)

guestfs_vfs_label

char * 
guestfs_vfs_label (guestfs_h *g, 
const char *mountable);

This returns
the label of the filesystem on "mountable".

If the
filesystem is unlabeled, this returns the empty string.

To find a
filesystem from the label, use
"guestfs_findfs_label".

This function
returns a string, or NULL on error. The caller must free
the returned string after use.

(Added in
1.3.18)

guestfs_vfs_minimum_size

int64_t 
guestfs_vfs_minimum_size (guestfs_h *g, 
const char *mountable);

Get the minimum
size of filesystem in bytes. This is the minimum possible
size for filesystem shrinking.

If getting
minimum size of specified filesystem is not supported, this
will fail and set errno as ENOTSUP.

See also
ntfsresize(8), resize2fs(8), btrfs(8),
xfs_info(8).

On error this
function returns -1.

(Added in
1.31.18)

guestfs_vfs_type

char * 
guestfs_vfs_type (guestfs_h *g, 
const char *mountable);

This command
gets the filesystem type corresponding to the filesystem on
"mountable".

For most
filesystems, the result is the name of the Linux VFS module
which would be used to mount this filesystem if you mounted
it without specifying the filesystem type. For example a
string such as "ext3" or "ntfs".

This function
returns a string, or NULL on error. The caller must free
the returned string after use.

(Added in
1.0.75)

guestfs_vfs_uuid

char * 
guestfs_vfs_uuid (guestfs_h *g, 
const char *mountable);

This returns
the filesystem UUID of the filesystem on
"mountable".

If the
filesystem does not have a UUID, this returns the empty
string.

To find a
filesystem from the UUID, use
"guestfs_findfs_uuid".

This function
returns a string, or NULL on error. The caller must free
the returned string after use.

(Added in
1.3.18)

guestfs_vg_activate

int 
guestfs_vg_activate (guestfs_h *g, 
int activate, 
char *const *volgroups);

This command
activates or (if "activate" is false) deactivates
all logical volumes in the listed volume groups
"volgroups".

This command is
the same as running "vgchange -a y|n
volgroups..."

Note that if
"volgroups" is an empty list then all
volume groups are activated or deactivated.

This function
returns 0 on success or -1 on error.

This function
depends on the feature "lvm2". See also
"guestfs_feature_available".

(Added in
1.0.26)

guestfs_vg_activate_all

int 
guestfs_vg_activate_all (guestfs_h *g, 
int activate);

This command
activates or (if "activate" is false) deactivates
all logical volumes in all volume groups.

This command is
the same as running "vgchange -a y|n"

This function
returns 0 on success or -1 on error.

This function
depends on the feature "lvm2". See also
"guestfs_feature_available".

(Added in
1.0.26)

guestfs_vgchange_uuid

int 
guestfs_vgchange_uuid (guestfs_h *g, 
const char *vg);

Generate a new
random UUID for the volume group "vg".

This function
returns 0 on success or -1 on error.

This function
depends on the feature "lvm2". See also
"guestfs_feature_available".

(Added in
1.19.26)

guestfs_vgchange_uuid_all

int 
guestfs_vgchange_uuid_all (guestfs_h *g);

Generate new
random UUIDs for all volume groups.

This function
returns 0 on success or -1 on error.

This function
depends on the feature "lvm2". See also
"guestfs_feature_available".

(Added in
1.19.26)

guestfs_vgcreate

int 
guestfs_vgcreate (guestfs_h *g, 
const char *volgroup, 
char *const *physvols);

This creates an
LVM volume group called "volgroup" from the
non-empty list of physical volumes "physvols".

This function
returns 0 on success or -1 on error.

This function
depends on the feature "lvm2". See also
"guestfs_feature_available".

(Added in
0.8)

guestfs_vglvuuids

char ** 
guestfs_vglvuuids (guestfs_h *g, 
const char *vgname);

Given a VG
called "vgname", this returns the UUIDs of all the
logical volumes created in this volume group.

You can use
this along with "guestfs_lvs" and
"guestfs_lvuuid" calls to associate logical
volumes and volume groups.

See also
"guestfs_vgpvuuids".

This function
returns a NULL-terminated array of strings (like
environ(3)), or NULL if there was an error. The
caller must free the strings and the array after
use.

(Added in
1.0.87)

guestfs_vgmeta

char * 
guestfs_vgmeta (guestfs_h *g, 
const char *vgname, 
size_t *size_r);

"vgname"
is an LVM volume group. This command examines the volume
group and returns its metadata.

Note that the
metadata is an internal structure used by LVM, subject to
change at any time, and is provided for information
only.

This function
returns a buffer, or NULL on error. The size of the returned
buffer is written to *size_r. The caller must free the
returned buffer after use.

This function
depends on the feature "lvm2". See also
"guestfs_feature_available".

(Added in
1.17.20)

guestfs_vgpvuuids

char ** 
guestfs_vgpvuuids (guestfs_h *g, 
const char *vgname);

Given a VG
called "vgname", this returns the UUIDs of all the
physical volumes that this volume group resides on.

You can use
this along with "guestfs_pvs" and
"guestfs_pvuuid" calls to associate physical
volumes and volume groups.

See also
"guestfs_vglvuuids".

This function
returns a NULL-terminated array of strings (like
environ(3)), or NULL if there was an error. The
caller must free the strings and the array after
use.

(Added in
1.0.87)

guestfs_vgremove

int 
guestfs_vgremove (guestfs_h *g, 
const char *vgname);

Remove an LVM
volume group "vgname", (for example
"VG").

This also
forcibly removes all logical volumes in the volume group (if
any).

This function
returns 0 on success or -1 on error.

This function
depends on the feature "lvm2". See also
"guestfs_feature_available".

(Added in
1.0.13)

guestfs_vgrename

int 
guestfs_vgrename (guestfs_h *g, 
const char *volgroup, 
const char *newvolgroup);

Rename a volume
group "volgroup" with the new name
"newvolgroup".

This function
returns 0 on success or -1 on error.

(Added in
1.0.83)

guestfs_vgs

char ** 
guestfs_vgs (guestfs_h *g);

List all the
volumes groups detected. This is the equivalent of the
vgs(8) command.

This returns a
list of just the volume group names that were detected (eg.
"VolGroup00").

See also
"guestfs_vgs_full".

This function
returns a NULL-terminated array of strings (like
environ(3)), or NULL if there was an error. The
caller must free the strings and the array after
use.

This function
depends on the feature "lvm2". See also
"guestfs_feature_available".

(Added in
0.4)

guestfs_vgs_full

struct guestfs_lvm_vg_list * 
guestfs_vgs_full (guestfs_h *g);

List all the
volumes groups detected. This is the equivalent of the
vgs(8) command. The "full" version includes
all fields.

This function
returns a "struct guestfs_lvm_vg_list *", or NULL
if there was an error. The caller must call
"guestfs_free_lvm_vg_list" after use.

This function
depends on the feature "lvm2". See also
"guestfs_feature_available".

(Added in
0.4)

guestfs_vgscan

int 
guestfs_vgscan (guestfs_h *g);

This
function is deprecated. In new code, use the
"guestfs_lvm_scan" call instead.

Deprecated
functions will not be removed from the API, but the fact
that they are deprecated indicates that there are problems
with correct use of these functions.

This rescans
all block devices and rebuilds the list of LVM physical
volumes, volume groups and logical volumes.

This function
returns 0 on success or -1 on error.

(Added in
1.3.2)

guestfs_vguuid

char * 
guestfs_vguuid (guestfs_h *g, 
const char *vgname);

This command
returns the UUID of the LVM VG named "vgname".

This function
returns a string, or NULL on error. The caller must free
the returned string after use.

(Added in
1.0.87)

guestfs_wait_ready

int 
guestfs_wait_ready (guestfs_h *g);

This
function is deprecated. There is no replacement. Consult
the API documentation in guestfs(3) for further
information.

Deprecated
functions will not be removed from the API, but the fact
that they are deprecated indicates that there are problems
with correct use of these functions.

This function
is a no op.

In versions of
the API 

If you see any
calls to this function in code then you can just remove
them, unless you want to retain compatibility with older
versions of the API.

This function
returns 0 on success or -1 on error.

(Added in
0.3)

guestfs_wc_c

int 
guestfs_wc_c (guestfs_h *g, 
const char *path);

This command
counts the characters in a file, using the "wc -c"
external command.

On error this
function returns -1.

(Added in
1.0.54)

guestfs_wc_l

int 
guestfs_wc_l (guestfs_h *g, 
const char *path);

This command
counts the lines in a file, using the "wc -l"
external command.

On error this
function returns -1.

(Added in
1.0.54)

guestfs_wc_w

int 
guestfs_wc_w (guestfs_h *g, 
const char *path);

This command
counts the words in a file, using the "wc -w"
external command.

On error this
function returns -1.

(Added in
1.0.54)

guestfs_wipefs

int 
guestfs_wipefs (guestfs_h *g, 
const char *device);

This command
erases filesystem or RAID signatures from the specified
"device" to make the filesystem invisible to
libblkid.

This does not
erase the filesystem itself nor any other data from the
"device".

Compare with
"guestfs_zero" which zeroes the first few blocks
of a device.

This function
returns 0 on success or -1 on error.

This function
depends on the feature "wipefs". See also
"guestfs_feature_available".

(Added in
1.17.6)

guestfs_write

int 
guestfs_write (guestfs_h *g, 
const char *path, 
const char *content, 
size_t content_size);

This call
creates a file called "path". The content of the
file is the string "content" (which can contain
any 8 bit data).

See also
"guestfs_write_append".

This function
returns 0 on success or -1 on error.

(Added in
1.3.14)

guestfs_write_append

int 
guestfs_write_append (guestfs_h *g, 
const char *path, 
const char *content, 
size_t content_size);

This call
appends "content" to the end of file
"path". If "path" does not exist, then a
new file is created.

See also
"guestfs_write".

This function
returns 0 on success or -1 on error.

(Added in
1.11.18)

guestfs_write_file

int 
guestfs_write_file (guestfs_h *g, 
const char *path, 
const char *content, 
int size);

This
function is deprecated. In new code, use the
"guestfs_write" call instead.

Deprecated
functions will not be removed from the API, but the fact
that they are deprecated indicates that there are problems
with correct use of these functions.

This call
creates a file called "path". The contents of the
file is the string "content" (which can contain
any 8 bit data), with length "size".

As a special
case, if "size" is 0 then the length is calculated
using "strlen" (so in this case the content cannot
contain embedded ASCII NULs).

NB.
Owing to a bug, writing content containing ASCII NUL
characters does not work, even if the length is
specified.

This function
returns 0 on success or -1 on error.

Because of the
message protocol, there is a transfer limit of somewhere
between 2MB and 4MB. See "PROTOCOL LIMITS".

(Added in
0.8)

guestfs_xfs_admin

int 
guestfs_xfs_admin (guestfs_h *g, 
const char *device, 
...);

You may supply
a list of optional arguments to this call. Use zero or more
of the following pairs of parameters, and terminate the list
with -1 on its own. See "CALLS WITH OPTIONAL
ARGUMENTS".

GUESTFS_XFS_ADMIN_EXTUNWRITTEN,
int extunwritten, 
GUESTFS_XFS_ADMIN_IMGFILE, int imgfile, 
GUESTFS_XFS_ADMIN_V2LOG, int v2log, 
GUESTFS_XFS_ADMIN_PROJID32BIT, int projid32bit, 
GUESTFS_XFS_ADMIN_LAZYCOUNTER, int lazycounter, 
GUESTFS_XFS_ADMIN_LABEL, const char *label, 
GUESTFS_XFS_ADMIN_UUID, const char *uuid,

Change the
parameters of the XFS filesystem on "device".

Devices that
are mounted cannot be modified. Administrators must unmount
filesystems before this call can modify parameters.

Some of the
parameters of a mounted filesystem can be examined and
modified using the "guestfs_xfs_info" and
"guestfs_xfs_growfs" calls.

Beginning with
XFS version 5, it is no longer possible to modify the
lazy-counters setting (ie. "lazycounter" parameter
has no effect).

This function
returns 0 on success or -1 on error.

This function
depends on the feature "xfs". See also
"guestfs_feature_available".

(Added in
1.19.33)

guestfs_xfs_admin_va

int 
guestfs_xfs_admin_va (guestfs_h *g, 
const char *device, 
va_list args);

This is the
"va_list variant" of
"guestfs_xfs_admin".

See "CALLS
WITH OPTIONAL ARGUMENTS".

guestfs_xfs_admin_argv

int 
guestfs_xfs_admin_argv (guestfs_h *g, 
const char *device, 
const struct guestfs_xfs_admin_argv *optargs);

This is the
"argv variant" of
"guestfs_xfs_admin".

See "CALLS
WITH OPTIONAL ARGUMENTS".

guestfs_xfs_growfs

int 
guestfs_xfs_growfs (guestfs_h *g, 
const char *path, 
...);

You may supply
a list of optional arguments to this call. Use zero or more
of the following pairs of parameters, and terminate the list
with -1 on its own. See "CALLS WITH OPTIONAL
ARGUMENTS".

GUESTFS_XFS_GROWFS_DATASEC,
int datasec, 
GUESTFS_XFS_GROWFS_LOGSEC, int logsec, 
GUESTFS_XFS_GROWFS_RTSEC, int rtsec, 
GUESTFS_XFS_GROWFS_DATASIZE, int64_t datasize, 
GUESTFS_XFS_GROWFS_LOGSIZE, int64_t logsize, 
GUESTFS_XFS_GROWFS_RTSIZE, int64_t rtsize, 
GUESTFS_XFS_GROWFS_RTEXTSIZE, int64_t rtextsize, 
GUESTFS_XFS_GROWFS_MAXPCT, int maxpct,

Grow the XFS
filesystem mounted at "path".

The returned
struct contains geometry information. Missing fields are
returned as -1 (for numeric fields) or empty string.

This function
returns 0 on success or -1 on error.

This function
depends on the feature "xfs". See also
"guestfs_feature_available".

(Added in
1.19.28)

guestfs_xfs_growfs_va

int 
guestfs_xfs_growfs_va (guestfs_h *g, 
const char *path, 
va_list args);

This is the
"va_list variant" of
"guestfs_xfs_growfs".

See "CALLS
WITH OPTIONAL ARGUMENTS".

guestfs_xfs_growfs_argv

int 
guestfs_xfs_growfs_argv (guestfs_h *g, 
const char *path, 
const struct guestfs_xfs_growfs_argv *optargs);

This is the
"argv variant" of
"guestfs_xfs_growfs".

See "CALLS
WITH OPTIONAL ARGUMENTS".

guestfs_xfs_info

struct guestfs_xfsinfo * 
guestfs_xfs_info (guestfs_h *g, 
const char *pathordevice);

"pathordevice"
is a mounted XFS filesystem or a device containing an XFS
filesystem. This command returns the geometry of the
filesystem.

The returned
struct contains geometry information. Missing fields are
returned as -1 (for numeric fields) or empty string.

This function
returns a "struct guestfs_xfsinfo *", or NULL if
there was an error. The caller must call
"guestfs_free_xfsinfo" after use.

This function
depends on the feature "xfs". See also
"guestfs_feature_available".

(Added in
1.19.21)

guestfs_xfs_repair

int 
guestfs_xfs_repair (guestfs_h *g, 
const char *device, 
...);

You may supply
a list of optional arguments to this call. Use zero or more
of the following pairs of parameters, and terminate the list
with -1 on its own. See "CALLS WITH OPTIONAL
ARGUMENTS".

GUESTFS_XFS_REPAIR_FORCELOGZERO,
int forcelogzero, 
GUESTFS_XFS_REPAIR_NOMODIFY, int nomodify, 
GUESTFS_XFS_REPAIR_NOPREFETCH, int noprefetch, 
GUESTFS_XFS_REPAIR_FORCEGEOMETRY, int forcegeometry, 
GUESTFS_XFS_REPAIR_MAXMEM, int64_t maxmem, 
GUESTFS_XFS_REPAIR_IHASHSIZE, int64_t ihashsize, 
GUESTFS_XFS_REPAIR_BHASHSIZE, int64_t bhashsize, 
GUESTFS_XFS_REPAIR_AGSTRIDE, int64_t agstride, 
GUESTFS_XFS_REPAIR_LOGDEV, const char *logdev, 
GUESTFS_XFS_REPAIR_RTDEV, const char *rtdev,

Repair corrupt
or damaged XFS filesystem on "device".

The filesystem
is specified using the "device" argument which
should be the device name of the disk partition or volume
containing the filesystem. If given the name of a block
device, "xfs_repair" will attempt to find the raw
device associated with the specified block device and will
use the raw device instead.

Regardless, the
filesystem to be repaired must be unmounted, otherwise, the
resulting filesystem may be inconsistent or corrupt.

The returned
status indicates whether filesystem corruption was detected
(returns 1) or was not detected (returns 0).

On error this
function returns -1.

This function
depends on the feature "xfs". See also
"guestfs_feature_available".

(Added in
1.19.36)

guestfs_xfs_repair_va

int 
guestfs_xfs_repair_va (guestfs_h *g, 
const char *device, 
va_list args);

This is the
"va_list variant" of
"guestfs_xfs_repair".

See "CALLS
WITH OPTIONAL ARGUMENTS".

guestfs_xfs_repair_argv

int 
guestfs_xfs_repair_argv (guestfs_h *g, 
const char *device, 
const struct guestfs_xfs_repair_argv *optargs);

This is the
"argv variant" of
"guestfs_xfs_repair".

See "CALLS
WITH OPTIONAL ARGUMENTS".

guestfs_yara_destroy

int 
guestfs_yara_destroy (guestfs_h *g);

Destroy
previously loaded Yara rules in order to free libguestfs
resources.

This function
returns 0 on success or -1 on error.

This function
depends on the feature "libyara". See also
"guestfs_feature_available".

(Added in
1.37.13)

guestfs_yara_load

int 
guestfs_yara_load (guestfs_h *g, 
const char *filename);

Upload a set of
Yara rules from local file filename.

Yara rules
allow to categorize files based on textual or binary
patterns within their content. See
"guestfs_yara_scan" to see how to scan files with
the loaded rules.

Rules can be in
binary format, as when compiled with yarac command, or in
source code format. In the latter case, the rules will be
first compiled and then loaded.

Rules in source
code format cannot include external files. In such cases, it
is recommended to compile them first.

Previously
loaded rules will be destroyed.

This function
returns 0 on success or -1 on error.

This
long-running command can generate progress notification
messages so that the caller can display a progress bar or
indicator. To receive these messages, the caller must
register a progress event callback. See
"GUESTFS_EVENT_PROGRESS".

This function
depends on the feature "libyara". See also
"guestfs_feature_available".

(Added in
1.37.13)

guestfs_yara_scan

struct guestfs_yara_detection_list * 
guestfs_yara_scan (guestfs_h *g, 
const char *path);

Scan a file
with the previously loaded Yara rules.

For each
matching rule, a "yara_detection" structure is
returned.

The
"yara_detection" structure contains the following
fields. 
"yara_name"

Path of the file matching a
Yara rule.

"yara_rule"

Identifier of the Yara rule
which matched against the given file.

This function
returns a "struct guestfs_yara_detection_list *",
or NULL if there was an error. The caller must call
"guestfs_free_yara_detection_list" after
use.

This
long-running command can generate progress notification
messages so that the caller can display a progress bar or
indicator. To receive these messages, the caller must
register a progress event callback. See
"GUESTFS_EVENT_PROGRESS".

This function
depends on the feature "libyara". See also
"guestfs_feature_available".

(Added in
1.37.13)

guestfs_zegrep

char ** 
guestfs_zegrep (guestfs_h *g, 
const char *regex, 
const char *path);

This
function is deprecated. In new code, use the
"guestfs_grep" call instead.

Deprecated
functions will not be removed from the API, but the fact
that they are deprecated indicates that there are problems
with correct use of these functions.

This calls the
external "zegrep" program and returns the matching
lines.

This function
returns a NULL-terminated array of strings (like
environ(3)), or NULL if there was an error. The
caller must free the strings and the array after
use.

Because of the
message protocol, there is a transfer limit of somewhere
between 2MB and 4MB. See "PROTOCOL LIMITS".

(Added in
1.0.66)

guestfs_zegrepi

char ** 
guestfs_zegrepi (guestfs_h *g, 
const char *regex, 
const char *path);

This
function is deprecated. In new code, use the
"guestfs_grep" call instead.

Deprecated
functions will not be removed from the API, but the fact
that they are deprecated indicates that there are problems
with correct use of these functions.

This calls the
external "zegrep -i" program and returns the
matching lines.

This function
returns a NULL-terminated array of strings (like
environ(3)), or NULL if there was an error. The
caller must free the strings and the array after
use.

Because of the
message protocol, there is a transfer limit of somewhere
between 2MB and 4MB. See "PROTOCOL LIMITS".

(Added in
1.0.66)

guestfs_zero

int 
guestfs_zero (guestfs_h *g, 
const char *device);

This command
writes zeroes over the first few blocks of
"device".

How many blocks
are zeroed isn&rsquo;t specified (but it&rsquo;s not
enough to securely wipe the device). It should be sufficient
to remove any partition tables, filesystem superblocks and
so on.

If blocks are
already zero, then this command avoids writing zeroes. This
prevents the underlying device from becoming non-sparse or
growing unnecessarily.

See also:
"guestfs_zero_device",
"guestfs_scrub_device",
"guestfs_is_zero_device"

This function
returns 0 on success or -1 on error.

This
long-running command can generate progress notification
messages so that the caller can display a progress bar or
indicator. To receive these messages, the caller must
register a progress event callback. See
"GUESTFS_EVENT_PROGRESS".

(Added in
1.0.16)

guestfs_zero_device

int 
guestfs_zero_device (guestfs_h *g, 
const char *device);

This command
writes zeroes over the entire "device". Compare
with "guestfs_zero" which just zeroes the first
few blocks of a device.

If blocks are
already zero, then this command avoids writing zeroes. This
prevents the underlying device from becoming non-sparse or
growing unnecessarily.

This function
returns 0 on success or -1 on error.

This
long-running command can generate progress notification
messages so that the caller can display a progress bar or
indicator. To receive these messages, the caller must
register a progress event callback. See
"GUESTFS_EVENT_PROGRESS".

(Added in
1.3.1)

guestfs_zero_free_space

int 
guestfs_zero_free_space (guestfs_h *g, 
const char *directory);

Zero the free
space in the filesystem mounted on directory. The
filesystem must be mounted read-write.

The filesystem
contents are not affected, but any free space in the
filesystem is freed.

Free space is
not "trimmed". You may want to call
"guestfs_fstrim" either as an alternative to this,
or after calling this, depending on your requirements.

This function
returns 0 on success or -1 on error.

This
long-running command can generate progress notification
messages so that the caller can display a progress bar or
indicator. To receive these messages, the caller must
register a progress event callback. See
"GUESTFS_EVENT_PROGRESS".

(Added in
1.17.18)

guestfs_zerofree

int 
guestfs_zerofree (guestfs_h *g, 
const char *device);

This runs the
zerofree program on "device". This program
claims to zero unused inodes and disk blocks on an ext2/3
filesystem, thus making it possible to compress the
filesystem more effectively.

You should
not run this program if the filesystem is
mounted.

It is possible
that using this program can damage the filesystem or data on
the filesystem.

This function
returns 0 on success or -1 on error.

This function
depends on the feature "zerofree". See also
"guestfs_feature_available".

(Added in
1.0.26)

guestfs_zfgrep

char ** 
guestfs_zfgrep (guestfs_h *g, 
const char *pattern, 
const char *path);

This
function is deprecated. In new code, use the
"guestfs_grep" call instead.

Deprecated
functions will not be removed from the API, but the fact
that they are deprecated indicates that there are problems
with correct use of these functions.

This calls the
external "zfgrep" program and returns the matching
lines.

This function
returns a NULL-terminated array of strings (like
environ(3)), or NULL if there was an error. The
caller must free the strings and the array after
use.

Because of the
message protocol, there is a transfer limit of somewhere
between 2MB and 4MB. See "PROTOCOL LIMITS".

(Added in
1.0.66)

guestfs_zfgrepi

char ** 
guestfs_zfgrepi (guestfs_h *g, 
const char *pattern, 
const char *path);

This
function is deprecated. In new code, use the
"guestfs_grep" call instead.

Deprecated
functions will not be removed from the API, but the fact
that they are deprecated indicates that there are problems
with correct use of these functions.

This calls the
external "zfgrep -i" program and returns the
matching lines.

This function
returns a NULL-terminated array of strings (like
environ(3)), or NULL if there was an error. The
caller must free the strings and the array after
use.

Because of the
message protocol, there is a transfer limit of somewhere
between 2MB and 4MB. See "PROTOCOL LIMITS".

(Added in
1.0.66)

guestfs_zfile

char * 
guestfs_zfile (guestfs_h *g, 
const char *meth, 
const char *path);

This
function is deprecated. In new code, use the
"guestfs_file" call instead.

Deprecated
functions will not be removed from the API, but the fact
that they are deprecated indicates that there are problems
with correct use of these functions.

This command
runs file(1) after first decompressing
"path" using "meth".

"meth"
must be one of "gzip", "compress" or
"bzip2".

Since 1.0.63,
use "guestfs_file" instead which can now process
compressed files.

This function
returns a string, or NULL on error. The caller must free
the returned string after use.

(Added in
1.0.59)

guestfs_zgrep

char ** 
guestfs_zgrep (guestfs_h *g, 
const char *regex, 
const char *path);

This
function is deprecated. In new code, use the
"guestfs_grep" call instead.

Deprecated
functions will not be removed from the API, but the fact
that they are deprecated indicates that there are problems
with correct use of these functions.

This calls the
external zgrep(1) program and returns the matching
lines.

This function
returns a NULL-terminated array of strings (like
environ(3)), or NULL if there was an error. The
caller must free the strings and the array after
use.

Because of the
message protocol, there is a transfer limit of somewhere
between 2MB and 4MB. See "PROTOCOL LIMITS".

(Added in
1.0.66)

guestfs_zgrepi

char ** 
guestfs_zgrepi (guestfs_h *g, 
const char *regex, 
const char *path);

This
function is deprecated. In new code, use the
"guestfs_grep" call instead.

Deprecated
functions will not be removed from the API, but the fact
that they are deprecated indicates that there are problems
with correct use of these functions.

This calls the
external "zgrep -i" program and returns the
matching lines.

This function
returns a NULL-terminated array of strings (like
environ(3)), or NULL if there was an error. The
caller must free the strings and the array after
use.

Because of the
message protocol, there is a transfer limit of somewhere
between 2MB and 4MB. See "PROTOCOL LIMITS".

(Added in
1.0.66)

STRUCTURES

guestfs_int_bool

struct guestfs_int_bool { 
int32_t i; 
int32_t b; 
}; 
struct guestfs_int_bool_list { 
uint32_t len; /* Number of elements in list. */ 
struct guestfs_int_bool *val; /* Elements. */ 
}; 
int guestfs_compare_int_bool (const struct guestfs_int_bool
*, const struct guestfs_int_bool *); 
int guestfs_compare_int_bool_list (const struct
guestfs_int_bool_list *, const struct guestfs_int_bool_list
*); 
struct guestfs_int_bool *guestfs_copy_int_bool (const struct
guestfs_int_bool *); 
struct guestfs_int_bool_list *guestfs_copy_int_bool_list
(const struct guestfs_int_bool_list *); 
void guestfs_free_int_bool (struct guestfs_int_bool *); 
void guestfs_free_int_bool_list (struct
guestfs_int_bool_list *);

guestfs_lvm_pv

struct guestfs_lvm_pv { 
char *pv_name; 
/* The next field is NOT nul-terminated, be careful when
printing it: */ 
char pv_uuid[32]; 
char *pv_fmt; 
uint64_t pv_size; 
uint64_t dev_size; 
uint64_t pv_free; 
uint64_t pv_used; 
char *pv_attr; 
int64_t pv_pe_count; 
int64_t pv_pe_alloc_count; 
char *pv_tags; 
uint64_t pe_start; 
int64_t pv_mda_count; 
uint64_t pv_mda_free; 
}; 
struct guestfs_lvm_pv_list { 
uint32_t len; /* Number of elements in list. */ 
struct guestfs_lvm_pv *val; /* Elements. */ 
}; 
int guestfs_compare_lvm_pv (const struct guestfs_lvm_pv *,
const struct guestfs_lvm_pv *); 
int guestfs_compare_lvm_pv_list (const struct
guestfs_lvm_pv_list *, const struct guestfs_lvm_pv_list *);

struct guestfs_lvm_pv *guestfs_copy_lvm_pv (const struct
guestfs_lvm_pv *); 
struct guestfs_lvm_pv_list *guestfs_copy_lvm_pv_list (const
struct guestfs_lvm_pv_list *); 
void guestfs_free_lvm_pv (struct guestfs_lvm_pv *); 
void guestfs_free_lvm_pv_list (struct guestfs_lvm_pv_list
*);

guestfs_lvm_vg

struct guestfs_lvm_vg { 
char *vg_name; 
/* The next field is NOT nul-terminated, be careful when
printing it: */ 
char vg_uuid[32]; 
char *vg_fmt; 
char *vg_attr; 
uint64_t vg_size; 
uint64_t vg_free; 
char *vg_sysid; 
uint64_t vg_extent_size; 
int64_t vg_extent_count; 
int64_t vg_free_count; 
int64_t max_lv; 
int64_t max_pv; 
int64_t pv_count; 
int64_t lv_count; 
int64_t snap_count; 
int64_t vg_seqno; 
char *vg_tags; 
int64_t vg_mda_count; 
uint64_t vg_mda_free; 
}; 
struct guestfs_lvm_vg_list { 
uint32_t len; /* Number of elements in list. */ 
struct guestfs_lvm_vg *val; /* Elements. */ 
}; 
int guestfs_compare_lvm_vg (const struct guestfs_lvm_vg *,
const struct guestfs_lvm_vg *); 
int guestfs_compare_lvm_vg_list (const struct
guestfs_lvm_vg_list *, const struct guestfs_lvm_vg_list *);

struct guestfs_lvm_vg *guestfs_copy_lvm_vg (const struct
guestfs_lvm_vg *); 
struct guestfs_lvm_vg_list *guestfs_copy_lvm_vg_list (const
struct guestfs_lvm_vg_list *); 
void guestfs_free_lvm_vg (struct guestfs_lvm_vg *); 
void guestfs_free_lvm_vg_list (struct guestfs_lvm_vg_list
*);

guestfs_lvm_lv

struct guestfs_lvm_lv { 
char *lv_name; 
/* The next field is NOT nul-terminated, be careful when
printing it: */ 
char lv_uuid[32]; 
char *lv_attr; 
int64_t lv_major; 
int64_t lv_minor; 
int64_t lv_kernel_major; 
int64_t lv_kernel_minor; 
uint64_t lv_size; 
int64_t seg_count; 
char *origin; 
/* The next field is [0..100] or -1 meaning 'not present':
*/ 
float snap_percent; 
/* The next field is [0..100] or -1 meaning 'not present':
*/ 
float copy_percent; 
char *move_pv; 
char *lv_tags; 
char *mirror_log; 
char *modules; 
}; 
struct guestfs_lvm_lv_list { 
uint32_t len; /* Number of elements in list. */ 
struct guestfs_lvm_lv *val; /* Elements. */ 
}; 
int guestfs_compare_lvm_lv (const struct guestfs_lvm_lv *,
const struct guestfs_lvm_lv *); 
int guestfs_compare_lvm_lv_list (const struct
guestfs_lvm_lv_list *, const struct guestfs_lvm_lv_list *);

struct guestfs_lvm_lv *guestfs_copy_lvm_lv (const struct
guestfs_lvm_lv *); 
struct guestfs_lvm_lv_list *guestfs_copy_lvm_lv_list (const
struct guestfs_lvm_lv_list *); 
void guestfs_free_lvm_lv (struct guestfs_lvm_lv *); 
void guestfs_free_lvm_lv_list (struct guestfs_lvm_lv_list
*);

guestfs_stat

struct guestfs_stat { 
int64_t dev; 
int64_t ino; 
int64_t mode; 
int64_t nlink; 
int64_t uid; 
int64_t gid; 
int64_t rdev; 
int64_t size; 
int64_t blksize; 
int64_t blocks; 
int64_t atime; 
int64_t mtime; 
int64_t ctime; 
}; 
struct guestfs_stat_list { 
uint32_t len; /* Number of elements in list. */ 
struct guestfs_stat *val; /* Elements. */ 
}; 
int guestfs_compare_stat (const struct guestfs_stat *, const
struct guestfs_stat *); 
int guestfs_compare_stat_list (const struct
guestfs_stat_list *, const struct guestfs_stat_list *); 
struct guestfs_stat *guestfs_copy_stat (const struct
guestfs_stat *); 
struct guestfs_stat_list *guestfs_copy_stat_list (const
struct guestfs_stat_list *); 
void guestfs_free_stat (struct guestfs_stat *); 
void guestfs_free_stat_list (struct guestfs_stat_list
*);

guestfs_statns

struct guestfs_statns { 
int64_t st_dev; 
int64_t st_ino; 
int64_t st_mode; 
int64_t st_nlink; 
int64_t st_uid; 
int64_t st_gid; 
int64_t st_rdev; 
int64_t st_size; 
int64_t st_blksize; 
int64_t st_blocks; 
int64_t st_atime_sec; 
int64_t st_atime_nsec; 
int64_t st_mtime_sec; 
int64_t st_mtime_nsec; 
int64_t st_ctime_sec; 
int64_t st_ctime_nsec; 
int64_t st_spare1; 
int64_t st_spare2; 
int64_t st_spare3; 
int64_t st_spare4; 
int64_t st_spare5; 
int64_t st_spare6; 
}; 
struct guestfs_statns_list { 
uint32_t len; /* Number of elements in list. */ 
struct guestfs_statns *val; /* Elements. */ 
}; 
int guestfs_compare_statns (const struct guestfs_statns *,
const struct guestfs_statns *); 
int guestfs_compare_statns_list (const struct
guestfs_statns_list *, const struct guestfs_statns_list *);

struct guestfs_statns *guestfs_copy_statns (const struct
guestfs_statns *); 
struct guestfs_statns_list *guestfs_copy_statns_list (const
struct guestfs_statns_list *); 
void guestfs_free_statns (struct guestfs_statns *); 
void guestfs_free_statns_list (struct guestfs_statns_list
*);

guestfs_statvfs

struct guestfs_statvfs { 
int64_t bsize; 
int64_t frsize; 
int64_t blocks; 
int64_t bfree; 
int64_t bavail; 
int64_t files; 
int64_t ffree; 
int64_t favail; 
int64_t fsid; 
int64_t flag; 
int64_t namemax; 
}; 
struct guestfs_statvfs_list { 
uint32_t len; /* Number of elements in list. */ 
struct guestfs_statvfs *val; /* Elements. */ 
}; 
int guestfs_compare_statvfs (const struct guestfs_statvfs *,
const struct guestfs_statvfs *); 
int guestfs_compare_statvfs_list (const struct
guestfs_statvfs_list *, const struct guestfs_statvfs_list
*); 
struct guestfs_statvfs *guestfs_copy_statvfs (const struct
guestfs_statvfs *); 
struct guestfs_statvfs_list *guestfs_copy_statvfs_list
(const struct guestfs_statvfs_list *); 
void guestfs_free_statvfs (struct guestfs_statvfs *); 
void guestfs_free_statvfs_list (struct guestfs_statvfs_list
*);

guestfs_dirent

struct guestfs_dirent { 
int64_t ino; 
char ftyp; 
char *name; 
}; 
struct guestfs_dirent_list { 
uint32_t len; /* Number of elements in list. */ 
struct guestfs_dirent *val; /* Elements. */ 
}; 
int guestfs_compare_dirent (const struct guestfs_dirent *,
const struct guestfs_dirent *); 
int guestfs_compare_dirent_list (const struct
guestfs_dirent_list *, const struct guestfs_dirent_list *);

struct guestfs_dirent *guestfs_copy_dirent (const struct
guestfs_dirent *); 
struct guestfs_dirent_list *guestfs_copy_dirent_list (const
struct guestfs_dirent_list *); 
void guestfs_free_dirent (struct guestfs_dirent *); 
void guestfs_free_dirent_list (struct guestfs_dirent_list
*);

guestfs_version

struct guestfs_version { 
int64_t major; 
int64_t minor; 
int64_t release; 
char *extra; 
}; 
struct guestfs_version_list { 
uint32_t len; /* Number of elements in list. */ 
struct guestfs_version *val; /* Elements. */ 
}; 
int guestfs_compare_version (const struct guestfs_version *,
const struct guestfs_version *); 
int guestfs_compare_version_list (const struct
guestfs_version_list *, const struct guestfs_version_list
*); 
struct guestfs_version *guestfs_copy_version (const struct
guestfs_version *); 
struct guestfs_version_list *guestfs_copy_version_list
(const struct guestfs_version_list *); 
void guestfs_free_version (struct guestfs_version *); 
void guestfs_free_version_list (struct guestfs_version_list
*);

guestfs_xattr

struct guestfs_xattr { 
char *attrname; 
/* The next two fields describe a byte array. */ 
uint32_t attrval_len; 
char *attrval; 
}; 
struct guestfs_xattr_list { 
uint32_t len; /* Number of elements in list. */ 
struct guestfs_xattr *val; /* Elements. */ 
}; 
int guestfs_compare_xattr (const struct guestfs_xattr *,
const struct guestfs_xattr *); 
int guestfs_compare_xattr_list (const struct
guestfs_xattr_list *, const struct guestfs_xattr_list *);

struct guestfs_xattr *guestfs_copy_xattr (const struct
guestfs_xattr *); 
struct guestfs_xattr_list *guestfs_copy_xattr_list (const
struct guestfs_xattr_list *); 
void guestfs_free_xattr (struct guestfs_xattr *); 
void guestfs_free_xattr_list (struct guestfs_xattr_list
*);

guestfs_inotify_event

struct guestfs_inotify_event { 
int64_t in_wd; 
uint32_t in_mask; 
uint32_t in_cookie; 
char *in_name; 
}; 
struct guestfs_inotify_event_list { 
uint32_t len; /* Number of elements in list. */ 
struct guestfs_inotify_event *val; /* Elements. */ 
}; 
int guestfs_compare_inotify_event (const struct
guestfs_inotify_event *, const struct guestfs_inotify_event
*); 
int guestfs_compare_inotify_event_list (const struct
guestfs_inotify_event_list *, const struct
guestfs_inotify_event_list *); 
struct guestfs_inotify_event *guestfs_copy_inotify_event
(const struct guestfs_inotify_event *); 
struct guestfs_inotify_event_list
*guestfs_copy_inotify_event_list (const struct
guestfs_inotify_event_list *); 
void guestfs_free_inotify_event (struct
guestfs_inotify_event *); 
void guestfs_free_inotify_event_list (struct
guestfs_inotify_event_list *);

guestfs_partition

struct guestfs_partition { 
int32_t part_num; 
uint64_t part_start; 
uint64_t part_end; 
uint64_t part_size; 
}; 
struct guestfs_partition_list { 
uint32_t len; /* Number of elements in list. */ 
struct guestfs_partition *val; /* Elements. */ 
}; 
int guestfs_compare_partition (const struct
guestfs_partition *, const struct guestfs_partition *); 
int guestfs_compare_partition_list (const struct
guestfs_partition_list *, const struct
guestfs_partition_list *); 
struct guestfs_partition *guestfs_copy_partition (const
struct guestfs_partition *); 
struct guestfs_partition_list *guestfs_copy_partition_list
(const struct guestfs_partition_list *); 
void guestfs_free_partition (struct guestfs_partition *);

void guestfs_free_partition_list (struct
guestfs_partition_list *);

guestfs_application

struct guestfs_application { 
char *app_name; 
char *app_display_name; 
int32_t app_epoch; 
char *app_version; 
char *app_release; 
char *app_install_path; 
char *app_trans_path; 
char *app_publisher; 
char *app_url; 
char *app_source_package; 
char *app_summary; 
char *app_description; 
}; 
struct guestfs_application_list { 
uint32_t len; /* Number of elements in list. */ 
struct guestfs_application *val; /* Elements. */ 
}; 
int guestfs_compare_application (const struct
guestfs_application *, const struct guestfs_application *);

int guestfs_compare_application_list (const struct
guestfs_application_list *, const struct
guestfs_application_list *); 
struct guestfs_application *guestfs_copy_application (const
struct guestfs_application *); 
struct guestfs_application_list
*guestfs_copy_application_list (const struct
guestfs_application_list *); 
void guestfs_free_application (struct guestfs_application
*); 
void guestfs_free_application_list (struct
guestfs_application_list *);

guestfs_application2

struct guestfs_application2 { 
char *app2_name; 
char *app2_display_name; 
int32_t app2_epoch; 
char *app2_version; 
char *app2_release; 
char *app2_arch; 
char *app2_install_path; 
char *app2_trans_path; 
char *app2_publisher; 
char *app2_url; 
char *app2_source_package; 
char *app2_summary; 
char *app2_description; 
char *app2_spare1; 
char *app2_spare2; 
char *app2_spare3; 
char *app2_spare4; 
}; 
struct guestfs_application2_list { 
uint32_t len; /* Number of elements in list. */ 
struct guestfs_application2 *val; /* Elements. */ 
}; 
int guestfs_compare_application2 (const struct
guestfs_application2 *, const struct guestfs_application2
*); 
int guestfs_compare_application2_list (const struct
guestfs_application2_list *, const struct
guestfs_application2_list *); 
struct guestfs_application2 *guestfs_copy_application2
(const struct guestfs_application2 *); 
struct guestfs_application2_list
*guestfs_copy_application2_list (const struct
guestfs_application2_list *); 
void guestfs_free_application2 (struct guestfs_application2
*); 
void guestfs_free_application2_list (struct
guestfs_application2_list *);

guestfs_isoinfo

struct guestfs_isoinfo { 
char *iso_system_id; 
char *iso_volume_id; 
uint32_t iso_volume_space_size; 
uint32_t iso_volume_set_size; 
uint32_t iso_volume_sequence_number; 
uint32_t iso_logical_block_size; 
char *iso_volume_set_id; 
char *iso_publisher_id; 
char *iso_data_preparer_id; 
char *iso_application_id; 
char *iso_copyright_file_id; 
char *iso_abstract_file_id; 
char *iso_bibliographic_file_id; 
int64_t iso_volume_creation_t; 
int64_t iso_volume_modification_t; 
int64_t iso_volume_expiration_t; 
int64_t iso_volume_effective_t; 
}; 
struct guestfs_isoinfo_list { 
uint32_t len; /* Number of elements in list. */ 
struct guestfs_isoinfo *val; /* Elements. */ 
}; 
int guestfs_compare_isoinfo (const struct guestfs_isoinfo *,
const struct guestfs_isoinfo *); 
int guestfs_compare_isoinfo_list (const struct
guestfs_isoinfo_list *, const struct guestfs_isoinfo_list
*); 
struct guestfs_isoinfo *guestfs_copy_isoinfo (const struct
guestfs_isoinfo *); 
struct guestfs_isoinfo_list *guestfs_copy_isoinfo_list
(const struct guestfs_isoinfo_list *); 
void guestfs_free_isoinfo (struct guestfs_isoinfo *); 
void guestfs_free_isoinfo_list (struct guestfs_isoinfo_list
*);

guestfs_mdstat

struct guestfs_mdstat { 
char *mdstat_device; 
int32_t mdstat_index; 
char *mdstat_flags; 
}; 
struct guestfs_mdstat_list { 
uint32_t len; /* Number of elements in list. */ 
struct guestfs_mdstat *val; /* Elements. */ 
}; 
int guestfs_compare_mdstat (const struct guestfs_mdstat *,
const struct guestfs_mdstat *); 
int guestfs_compare_mdstat_list (const struct
guestfs_mdstat_list *, const struct guestfs_mdstat_list *);

struct guestfs_mdstat *guestfs_copy_mdstat (const struct
guestfs_mdstat *); 
struct guestfs_mdstat_list *guestfs_copy_mdstat_list (const
struct guestfs_mdstat_list *); 
void guestfs_free_mdstat (struct guestfs_mdstat *); 
void guestfs_free_mdstat_list (struct guestfs_mdstat_list
*);

guestfs_btrfssubvolume

struct guestfs_btrfssubvolume { 
uint64_t btrfssubvolume_id; 
uint64_t btrfssubvolume_top_level_id; 
char *btrfssubvolume_path; 
}; 
struct guestfs_btrfssubvolume_list { 
uint32_t len; /* Number of elements in list. */ 
struct guestfs_btrfssubvolume *val; /* Elements. */ 
}; 
int guestfs_compare_btrfssubvolume (const struct
guestfs_btrfssubvolume *, const struct
guestfs_btrfssubvolume *); 
int guestfs_compare_btrfssubvolume_list (const struct
guestfs_btrfssubvolume_list *, const struct
guestfs_btrfssubvolume_list *); 
struct guestfs_btrfssubvolume *guestfs_copy_btrfssubvolume
(const struct guestfs_btrfssubvolume *); 
struct guestfs_btrfssubvolume_list
*guestfs_copy_btrfssubvolume_list (const struct
guestfs_btrfssubvolume_list *); 
void guestfs_free_btrfssubvolume (struct
guestfs_btrfssubvolume *); 
void guestfs_free_btrfssubvolume_list (struct
guestfs_btrfssubvolume_list *);

guestfs_btrfsqgroup

struct guestfs_btrfsqgroup { 
char *btrfsqgroup_id; 
uint64_t btrfsqgroup_rfer; 
uint64_t btrfsqgroup_excl; 
}; 
struct guestfs_btrfsqgroup_list { 
uint32_t len; /* Number of elements in list. */ 
struct guestfs_btrfsqgroup *val; /* Elements. */ 
}; 
int guestfs_compare_btrfsqgroup (const struct
guestfs_btrfsqgroup *, const struct guestfs_btrfsqgroup *);

int guestfs_compare_btrfsqgroup_list (const struct
guestfs_btrfsqgroup_list *, const struct
guestfs_btrfsqgroup_list *); 
struct guestfs_btrfsqgroup *guestfs_copy_btrfsqgroup (const
struct guestfs_btrfsqgroup *); 
struct guestfs_btrfsqgroup_list
*guestfs_copy_btrfsqgroup_list (const struct
guestfs_btrfsqgroup_list *); 
void guestfs_free_btrfsqgroup (struct guestfs_btrfsqgroup
*); 
void guestfs_free_btrfsqgroup_list (struct
guestfs_btrfsqgroup_list *);

guestfs_btrfsbalance

struct guestfs_btrfsbalance { 
char *btrfsbalance_status; 
uint64_t btrfsbalance_total; 
uint64_t btrfsbalance_balanced; 
uint64_t btrfsbalance_considered; 
uint64_t btrfsbalance_left; 
}; 
struct guestfs_btrfsbalance_list { 
uint32_t len; /* Number of elements in list. */ 
struct guestfs_btrfsbalance *val; /* Elements. */ 
}; 
int guestfs_compare_btrfsbalance (const struct
guestfs_btrfsbalance *, const struct guestfs_btrfsbalance
*); 
int guestfs_compare_btrfsbalance_list (const struct
guestfs_btrfsbalance_list *, const struct
guestfs_btrfsbalance_list *); 
struct guestfs_btrfsbalance *guestfs_copy_btrfsbalance
(const struct guestfs_btrfsbalance *); 
struct guestfs_btrfsbalance_list
*guestfs_copy_btrfsbalance_list (const struct
guestfs_btrfsbalance_list *); 
void guestfs_free_btrfsbalance (struct guestfs_btrfsbalance
*); 
void guestfs_free_btrfsbalance_list (struct
guestfs_btrfsbalance_list *);

guestfs_btrfsscrub

struct guestfs_btrfsscrub { 
uint64_t btrfsscrub_data_extents_scrubbed; 
uint64_t btrfsscrub_tree_extents_scrubbed; 
uint64_t btrfsscrub_data_bytes_scrubbed; 
uint64_t btrfsscrub_tree_bytes_scrubbed; 
uint64_t btrfsscrub_read_errors; 
uint64_t btrfsscrub_csum_errors; 
uint64_t btrfsscrub_verify_errors; 
uint64_t btrfsscrub_no_csum; 
uint64_t btrfsscrub_csum_discards; 
uint64_t btrfsscrub_super_errors; 
uint64_t btrfsscrub_malloc_errors; 
uint64_t btrfsscrub_uncorrectable_errors; 
uint64_t btrfsscrub_unverified_errors; 
uint64_t btrfsscrub_corrected_errors; 
uint64_t btrfsscrub_last_physical; 
}; 
struct guestfs_btrfsscrub_list { 
uint32_t len; /* Number of elements in list. */ 
struct guestfs_btrfsscrub *val; /* Elements. */ 
}; 
int guestfs_compare_btrfsscrub (const struct
guestfs_btrfsscrub *, const struct guestfs_btrfsscrub *);

int guestfs_compare_btrfsscrub_list (const struct
guestfs_btrfsscrub_list *, const struct
guestfs_btrfsscrub_list *); 
struct guestfs_btrfsscrub *guestfs_copy_btrfsscrub (const
struct guestfs_btrfsscrub *); 
struct guestfs_btrfsscrub_list *guestfs_copy_btrfsscrub_list
(const struct guestfs_btrfsscrub_list *); 
void guestfs_free_btrfsscrub (struct guestfs_btrfsscrub *);

void guestfs_free_btrfsscrub_list (struct
guestfs_btrfsscrub_list *);

guestfs_xfsinfo

struct guestfs_xfsinfo { 
char *xfs_mntpoint; 
uint32_t xfs_inodesize; 
uint32_t xfs_agcount; 
uint32_t xfs_agsize; 
uint32_t xfs_sectsize; 
uint32_t xfs_attr; 
uint32_t xfs_blocksize; 
uint64_t xfs_datablocks; 
uint32_t xfs_imaxpct; 
uint32_t xfs_sunit; 
uint32_t xfs_swidth; 
uint32_t xfs_dirversion; 
uint32_t xfs_dirblocksize; 
uint32_t xfs_cimode; 
char *xfs_logname; 
uint32_t xfs_logblocksize; 
uint32_t xfs_logblocks; 
uint32_t xfs_logversion; 
uint32_t xfs_logsectsize; 
uint32_t xfs_logsunit; 
uint32_t xfs_lazycount; 
char *xfs_rtname; 
uint32_t xfs_rtextsize; 
uint64_t xfs_rtblocks; 
uint64_t xfs_rtextents; 
}; 
struct guestfs_xfsinfo_list { 
uint32_t len; /* Number of elements in list. */ 
struct guestfs_xfsinfo *val; /* Elements. */ 
}; 
int guestfs_compare_xfsinfo (const struct guestfs_xfsinfo *,
const struct guestfs_xfsinfo *); 
int guestfs_compare_xfsinfo_list (const struct
guestfs_xfsinfo_list *, const struct guestfs_xfsinfo_list
*); 
struct guestfs_xfsinfo *guestfs_copy_xfsinfo (const struct
guestfs_xfsinfo *); 
struct guestfs_xfsinfo_list *guestfs_copy_xfsinfo_list
(const struct guestfs_xfsinfo_list *); 
void guestfs_free_xfsinfo (struct guestfs_xfsinfo *); 
void guestfs_free_xfsinfo_list (struct guestfs_xfsinfo_list
*);

guestfs_utsname

struct guestfs_utsname { 
char *uts_sysname; 
char *uts_release; 
char *uts_version; 
char *uts_machine; 
}; 
struct guestfs_utsname_list { 
uint32_t len; /* Number of elements in list. */ 
struct guestfs_utsname *val; /* Elements. */ 
}; 
int guestfs_compare_utsname (const struct guestfs_utsname *,
const struct guestfs_utsname *); 
int guestfs_compare_utsname_list (const struct
guestfs_utsname_list *, const struct guestfs_utsname_list
*); 
struct guestfs_utsname *guestfs_copy_utsname (const struct
guestfs_utsname *); 
struct guestfs_utsname_list *guestfs_copy_utsname_list
(const struct guestfs_utsname_list *); 
void guestfs_free_utsname (struct guestfs_utsname *); 
void guestfs_free_utsname_list (struct guestfs_utsname_list
*);

guestfs_hivex_node

struct guestfs_hivex_node { 
int64_t hivex_node_h; 
}; 
struct guestfs_hivex_node_list { 
uint32_t len; /* Number of elements in list. */ 
struct guestfs_hivex_node *val; /* Elements. */ 
}; 
int guestfs_compare_hivex_node (const struct
guestfs_hivex_node *, const struct guestfs_hivex_node *);

int guestfs_compare_hivex_node_list (const struct
guestfs_hivex_node_list *, const struct
guestfs_hivex_node_list *); 
struct guestfs_hivex_node *guestfs_copy_hivex_node (const
struct guestfs_hivex_node *); 
struct guestfs_hivex_node_list *guestfs_copy_hivex_node_list
(const struct guestfs_hivex_node_list *); 
void guestfs_free_hivex_node (struct guestfs_hivex_node *);

void guestfs_free_hivex_node_list (struct
guestfs_hivex_node_list *);

guestfs_hivex_value

struct guestfs_hivex_value { 
int64_t hivex_value_h; 
}; 
struct guestfs_hivex_value_list { 
uint32_t len; /* Number of elements in list. */ 
struct guestfs_hivex_value *val; /* Elements. */ 
}; 
int guestfs_compare_hivex_value (const struct
guestfs_hivex_value *, const struct guestfs_hivex_value *);

int guestfs_compare_hivex_value_list (const struct
guestfs_hivex_value_list *, const struct
guestfs_hivex_value_list *); 
struct guestfs_hivex_value *guestfs_copy_hivex_value (const
struct guestfs_hivex_value *); 
struct guestfs_hivex_value_list
*guestfs_copy_hivex_value_list (const struct
guestfs_hivex_value_list *); 
void guestfs_free_hivex_value (struct guestfs_hivex_value
*); 
void guestfs_free_hivex_value_list (struct
guestfs_hivex_value_list *);

guestfs_internal_mountable

struct guestfs_internal_mountable { 
int32_t im_type; 
char *im_device; 
char *im_volume; 
}; 
struct guestfs_internal_mountable_list { 
uint32_t len; /* Number of elements in list. */ 
struct guestfs_internal_mountable *val; /* Elements. */ 
}; 
int guestfs_compare_internal_mountable (const struct
guestfs_internal_mountable *, const struct
guestfs_internal_mountable *); 
int guestfs_compare_internal_mountable_list (const struct
guestfs_internal_mountable_list *, const struct
guestfs_internal_mountable_list *); 
struct guestfs_internal_mountable
*guestfs_copy_internal_mountable (const struct
guestfs_internal_mountable *); 
struct guestfs_internal_mountable_list
*guestfs_copy_internal_mountable_list (const struct
guestfs_internal_mountable_list *); 
void guestfs_free_internal_mountable (struct
guestfs_internal_mountable *); 
void guestfs_free_internal_mountable_list (struct
guestfs_internal_mountable_list *);

guestfs_tsk_dirent

struct guestfs_tsk_dirent { 
uint64_t tsk_inode; 
char tsk_type; 
int64_t tsk_size; 
char *tsk_name; 
uint32_t tsk_flags; 
int64_t tsk_atime_sec; 
int64_t tsk_atime_nsec; 
int64_t tsk_mtime_sec; 
int64_t tsk_mtime_nsec; 
int64_t tsk_ctime_sec; 
int64_t tsk_ctime_nsec; 
int64_t tsk_crtime_sec; 
int64_t tsk_crtime_nsec; 
int64_t tsk_nlink; 
char *tsk_link; 
int64_t tsk_spare1; 
}; 
struct guestfs_tsk_dirent_list { 
uint32_t len; /* Number of elements in list. */ 
struct guestfs_tsk_dirent *val; /* Elements. */ 
}; 
int guestfs_compare_tsk_dirent (const struct
guestfs_tsk_dirent *, const struct guestfs_tsk_dirent *);

int guestfs_compare_tsk_dirent_list (const struct
guestfs_tsk_dirent_list *, const struct
guestfs_tsk_dirent_list *); 
struct guestfs_tsk_dirent *guestfs_copy_tsk_dirent (const
struct guestfs_tsk_dirent *); 
struct guestfs_tsk_dirent_list *guestfs_copy_tsk_dirent_list
(const struct guestfs_tsk_dirent_list *); 
void guestfs_free_tsk_dirent (struct guestfs_tsk_dirent *);

void guestfs_free_tsk_dirent_list (struct
guestfs_tsk_dirent_list *);

guestfs_yara_detection

struct guestfs_yara_detection { 
char *yara_name; 
char *yara_rule; 
}; 
struct guestfs_yara_detection_list { 
uint32_t len; /* Number of elements in list. */ 
struct guestfs_yara_detection *val; /* Elements. */ 
}; 
int guestfs_compare_yara_detection (const struct
guestfs_yara_detection *, const struct
guestfs_yara_detection *); 
int guestfs_compare_yara_detection_list (const struct
guestfs_yara_detection_list *, const struct
guestfs_yara_detection_list *); 
struct guestfs_yara_detection *guestfs_copy_yara_detection
(const struct guestfs_yara_detection *); 
struct guestfs_yara_detection_list
*guestfs_copy_yara_detection_list (const struct
guestfs_yara_detection_list *); 
void guestfs_free_yara_detection (struct
guestfs_yara_detection *); 
void guestfs_free_yara_detection_list (struct
guestfs_yara_detection_list *);

AVAILABILITY

GROUPS OF
FUNCTIONALITY IN THE APPLIANCE 
Using "guestfs_available" you can test
availability of the following groups of functions. This test
queries the appliance to see if the appliance you are
currently using supports the functionality.

acl

The following functions:
"guestfs_acl_delete_def_file"
"guestfs_acl_get_file"
"guestfs_acl_set_file" 

blkdiscard

The following functions:
"guestfs_blkdiscard"

blkdiscardzeroes

The following functions:
"guestfs_blkdiscardzeroes"

btrfs

The following functions:
"guestfs_btrfs_balance_cancel"
"guestfs_btrfs_balance_pause"
"guestfs_btrfs_balance_resume"
"guestfs_btrfs_balance_status"
"guestfs_btrfs_device_add"
"guestfs_btrfs_device_delete"
"guestfs_btrfs_filesystem_balance"
"guestfs_btrfs_filesystem_defragment"
"guestfs_btrfs_filesystem_resize"
"guestfs_btrfs_filesystem_show"
"guestfs_btrfs_filesystem_sync"
"guestfs_btrfs_fsck"
"guestfs_btrfs_image"
"guestfs_btrfs_qgroup_assign"
"guestfs_btrfs_qgroup_create"
"guestfs_btrfs_qgroup_destroy"
"guestfs_btrfs_qgroup_limit"
"guestfs_btrfs_qgroup_remove"
"guestfs_btrfs_qgroup_show"
"guestfs_btrfs_quota_enable"
"guestfs_btrfs_quota_rescan"
"guestfs_btrfs_replace"
"guestfs_btrfs_rescue_chunk_recover"
"guestfs_btrfs_rescue_super_recover"
"guestfs_btrfs_scrub_cancel"
"guestfs_btrfs_scrub_resume"
"guestfs_btrfs_scrub_start"
"guestfs_btrfs_scrub_status"
"guestfs_btrfs_set_seeding"
"guestfs_btrfs_subvolume_create"
"guestfs_btrfs_subvolume_delete"
"guestfs_btrfs_subvolume_get_default"
"guestfs_btrfs_subvolume_list"
"guestfs_btrfs_subvolume_set_default"
"guestfs_btrfs_subvolume_show"
"guestfs_btrfs_subvolume_snapshot"
"guestfs_btrfstune_enable_extended_inode_refs"
"guestfs_btrfstune_enable_skinny_metadata_extent_refs"
"guestfs_btrfstune_seeding"
"guestfs_mkfs_btrfs"

clevisluks

The following functions:
"guestfs_clevis_luks_unlock"

extlinux

The following functions:
"guestfs_extlinux"

f2fs

The following functions:
"guestfs_f2fs_expand"

fstrim

The following functions:
"guestfs_fstrim"

gdisk

The following functions:
"guestfs_part_expand_gpt"
"guestfs_part_get_disk_guid"
"guestfs_part_get_gpt_attributes"
"guestfs_part_get_gpt_guid"
"guestfs_part_get_gpt_type"
"guestfs_part_set_disk_guid"
"guestfs_part_set_disk_guid_random"
"guestfs_part_set_gpt_attributes"
"guestfs_part_set_gpt_guid"
"guestfs_part_set_gpt_type"

grub

The following functions:
"guestfs_grub_install"

hivex

The following functions:
"guestfs_hivex_close"
"guestfs_hivex_commit"
"guestfs_hivex_node_add_child"
"guestfs_hivex_node_children"
"guestfs_hivex_node_delete_child"
"guestfs_hivex_node_get_child"
"guestfs_hivex_node_get_value"
"guestfs_hivex_node_name"
"guestfs_hivex_node_parent"
"guestfs_hivex_node_set_value"
"guestfs_hivex_node_values"
"guestfs_hivex_open"
"guestfs_hivex_root"
"guestfs_hivex_value_key"
"guestfs_hivex_value_string"
"guestfs_hivex_value_type"
"guestfs_hivex_value_utf8"
"guestfs_hivex_value_value"

inotify

The following functions:
"guestfs_inotify_add_watch"
"guestfs_inotify_close"
"guestfs_inotify_files"
"guestfs_inotify_init"
"guestfs_inotify_read"
"guestfs_inotify_rm_watch"

journal

The following functions:
"guestfs_internal_journal_get"
"guestfs_journal_close"
"guestfs_journal_get_data_threshold"
"guestfs_journal_get_realtime_usec"
"guestfs_journal_next"
"guestfs_journal_open"
"guestfs_journal_set_data_threshold"
"guestfs_journal_skip"

ldm

The following functions:
"guestfs_ldmtool_create_all"
"guestfs_ldmtool_diskgroup_disks"
"guestfs_ldmtool_diskgroup_name"
"guestfs_ldmtool_diskgroup_volumes"
"guestfs_ldmtool_remove_all"
"guestfs_ldmtool_scan"
"guestfs_ldmtool_scan_devices"
"guestfs_ldmtool_volume_hint"
"guestfs_ldmtool_volume_partitions"
"guestfs_ldmtool_volume_type"
"guestfs_list_ldm_partitions"
"guestfs_list_ldm_volumes" 

libtsk

The following functions:
"guestfs_internal_filesystem_walk"
"guestfs_internal_find_inode"

libyara

The following functions:
"guestfs_internal_yara_scan"
"guestfs_yara_destroy"
"guestfs_yara_load"

linuxcaps

The following functions:
"guestfs_cap_get_file"
"guestfs_cap_set_file"

linuxfsuuid

The following functions:
"guestfs_mke2fs_JU"
"guestfs_mke2journal_U"
"guestfs_mkswap_U"
"guestfs_swapoff_uuid"
"guestfs_swapon_uuid"

linuxmodules

The following functions:
"guestfs_modprobe"

linuxxattrs

The following functions:
"guestfs_getxattr" "guestfs_getxattrs"
"guestfs_internal_lxattrlist"
"guestfs_lgetxattr" "guestfs_lgetxattrs"
"guestfs_lremovexattr"
"guestfs_lsetxattr"
"guestfs_removexattr"
"guestfs_setxattr"

luks

The following functions:
"guestfs_cryptsetup_close"
"guestfs_cryptsetup_open"
"guestfs_luks_add_key"
"guestfs_luks_close"
"guestfs_luks_format"
"guestfs_luks_format_cipher"
"guestfs_luks_kill_slot"
"guestfs_luks_open"
"guestfs_luks_open_ro"
"guestfs_luks_uuid"

lvm2

The following functions:
"guestfs_lvcreate"
"guestfs_lvcreate_free"
"guestfs_lvm_remove_all"
"guestfs_lvm_set_filter"
"guestfs_lvremove" "guestfs_lvresize"
"guestfs_lvresize_free" "guestfs_lvs"
"guestfs_lvs_full"
"guestfs_pvchange_uuid"
"guestfs_pvchange_uuid_all"
"guestfs_pvcreate" "guestfs_pvremove"
"guestfs_pvresize"
"guestfs_pvresize_size" "guestfs_pvs"
"guestfs_pvs_full" "guestfs_vg_activate"
"guestfs_vg_activate_all"
"guestfs_vgchange_uuid"
"guestfs_vgchange_uuid_all"
"guestfs_vgcreate" "guestfs_vgmeta"
"guestfs_vgremove" "guestfs_vgs"
"guestfs_vgs_full"

mdadm

The following functions:
"guestfs_md_create" "guestfs_md_detail"
"guestfs_md_stat" "guestfs_md_stop"

mknod

The following functions:
"guestfs_mkfifo" "guestfs_mknod"
"guestfs_mknod_b" "guestfs_mknod_c"

ntfs3g

The following functions:
"guestfs_ntfs_3g_probe"
"guestfs_ntfsclone_in"
"guestfs_ntfsclone_out"
"guestfs_ntfsfix"

ntfsprogs

The following functions:
"guestfs_ntfsresize"
"guestfs_ntfsresize_size"

rsync

The following functions:
"guestfs_rsync" "guestfs_rsync_in"
"guestfs_rsync_out"

scrub

The following functions:
"guestfs_scrub_device"
"guestfs_scrub_file"
"guestfs_scrub_freespace"

selinux

The following functions:
"guestfs_getcon" "guestfs_setcon"

selinuxrelabel

The following functions:
"guestfs_selinux_relabel"

sleuthkit

The following functions:
"guestfs_download_blocks"
"guestfs_download_inode"

squashfs

The following functions:
"guestfs_mksquashfs"

syslinux

The following functions:
"guestfs_syslinux"

wipefs

The following functions:
"guestfs_wipefs"

xfs

The following functions: "guestfs_xfs_admin"
"guestfs_xfs_growfs" "guestfs_xfs_info"
"guestfs_xfs_repair" 

xz

The following functions: "guestfs_txz_in"
"guestfs_txz_out" 

zerofree

The following functions:
"guestfs_zerofree"

FILESYSTEM
AVAILABLE 
The "guestfs_filesystem_available" call tests
whether a filesystem type is supported by the appliance
kernel.

This is mainly
useful as a negative test. If this returns true, it
doesn&rsquo;t mean that a particular filesystem can be
mounted, since filesystems can fail for other reasons such
as it being a later version of the filesystem, or having
incompatible features.

GUESTFISH
supported COMMAND 
In guestfish(3) there is a handy interactive command
"supported" which prints out the available groups
and whether they are supported by this build of libguestfs.
Note however that you have to do "run" first.

SINGLE CALLS
AT COMPILE TIME 
Since version 1.5.8, "" defines
symbols for each C API function, such as:

#define
GUESTFS_HAVE_DD 1

if
"guestfs_dd" is available.

Before version
1.5.8, if you needed to test whether a single libguestfs
function is available at compile time, we recommended using
build tools such as autoconf or cmake. For example in
autotools you could use:

AC_CHECK_LIB([guestfs],[guestfs_create])

AC_CHECK_FUNCS([guestfs_dd])

which would
result in "HAVE_GUESTFS_DD" being either defined
or not defined in your program.

SINGLE CALLS
AT RUN TIME 
Testing at compile time doesn&rsquo;t guarantee that a
function really exists in the library. The reason is that
you might be dynamically linked against a previous
libguestfs.so (dynamic library) which doesn&rsquo;t
have the call. This situation unfortunately results in a
segmentation fault, which is a shortcoming of the C dynamic
linking system itself.

You can use
dlopen(3) to test if a function is available at run
time, as in this example program (note that you still need
the compile time check as well):

#include

#include  
#include  
#include  
#include  
main () 
{ 
#ifdef GUESTFS_HAVE_DD 
void *dl; 
int has_function; 
/* Test if the function guestfs_dd is really available. */

dl = dlopen (NULL, RTLD_LAZY); 
if (!dl) { 
fprintf (stderr, "dlopen: %s\n", dlerror ()); 
exit (EXIT_FAILURE); 
} 
has_function = dlsym (dl, "guestfs_dd") != NULL;

dlclose (dl); 
if (!has_function) 
printf ("this libguestfs.so does NOT have guestfs_dd
function\n"); 
else { 
printf ("this libguestfs.so has guestfs_dd
function\n"); 
/* Now it's safe to call 
guestfs_dd (g, "foo", "bar"); 
*/ 
} 
#else 
printf ("guestfs_dd function was not found at compile
time\n"); 
#endif 
}

You may think
the above is an awful lot of hassle, and it is. There are
other ways outside of the C linking system to ensure that
this kind of incompatibility never arises, such as using
package versioning:

Requires:
libguestfs >= 1.0.80

CALLS WITH OPTIONAL ARGUMENTS

A recent
feature of the API is the introduction of calls which take
optional arguments. In C these are declared 3 ways. The main
way is as a call which takes variable arguments (ie.
"..."), as in this example:

int
guestfs_add_drive_opts (guestfs_h *g, const char *filename,
...);

Call this with
a list of optional arguments, terminated by -1. So to call
with no optional arguments specified:

guestfs_add_drive_opts
(g, filename, -1);

With a single
optional argument:

guestfs_add_drive_opts
(g, filename, 
GUESTFS_ADD_DRIVE_OPTS_FORMAT, "qcow2", 
-1);

With two:

guestfs_add_drive_opts
(g, filename, 
GUESTFS_ADD_DRIVE_OPTS_FORMAT, "qcow2", 
GUESTFS_ADD_DRIVE_OPTS_READONLY, 1, 
-1);

and so forth.
Don&rsquo;t forget the terminating -1 otherwise Bad Things
will happen!

USING
va_list FOR OPTIONAL ARGUMENTS 
The second variant has the same name with the suffix
"_va", which works the same way but takes a
"va_list". See the C manual for details. For the
example function, this is declared:

int
guestfs_add_drive_opts_va (guestfs_h *g, const char
*filename, 
va_list args);

CONSTRUCTING
OPTIONAL ARGUMENTS 
The third variant is useful where you need to construct
these calls. You pass in a structure where you fill in the
optional fields. The structure has a bitmask as the first
element which you must set to indicate which fields you have
filled in. For our example function the structure and call
are declared:

struct
guestfs_add_drive_opts_argv { 
uint64_t bitmask; 
int readonly; 
const char *format; 
/* ... */ 
}; 
int guestfs_add_drive_opts_argv (guestfs_h *g, const char
*filename, 
const struct guestfs_add_drive_opts_argv *optargs);

You could call
it like this:

struct
guestfs_add_drive_opts_argv optargs = { 
.bitmask = GUESTFS_ADD_DRIVE_OPTS_READONLY_BITMASK | 
GUESTFS_ADD_DRIVE_OPTS_FORMAT_BITMASK, 
.readonly = 1, 
.format = "qcow2" 
}; 
guestfs_add_drive_opts_argv (g, filename, &optargs);

Notes:

&bull;

The "_BITMASK" suffix on each option name when
specifying the bitmask.

&bull;

You do not need to fill in all fields of the
structure. 

&bull;

There must be a one-to-one correspondence between fields
of the structure that are filled in, and bits set in the
bitmask. 

OPTIONAL
ARGUMENTS IN OTHER LANGUAGES 
In other languages, optional arguments are expressed in the
way that is natural for that language. We refer you to the
language-specific documentation for more details on
that.

For guestfish,
see "OPTIONAL ARGUMENTS" in
guestfish(1).

EVENTS

SETTING
CALLBACKS TO HANDLE EVENTS 
Note: This section documents the generic event mechanism
introduced in libguestfs 1.10, which you should use in new
code if possible. The old functions
"guestfs_set_log_message_callback",
"guestfs_set_subprocess_quit_callback",
"guestfs_set_launch_done_callback",
"guestfs_set_close_callback" and
"guestfs_set_progress_callback" are no longer
documented in this manual page. Because of the ABI
guarantee, the old functions continue to work.

Handles
generate events when certain things happen, such as log
messages being generated, progress messages during
long-running operations, or the handle being closed. The API
calls described below let you register a callback to be
called when events happen. You can register multiple
callbacks (for the same, different or overlapping sets of
events), and individually remove callbacks. If callbacks are
not removed, then they remain in force until the handle is
closed.

In the current
implementation, events are only generated synchronously:
that means that events (and hence callbacks) can only happen
while you are in the middle of making another libguestfs
call. The callback is called in the same thread.

Events may
contain a payload, usually nothing (void), an array of 64
bit unsigned integers, or a message buffer. Payloads are
discussed later on.

CLASSES OF
EVENTS 
GUESTFS_EVENT_CLOSE (payload type: void)

The callback function will be
called while the handle is being closed (synchronously from
"guestfs_close").

Note that
libguestfs installs an atexit(3) handler to try to
clean up handles that are open when the program exits. This
means that this callback might be called indirectly from
exit(3), which can cause unexpected problems in
higher-level languages (eg. if your HLL interpreter has
already been cleaned up by the time this is called, and if
your callback then jumps into some HLL function).

If no callback
is registered: the handle is closed without any callback
being invoked.

GUESTFS_EVENT_SUBPROCESS_QUIT
(payload type: void)

The callback function will be
called when the child process quits, either asynchronously
or if killed by "guestfs_kill_subprocess". (This
corresponds to a transition from any state to the CONFIG
state).

If no callback
is registered: the event is ignored.

GUESTFS_EVENT_LAUNCH_DONE
(payload type: void)

The callback function will be
called when the child process becomes ready first time after
it has been launched. (This corresponds to a transition from
LAUNCHING to the READY state).

If no callback
is registered: the event is ignored.

GUESTFS_EVENT_PROGRESS (payload
type: array of 4 x uint64_t)

Some long-running operations
can generate progress messages. If this callback is
registered, then it will be called each time a progress
message is generated (usually two seconds after the
operation started, and three times per second thereafter
until it completes, although the frequency may change in
future versions).

The callback
receives in the payload four unsigned 64 bit numbers which
are (in order): "proc_nr", "serial",
"position", "total".

The units of
"total" are not defined, although for some
operations "total" may relate in some way to the
amount of data to be transferred (eg. in bytes or
megabytes), and "position" may be the portion
which has been transferred.

The only
defined and stable parts of the API are:

&bull;

The callback can display to the user some type of
progress bar or indicator which shows the ratio of
"position":"total". 

&bull;

0 

&bull;

If any progress notification is sent during a call, then
a final progress notification is always sent when
"position" = "total" (unless the
call fails with an error).

This is to
simplify caller code, so callers can easily set the progress
indicator to "100%" at the end of the operation,
without requiring special code to detect this case.

&bull;

For some calls we are unable to
estimate the progress of the call, but we can still generate
progress messages to indicate activity. This is known as
"pulse mode", and is directly supported by certain
progress bar implementations (eg. GtkProgressBar).

For these
calls, zero or more progress messages are generated with
"position = 0" and "total = 1", followed
by a final message with "position = total =
1".

As noted above,
if the call fails with an error then the final message may
not be generated.

The callback
also receives the procedure number ("proc_nr") and
serial number ("serial") of the call. These are
only useful for debugging protocol issues, and the callback
can normally ignore them. The callback may want to print
these numbers in error messages or debugging messages.

If no callback
is registered: progress messages are discarded.

GUESTFS_EVENT_APPLIANCE
(payload type: message buffer)

The callback function is called
whenever a log message is generated by qemu, the appliance
kernel, guestfsd (daemon), or utility programs.

If the verbose
flag ("guestfs_set_verbose") is set before launch
("guestfs_launch") then additional debug messages
are generated.

If no callback
is registered: the messages are discarded unless the verbose
flag is set in which case they are sent to stderr. You can
override the printing of verbose messages to stderr by
setting up a callback.

GUESTFS_EVENT_LIBRARY (payload
type: message buffer)

The callback function is called
whenever a log message is generated by the library part of
libguestfs.

If the verbose
flag ("guestfs_set_verbose") is set then
additional debug messages are generated.

If no callback
is registered: the messages are discarded unless the verbose
flag is set in which case they are sent to stderr. You can
override the printing of verbose messages to stderr by
setting up a callback.

GUESTFS_EVENT_WARNING (payload
type: message buffer)

The callback function is called
whenever a warning message is generated by the library part
of libguestfs.

If no callback
is registered: the messages are printed to stderr. You can
override the printing of warning messages to stderr by
setting up a callback.

GUESTFS_EVENT_TRACE (payload
type: message buffer)

The callback function is called
whenever a trace message is generated. This only applies if
the trace flag ("guestfs_set_trace") is set.

If no callback
is registered: the messages are sent to stderr. You can
override the printing of trace messages to stderr by setting
up a callback.

GUESTFS_EVENT_ENTER (payload
type: function name)

The callback function is called
whenever a libguestfs function is entered.

The payload is
a string which contains the name of the function that we are
entering (not including "guestfs_" prefix).

Note that
libguestfs functions can call themselves, so you may see
many events from a single call. A few libguestfs functions
do not generate this event.

If no callback
is registered: the event is ignored.

GUESTFS_EVENT_LIBVIRT_AUTH
(payload type: libvirt URI)

For any API function that opens
a libvirt connection, this event may be generated to
indicate that libvirt demands authentication information.
See "LIBVIRT AUTHENTICATION" below.

If no callback
is registered: "virConnectAuthPtrDefault" is used
(suitable for command-line programs only).

EVENT
API 
guestfs_set_event_callback

int
guestfs_set_event_callback (guestfs_h *g, 
guestfs_event_callback cb, 
uint64_t event_bitmask, 
int flags, 
void *opaque);

This function
registers a callback ("cb") for all event classes
in the "event_bitmask".

For example, to
register for all log message events, you could call this
function with the bitmask
"GUESTFS_EVENT_APPLIANCE|GUESTFS_EVENT_LIBRARY|GUESTFS_EVENT_WARNING".
To register a single callback for all possible classes of
events, use "GUESTFS_EVENT_ALL".

"flags"
should always be passed as 0.

"opaque"
is an opaque pointer which is passed to the callback. You
can use it for any purpose.

The return
value is the event handle (an integer) which you can use to
delete the callback (see below).

If there is an
error, this function returns -1, and sets the error in the
handle in the usual way (see "guestfs_last_error"
etc.)

Callbacks
remain in effect until they are deleted, or until the handle
is closed.

In the case
where multiple callbacks are registered for a particular
event class, all of the callbacks are called. The order in
which multiple callbacks are called is not defined.

guestfs_delete_event_callback

void
guestfs_delete_event_callback (guestfs_h *g, int
event_handle);

Delete a
callback that was previously registered.
"event_handle" should be the integer that was
returned by a previous call to
"guestfs_set_event_callback" on the same
handle.

guestfs_event_to_string

char
*guestfs_event_to_string (uint64_t event);

"event"
is either a single event or a bitmask of events. This
returns a string representation (useful for debugging or
printing events).

A single event
is returned as the name in lower case, eg.
"close".

A bitmask of
several events is returned as a comma-separated list, eg.
"close,progress".

If zero is
passed, then the empty string "" is returned.

On success this
returns a string. On error it returns NULL and sets
"errno".

The returned
string must be freed by the caller.

guestfs_event_callback

typedef void
(*guestfs_event_callback) ( 
guestfs_h *g, 
void *opaque, 
uint64_t event, 
int event_handle, 
int flags, 
const char *buf, size_t buf_len, 
const uint64_t *array, size_t array_len);

This is the
type of the event callback function that you have to
provide.

The basic
parameters are: the handle ("g"), the opaque user
pointer ("opaque"), the event class (eg.
"GUESTFS_EVENT_PROGRESS"), the event handle, and
"flags" which in the current API you should
ignore.

The remaining
parameters contain the event payload (if any). Each event
may contain a payload, which usually relates to the event
class, but for future proofing your code should be written
to handle any payload for any event class.

"buf"
and "buf_len" contain a message buffer (if
"buf_len == 0", then there is no message buffer).
Note that this message buffer can contain arbitrary 8 bit
data, including NUL bytes.

"array"
and "array_len" is an array of 64 bit unsigned
integers. At the moment this is only used for progress
messages.

EXAMPLE:
CAPTURING LOG MESSAGES 
A working program demonstrating this can be found in
examples/debug-logging.c in the source of
libguestfs.

One motivation
for the generic event API was to allow GUI programs to
capture debug and other messages. In libguestfs &le; 1.8
these were sent unconditionally to "stderr".

Events
associated with log messages are:
"GUESTFS_EVENT_LIBRARY",
"GUESTFS_EVENT_APPLIANCE",
"GUESTFS_EVENT_WARNING" and
"GUESTFS_EVENT_TRACE". (Note that error messages
are not events; you must capture error messages
separately).

Programs have
to set up a callback to capture the classes of events of
interest:

int eh = 
guestfs_set_event_callback 
(g, message_callback, 
GUESTFS_EVENT_LIBRARY | GUESTFS_EVENT_APPLIANCE | 
GUESTFS_EVENT_WARNING | GUESTFS_EVENT_TRACE, 
0, NULL) == -1) 
if (eh == -1) { 
// handle error in the usual way 
}

The callback
can then direct messages to the appropriate place. In this
example, messages are directed to syslog:

static void

message_callback ( 
guestfs_h *g, 
void *opaque, 
uint64_t event, 
int event_handle, 
int flags, 
const char *buf, size_t buf_len, 
const uint64_t *array, size_t array_len) 
{ 
const int priority = LOG_USER|LOG_INFO; 
if (buf_len > 0) 
syslog (priority, "event 0x%lx: %s", event, buf);

}

LIBVIRT
AUTHENTICATION 
Some libguestfs API calls can open libvirt connections.
Currently the only ones are "guestfs_add_domain";
and "guestfs_launch" if the libvirt backend has
been selected. Libvirt connections may require
authentication, for example if they need to access a remote
server or to access root services from non-root. Libvirt
authentication happens via a callback mechanism, see
http://libvirt.org/guide/html/Application_Development_Guide-Connections.html

You may provide
libvirt authentication data by registering a callback for
events of type "GUESTFS_EVENT_LIBVIRT_AUTH".

If no such
event is registered, then libguestfs uses a libvirt function
that provides command-line prompts
("virConnectAuthPtrDefault"). This is only
suitable for command-line libguestfs programs.

To provide
authentication, first call
"guestfs_set_libvirt_supported_credentials" with
the list of credentials your program knows how to provide.
Second, register a callback for the
"GUESTFS_EVENT_LIBVIRT_AUTH" event. The event
handler will be called when libvirt is requesting
authentication information.

In the event
handler, call
"guestfs_get_libvirt_requested_credentials" to get
a list of the credentials that libvirt is asking for. You
then need to ask (eg. the user) for each credential, and
call "guestfs_set_libvirt_requested_credential"
with the answer. Note that for each credential, additional
information may be available via the calls
"guestfs_get_libvirt_requested_credential_prompt",
"guestfs_get_libvirt_requested_credential_challenge"
or
"guestfs_get_libvirt_requested_credential_defresult".

The example
program below should make this clearer.

There is also a
more substantial working example program supplied with the
libguestfs sources, called libvirt-auth.c.

main () 
{ 
guestfs_h *g; 
char *creds[] = { "authname",
"passphrase", NULL }; 
int r, eh; 
g = guestfs_create (); 
if (!g) exit (EXIT_FAILURE); 
/* Tell libvirt what credentials the program supports. */

r = guestfs_set_libvirt_supported_credentials (g, creds);

if (r == -1) 
exit (EXIT_FAILURE); 
/* Set up the event handler. */ 
eh = guestfs_set_event_callback ( 
g, do_auth, 
GUESTFS_EVENT_LIBVIRT_AUTH, 0, NULL); 
if (eh == -1) 
exit (EXIT_FAILURE); 
/* An example of a call that may ask for credentials. */

r = guestfs_add_domain ( 
g, "dom", 
GUESTFS_ADD_DOMAIN_LIBVIRTURI, "qemu:///system&quot;,

-1); 
if (r == -1) 
exit (EXIT_FAILURE); 
exit (EXIT_SUCCESS); 
} 
static void 
do_auth (guestfs_h *g, 
void *opaque, 
uint64_t event, 
int event_handle, 
int flags, 
const char *buf, size_t buf_len, 
const uint64_t *array, size_t array_len) 
{ 
char **creds; 
size_t i; 
char *prompt; 
char *reply; 
size_t replylen; 
int r; 
// buf will be the libvirt URI. buf_len may be ignored. 
printf ("Authentication required for libvirt conn
'%s'\n", 
buf); 
// Ask libguestfs what credentials libvirt is demanding.

creds = guestfs_get_libvirt_requested_credentials (g); 
if (creds == NULL) 
exit (EXIT_FAILURE); 
// Now ask the user for answers. 
for (i = 0; creds[i] != NULL; ++i) 
{ 
if (strcmp (creds[i], "authname") == 0 || 
strcmp (creds[i], "passphrase") == 0) 
{ 
prompt = 
guestfs_get_libvirt_requested_credential_prompt (g, i); 
if (prompt && strcmp (prompt, "") != 0)

printf ("%s: ", prompt); 
free (prompt); 
// Some code here to ask for the credential. 
// ... 
// Put the reply in 'reply', length 'replylen' (bytes). 
r = guestfs_set_libvirt_requested_credential (g, i, 
reply, replylen); 
if (r == -1) 
exit (EXIT_FAILURE); 
} 
free (creds[i]); 
} 
free (creds); 
}

CANCELLING LONG TRANSFERS

Some operations
can be cancelled by the caller while they are in progress.
Currently only operations that involve uploading or
downloading data can be cancelled (technically: operations
that have "FileIn" or "FileOut"
parameters in the generator).

To cancel the
transfer, call "guestfs_user_cancel". For more
information, read the description of
"guestfs_user_cancel".

PRIVATE DATA AREA

You can attach
named pieces of private data to the libguestfs handle, fetch
them by name, and walk over them, for the lifetime of the
handle. This is called the private data area and is only
available from the C API.

To attach a
named piece of data, use the following call:

void
guestfs_set_private (guestfs_h *g, const char *key, void
*data);

"key"
is the name to associate with this data, and
"data" is an arbitrary pointer (which can be
"NULL"). Any previous item with the same key is
overwritten.

You can use any
"key" string you want, but avoid keys beginning
with an underscore character (libguestfs uses those for its
own internal purposes, such as implementing language
bindings). It is recommended that you prefix the key with
some unique string to avoid collisions with other users.

To retrieve the
pointer, use:

void
*guestfs_get_private (guestfs_h *g, const char *key);

This function
returns "NULL" if either no data is found
associated with "key", or if the user previously
set the "key"&rsquo;s "data" pointer to
"NULL".

Libguestfs does
not try to look at or interpret the "data" pointer
in any way. As far as libguestfs is concerned, it need not
be a valid pointer at all. In particular, libguestfs does
not try to free the data when the handle is closed.
If the data must be freed, then the caller must either free
it before calling "guestfs_close" or must set up a
close callback to do it (see
"GUESTFS_EVENT_CLOSE").

To walk over
all entries, use these two functions:

void
*guestfs_first_private (guestfs_h *g, const char **key_rtn);

void *guestfs_next_private (guestfs_h *g, const char
**key_rtn);

"guestfs_first_private"
returns the first key, pointer pair ("first" does
not have any particular meaning -- keys are not returned in
any defined order). A pointer to the key is returned in
*key_rtn and the corresponding data pointer is returned from
the function. "NULL" is returned if there are no
keys stored in the handle.

"guestfs_next_private"
returns the next key, pointer pair. The return value of this
function is "NULL" if there are no further entries
to return.

Notes about
walking over entries:

&bull;

You must not call "guestfs_set_private" while
walking over the entries.

&bull;

The handle maintains an internal iterator which is reset
when you call "guestfs_first_private". This
internal iterator is invalidated when you call
"guestfs_set_private". 

&bull;

If you have set the data pointer associated with a key
to "NULL", ie:

guestfs_set_private
(g, key, NULL);

then that
"key" is not returned when walking.

&bull;

*key_rtn is only valid until the
next call to "guestfs_first_private",
"guestfs_next_private" or
"guestfs_set_private". 

The following
example code shows how to print all keys and data pointers
that are associated with the handle "g":

const char
*key; 
void *data = guestfs_first_private (g, &key); 
while (data != NULL) 
{ 
printf ("key = %s, data = %p\n", key, data); 
data = guestfs_next_private (g, &key); 
}

More commonly
you are only interested in keys that begin with an
application-specific prefix "foo_". Modify the
loop like so:

const char
*key; 
void *data = guestfs_first_private (g, &key); 
while (data != NULL) 
{ 
if (strncmp (key, "foo_", strlen
("foo_")) == 0) 
printf ("key = %s, data = %p\n", key, data); 
data = guestfs_next_private (g, &key); 
}

If you need to
modify keys while walking, then you have to jump back to the
beginning of the loop. For example, to delete all keys
prefixed with "foo_":

const char
*key; 
void *data; 
again: 
data = guestfs_first_private (g, &key); 
while (data != NULL) 
{ 
if (strncmp (key, "foo_", strlen
("foo_")) == 0) 
{ 
guestfs_set_private (g, key, NULL); 
/* note that 'key' pointer is now invalid, and so is 
the internal iterator */ 
goto again; 
} 
data = guestfs_next_private (g, &key); 
}

Note that the
above loop is guaranteed to terminate because the keys are
being deleted, but other manipulations of keys within the
loop might not terminate unless you also maintain an
indication of which keys have been visited.

LIBGUESTFS VERSION NUMBERS

Since April
2010, libguestfs has started to make separate development
and stable releases, along with corresponding branches in
our git repository. These separate releases can be
identified by version number:

even numbers
for stable: 1.2.x, 1.4.x, ... 
.-------- odd numbers for development: 1.3.x, 1.5.x, ...

| 
v 
1 . 3 . 5 
^ ^ 
| | 
| `-------- sub-version 
| 
`------ always '1' because we don't change the ABI

Thus
"1.3.5" is the 5th update to the development
branch "1.3".

As time passes
we cherry pick fixes from the development branch and
backport those into the stable branch, the effect being that
the stable branch should get more stable and less buggy over
time. So the stable releases are ideal for people who
don&rsquo;t need new features but would just like the
software to work.

Our criteria
for backporting changes are:

&bull;

Documentation changes which
don&rsquo;t affect any code are backported unless the
documentation refers to a future feature which is not in
stable. 

&bull;

Bug fixes which are not controversial, fix obvious
problems, and have been well tested are backported.

&bull;

Simple rearrangements of code which shouldn&rsquo;t
affect how it works get backported. This is so that the code
in the two branches doesn&rsquo;t get too far out of step,
allowing us to backport future fixes more easily.

&bull;

We don&rsquo;t backport new features, new APIs,
new tools etc, except in one exceptional case: the new
feature is required in order to implement an important bug
fix. 

A new stable
branch starts when we think the new features in development
are substantial and compelling enough over the current
stable branch to warrant it. When that happens we create new
stable and development versions 1.N.0 and 1.(N+1).0 [N is
even]. The new dot-oh release won&rsquo;t necessarily be so
stable at this point, but by backporting fixes from
development, that branch will stabilize over time.

LIMITS

PROTOCOL
LIMITS 
Internally libguestfs uses a message-based protocol to pass
API calls and their responses to and from a small
"appliance" (see guestfs-internals(1) for
plenty more detail about this). The maximum message size
used by the protocol is slightly less than 4 MB. For some
API calls you may need to be aware of this limit. The API
calls which may be affected are individually documented,
with a link back to this section of the documentation.

In libguestfs

"guestfs_cat",
"guestfs_find", "guestfs_read_file",
"guestfs_read_lines", "guestfs_write",
"guestfs_write_append",
"guestfs_lstatlist",
"guestfs_lxattrlist",
"guestfs_readlinklist",
"guestfs_ls".

See also
"UPLOADING" and "DOWNLOADING" for
further information about copying large amounts of data into
or out of a filesystem.

MAXIMUM
NUMBER OF DISKS 
In libguestfs &ge; 1.19.7, you can query the maximum number
of disks that may be added by calling
"guestfs_max_disks". In earlier versions of
libguestfs (ie. where this call is not available) you should
assume the maximum is 25.

The rest of
this section covers implementation details, which could
change in future.

When using
virtio-scsi disks (the default if available in qemu) the
current limit is 255 disks. When using virtio-blk
(the old default) the limit is around 27 disks, but
may vary according to implementation details and whether the
network is enabled.

Virtio-scsi as
used by libguestfs is configured to use one target per disk,
and 256 targets are available.

Virtio-blk
consumes 1 virtual PCI slot per disk, and PCI is limited to
31 slots, but some of these are used for other purposes.

One virtual
disk is used by libguestfs internally.

Before
libguestfs 1.19.7, disk names had to be a single character
(eg. /dev/sda through /dev/sdz), and since one
disk is reserved, that meant the limit was 25. This has been
fixed in more recent versions.

MAXIMUM
NUMBER OF PARTITIONS PER DISK 
Virtio limits the maximum number of partitions per disk to
15.

This is because
it reserves 4 bits for the minor device number (thus
/dev/vda, and /dev/vda1 through
/dev/vda15).

If you attach a
disk with more than 15 partitions, the extra partitions are
ignored by libguestfs.

MAXIMUM SIZE
OF A DISK 
Probably the limit is between 2**63-1 and 2**64-1 bytes.

We have tested
block devices up to 1 exabyte (2**60 or
1,152,921,504,606,846,976 bytes) using sparse files backed
by an XFS host filesystem.

Although
libguestfs probably does not impose any limit, the
underlying host storage will. If you store disk images on a
host ext4 filesystem, then the maximum size will be limited
by the maximum ext4 file size (currently 16 TB). If you
store disk images as host logical volumes then you are
limited by the maximum size of an LV.

For the hugest
disk image files, we recommend using XFS on the host for
storage.

MAXIMUM SIZE
OF A PARTITION 
The MBR (ie. classic MS-DOS) partitioning scheme uses 32 bit
sector numbers. Assuming a 512 byte sector size, this means
that MBR cannot address a partition located beyond 2 TB on
the disk.

It is
recommended that you use GPT partitions on disks which are
larger than this size. GPT uses 64 bit sector numbers and so
can address partitions which are theoretically larger than
the largest disk we could support.

MAXIMUM SIZE
OF A FILESYSTEM, FILES, DIRECTORIES 
This depends on the filesystem type. libguestfs itself does
not impose any known limit. Consult Wikipedia or the
filesystem documentation to find out what these limits
are.

MAXIMUM
UPLOAD AND DOWNLOAD 
The API functions "guestfs_upload",
"guestfs_download", "guestfs_tar_in",
"guestfs_tar_out" and the like allow unlimited
sized uploads and downloads.

INSPECTION
LIMITS 
The inspection code has several arbitrary limits on things
like the size of Windows Registry hive it will read, and the
length of product name. These are intended to stop a
malicious guest from consuming arbitrary amounts of memory
and disk space on the host, and should not be reached in
practice. See the source code for more information.

ADVANCED MACHINE READABLE OUTPUT

Some of the
tools support a --machine-readable option, which is
generally used to make the output more machine friendly, for
easier parsing for example. By default, this output goes to
stdout.

When using the
--machine-readable option, the progress, information,
warning, and error messages are also printed in JSON format
for easier log tracking. Thus, it is highly recommended to
redirect the machine-readable output to a different stream.
The format of these JSON messages is like the following
(actually printed within a single line, below it is indented
for readability):

{ 
"message": "Finishing off", 
"timestamp":
"2019-03-22T14:46:49.067294446+01:00", 
"type": "message" 
}

"type"
can be: "message" for progress messages,
"info" for information messages,
"warning" for warning messages, and
"error" for error message. "timestamp"
is the RFC 3339 timestamp of the message.

In addition to
that, a subset of these tools support an extra string passed
to the --machine-readable option: this string
specifies where the machine-readable output will go.

The possible
values are: 
fd:fd

The output goes to the
specified fd, which is a file descriptor already
opened for writing.

file:filename

The output goes to the
specified filename.

stream:stdout

The output goes to stdout. This
is basically the same as the default behaviour of
--machine-readable with no parameter, although stdout
as output is specified explicitly.

stream:stderr

The output goes to stderr.

ENVIRONMENT VARIABLES

LIBGUESTFS_APPEND

Pass additional options to the
guest kernel.

LIBGUESTFS_ATTACH_METHOD

This is the old way to set
"LIBGUESTFS_BACKEND".

LIBGUESTFS_BACKEND

Choose the default way to
create the appliance. See "guestfs_set_backend"
and "BACKEND".

LIBGUESTFS_BACKEND_SETTINGS

A colon-separated list of
backend-specific settings. See "BACKEND",
"BACKEND SETTINGS".

LIBGUESTFS_CACHEDIR

The location where libguestfs
will cache its appliance, when using a supermin appliance.
The appliance is cached and shared between all handles which
have the same effective user ID.

If
"LIBGUESTFS_CACHEDIR" is not set, then
"TMPDIR" is used. If "TMPDIR" is not
set, then /var/tmp is used.

See also
"LIBGUESTFS_TMPDIR",
"guestfs_set_cachedir".

LIBGUESTFS_DEBUG

Set
"LIBGUESTFS_DEBUG=1" to enable verbose messages.
This has the same effect as calling
"guestfs_set_verbose (g, 1)".

LIBGUESTFS_HV

Set the default hypervisor
(usually qemu) binary that libguestfs uses. If not set, then
the qemu which was found at compile time by the configure
script is used.

See also
"QEMU WRAPPERS" above.

LIBGUESTFS_MEMSIZE

Set the memory allocated to the
qemu process, in megabytes. For example:

LIBGUESTFS_MEMSIZE=700

LIBGUESTFS_PATH

Set the path that libguestfs
uses to search for a supermin appliance. See the discussion
of paths in section "PATH" above.

LIBGUESTFS_QEMU

This is the old way to set
"LIBGUESTFS_HV".

LIBGUESTFS_TMPDIR

The location where libguestfs
will store temporary files used by each handle.

If
"LIBGUESTFS_TMPDIR" is not set, then
"TMPDIR" is used. If "TMPDIR" is not
set, then /tmp is used.

See also
"LIBGUESTFS_CACHEDIR",
"guestfs_set_tmpdir".

LIBGUESTFS_TRACE

Set
"LIBGUESTFS_TRACE=1" to enable command traces.
This has the same effect as calling "guestfs_set_trace
(g, 1)".

PATH

Libguestfs may run some
external programs, and relies on $PATH being set to a
reasonable value. If using the libvirt backend, libvirt will
not work at all unless $PATH contains the path of qemu/KVM.
Note that PHP by default removes $PATH from the environment
which tends to break everything.

SUPERMIN_KERNEL 
SUPERMIN_KERNEL_VERSION 
SUPERMIN_MODULES

These three environment
variables allow the kernel that libguestfs uses in the
appliance to be selected. If $SUPERMIN_KERNEL is not set,
then the most recent host kernel is chosen. For more
information about kernel selection, see
supermin(1).

TMPDIR

See
"LIBGUESTFS_CACHEDIR",
"LIBGUESTFS_TMPDIR".

XDG_RUNTIME_DIR

This directory represents a
user-specific directory for storing non-essential runtime
files.

If it is set,
then is used to store temporary sockets and PID files.
Otherwise, /tmp is used.

See also
"guestfs_get_sockdir",
http://www.freedesktop.org/wiki/Specifications/basedir-spec/.

SEE ALSO

Examples
written in C: guestfs-examples(3).

Language
bindings: guestfs-erlang(3),
guestfs-gobject(3), guestfs-golang(3),
guestfs-java(3), guestfs-lua(3),
guestfs-ocaml(3), guestfs-perl(3),
guestfs-python(3), guestfs-ruby(3).

Tools:
guestfish(1), guestmount(1),
virt-alignment-scan(1), virt-builder(1),
virt-builder-repository(1), virt-cat(1),
virt-copy-in(1), virt-copy-out(1),
virt-customize(1), virt-df(1),
virt-diff(1), virt-edit(1),
virt-filesystems(1), virt-format(1),
virt-inspector(1), virt-list-filesystems(1),
virt-list-partitions(1), virt-log(1),
virt-ls(1), virt-make-fs(1),
virt-p2v(1), virt-rescue(1),
virt-resize(1), virt-sparsify(1),
virt-sysprep(1), virt-tail(1),
virt-tar(1), virt-tar-in(1),
virt-tar-out(1), virt-v2v(1),
virt-win-reg(1).

Other
libguestfs topics: guestfs-building(1),
guestfs-faq(1), guestfs-hacking(1),
guestfs-internals(1), guestfs-performance(1),
guestfs-release-notes(1), guestfs-security(1),
guestfs-testing(1), libguestfs-test-tool(1),
libguestfs-make-fixed-appliance(1).

Related manual
pages: supermin(1), qemu(1), hivex(3),
stap(1), sd-journal(3).

Website:
http://libguestfs.org/

Tools with a
similar purpose: fdisk(8), parted(8),
kpartx(8), lvm(8), disktype(1).

AUTHORS

Richard W.M.
Jones ("rjones at redhat dot com")

COPYRIGHT

Copyright (C)
2009-2023 Red Hat Inc.

LICENSE

This library is
free software; you can redistribute it and/or modify it
under the terms of the GNU Lesser General Public License as
published by the Free Software Foundation; either version 2
of the License, or (at your option) any later version.

This library is
distributed in the hope that it will be useful, but WITHOUT
ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
GNU Lesser General Public License for more details.

You should have
received a copy of the GNU Lesser General Public License
along with this library; if not, write to the Free Software
Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
MA 02110-1301 USA

BUGS

To get a list
of bugs against libguestfs, use this link:
https://bugzilla.redhat.com/buglist.cgi?component=libguestfs&product=Virtualization+Tools

To report a new
bug against libguestfs, use this link:
https://bugzilla.redhat.com/enter_bug.cgi?component=libguestfs&product=Virtualization+Tools

When reporting
a bug, please supply:

&bull;

The version of libguestfs.

&bull;

Where you got libguestfs (eg. which Linux distro,
compiled from source, etc)

&bull;

Describe the bug accurately and give a way to reproduce
it. 

&bull;

Run libguestfs-test-tool(1) and paste the
complete, unedited output into the bug report.