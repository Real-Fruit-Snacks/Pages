IF_BRIDGE(4) BSD Kernel Interfaces Manual
IF_BRIDGE(4)

NAME

if_bridge &mdash; network
bridge device

SYNOPSIS

To compile this driver into the
kernel, place the following line in your kernel
configuration file:

device
if_bridge

Alternatively,
to load the driver as a module at boot time, place the
following lines in loader.conf(5):

if_bridge_load="YES"

bridgestp_load="YES"

DESCRIPTION

The if_bridge driver
creates a logical link between two or more IEEE 802 networks
that use the same (or &rsquo;&rsquo;similar
enough&rsquo;&rsquo;) framing format. For example, it is
possible to bridge Ethernet and 802.11 networks together,
but it is not possible to bridge Ethernet and Token Ring
together.

Each
if_bridge interface is created at runtime using
interface cloning. This is most easily done with the
ifconfig(8) create command or using the
cloned_interfaces variable in rc.conf(5).

The
if_bridge interface randomly chooses a link (MAC)
address in the range reserved for locally administered
addresses when it is created. This address is guaranteed to
be unique only across all if_bridge interfaces
on the local machine. Thus you can theoretically have two
bridges on the different machines with the same link
addresses. The address can be changed by assigning the
desired link address using ifconfig(8).

If sysctl(8)
node net.link.bridge.inherit_mac has non-zero value,
newly created bridge will inherit MAC address from its first
member instead of choosing random link-level address. This
will provide more predictable bridge MAC without any
additional configuration, but currently this feature is
known to break some L2 protocols, for example PPPoE that is
provided by ng_pppoe(4) and ppp(8). Now this feature is
considered as experimental and is turned off by-default.

A bridge can be
used to provide several services, such as a simple
802.11-to-Ethernet bridge for wireless hosts, and traffic
isolation.

A bridge works
like a switch, forwarding traffic from one interface to
another. Multicast and broadcast packets are always
forwarded to all interfaces that are part of the bridge. For
unicast traffic, the bridge learns which MAC addresses are
associated with which interfaces and will forward the
traffic selectively.

All the bridged
member interfaces need to be up in order to pass network
traffic. These can be enabled using ifconfig(8) or
ifconfig_&lang;

interface &rang; ="up" in
rc.conf(5).

The MTU of the
first member interface to be added is used as the bridge
MTU. All additional members are required to have exactly the
same value.

The TOE, TSO,
TXCSUM and TXCSUM6 capabilities on all interfaces added to
the bridge are disabled if any of the interfaces
doesn&rsquo;t support/enable them. The LRO capability is
always disabled. All the capabilities are restored when the
interface is removed from bridge. Changing capabilities in
run time may cause NIC reinit and the link flap.

The bridge
supports &rsquo;&rsquo;monitor mode&rsquo;&rsquo;, where the
packets are discarded after bpf(4) processing, and are not
processed or forwarded further. This can be used to
multiplex the input of two or more interfaces into a single
bpf(4) stream. This is useful for reconstructing the traffic
for network taps that transmit the RX/TX signals out through
two separate interfaces.

IPV6 SUPPORT

if_bridge supports the
AF_INET6 address family on bridge interfaces. The following
rc.conf(5) variable configures an IPv6 link-local address on
bridge0 interface:

ifconfig_bridge0_ipv6="up"

or in a more
explicit manner:

ifconfig_bridge0_ipv6="inet6
auto_linklocal"

However, the
AF_INET6 address family has a concept of scope zone.
Bridging multiple interfaces change the zone configuration
because multiple links are merged to each other and form a
new single link while the member interfaces still work
individually. This means each member interface still has a
separate link-local scope zone and the if_bridge
interface has another single, aggregated link-local scope
zone at the same time. This situation is clearly against the
description "zones of the same scope cannot
overlap" in Section 5, RFC 4007. Although it works in
most cases, it can cause some conterintuitive or undesirable
behavior in some edge cases when both of the
if_bridge interface and one of the member interface
have an IPv6 address and applications use both of them.

To prevent this
situation, if_bridge checks whether a link-local
scoped IPv6 address is configured on a member interface to
be added and the if_bridge interface. When the
if_bridge interface has IPv6 addresses, IPv6
addresses on the member interface will be automatically
removed before the interface is added.

This behavior
can be disabled by setting sysctl(8) variable
net.link.bridge.allow_llz_overlap to 1.

Note that
ACCEPT_RTADV and AUTO_LINKLOCAL interface flag are not
enabled by default on if_bridge interface even when
net.inet6.ip6.accept_rtadv and/or
net.inet6.ip6.auto_linklocal is set to 1.

SPANNING TREE

The if_bridge driver
implements the Rapid Spanning Tree Protocol (RSTP or 802.1w)
with backwards compatibility with the legacy Spanning Tree
Protocol (STP). Spanning Tree is used to detect and remove
loops in a network topology.

RSTP provides
faster spanning tree convergence than legacy STP, the
protocol will exchange information with neighbouring
switches to quickly transition to forwarding without
creating loops.

The code will
default to RSTP mode but will downgrade any port connected
to a legacy STP network so is fully backward compatible. A
bridge can be forced to operate in STP mode without rapid
state transitions via the proto command in
ifconfig(8).

The bridge can
log STP port changes to syslog(3) by enabling the
net.link.bridge.log_stp variable using sysctl(8).

PACKET FILTERING

Packet filtering can be used
with any firewall package that hooks in via the pfil(9)
framework. When filtering is enabled, bridged packets will
pass through the filter inbound on the originating
interface, on the bridge interface and outbound on the
appropriate interfaces. Either stage can be disabled. The
filtering behaviour can be controlled using sysctl(8):

net.link.bridge.pfil_onlyip

Controls the
handling of non-IP packets which are not passed to pfil(9).
Set to 1 to only allow IP packets to pass (subject to
firewall rules), set to 0 to unconditionally pass all non-IP
Ethernet frames.

net.link.bridge.pfil_member

Set to 1 to
enable filtering on the incoming and outgoing member
interfaces, set to 0 to disable it.

net.link.bridge.pfil_bridge

Set to 1 to
enable filtering on the bridge interface, set to 0 to
disable it.

net.link.bridge.pfil_local_phys

Set to 1 to additionally filter
on the physical interface for locally destined packets. Set
to 0 to disable this feature.

net.link.bridge.ipfw

Set to 1 to
enable layer2 filtering with ipfirewall(4), set to 0 to
disable it. This needs to be enabled for dummynet(4)
support. When ipfw is enabled, pfil_bridge and
pfil_member will be disabled so that IPFW is not run
twice; these can be re-enabled if desired.

net.link.bridge.ipfw_arp

Set to 1 to
enable layer2 ARP filtering with ipfirewall(4), set to 0 to
disable it. Requires ipfw to be enabled.

ARP and REVARP
packets are forwarded without being filtered and others that
are not IP nor IPv6 packets are not forwarded when
pfil_onlyip is enabled. IPFW can filter Ethernet
types using mac-type so all packets are passed to the
filter for processing.

The packets
originating from the bridging host will be seen by the
filter on the interface that is looked up in the routing
table.

The packets
destined to the bridging host will be seen by the filter on
the interface with the MAC address equal to the
packet&rsquo;s destination MAC. There are situations when
some of the bridge members are sharing the same MAC address
(for example the vlan(4) interfaces: they are currently
sharing the MAC address of the parent physical interface).
It is not possible to distinguish between these interfaces
using their MAC address, excluding the case when the
packet&rsquo;s destination MAC address is equal to the MAC
address of the interface on which the packet was entered to
the system. In this case the filter will see the incoming
packet on this interface. In all other cases the interface
seen by the packet filter is chosen from the list of bridge
members with the same MAC address and the result strongly
depends on the member addition sequence and the actual
implementation of if_bridge. It is not recommended to
rely on the order chosen by the current if_bridge
implementation: it can be changed in the future.

The previous
paragraph is best illustrated with the following pictures.
Let

&bull;

the MAC address of the incoming
packet&rsquo;s destination is nn:nn:nn:nn:nn:nn,

&bull;

the interface on which packet
entered the system is ifX,

&bull;

ifX MAC address is
xx:xx:xx:xx:xx:xx,

&bull;

there are possibly other bridge
members with the same MAC address
xx:xx:xx:xx:xx:xx,

&bull;

the bridge has more than one
interface that are sharing the same MAC address
yy:yy:yy:yy:yy:yy; we will call them vlanY1,
vlanY2, etc.

Then if the MAC
address nn:nn:nn:nn:nn:nn is equal to the
xx:xx:xx:xx:xx:xx then the filter will see the packet
on the interface ifX no matter if there are any other
bridge members carrying the same MAC address. But if the MAC
address nn:nn:nn:nn:nn:nn is equal to the
yy:yy:yy:yy:yy:yy then the interface that will be
seen by the filter is one of the vlanYn. It is not
possible to predict the name of the actual interface without
the knowledge of the system state and the if_bridge
implementation details.

This problem
arises for any bridge members that are sharing the same MAC
address, not only to the vlan(4) ones: they we taken just as
the example of such situation. So if one wants the filter
the locally destined packets based on their interface name,
one should be aware of this implication. The described
situation will appear at least on the filtering bridges that
are doing IP-forwarding; in some of such cases it is better
to assign the IP address only to the if_bridge
interface and not to the bridge members. Enabling
net.link.bridge.pfil_local_phys will let you do the
additional filtering on the physical interface.

EXAMPLES

The following when placed in the
file /etc/rc.conf will cause a bridge called
&rsquo;&rsquo;bridge0&rsquo;&rsquo; to be created, and will
add the interfaces &rsquo;&rsquo;wlan0&rsquo;&rsquo; and
&rsquo;&rsquo;fxp0&rsquo;&rsquo; to the bridge, and then
enable packet forwarding. Such a configuration could be used
to implement a simple 802.11-to-Ethernet bridge (assuming
the 802.11 interface is in ad-hoc mode).

cloned_interfaces="bridge0"

ifconfig_bridge0="addm wlan0 addm fxp0 up"

For the bridge
to forward packets, all member interfaces and the bridge
need to be up. The above example would also require:

create_args_wlan0="wlanmode
hostap" 
ifconfig_wlan0="up ssid my_ap mode 11g" 
ifconfig_fxp0="up"

Consider a
system with two 4-port Ethernet boards. The following will
cause a bridge consisting of all 8 ports with Rapid Spanning
Tree enabled to be created:

ifconfig
bridge0 create 
ifconfig bridge0 \ 
addm fxp0 stp fxp0 \ 
addm fxp1 stp fxp1 \ 
addm fxp2 stp fxp2 \ 
addm fxp3 stp fxp3 \ 
addm fxp4 stp fxp4 \ 
addm fxp5 stp fxp5 \ 
addm fxp6 stp fxp6 \ 
addm fxp7 stp fxp7 \ 
up

The bridge can
be used as a regular host interface at the same time as
bridging between its member ports. In this example, the
bridge connects em0 and em1, and will receive its IP address
through DHCP:

cloned_interfaces="bridge0"

ifconfig_bridge0="addm em0 addm em1 DHCP" 
ifconfig_em0="up" 
ifconfig_em1="up"

The bridge can
tunnel Ethernet across an IP internet using the EtherIP
protocol. This can be combined with ipsec(4) to provide an
encrypted connection. Create a gif(4) interface and set the
local and remote IP addresses for the tunnel, these are
reversed on the remote bridge.

ifconfig gif0
create 
ifconfig gif0 tunnel 1.2.3.4 5.6.7.8 up 
ifconfig bridge0 create 
ifconfig bridge0 addm fxp0 addm gif0 up

Note that
FreeBSD 6.1, 6.2, 6.3, 7.0, 7.1, and 7.2 have a bug in the
EtherIP protocol. For more details and workaround, see
gif(4) manual page.

SEE ALSO

gif(4), ipf(4), ipfw(4), pf(4),
ifconfig(8)

HISTORY

The if_bridge driver
first appeared in FreeBSD 6.0.

AUTHORS

The bridge driver was
originally written by Jason L. Wright
jason [AT] thought.net> as part of an undergraduate
independent study at the University of North Carolina at
Greensboro.

This version of
the if_bridge driver has been heavily modified from
the original version by Jason R. Thorpe
thorpej [AT] wasabisystems.com>.

Rapid Spanning
Tree Protocol (RSTP) support was added by Andrew Thompson
thompsa [AT] FreeBSD.org>.

BUGS

The if_bridge driver
currently supports only Ethernet and Ethernet-like (e.g.,
802.11) network devices, with exactly the same interface MTU
size as the bridge device.

BSD
October 16, 2017 BSD