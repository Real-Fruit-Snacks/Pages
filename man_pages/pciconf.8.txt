PCICONF(8) BSD System Manager’s Manual
PCICONF(8)

NAME

pciconf —
diagnostic utility for the PCI bus

SYNOPSIS

pciconf −l
[−v] 
pciconf −a selector 
pciconf −r [

−b | −h ] selector
addr[:addr2]

pciconf −w [

−b | −h ] selector addr
value

DESCRIPTION

The pciconf utility
provides a command line interface to functionality provided
by the pci(4) ioctl(2) interface. As such, some of the
functions are only available to users with write access to
/dev/pci, normally only the super-user.

With the
−l option, it lists all devices found by the
boot probe in the following format:

foo0@pci0:4:0:
class=0x010000 card=0x00000000 chip=0x000f1000 rev=0x01
hdr=0x00 
bar0@pci0:5:0: class=0x000100 card=0x00000000
chip=0x88c15333 rev=0x00 hdr=0x00 
none0@pci0:6:0: class=0x020000 card=0x00000000
chip=0x802910ec rev=0x00 hdr=0x00

If the
−v option is supplied, pciconf will
attempt to load the vendor/device information database, and
print vendor, device, class and subclass identification
strings for each device.

The first column
gives the device name, unit number, and selector. If
there is no device configured in the kernel for the PCI
device in question, the device name will be
’’none’’. Unit numbers for
unconfigured devices start at zero and are incremented for
each unconfigured device that is encountered. The
selector is in a form which may directly be used for
the other forms of the command. The second column is the
class code, with the class byte printed as two hex digits,
followed by the sub-class and the interface bytes. The third
column gives the contents of the subvendorid register,
introduced in revision 2.1 of the PCI standard. It is 0 for
most current (2.0) PCI cards, but is supposed to be loaded
with a unique card identification code in newly developed
PCI cards. The field consists of the card ID in the upper
half and the card vendor ID in the lower half of the
value.

The fourth
column contains the chip device ID, which identifies the
chip this card is based on. It consists of two fields,
identifying the chip and its vendor, as above. The fifth
column prints the chip’s revision. The sixth column
describes the header type. Currently assigned header types
are 0 for all devices except PCI to PCI bridges, and 1 for
such bridge chips. If the most significant bit of the header
type register is set for function 0 of a PCI device, it is a
multi-function device, which contains several
(similar or independent) functions on one chip.

All invocations
of pciconf except for −l require a
selector of the form pcibus:device
(optionally followed by :function). A final colon may
be appended and will be ignored; this is so that the first
column in the output of pciconf −l can be used
without modification. All numbers are base 10.

With the
−a flag, pciconf determines whether any
driver has been assigned to the device identified by
selector. An exit status of zero indicates that the
device has a driver; non-zero indicates that it does
not.

The
−r option reads a configuration space register
at byte offset addr of device selector and
prints out its value in hexadecimal. The optional second
address addr2 specifies a range to read. The
−w option writes the value into a
configuration space register at byte offset addr of
device selector. For both operations, the flags
−b and −h select the width of the
operation; −b indicates a byte operation, and
−h indicates a halfword (two-byte) operation.
The default is to read or write a longword (four bytes).

ENVIRONMENT

The PCI vendor/device
information database is normally read from
/usr/share/misc/pci_vendors. This path can be
overridden by setting the environment variable
PCICONF_VENDOR_DATABASE.

SEE ALSO

ioctl(2), kldload(8)

HISTORY

The pciconf utility
appeared first in FreeBSD 2.2. The −a
option was added for PCI KLD support in
FreeBSD 3.0.

AUTHORS

The pciconf utility was
written by Stefan Esser and Garrett Wollman.

BUGS

The −b and
−h options are implemented in pciconf,
but not in the underlying ioctl(2).

It might be
useful to give non-root users access to the −a
and −r options. But only root will be able to
execute a kldload to provide the device with a driver
KLD, and reading of configuration space registers may cause
a failure in badly designed PCI chips.

BSD
February 7, 1997 BSD