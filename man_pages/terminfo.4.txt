NAME

terminfo
&minus; terminal and printer capability database

SYNOPSIS

/usr/share/lib/terminfo/?/*

DESCRIPTION

terminfo
is a database that describes the capabilities of devices
such as terminals and printers. Devices are described in
terminfo source files by specifying a set of
capabilities, by quantifying certain aspects of the device,
and by specifying character sequences that affect particular
results. This database is often used by screen oriented
applications such as vi and curses-based
programs, as well as by some system commands such as
ls and more. This usage allows them to work
with a variety of devices without changes to the
programs.

terminfo
descriptions are located in the directory pointed to by the
environment variable TERMINFO or in
/usr/share/lib/terminfo. terminfo descriptions
are generated by tic(1M).

terminfo
source files consist of one or more device descriptions.
Each description consists of a header (beginning in column
1) and one or more lines that list the features for that
particular device. Every line in a terminfo source
file must end in a comma (,). Every line in a
terminfo source file except the header must be
indented with one or more white spaces (either spaces or
tabs).

Entries in
terminfo source files consist of a number of
comma-separated fields. White space after each comma is
ignored. Embedded commas must be escaped by using a
backslash. Each device entry has the following format:

alias1 |
alias2 | ... | aliasn | fullname, 
capability1, capability2, 
. 
. 
. 
capabilityn,

The first line,
commonly referred to as the header line, must begin in
column one and must contain at least two aliases separated
by vertical bars. The last field in the header line must be
the long name of the device and it may contain any string.
Alias names must be unique in the terminfo database
and they must conform to system file naming conventions (see
tic(1M)); they cannot, for example, contain white
space or slashes.

Every device
must be assigned a name, such as "vt100". Device
names (except the long name) should be chosen using the
following conventions. The name should not contain hyphens
because hyphens are reserved for use when adding suffixes
that indicate special modes.

These special
modes may be modes that the hardware can be in, or user
preferences. To assign a special mode to a particular
device, append a suffix consisting of a hyphen and an
indicator of the mode to the device name. For example, the
-w suffix means "wide mode"; when
specified, it allows for a width of 132 columns instead of
the standard 80 columns. Therefore, if you want to use a
"vt100" device set to wide mode, name the device
"vt100-w." Use the following suffixes where
possible.

The
terminfo reference manual page is organized in two
sections:

&bull;

PART 1: DEVICE CAPABILITIES

&bull;

PART 2: PRINTER CAPABILITIES

PART 1:
DEVICE CAPABILITIES 
Capabilities in terminfo are of three types: Boolean
capabilities (which show that a device has or does not have
a particular feature), numeric capabilities (which quantify
particular features of a device), and string capabilities
(which provide sequences that can be used to perform
particular operations on devices).

In the
following table, a Variable is the name by which a
C programmer accesses a capability (at the
terminfo level). A Capname is the short name
for a capability specified in the terminfo source
file. It is used by a person updating the source file and by
the tput command. A Termcap Code is a
two-letter sequence that corresponds to the termcap
capability name. (Note that termcap is no longer
supported.)

Capability
names have no real length limit, but an informal limit of
five characters has been adopted to keep them short.
Whenever possible, capability names are chosen to be the
same as or similar to those specified by the ANSI X3.64-1979
standard. Semantics are also intended to match those of the
ANSI standard.

All string
capabilities listed below may have padding specified, with
the exception of those used for input. Input capabilities,
listed under the Strings section in the following
tables, have names beginning with key_. The #i
symbol in the description field of the following tables
refers to the ith parameter.

Table 1
Booleans

Table 2
Numbers

Table 3
Strings

The
&rsquo;&rsquo;key_&rsquo;&rsquo; strings are sent by
specific keys. The &rsquo;&rsquo;key_&rsquo;&rsquo;
descriptions include the macro, defined in
, for the code returned by the
curses routine getch when the key is pressed
(see curs_getch(3CURSES)).

Table 4 key_
Strings

Sample
Entry 
The following entry, which describes the AT&T 610
terminal, is among the more complex entries in the
terminfo file as of this writing.

610|610bct|ATT610|att610|AT&T610;80column;98key keyboard
   am, eslok, hs, mir, msgr, xenl, xon,
   cols#80, it#8, lh#2, lines#24, lw#8, nlab#8, wsl#80,
   acsc=&rsquo;&rsquo;aaffggjjkkllmmnnooppqqrrssttuuvvwwxxyyzz{{||}}~~,
   bel=^G, blink=\E[5m, bold=\E[1m, cbt=\E[Z,
   civis=\E[?25l, clear=\E[H\E[J, cnorm=\E[?25h\E[?12l,
   cr=\r, csr=\E[%i%p1%d;%p2%dr, cub=\E[%p1%dD, cub1=\b,
   cud=\E[%p1%dB, cud1=\E[B, cuf=\E[%p1%dC, cuf1=\E[C,
   cup=\E[%i%p1%d;%p2%dH, cuu=\E[%p1%dA, cuu1=\E[A,
   cvvis=\E[?12;25h, dch=\E[%p1%dP, dch1=\E[P, dim=\E[2m,
   dl=\E[%p1%dM, dl1=\E[M, ed=\E[J, el=\E[K, el1=\E[1K,
   flash=\E[?5h$\E[?5l, fsl=\E8, home=\E[H, ht=\t,
   ich=\E[%p1%d@, il=\E[%p1%dL, il1=\E[L, ind=\ED, .ind=\ED$,
   invis=\E[8m,
   is1=\E[8;0 | \E[?3;4;5;13;15l\E[13;20l\E[?7h\E[12h\E(B\E)0,
   is2=\E[0m^O, is3=\E(B\E)0, kLFT=\E[\s@, kRIT=\E[\sA,
   kbs=^H, kcbt=\E[Z, kclr=\E[2J, kcub1=\E[D, kcud1=\E[B,
   kcuf1=\E[C, kcuu1=\E[A, kf1=\EOc, kf10=\ENp,
   kf11=\ENq, kf12=\ENr, kf13=\ENs, kf14=\ENt, kf2=\EOd,
   kf3=\EOe, kf4=\EOf, kf5=\EOg, kf6=\EOh, kf7=\EOi,
   kf8=\EOj, kf9=\ENo, khome=\E[H, kind=\E[S, kri=\E[T,
   ll=\E[24H, mc4=\E[?4i, mc5=\E[?5i, nel=\EE,
   pfxl=\E[%p1%d;%p2%l%02dq%?%p1%{9}%

Types of
Capabilities in the Sample Entry 
The sample entry shows the formats for the three types of
terminfo capabilities listed: Boolean, numeric, and
string. All capabilities specified in the terminfo
source file must be followed by commas, including the last
capability in the source file. In terminfo source
files, capabilities are referenced by their capability names
(as shown in the previous tables).

Boolean
capabilities are specified simply by their comma separated
cap names.

Numeric
capabilities are followed by the character &rsquo;#&rsquo;
and then a positive integer value. Thus, in the sample,
cols (which shows the number of columns available on
a device) is assigned the value 80 for the AT&T
610. (Values for numeric capabilities may be specified in
decimal, octal, or hexadecimal, using normal C programming
language conventions.)

Finally,
string-valued capabilities such as el (clear to end
of line sequence) are listed by a two- to five-character
capname, an &rsquo;=&rsquo;, and a string ended by the next
occurrence of a comma. A delay in milliseconds may appear
anywhere in such a capability, preceded by $ and
enclosed in angle brackets, as in el=\EK$.
Padding characters are supplied by tput. The delay
can be any of the following: a number, a number followed by
an asterisk, such as 5*, a number followed by a
slash, such as 5/, or a number followed by both, such
as 5*/. A &rsquo;*&rsquo; shows that the
padding required is proportional to the number of lines
affected by the operation, and the amount given is the
per-affected-unit padding required. (In the case of insert
characters, the factor is still the number of lines
affected. This is always 1 unless the device has in
and the software uses it.) When a &rsquo;*&rsquo; is
specified, it is sometimes useful to give a delay of the
form 3.5 to specify a delay per unit to tenths of
milliseconds. (Only one decimal place is allowed.)

A
&rsquo;/&rsquo; indicates that the padding is mandatory. If
a device has xon defined, the padding information is
advisory and will only be used for cost estimates or when
the device is in raw mode. Mandatory padding will be
transmitted regardless of the setting of xon. If
padding (whether advisory or mandatory) is specified for
bel or flash, however, it will always be used,
regardless of whether xon is specified.

terminfo
offers notation for encoding special characters. Both
\E and \e map to an ESCAPE character,
^x maps to a control x for any appropriate
x, and the sequences \n, \l, \r, \t, \b, \f,
and \s give a newline, linefeed, return, tab,
backspace, formfeed, and space, respectively. Other escapes
include: \^ for caret (^); \\ for backslash
(\); \, for comma (,); \: for colon (:); and
\0 for null. (\0 will actually produce
\200, which does not terminate a string but behaves
as a null character on most devices, providing CS7 is
specified. (See stty(1)). Finally, characters may be
given as three octal digits after a backslash (for example,
\123).

Sometimes
individual capabilities must be commented out. To do this,
put a period before the capability name. For example, see
the second ind in the example above. Note that
capabilities are defined in a left-to-right order and,
therefore, a prior definition will override a later
definition.

Preparing
Descriptions 
The most effective way to prepare a device description is by
imitating the description of a similar device in
terminfo and building up a description gradually,
using partial descriptions with vi to check that they
are correct. Be aware that a very unusual device may expose
deficiencies in the ability of the terminfo file to
describe it or the inability of vi to work with that
device. To test a new device description, set the
environment variable TERMINFO to the pathname of a
directory containing the compiled description you are
working on and programs will look there rather than in
/usr/share/lib/terminfo. To get the padding for
insert-line correct (if the device manufacturer did not
document it) a severe test is to comment out xon,
edit a large file at 9600 baud with vi, delete 16 or
so lines from the middle of the screen, and then press the
u key several times quickly. If the display is
corrupted, more padding is usually needed. A similar test
can be used for insert-character.

Section 1-1:
Basic Capabilities 
The number of columns on each line for the device is given
by the cols numeric capability. If the device has a
screen, then the number of lines on the screen is given by
the lines capability. If the device wraps around to
the beginning of the next line when it reaches the right
margin, then it should have the am capability. If the
terminal can clear its screen, leaving the cursor in the
home position, then this is given by the clear string
capability. If the terminal overstrikes (rather than
clearing a position when a character is struck over) then it
should have the os capability. If the device is a
printing terminal, with no soft copy unit, specify both
hc and os. If there is a way to move the
cursor to the left edge of the current row, specify this as
cr. (Normally this will be carriage return, control
M.) If there is a way to produce an audible signal (such as
a bell or a beep), specify it as bel. If, like most
devices, the device uses the xon-xoff flow-control protocol,
specify xon.

If there is a
way to move the cursor one position to the left (such as
backspace), that capability should be given as cub1.
Similarly, sequences to move to the right, up, and down
should be given as cuf1, cuu1, and
cud1, respectively. These local cursor motions must
not alter the text they pass over; for example, you would
not normally use &rsquo;&rsquo;cuf1=\s&rsquo;&rsquo;
because the space would erase the character moved over.

A very
important point here is that the local cursor motions
encoded in terminfo are undefined at the left and top
edges of a screen terminal. Programs should never attempt to
backspace around the left edge, unless bw is
specified, and should never attempt to go up locally off the
top. To scroll text up, a program goes to the bottom left
corner of the screen and sends the ind (index)
string.

To scroll text
down, a program goes to the top left corner of the screen
and sends the ri (reverse index) string. The strings
ind and ri are undefined when not on their
respective corners of the screen.

Parameterized
versions of the scrolling sequences are indn and
rin. These versions have the same semantics as
ind and ri, except that they take one
parameter and scroll the number of lines specified by that
parameter. They are also undefined except at the appropriate
edge of the screen.

The am
capability tells whether the cursor sticks at the right edge
of the screen when text is output, but this does not
necessarily apply to a cuf1 from the last column.
Backward motion from the left edge of the screen is possible
only when bw is specified. In this case, cub1
will move to the right edge of the previous row. If
bw is not given, the effect is undefined. This is
useful for drawing a box around the edge of the screen, for
example. If the device has switch selectable automatic
margins, am should be specified in the
terminfo source file. In this case, initialization
strings should turn on this option, if possible. If the
device has a command that moves to the first column of the
next line, that command can be given as nel
(newline). It does not matter if the command clears the
remainder of the current line, so if the device has no
cr and lf it may still be possible to craft a
working nel out of one or both of them.

These
capabilities suffice to describe hardcopy and screen
terminals. Thus the AT&T 5320 hardcopy terminal is
described as follows:

5320|att5320|AT&T
5320 hardcopy terminal, 
am, hc, os, 
cols#132, 
bel=^G, cr=\r, cub1=\b, cnd1=\n, 
dch1=\E[P, dl1=\E[M, 
ind=\n,

while the Lear
Siegler ADM&minus;3 is described as

adm3 | lsi
adm3, 
am, bel=^G, clear=^Z, cols#80, cr=^M, cub1=^H, 
cud1=^J, ind=^J, lines#24,

Section 1-2:
Parameterized Strings 
Cursor addressing and other strings requiring parameters are
described by a parameterized string capability, with
printf-like escapes (%x) in it. For
example, to address the cursor, the cup capability is
given, using two parameters: the row and column to address
to. (Rows and columns are numbered from zero and refer to
the physical screen visible to the user, not to any unseen
memory.) If the terminal has memory relative cursor
addressing, that can be indicated by mrcup.

The parameter
mechanism uses a stack and special % codes to
manipulate the stack in the manner of Reverse Polish
Notation (postfix). Typically a sequence will push one of
the parameters onto the stack and then print it in some
format. Often more complex operations are necessary.
Operations are in postfix form with the operands in the
usual order. That is, to subtract 5 from the first
parameter, one would use %p1%{5}%&minus;.

The %
encodings have the following meanings:

%%

outputs &rsquo;%&rsquo;

%[[:]flags][width[.precision]][doxXs]

as in printf, flags are
[&minus;+#] and space

%c

print pop gives %c

%p[1-9]

push ith parm

%P[a-z]

set dynamic variable [a-z] to
pop

%g[a-z]

get dynamic variable [a-z] and
push it

%P[A-Z]

set static variable [a-z] to
pop

%g[A-Z]

get static variable [a-z] and
push it

%&rsquo;c&rsquo;

push char constant c

%{nn}

push decimal constant nn

%l

push strlen(pop)

%+ %&minus; %* %/ %m

arithmetic (%m is mod):
push(pop integer2 op pop integer1)

%& %| %^

bit operations: push(pop
integer2 op pop integer1)

%= %> %

logical operations: push(pop
integer2 op pop integer1)

%A %O

logical operations: and, or

%! %~

unary operations: push(op pop)

%i

(for ANSI terminals) add 1 to first parm, if one parm
present, or first two parms, if more than one parm
present 

%? expr %t
thenpart %e elsepart %;

if-then-else, %e
elsepart is optional; else-if&rsquo;s are possible
ala Algol 68: %? c1 %t b1 %e c2 %t b2 %e c3 %t b3 %e
c4 %t b4 %e b5%; ci are conditions, bi are
bodies.

If the
&rsquo;&rsquo;&minus;&rsquo;&rsquo; flag is used with
&rsquo;&rsquo;%[doxXs]&rsquo;&rsquo;, then a colon
(:) must be placed between the
&rsquo;&rsquo;%&rsquo;&rsquo; and the
&rsquo;&rsquo;&minus;&rsquo;&rsquo; to differentiate
the flag from the binary
&rsquo;&rsquo;%&minus;&rsquo;&rsquo; operator, for
example
&rsquo;&rsquo;%:&minus;16.16s&rsquo;&rsquo;.

Consider the
Hewlett-Packard 2645, which, to get to row 3 and column 12,
needs to be sent \E&a12c03Y padded for 6
milliseconds. Note that the order of the rows and columns is
inverted here, and that the row and column are zero-padded
as two digits. Thus its cup capability is:
cup=\E&a%p2%2.2dc%p1%2.2dY$

The Micro-Term
ACT-IV needs the current row and column sent preceded by a
^T, with the row and column simply encoded in binary,
&rsquo;&rsquo;cup=^T%p1%c%p2%c&rsquo;&rsquo;. Devices
that use &rsquo;&rsquo;%c&rsquo;&rsquo; need to be
able to backspace the cursor (cub1), and to move the
cursor up one line on the screen (cuu1). This is
necessary because it is not always safe to transmit
\n, ^D, and \r, as the system may
change or discard them. (The library routines dealing with
terminfo set tty modes so that tabs are never
expanded, so \t is safe to send. This turns out to be
essential for the Ann Arbor 4080.)

A final example
is the LSI ADM-3a, which uses row and column offset by a
blank character, thus
&rsquo;&rsquo;cup=\E=%p1%&rsquo;\s&rsquo;%+%c%p2%&rsquo;\s&rsquo;%+%c&rsquo;&rsquo;.
After sending &rsquo;&rsquo;\E=&rsquo;&rsquo;, this
pushes the first parameter, pushes the ASCII value for a
space (32), adds them (pushing the sum on the stack in place
of the two previous values), and outputs that value as a
character. Then the same is done for the second parameter.
More complex arithmetic is possible using the stack.

Section 1-3:
Cursor Motions 
If the terminal has a fast way to home the cursor (to very
upper left corner of screen) then this can be given as
home; similarly a fast way of getting to the lower
left-hand corner can be given as ll; this may involve
going up with cuu1 from the home position, but a
program should never do this itself (unless ll does)
because it can make no assumption about the effect of moving
up from the home position. Note that the home position is
the same as addressing to (0,0): to the top left corner of
the screen, not of memory. (Thus, the \EH sequence on
Hewlett-Packard terminals cannot be used for home
without losing some of the other features on the
terminal.)

If the device
has row or column absolute-cursor addressing, these can be
given as single parameter capabilities hpa
(horizontal position absolute) and vpa (vertical
position absolute). Sometimes these are shorter than the
more general two-parameter sequence (as with the
Hewlett-Packard 2645) and can be used in preference to
cup. If there are parameterized local motions (for
example, move n spaces to the right) these can be
given as cud, cub, cuf, and cuu
with a single parameter indicating how many spaces to move.
These are primarily useful if the device does not have
cup, such as the Tektronix 4025.

If the device
needs to be in a special mode when running a program that
uses these capabilities, the codes to enter and exit this
mode can be given as smcup and rmcup. This
arises, for example, from terminals, such as the Concept,
with more than one page of memory. If the device has only
memory relative cursor addressing and not screen relative
cursor addressing, a one screen-sized window must be fixed
into the device for cursor addressing to work properly. This
is also used for the Tektronix 4025, where smcup sets
the command character to be the one used by terminfo.
If the smcup sequence will not restore the screen
after an rmcup sequence is output (to the state prior
to outputting rmcup), specify nrrmc.

Section 1-4:
Area Clears 
If the terminal can clear from the current position to the
end of the line, leaving the cursor where it is, this should
be given as el. If the terminal can clear from the
beginning of the line to the current position inclusive,
leaving the cursor where it is, this should be given as
el1. If the terminal can clear from the current
position to the end of the display, then this should be
given as ed. ed is only defined from the first
column of a line. (Thus, it can be simulated by a request to
delete a large number of lines, if a true ed is not
available.)

Section 1-5:
Insert/Delete Line 
If the terminal can open a new blank line before the line
where the cursor is, this should be given as il1;
this is done only from the first position of a line. The
cursor must then appear on the newly blank line. If the
terminal can delete the line which the cursor is on, then
this should be given as dl1; this is done only from
the first position on the line to be deleted. Versions of
il1 and dl1 which take a single parameter and
insert or delete that many lines can be given as il
and dl.

If the terminal
has a settable destructive scrolling region (like the VT100)
the command to set this can be described with the csr
capability, which takes two parameters: the top and bottom
lines of the scrolling region. The cursor position is, alas,
undefined after using this command. It is possible to get
the effect of insert or delete line using this command
&mdash; the sc and rc (save and restore
cursor) commands are also useful. Inserting lines at the top
or bottom of the screen can also be done using ri or
ind on many terminals without a true insert/delete
line, and is often faster even on terminals with those
features.

To determine
whether a terminal has destructive scrolling regions or
non-destructive scrolling regions, create a scrolling region
in the middle of the screen, place data on the bottom line
of the scrolling region, move the cursor to the top line of
the scrolling region, and do a reverse index (ri)
followed by a delete line (dl1) or index
(ind). If the data that was originally on the bottom
line of the scrolling region was restored into the scrolling
region by the dl1 or ind, then the terminal
has non-destructive scrolling regions. Otherwise, it has
destructive scrolling regions. Do not specify csr if
the terminal has non-destructive scrolling regions, unless
ind, ri, indn, rin, dl,
and dl1 all simulate destructive scrolling.

If the terminal
has the ability to define a window as part of memory, which
all commands affect, it should be given as the parameterized
string wind. The four parameters are the starting and
ending lines in memory and the starting and ending columns
in memory, in that order.

If the terminal
can retain display memory above, then the da
capability should be given; if display memory can be
retained below, then db should be given. These
indicate that deleting a line or scrolling a full screen may
bring non-blank lines up from below or that scrolling back
with ri may bring down non-blank lines.

Section 1-6:
Insert/Delete Character 
There are two basic kinds of intelligent terminals with
respect to insert/delete character operations which can be
described using terminfo. The most common
insert/delete character operations affect only the
characters on the current line and shift characters off the
end of the line rigidly. Other terminals, such as the
Concept 100 and the Perkin Elmer Owl, make a distinction
between typed and untyped blanks on the screen, shifting
upon an insert or delete only to an untyped blank on the
screen which is either eliminated, or expanded to two
untyped blanks. You can determine the kind of terminal you
have by clearing the screen and then typing text separated
by cursor motions. Type
&rsquo;&rsquo;abc    def&rsquo;&rsquo;
using local cursor motions (not spaces) between the
abc and the def. Then position the cursor
before the abc and put the terminal in insert mode.
If typing characters causes the rest of the line to shift
rigidly and characters to fall off the end, then your
terminal does not distinguish between blanks and untyped
positions. If the abc shifts over to the def
which then move together around the end of the current line
and onto the next as you insert, you have the second type of
terminal, and should give the capability in, which
stands for &rsquo;&rsquo;insert null.&rsquo;&rsquo; While
these are two logically separate attributes (one line versus
multiline insert mode, and special treatment of untyped
spaces) we have seen no terminals whose insert mode cannot
be described with the single attribute.

terminfo
can describe both terminals that have an insert mode and
terminals which send a simple sequence to open a blank
position on the current line. Give as smir the
sequence to get into insert mode. Give as rmir the
sequence to leave insert mode. Now give as ich1 any
sequence needed to be sent just before sending the character
to be inserted. Most terminals with a true insert mode will
not give ich1; terminals that send a sequence to open
a screen position should give it here. (If your terminal has
both, insert mode is usually preferable to ich1. Do
not give both unless the terminal actually requires both to
be used in combination.) If post-insert padding is needed,
give this as a number of milliseconds padding in ip
(a string option). Any other sequence which may need to be
sent after an insert of a single character may also be given
in ip. If your terminal needs both to be placed into
an &rsquo;insert mode&rsquo; and a special code to precede
each inserted character, then both smir/rmir and
ich1 can be given, and both will be used. The
ich capability, with one parameter, n, will
insert n blanks.

If padding is
necessary between characters typed while not in insert mode,
give this as a number of milliseconds padding in
rmp.

It is
occasionally necessary to move around while in insert mode
to delete characters on the same line (for example, if there
is a tab after the insertion position). If your terminal
allows motion while in insert mode you can give the
capability mir to speed up inserting in this case.
Omitting mir will affect only speed. Some terminals
(notably Datamedia&rsquo;s) must not have mir because
of the way their insert mode works.

Finally, you
can specify dch1 to delete a single character,
dch with one parameter, n, to delete n
characters, and delete mode by giving smdc and
rmdc to enter and exit delete mode (any mode the
terminal needs to be placed in for dch1 to work).

A command to
erase n characters (equivalent to outputting n
blanks without moving the cursor) can be given as ech
with one parameter.

Section 1-7:
Highlighting, Underlining, and Visible Bells 
Your device may have one or more kinds of display attributes
that allow you to highlight selected characters when they
appear on the screen. The following display modes (shown
with the names by which they are set) may be available: a
blinking screen (blink), bold or extra-bright
characters (bold), dim or half-bright characters
(dim), blanking or invisible text (invis),
protected text (prot), a reverse-video screen
(rev), and an alternate character set (smacs
to enter this mode and rmacs to exit it). (If a
command is necessary before you can enter alternate
character set mode, give the sequence in enacs or
"enable alternate-character-set" mode.) Turning on
any of these modes singly may or may not turn off other
modes.

sgr0
should be used to turn off all video enhancement
capabilities. It should always be specified because it
represents the only way to turn off some capabilities, such
as dim or blink.

You should
choose one display method as standout mode and use it
to highlight error messages and other kinds of text to which
you want to draw attention. Choose a form of display that
provides strong contrast but that is easy on the eyes. (We
recommend reverse-video plus half-bright or reverse-video
alone.) The sequences to enter and exit standout mode are
given as smso and rmso, respectively. If the
code to change into or out of standout mode leaves one or
even two blank spaces on the screen, as the TVI 912 and
Teleray 1061 do, then xmc should be given to tell how
many spaces are left.

Sequences to
begin underlining and end underlining can be specified as
smul and rmul , respectively. If the device
has a sequence to underline the current character and to
move the cursor one space to the right (such as the
Micro-Term MIME), this sequence can be specified as
uc.

Terminals with
the &rsquo;&rsquo;magic cookie&rsquo;&rsquo; glitch
(xmc) deposit special
&rsquo;&rsquo;cookies&rsquo;&rsquo; when they receive
mode-setting sequences, which affect the display algorithm
rather than having extra bits for each character. Some
terminals, such as the Hewlett-Packard 2621, automatically
leave standout mode when they move to a new line or the
cursor is addressed. Programs using standout mode should
exit standout mode before moving the cursor or sending a
newline, unless the msgr capability, asserting that
it is safe to move in standout mode, is present.

If the terminal
has a way of flashing the screen to indicate an error
quietly (a bell replacement), then this can be given as
flash; it must not move the cursor. A good flash can
be done by changing the screen into reverse video, pad for
200 ms, then return the screen to normal video.

If the cursor
needs to be made more visible than normal when it is not on
the bottom line (to make, for example, a non-blinking
underline into an easier to find block or blinking
underline) give this sequence as cvvis. The boolean
chts should also be given. If there is a way to make
the cursor completely invisible, give that as civis.
The capability cnorm should be given which undoes the
effects of either of these modes.

If your
terminal generates underlined characters by using the
underline character (with no special sequences needed) even
though it does not otherwise overstrike characters, then you
should specify the capability ul. For devices on
which a character overstriking another leaves both
characters on the screen, specify the capability os.
If overstrikes are erasable with a blank, then this should
be indicated by specifying eo.

If there is a
sequence to set arbitrary combinations of modes, this should
be given as sgr (set attributes), taking nine
parameters. Each parameter is either 0 or non-zero,
as the corresponding attribute is on or off. The nine
parameters are, in order: standout, underline, reverse,
blink, dim, bold, blank, protect, alternate character set.
Not all modes need to be supported by sgr; only those
for which corresponding separate attribute commands exist
should be supported. For example, let&rsquo;s assume that
the terminal in question needs the following escape
sequences to turn on various modes.

Note that each
escape sequence requires a 0 to turn off other modes
before turning on its own mode. Also note that, as suggested
above, standout is set up to be the combination of
reverse and dim. Also, because this terminal
has no bold mode, bold is set up as the
combination of reverse and underline. In
addition, to allow combinations, such as
underline+blink, the sequence to use would be
\E[0;3;5m. The terminal doesn&rsquo;t have
protect mode, either, but that cannot be simulated in
any way, so p8 is ignored. The altcharset mode
is different in that it is either ^O or ^N,
depending on whether it is off or on. If all modes were to
be turned on, the sequence would be
\E[0;3;4;5;7;8m^N.

Now look at
when different sequences are output. For example, ;3
is output when either p2 or p6 is true, that
is, if either underline or bold modes are
turned on. Writing out the above sequences, along with their
dependencies, gives the following:

Putting this
all together into the sgr sequence gives:

sgr=\E[0%?%p2%p6%|%t;3%;%?%p1%p3%|%p6%
|%t;4%;%?%p5%t;5%;%?%p1%p5%
|%t;7%;%?%p7%t;8%;m%?%p9%t^N%e^O%;,

Remember that
sgr and sgr0 must always be specified.

Section 1-8:
Keypad 
If the device has a keypad that transmits sequences when the
keys are pressed, this information can also be specified.
Note that it is not possible to handle devices where the
keypad only works in local (this applies, for example, to
the unshifted Hewlett-Packard 2621 keys). If the keypad can
be set to transmit or not transmit, specify these sequences
as smkx and rmkx. Otherwise the keypad is
assumed to always transmit.

The sequences
sent by the left arrow, right arrow, up arrow, down arrow,
and home keys can be given as kcub1, kcuf1, kcuu1,
kcud1,and khome, respectively. If there are
function keys such as f0, f1, ..., f63, the sequences they
send can be specified as kf0, kf1, ..., kf63. If the
first 11 keys have labels other than the default f0 through
f10, the labels can be given as lf0, lf1, ..., lf10.
The codes transmitted by certain other special keys can be
given: kll (home down), kbs (backspace),
ktbc (clear all tabs), kctab (clear the tab
stop in this column), kclr (clear screen or erase
key), kdch1 (delete character), kdl1 (delete
line), krmir (exit insert mode), kel (clear to
end of line), ked (clear to end of screen),
kich1 (insert character or enter insert mode),
kil1 (insert line), knp (next page),
kpp (previous page), kind (scroll
forward/down), kri (scroll backward/up), khts
(set a tab stop in this column). In addition, if the keypad
has a 3 by 3 array of keys including the four arrow keys,
the other five keys can be given as ka1, ka3,
kb2, kc1, and kc3. These keys are
useful when the effects of a 3 by 3 directional pad are
needed. Further keys are defined above in the capabilities
list.

Strings to
program function keys can be specified as pfkey,
pfloc, and pfx. A string to program screen
labels should be specified as pln. Each of these
strings takes two parameters: a function key identifier and
a string to program it with. pfkey causes pressing
the given key to be the same as the user typing the given
string; pfloc causes the string to be executed by the
terminal in local mode; and pfx causes the string to
be transmitted to the computer. The capabilities
nlab, lw and lh define the number of
programmable screen labels and their width and height. If
there are commands to turn the labels on and off, give them
in smln and rmln. smln is normally
output after one or more pln sequences to make sure
that the change becomes visible.

Section 1-9:
Tabs and Initialization 
If the device has hardware tabs, the command to advance to
the next tab stop can be given as ht (usually control
I). A &rsquo;&rsquo;backtab&rsquo;&rsquo; command that moves
leftward to the next tab stop can be given as cbt. By
convention, if tty modes show that tabs are being expanded
by the computer rather than being sent to the device,
programs should not use ht or cbt (even if
they are present) because the user may not have the tab
stops properly set. If the device has hardware tabs that are
initially set every n spaces when the device is
powered up, the numeric parameter it is given,
showing the number of spaces the tabs are set to. This is
normally used by tput init (see tput(1)) to
determine whether to set the mode for hardware tab expansion
and whether to set the tab stops. If the device has tab
stops that can be saved in nonvolatile memory, the
terminfo description can assume that they are
properly set. If there are commands to set and clear tab
stops, they can be given as tbc (clear all tab stops)
and hts (set a tab stop in the current column of
every row).

Other
capabilities include: is1, is2, and
is3, initialization strings for the device;
iprog, the path name of a program to be run to
initialize the device; and if, the name of a file
containing long initialization strings. These strings are
expected to set the device into modes consistent with the
rest of the terminfo description. They must be sent
to the device each time the user logs in and be output in
the following order: run the program iprog; output
is1; output is2; set the margins using
mgc, smgl and smgr; set the tabs using
tbc and hts; print the file if; and
finally output is3. This is usually done using the
init option of tput.

Most
initialization is done with is2. Special device modes
can be set up without duplicating strings by putting the
common sequences in is2 and special cases in
is1 and is3. Sequences that do a reset from a
totally unknown state can be given as rs1,
rs2, rf, and rs3, analogous to
is1, is2, is3, and if. (The
method using files, if and rf, is used for a
few terminals, from /usr/share/lib/tabset/*; however,
the recommended method is to use the initialization and
reset strings.) These strings are output by tput
reset, which is used when the terminal gets into a wedged
state. Commands are normally placed in rs1,
rs2, rs3, and rf only if they produce
annoying effects on the screen and are not necessary when
logging in. For example, the command to set a terminal into
80-column mode would normally be part of is2, but on
some terminals it causes an annoying glitch on the screen
and is not normally needed because the terminal is usually
already in 80-column mode.

If a more
complex sequence is needed to set the tabs than can be
described by using tbc and hts, the sequence
can be placed in is2 or if.

Any margin can
be cleared with mgc. (For instructions on how to
specify commands to set and clear margins, see
"Margins" below under "PRINTER
CAPABILITIES.")

Section
1-10: Delays 
Certain capabilities control padding in the tty
driver. These are primarily needed by hard-copy terminals,
and are used by tput init to set tty modes
appropriately. Delays embedded in the capabilities
cr, ind, cub1, ff, and
tab can be used to set the appropriate delay bits to
be set in the tty driver. If pb (padding baud rate)
is given, these values can be ignored at baud rates below
the value of pb.

Section
1-11: Status Lines 
If the terminal has an extra &rsquo;&rsquo;status
line&rsquo;&rsquo; that is not normally used by software,
this fact can be indicated. If the status line is viewed as
an extra line below the bottom line, into which one can
cursor address normally (such as the Heathkit h19&rsquo;s
25th line, or the 24th line of a VT100 which is set to a
23-line scrolling region), the capability hs should
be given. Special strings that go to a given column of the
status line and return from the status line can be given as
tsl and fsl. (fsl must leave the cursor
position in the same place it was before tsl. If
necessary, the sc and rc strings can be
included in tsl and fsl to get this effect.)
The capability tsl takes one parameter, which is the
column number of the status line the cursor is to be moved
to.

If escape
sequences and other special commands, such as tab, work
while in the status line, the flag eslok can be
given. A string which turns off the status line (or
otherwise erases its contents) should be given as
dsl. If the terminal has commands to save and restore
the position of the cursor, give them as sc and
rc. The status line is normally assumed to be the
same width as the rest of the screen, for example,
cols. If the status line is a different width
(possibly because the terminal does not allow an entire line
to be loaded) the width, in columns, can be indicated with
the numeric parameter wsl.

Section
1-12: Line Graphics 
If the device has a line drawing alternate character set,
the mapping of glyph to character would be given in
acsc. The definition of this string is based on the
alternate character set used in the DEC VT100 terminal,
extended slightly with some characters from the AT&T
4410v1 terminal.

The best way to
describe a new device&rsquo;s line graphics set is to add a
third column to the above table with the characters for the
new device that produce the appropriate glyph when the
device is in the alternate character set mode. For
example,

Now write down
the characters left to right, as in
&rsquo;&rsquo;acsc=lRmFkTjGq\,x.&rsquo;&rsquo;.

In addition,
terminfo allows you to define multiple character
sets. See Section 2-5 for details.

Section
1-13: Color Manipulation 
Let us define two methods of color manipulation: the
Tektronix method and the HP method. The Tektronix method
uses a set of N predefined colors (usually 8) from which a
user can select "current" foreground and
background colors. Thus a terminal can support up to N
colors mixed into N*N color-pairs to be displayed on the
screen at the same time. When using an HP method the user
cannot define the foreground independently of the
background, or vice-versa. Instead, the user must define an
entire color-pair at once. Up to M color-pairs, made from
2*M different colors, can be defined this way. Most existing
color terminals belong to one of these two classes of
terminals.

The numeric
variables colors and pairs define the number
of colors and color-pairs that can be displayed on the
screen at the same time. If a terminal can change the
definition of a color (for example, the Tektronix 4100 and
4200 series terminals), this should be specified with
ccc (can change color). To change the definition of a
color (Tektronix 4200 method), use initc (initialize
color). It requires four arguments: color number (ranging
from 0 to colors&minus;1) and three RGB (red, green,
and blue) values or three HLS colors (Hue, Lightness,
Saturation). Ranges of RGB and HLS values are terminal
dependent.

Tektronix 4100
series terminals only use HLS color notation. For such
terminals (or dual-mode terminals to be operated in HLS
mode) one must define a boolean variable hls; that
would instruct the curses init_color routine to
convert its RGB arguments to HLS before sending them to the
terminal. The last three arguments to the initc
string would then be HLS values.

If a terminal
can change the definitions of colors, but uses a color
notation different from RGB and HLS, a mapping to either RGB
or HLS must be developed.

To set current
foreground or background to a given color, use setaf
(set ANSI foreground) and setab (set ANSI
background). They require one parameter: the number of the
color. To initialize a color-pair (HP method), use
initp (initialize pair). It requires seven
parameters: the number of a color-pair (range=0 to
pairs&minus;1), and six RGB values: three for the
foreground followed by three for the background. (Each of
these groups of three should be in the order RGB.) When
initc or initp are used, RGB or HLS arguments
should be in the order "red, green, blue" or
"hue, lightness, saturation"), respectively. To
make a color-pair current, use scp (set color-pair).
It takes one parameter, the number of a color-pair.

Some terminals
(for example, most color terminal emulators for PCs) erase
areas of the screen with current background color. In such
cases, bce (background color erase) should be
defined. The variable op (original pair) contains a
sequence for setting the foreground and the background
colors to what they were at the terminal start-up time.
Similarly, oc (original colors) contains a control
sequence for setting all colors (for the Tektronix method)
or color-pairs (for the HP method) to the values they had at
the terminal start-up time.

Some color
terminals substitute color for video attributes. Such video
attributes should not be combined with colors. Information
about these video attributes should be packed into the
ncv (no color video) variable. There is a one-to-one
correspondence between the nine least significant bits of
that variable and the video attributes. The following table
depicts this correspondence.

When a
particular video attribute should not be used with colors,
the corresponding ncv bit should be set to 1;
otherwise it should be set to zero. To determine the
information to pack into the ncv variable, you must
add together the decimal values corresponding to those
attributes that cannot coexist with colors. For example, if
the terminal uses colors to simulate reverse video (bit
number 2 and decimal value 4) and bold (bit number 5 and
decimal value 32), the resulting value for ncv will
be 36 (4 + 32).

Section
1-14: Miscellaneous 
If the terminal requires other than a null (zero) character
as a pad, then this can be given as pad. Only the
first character of the pad string is used. If the
terminal does not have a pad character, specify
npc.

If the terminal
can move up or down half a line, this can be indicated with
hu (half-line up) and hd (half-line down).
This is primarily useful for superscripts and subscripts on
hardcopy terminals. If a hardcopy terminal can eject to the
next page (form feed), give this as ff (usually
control L).

If there is a
command to repeat a given character a given number of times
(to save time transmitting a large number of identical
characters) this can be indicated with the parameterized
string rep. The first parameter is the character to
be repeated and the second is the number of times to repeat
it. Thus, tparm(repeat_char, &rsquo;x&rsquo;, 10) is
the same as xxxxxxxxxx.

If the terminal
has a settable command character, such as the Tektronix
4025, this can be indicated with cmdch. A prototype
command character is chosen which is used in all
capabilities. This character is given in the cmdch
capability to identify it. The following convention is
supported on some systems: If the environment variable
CC exists, all occurrences of the prototype character
are replaced with the character in CC.

Terminal
descriptions that do not represent a specific kind of known
terminal, such as switch, dialup,
patch, and network, should include the
gn (generic) capability so that programs can complain
that they do not know how to talk to the terminal. (This
capability does not apply to virtual terminal
descriptions for which the escape sequences are known.) If
the terminal is one of those supported by the system virtual
terminal protocol, the terminal number can be given as
vt. A line-turn-around sequence to be transmitted
before doing reads should be specified in rfi.

If the device
uses xon/xoff handshaking for flow control, give xon.
Padding information should still be included so that
routines can make better decisions about costs, but actual
pad characters will not be transmitted. Sequences to turn on
and off xon/xoff handshaking may be given in smxon
and rmxon. If the characters used for handshaking are
not ^S and ^Q, they may be specified with
xonc and xoffc.

If the terminal
has a &rsquo;&rsquo;meta key&rsquo;&rsquo; which acts as a
shift key, setting the 8th bit of any character transmitted,
this fact can be indicated with km. Otherwise,
software will assume that the 8th bit is parity and it will
usually be cleared. If strings exist to turn this
&rsquo;&rsquo;meta mode&rsquo;&rsquo; on and off, they can
be given as smm and rmm.

If the terminal
has more lines of memory than will fit on the screen at
once, the number of lines of memory can be indicated with
lm. A value of lm#0 indicates that the number
of lines is not fixed, but that there is still more memory
than fits on the screen.

Media copy
strings which control an auxiliary printer connected to the
terminal can be given as mc0: print the contents of
the screen, mc4: turn off the printer, and
mc5: turn on the printer. When the printer is on, all
text sent to the terminal will be sent to the printer. A
variation, mc5p, takes one parameter, and leaves the
printer on for as many characters as the value of the
parameter, then turns the printer off. The parameter should
not exceed 255. If the text is not displayed on the terminal
screen when the printer is on, specify mc5i (silent
printer). All text, including mc4, is transparently
passed to the printer while an mc5p is in effect.

Section
1-15: Special Cases 
The working model used by terminfo fits most
terminals reasonably well. However, some terminals do not
completely match that model, requiring special support by
terminfo. These are not meant to be construed as
deficiencies in the terminals; they are just differences
between the working model and the actual hardware. They may
be unusual devices or, for some reason, do not have all the
features of the terminfo model implemented.

Terminals that
cannot display tilde (~) characters, such as certain
Hazeltine terminals, should indicate hz.

Terminals that
ignore a linefeed immediately after an am wrap, such
as the Concept 100, should indicate xenl. Those
terminals whose cursor remains on the right-most column
until another character has been received, rather than
wrapping immediately upon receiving the right-most
character, such as the VT100, should also indicate
xenl.

If el is
required to get rid of standout (instead of writing normal
text on top of it), xhp should be given.

Those Teleray
terminals whose tabs turn all characters moved over to
blanks, should indicate xt (destructive tabs). This
capability is also taken to mean that it is not possible to
position the cursor on top of a &rsquo;&rsquo;magic
cookie.&rsquo;&rsquo; Therefore, to erase standout mode, it
is necessary, instead, to use delete and insert line.

Those Beehive
Superbee terminals which do not transmit the escape or
control&minus;C characters, should specify xsb,
indicating that the f1 key is to be used for escape and the
f2 key for control C.

Section
1-16: Similar Terminals 
If there are two very similar terminals, one can be defined
as being just like the other with certain exceptions. The
string capability use can be given with the name of
the similar terminal. The capabilities given before
use override those in the terminal type invoked by
use. A capability can be canceled by placing
xx@ to the left of the capability definition,
where xx is the capability. For example, the
entry

att4424-2|Teletype4424
in display function group ii, 
rev@, sgr@, smul@, use=att4424,

defines an
AT&T4424 terminal that does not have the rev,
sgr, and smul capabilities, and hence cannot
do highlighting. This is useful for different modes for a
terminal, or for different user preferences. More than one
use capability may be given.

PART 2:
PRINTER CAPABILITIES 
The terminfo database allows you to define
capabilities of printers as well as terminals. To find out
what capabilities are available for printers as well as for
terminals, see the two lists under "DEVICE
CAPABILITIES" that list capabilities by variable and by
capability name.

Section 2-1:
Rounding Values 
Because parameterized string capabilities work only with
integer values, we recommend that terminfo designers
create strings that expect numeric values that have been
rounded. Application designers should note this and should
always round values to the nearest integer before using them
with a parameterized string capability.

Section 2-2:
Printer Resolution 
A printer&rsquo;s resolution is defined to be the smallest
spacing of characters it can achieve. In general printers
have independent resolution horizontally and vertically.
Thus the vertical resolution of a printer can be determined
by measuring the smallest achievable distance between
consecutive printing baselines, while the horizontal
resolution can be determined by measuring the smallest
achievable distance between the left-most edges of
consecutive printed, identical, characters.

All printers
are assumed to be capable of printing with a uniform
horizontal and vertical resolution. The view of printing
that terminfo currently presents is one of printing
inside a uniform matrix: All characters are printed at fixed
positions relative to each &rsquo;&rsquo;cell&rsquo;&rsquo;
in the matrix; furthermore, each cell has the same size
given by the smallest horizontal and vertical step sizes
dictated by the resolution. (The cell size can be changed as
will be seen later.)

Many printers
are capable of &rsquo;&rsquo;proportional
printing,&rsquo;&rsquo; where the horizontal spacing depends
on the size of the character last printed. terminfo
does not make use of this capability, although it does
provide enough capability definitions to allow an
application to simulate proportional printing.

A printer must
not only be able to print characters as close together as
the horizontal and vertical resolutions suggest, but also of
&rsquo;&rsquo;moving&rsquo;&rsquo; to a position an integral
multiple of the smallest distance away from a previous
position. Thus printed characters can be spaced apart a
distance that is an integral multiple of the smallest
distance, up to the length or width of a single page.

Some printers
can have different resolutions depending on different
&rsquo;&rsquo;modes.&rsquo;&rsquo; In &rsquo;&rsquo;normal
mode,&rsquo;&rsquo; the existing terminfo
capabilities are assumed to work on columns and lines, just
like a video terminal. Thus the old lines capability
would give the length of a page in lines, and the
cols capability would give the width of a page in
columns. In &rsquo;&rsquo;micro mode,&rsquo;&rsquo; many
terminfo capabilities work on increments of lines and
columns. With some printers the micro mode may be
concomitant with normal mode, so that all the capabilities
work at the same time.

Section 2-3:
Specifying Printer Resolution 
The printing resolution of a printer is given in several
ways. Each specifies the resolution as the number of
smallest steps per distance:

Specification
of Printer Resolution 
Characteristic Number of Smallest Steps

orhi Steps per
inch horizontally 
orvi Steps per inch vertically 
orc Steps per column 
orl Steps per line

When printing
in normal mode, each character printed causes movement to
the next column, except in special cases described later;
the distance moved is the same as the per-column resolution.
Some printers cause an automatic movement to the next line
when a character is printed in the rightmost position; the
distance moved vertically is the same as the per-line
resolution. When printing in micro mode, these distances can
be different, and may be zero for some printers.

Specification
of Printer Resolution 
Automatic Motion after Printing

Normal
Mode:

orc Steps moved
horizontally 
orl Steps moved vertically

Micro Mode:

mcs Steps moved
horizontally 
mls Steps moved vertically

Some printers
are capable of printing wide characters. The distance moved
when a wide character is printed in normal mode may be
different from when a regular width character is printed.
The distance moved when a wide character is printed in micro
mode may also be different from when a regular character is
printed in micro mode, but the differences are assumed to be
related: If the distance moved for a regular character is
the same whether in normal mode or micro mode
(mcs=orc), then the distance moved for a wide
character is also the same whether in normal mode or micro
mode. This doesn&rsquo;t mean the normal character distance
is necessarily the same as the wide character distance, just
that the distances don&rsquo;t change with a change in
normal to micro mode. However, if the distance moved for a
regular character is different in micro mode from the
distance moved in normal mode (mcsorc),
the micro mode distance is assumed to be the same for a wide
character printed in micro mode, as the table below
shows.

Specification
of Printer Resolution 
Automatic Motion after Printing Wide Character

Normal Mode or
Micro Mode (mcs = orc): 
sp 
widcs Steps moved horizontally

Micro Mode (mcs

mcs Steps moved
horizontally

There may be
control sequences to change the number of columns per inch
(the character pitch) and to change the number of lines per
inch (the line pitch). If these are used, the resolution of
the printer changes, but the type of change depends on the
printer:

Specification
of Printer Resolution 
Changing the Character/Line Pitches

cpi Change
character pitch 
cpix If set, cpi changes orhi, otherwise changes 
orc 
lpi Change line pitch 
lpix If set, lpi changes orvi, otherwise changes 
orl 
chr Change steps per column 
cvr Change steps per line

The cpi
and lpi string capabilities are each used with a
single argument, the pitch in columns (or characters) and
lines per inch, respectively. The chr and cvr
string capabilities are each used with a single argument,
the number of steps per column and line, respectively.

Using any of
the control sequences in these strings will imply a change
in some of the values of orc, orhi,
orl, and orvi. Also, the distance moved when a
wide character is printed, widcs, changes in relation
to orc. The distance moved when a character is
printed in micro mode, mcs, changes similarly, with
one exception: if the distance is 0 or 1, then no change is
assumed (see items marked with * in the following
table).

Programs that
use cpi, lpi, chr, or cvr should
recalculate the printer resolution (and should recalculate
other values&mdash; see "Effect of Changing Printing
Resolution" under "Dot-Mapped Graphics").

Specification
of Printer Resolution 
Effects of Changing the Character/Line Pitches

Before
After

Using cpi with
cpix clear: 
$bold orhi &rsquo;$ orhi 
$bold orc &rsquo;$ $bold orc = bold orhi over V sub italic
cpi$

Using cpi with
cpix set: 
$bold orhi &rsquo;$ $bold orhi = bold orc cdot V sub italic
cpi$ 
$bold orc &rsquo;$ $bold orc$

Using lpi with
lpix clear: 
$bold orvi &rsquo;$ $bold orvi$ 
$bold orl &rsquo;$ $bold orl = bold orvi over V sub italic
lpi$

Using lpi with
lpix set: 
$bold orvi &rsquo;$ $bold orvi = bold orl cdot V sub italic
lpi$ 
$bold orl &rsquo;$ $bold orl$

Using chr: 
$bold orhi &rsquo;$ $bold orhi$ 
$bold orc &rsquo;$ $V sub italic chr$

Using cvr: 
$bold orvi &rsquo;$ $bold orvi$ 
$bold orl &rsquo;$ $V sub italic cvr$

Using cpi or
chr: 
$bold widcs &rsquo;$ $bold widcs = bold {widcs &rsquo;} bold
orc over { bold {orc &rsquo;} }$ 
$bold mcs &rsquo;$ $bold mcs = bold {mcs &rsquo;} bold orc
over { bold {orc &rsquo;} }$

$V sub italic
cpi$, $V sub italic lpi$, $V sub italic chr$, and $V sub
italic cvr$ are the arguments used with cpi,
lpi, chr, and cvr, respectively. The
prime marks (&rsquo;) indicate the old values.

Section 2-4:
Capabilities that Cause Movement 
In the following descriptions,
&rsquo;&rsquo;movement&rsquo;&rsquo; refers to the motion of
the &rsquo;&rsquo;current position.&rsquo;&rsquo; With video
terminals this would be the cursor; with some printers this
is the carriage position. Other printers have different
equivalents. In general, the current position is where a
character would be displayed if printed.

terminfo
has string capabilities for control sequences that cause
movement a number of full columns or lines. It also has
equivalent string capabilities for control sequences that
cause movement a number of smallest steps.

String
Capabilities for Motion

mcub1 Move 1
step left 
mcuf1 Move 1 step right 
mcuu1 Move 1 step up 
mcud1 Move 1 step down 
mcub Move N steps left 
mcuf Move N steps right 
mcuu Move N steps up 
mcud Move N steps down 
mhpa Move N steps from the left 
mvpa Move N steps from the top

The latter six
strings are each used with a single argument, N.

Sometimes the
motion is limited to less than the width or length of a
page. Also, some printers don&rsquo;t accept absolute motion
to the left of the current position. terminfo has
capabilities for specifying these limits.

Limits to
Motion

mjump Limit on
use of mcub1, mcuf1, mcuu1, mcud1 
maddr Limit on use of mhpa, mvpa 
xhpa If set, hpa and mhpa can&rsquo;t move left 
xvpa If set, vpa and mvpa can&rsquo;t move up

If a printer
needs to be in a &rsquo;&rsquo;micro mode&rsquo;&rsquo; for
the motion capabilities described above to work, there are
string capabilities defined to contain the control sequence
to enter and exit this mode. A boolean is available for
those printers where using a carriage return causes an
automatic return to normal mode.

Entering/Exiting
Micro Mode

smicm Enter
micro mode 
rmicm Exit micro mode 
crxm Using cr exits micro mode

The movement
made when a character is printed in the rightmost position
varies among printers. Some make no movement, some move to
the beginning of the next line, others move to the beginning
of the same line. terminfo has boolean capabilities
for describing all three cases.

What Happens
After Character 
Printed in Rightmost Position

sam Automatic
move to beginning of same line

Some printers
can be put in a mode where the normal direction of motion is
reversed. This mode can be especially useful when there are
no capabilities for leftward or upward motion, because those
capabilities can be built from the motion reversal
capability and the rightward or downward motion
capabilities. It is best to leave it up to an application to
build the leftward or upward capabilities, though, and not
enter them in the terminfo database. This allows
several reverse motions to be strung together without
intervening wasted steps that leave and reenter reverse
mode.

Entering/Exiting
Reverse Modes

slm Reverse
sense of horizontal motions 
rlm Restore sense of horizontal motions 
sum Reverse sense of vertical motions 
rum Restore sense of vertical motions

While sense of
horizontal motions reversed: 
mcub1 Move 1 step right 
mcuf1 Move 1 step left 
mcub Move N steps right 
mcuf Move N steps left 
cub1 Move 1 column right 
cuf1 Move 1 column left 
cub Move N columns right 
cuf Move N columns left

While sense of
vertical motions reversed: 
mcuu1 Move 1 step down 
mcud1 Move 1 step up 
mcuu Move N steps down 
mcud Move N steps up 
cuu1 Move 1 line down 
cud1 Move 1 line up 
cuu Move N lines down 
cud Move N lines up

The reverse
motion modes should not affect the mvpa and
mhpa absolute motion capabilities. The reverse
vertical motion mode should, however, also reverse the
action of the line &rsquo;&rsquo;wrapping&rsquo;&rsquo; that
occurs when a character is printed in the right-most
position. Thus printers that have the standard
terminfo capability am defined should
experience motion to the beginning of the previous line when
a character is printed in the right-most position under
reverse vertical motion mode.

The action when
any other motion capabilities are used in reverse motion
modes is not defined; thus, programs must exit reverse
motion modes before using other motion capabilities.

Two
miscellaneous capabilities complete the list of new motion
capabilities. One of these is needed for printers that move
the current position to the beginning of a line when certain
control characters, such as
&rsquo;&rsquo;line-feed&rsquo;&rsquo; or
&rsquo;&rsquo;form-feed,&rsquo;&rsquo; are used. The other
is used for the capability of suspending the motion that
normally occurs after printing a character.

Miscellaneous
Motion Strings

docr List of
control characters causing cr 
zerom Prevent auto motion after printing next single
character

Margins 
terminfo provides two strings for setting margins on
terminals: one for the left and one for the right margin.
Printers, however, have two additional margins, for the top
and bottom margins of each page. Furthermore, some printers
require not using motion strings to move the current
position to a margin and then fixing the margin there, but
require the specification of where a margin should be
regardless of the current position. Therefore
terminfo offers six additional strings for defining
margins with printers.

Setting
Margins

smgl Set left
margin at current column 
smgr Set right margin at current column 
smgb Set bottom margin at current line 
smgt Set top margin at current line 
smgbp Set bottom margin at line N 
smglp Set left margin at column N 
smgrp Set right margin at column N 
smgtp Set top margin at line N

The last four
strings are used with one or more arguments that give the
position of the margin or margins to set. If both of
smglp and smgrp are set, each is used with a
single argument, N, that gives the column number of
the left and right margin, respectively. If both of
smgtp and smgbp are set, each is used to set
the top and bottom margin, respectively: smgtp is
used with a single argument, N, the line number of
the top margin; however, smgbp is used with two
arguments, N and M, that give the line number
of the bottom margin, the first counting from the top of the
page and the second counting from the bottom. This
accommodates the two styles of specifying the bottom margin
in different manufacturers&rsquo; printers. When coding a
terminfo entry for a printer that has a settable
bottom margin, only the first or second parameter should be
used, depending on the printer. When writing an application
that uses smgbp to set the bottom margin, both
arguments must be given.

If only one of
smglp and smgrp is set, then it is used with
two arguments, the column number of the left and right
margins, in that order. Likewise, if only one of
smgtp and smgbp is set, then it is used with
two arguments that give the top and bottom margins, in that
order, counting from the top of the page. Thus when coding a
terminfo entry for a printer that requires setting
both left and right or top and bottom margins
simultaneously, only one of smglp and smgrp or
smgtp and smgbp should be defined; the other
should be left blank. When writing an application that uses
these string capabilities, the pairs should be first checked
to see if each in the pair is set or only one is set, and
should then be used accordingly.

In counting
lines or columns, line zero is the top line and column zero
is the left-most column. A zero value for the second
argument with smgbp means the bottom line of the
page.

All margins can
be cleared with mgc.

Shadows,
Italics, Wide Characters 
Five new sets of strings describe the capabilities printers
have of enhancing printed text.

Enhanced
Printing

sshm Enter
shadow-printing mode 
rshm Exit shadow-printing mode 
sitm Enter italicizing mode 
ritm Exit italicizing mode 
swidm Enter wide character mode 
rwidm Exit wide character mode 
ssupm Enter superscript mode 
rsupm Exit superscript mode 
supcs List of characters available as superscripts 
ssubm Enter subscript mode 
rsubm Exit subscript mode 
subcs List of characters available as subscripts

If a printer
requires the sshm control sequence before every
character to be shadow-printed, the rshm string is
left blank. Thus programs that find a control sequence in
sshm but none in rshm should use the
sshm control sequence before every character to be
shadow-printed; otherwise, the sshm control sequence
should be used once before the set of characters to be
shadow-printed, followed by rshm. The same is also
true of each of the sitm/ritm,
swidm/rwidm, ssupm/rsupm, and
ssubm/ rsubm pairs.

Note that
terminfo also has a capability for printing
emboldened text (bold). While shadow printing and
emboldened printing are similar in that they
&rsquo;&rsquo;darken&rsquo;&rsquo; the text, many printers
produce these two types of print in slightly different ways.
Generally, emboldened printing is done by overstriking the
same character one or more times. Shadow printing likewise
usually involves overstriking, but with a slight movement up
and/or to the side so that the character is
&rsquo;&rsquo;fatter.&rsquo;&rsquo;

It is assumed
that enhanced printing modes are independent modes, so that
it would be possible, for instance, to shadow print
italicized subscripts.

As mentioned
earlier, the amount of motion automatically made after
printing a wide character should be given in
widcs.

If only a
subset of the printable ASCII characters can be printed as
superscripts or subscripts, they should be listed in
supcs or subcs strings, respectively. If the
ssupm or ssubm strings contain control
sequences, but the corresponding supcs or
subcs strings are empty, it is assumed that all
printable ASCII characters are available as superscripts or
subscripts.

Automatic
motion made after printing a superscript or subscript is
assumed to be the same as for regular characters. Thus, for
example, printing any of the following three examples will
result in equivalent motion:

Bi Bi
Bi

Note that the
existing msgr boolean capability describes whether
motion control sequences can be used while in
&rsquo;&rsquo;standout mode.&rsquo;&rsquo; This capability
is extended to cover the enhanced printing modes added here.
msgr should be set for those printers that accept any
motion control sequences without affecting shadow,
italicized, widened, superscript, or subscript printing.
Conversely, if msgr is not set, a program should end
these modes before attempting any motion.

Section 2-5:
Alternate Character Sets 
In addition to allowing you to define line graphics
(described in Section 1-12), terminfo lets you define
alternate character sets. The following capabilities cover
printers and terminals with multiple selectable or definable
character sets.

Alternate
Character Sets

scs Select
character set N 
scsd Start definition of character set N, M characters 
defc Define character A, B dots wide, descender D 
rcsd End definition of character set N 
csnm List of character set names 
daisy Printer has manually changed print-wheels

The scs,
rcsd, and csnm strings are used with a single
argument, N, a number from 0 to 63 that identifies
the character set. The scsd string is also used with
the argument N and another, M, that gives the
number of characters in the set. The defc string is
used with three arguments: A gives the ASCII code
representation for the character, B gives the width
of the character in dots, and D is zero or one
depending on whether the character is a
&rsquo;&rsquo;descender&rsquo;&rsquo; or not. The
defc string is also followed by a string of
&rsquo;&rsquo;image-data&rsquo;&rsquo; bytes that describe
how the character looks (see below).

Character set 0
is the default character set present after the printer has
been initialized. Not every printer has 64 character sets,
of course; using scs with an argument that
doesn&rsquo;t select an available character set should cause
a null result from tparm.

If a character
set has to be defined before it can be used, the scsd
control sequence is to be used before defining the character
set, and the rcsd is to be used after. They should
also cause a null result from tparm when used with an
argument N that doesn&rsquo;t apply. If a character
set still has to be selected after being defined, the
scs control sequence should follow the rcsd
control sequence. By examining the results of using each of
the scs, scsd, and rcsd strings with a
character set number in a call to tparm, a program
can determine which of the three are needed.

Between use of
the scsd and rcsd strings, the defc
string should be used to define each character. To print any
character on printers covered by terminfo, the ASCII
code is sent to the printer. This is true for characters in
an alternate set as well as
&rsquo;&rsquo;normal&rsquo;&rsquo; characters. Thus the
definition of a character includes the ASCII code that
represents it. In addition, the width of the character in
dots is given, along with an indication of whether the
character should descend below the print line (such as the
lower case letter &rsquo;&rsquo;g&rsquo;&rsquo; in most
character sets). The width of the character in dots also
indicates the number of image-data bytes that will follow
the defc string. These image-data bytes indicate
where in a dot-matrix pattern ink should be applied to
&rsquo;&rsquo;draw&rsquo;&rsquo; the character; the number
of these bytes and their form are defined below under
&rsquo;&rsquo;Dot-Mapped Graphics.&rsquo;&rsquo;

It&rsquo;s
easiest for the creator of terminfo entries to refer
to each character set by number; however, these numbers will
be meaningless to the application developer. The csnm
string alleviates this problem by providing names for each
number.

When used with
a character set number in a call to tparm, the
csnm string will produce the equivalent name. These
names should be used as a reference only. No naming
convention is implied, although anyone who creates a
terminfo entry for a printer should use names
consistent with the names found in user documents for the
printer. Application developers should allow a user to
specify a character set by number (leaving it up to the user
to examine the csnm string to determine the correct
number), or by name, where the application examines the
csnm string to determine the corresponding character
set number.

These
capabilities are likely to be used only with dot-matrix
printers. If they are not available, the strings should not
be defined. For printers that have manually changed
print-wheels or font cartridges, the boolean daisy is
set.

Section 2-6:
Dot-Matrix Graphics 
Dot-matrix printers typically have the capability of
reproducing &rsquo;&rsquo;raster-graphics&rsquo;&rsquo;
images. Three new numeric capabilities and three new string
capabilities can help a program draw raster-graphics images
independent of the type of dot-matrix printer or the number
of pins or dots the printer can handle at one time.

Dot-Matrix
Graphics

npins Number of
pins, N, in print-head 
spinv Spacing of pins vertically in pins per inch 
spinh Spacing of dots horizontally in dots per inch 
porder Matches software bits to print-head pins 
sbim Start printing bit image graphics, B bits wide 
rbim End printing bit image graphics

The sbim
sring is used with a single argument, B, the width of
the image in dots.

The model of
dot-matrix or raster-graphics that terminfo presents
is similar to the technique used for most dot-matrix
printers: each pass of the printer&rsquo;s print-head is
assumed to produce a dot-matrix that is N dots high
and B dots wide. This is typically a wide, squat,
rectangle of dots. The height of this rectangle in dots will
vary from one printer to the next; this is given in the
npins numeric capability. The size of the rectangle
in fractions of an inch will also vary; it can be deduced
from the spinv and spinh numeric capabilities.
With these three values an application can divide a complete
raster-graphics image into several horizontal strips,
perhaps interpolating to account for different dot spacing
vertically and horizontally.

The sbim
and rbim strings are used to start and end a
dot-matrix image, respectively. The sbim string is
used with a single argument that gives the width of the
dot-matrix in dots. A sequence of &rsquo;&rsquo;image-data
bytes&rsquo;&rsquo; are sent to the printer after the
sbim string and before the rbim string. The
number of bytes is a integral multiple of the width of the
dot-matrix; the multiple and the form of each byte is
determined by the porder string as described
below.

The
porder string is a comma separated list of pin
numbers optionally followed by an numerical offset. The
offset, if given, is separated from the list with a
semicolon. The position of each pin number in the list
corresponds to a bit in an 8-bit data byte. The pins are
numbered consecutively from 1 to npins, with 1 being
the top pin. Note that the term
&rsquo;&rsquo;pin&rsquo;&rsquo; is used loosely here;
&rsquo;&rsquo;ink-jet&rsquo;&rsquo; dot-matrix printers
don&rsquo;t have pins, but can be considered to have an
equivalent method of applying a single dot of ink to paper.
The bit positions in porder are in groups of 8, with
the first position in each group the most significant bit
and the last position the least significant bit. An
application produces 8-bit bytes in the order of the groups
in porder.

An application
computes the &rsquo;&rsquo;image-data bytes&rsquo;&rsquo;
from the internal image, mapping vertical dot positions in
each print-head pass into 8-bit bytes, using a 1 bit where
ink should be applied and 0 where no ink should be applied.
This can be reversed (0 bit for ink, 1 bit for no ink) by
giving a negative pin number. If a position is skipped in
porder, a 0 bit is used. If a position has a lower
case &rsquo;x&rsquo; instead of a pin number, a 1 bit is
used in the skipped position. For consistency, a lower case
&rsquo;o&rsquo; can be used to represent a 0 filled, skipped
bit. There must be a multiple of 8 bit positions used or
skipped in porder; if not, 0 bits are used to fill
the last byte in the least significant bits. The offset, if
given, is added to each data byte; the offset can be
negative.

Some examples
may help clarify the use of the porder string. The
AT&T 470, AT&T 475 and C.Itoh 8510 printers provide
eight pins for graphics. The pins are identified top to
bottom by the 8 bits in a byte, from least significant to
most. The porder strings for these printers would be
8,7,6,5,4,3,2,1. The AT&T 478 and AT&T 479
printers also provide eight pins for graphics. However, the
pins are identified in the reverse order. The porder
strings for these printers would be 1,2,3,4,5,6,7,8.
The AT&T 5310, AT&T 5320, DEC LA100, and DEC LN03
printers provide six pins for graphics. The pins are
identified top to bottom by the decimal values 1, 2, 4, 8,
16 and 32. These correspond to the low six bits in an 8-bit
byte, although the decimal values are further offset by the
value 63. The porder string for these printers would
be ,,6,5,4,3,2,1;63, or alternately
o,o,6,5,4,3,2,1;63.

Section 2-7:
Effect of Changing Printing Resolution 
If the control sequences to change the character pitch or
the line pitch are used, the pin or dot spacing may
change:

Dot-Matrix
Graphics 
Changing the Character/Line Pitches

cpi Change
character pitch 
cpix If set, cpi changes spinh 
lpi Change line pitch 
lpix If set, lpi changes spinv

Programs that
use cpi or lpi should recalculate the dot
spacing:

Dot-Matrix
Graphics 
Effects of Changing the Character/Line Pitches

Before
After

Using cpi with
cpix clear: 
$bold spinh &rsquo;$ $bold spinh$

Using cpi with
cpix set: 
$bold spinh &rsquo;$ $bold spinh = bold spinh &rsquo; cdot
bold orhi over 
{ bold {orhi &rsquo;} }$

Using lpi with
lpix clear: 
$bold spinv &rsquo;$ $bold spinv$

Using lpi with
lpix set: 
$bold spinv &rsquo;$ $bold spinv = bold {spinv &rsquo;} cdot
bold orhi over 
{ bold {orhi &rsquo;}}$

Using chr: 
$bold spinh &rsquo;$ $bold spinh$

Using cvr: 
$bold spinv &rsquo;$ $bold spinv$

orhi&rsquo;
and orhi are the values of the horizontal resolution
in steps per inch, before using cpi and after using
cpi, respectively. Likewise, orvi&rsquo; and
orvi are the values of the vertical resolution in
steps per inch, before using lpi and after using
lpi, respectively. Thus, the changes in the dots per
inch for dot-matrix graphics follow the changes in steps per
inch for printer resolution.

Section 2-8:
Print Quality 
Many dot-matrix printers can alter the dot spacing of
printed text to produce near &rsquo;&rsquo;letter
quality&rsquo;&rsquo; printing or &rsquo;&rsquo;draft
quality&rsquo;&rsquo; printing. Usually it is important to
be able to choose one or the other because the rate of
printing generally falls off as the quality improves. There
are three new strings used to describe these
capabilities.

Print
Quality

snlq Set
near-letter quality print 
snrmq Set normal quality print 
sdrfq Set draft quality print

The
capabilities are listed in decreasing levels of quality. If
a printer doesn&rsquo;t have all three levels, one or two of
the strings should be left blank as appropriate.

Section 2-9:
Printing Rate and Buffer Size 
Because there is no standard protocol that can be used to
keep a program synchronized with a printer, and because
modern printers can buffer data before printing it, a
program generally cannot determine at any time what has been
printed. Two new numeric capabilities can help a program
estimate what has been printed.

Print
Rate/Buffer Size

cps Nominal
print rate in characters per second 
bufsz Buffer capacity in characters

cps is
the nominal or average rate at which the printer prints
characters; if this value is not given, the rate should be
estimated at one-tenth the prevailing baud rate.
bufsz is the maximum number of subsequent characters
buffered before the guaranteed printing of an earlier
character, assuming proper flow control has been used. If
this value is not given it is assumed that the printer does
not buffer characters, but prints them as they are
received.

As an example,
if a printer has a 1000-character buffer, then sending the
letter &rsquo;&rsquo;a&rsquo;&rsquo; followed by 1000
additional characters is guaranteed to cause the letter
&rsquo;&rsquo;a&rsquo;&rsquo; to print. If the same printer
prints at the rate of 100 characters per second, then it
should take 10 seconds to print all the characters in the
buffer, less if the buffer is not full. By keeping track of
the characters sent to a printer, and knowing the print rate
and buffer size, a program can synchronize itself with the
printer.

Note that most
printer manufacturers advertise the maximum print rate, not
the nominal print rate. A good way to get a value to put in
for cps is to generate a few pages of text, count the
number of printable characters, and then see how long it
takes to print the text.

Applications
that use these values should recognize the variability in
the print rate. Straight text, in short lines, with no
embedded control sequences will probably print at close to
the advertised print rate and probably faster than the rate
in cps. Graphics data with a lot of control
sequences, or very long lines of text, will print at well
below the advertised rate and below the rate in cps.
If the application is using cps to decide how long it
should take a printer to print a block of text, the
application should pad the estimate. If the application is
using cps to decide how much text has already been
printed, it should shrink the estimate. The application will
thus err in favor of the user, who wants, above all, to see
all the output in its correct place.

FILES

/usr/share/lib/terminfo/?/*

compiled terminal description
database

/usr/share/lib/.COREterm/?/*

subset of compiled terminal
description database

/usr/share/lib/tabset/*

tab settings for some
terminals, in a format appropriate to be output to the
terminal (escape sequences that set margins and tabs)

SEE ALSO

ls(1),
pg(1), stty(1), tput(1), tty(1),
vi(1), infocmp(1M), tic(1M),
printf(3C), curses(3CURSES),
curses(3XCURSES)

NOTES

The most
effective way to prepare a terminal description is by
imitating the description of a similar terminal in
terminfo and to build up a description gradually,
using partial descriptions with a screen oriented editor,
such as vi, to check that they are correct. To easily
test a new terminal description the environment variable
TERMINFO can be set to the pathname of a directory
containing the compiled description, and programs will look
there rather than in /usr/share/lib/terminfo.