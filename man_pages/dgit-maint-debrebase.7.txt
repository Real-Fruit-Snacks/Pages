NAME

dgit - tutorial
for package maintainers, using a workflow centered around
git-debrebase(1)

INTRODUCTION

This document
describes elements of a workflow for maintaining a
non-native Debian package using dgit. We maintain the
Debian delta as a series of git commits on our master
branch. We use git-debrebase(1) to shuffle our branch
such that this series of git commits appears at the end of
the branch. All the public git history is fast-forwarding,
i.e., we do not rewrite and force-push.

Some advantages
of this workflow:

&bull;

Manipulate the delta queue using the full power of
git-rebase(1), instead of relying on quilt(1),
and without having to switch back and forth between
patches-applied and patches-unapplied branches when
committing changes and trying to build, as with
gbp-pq(1). 

&bull;

If you are using 3.0 (quilt), provide your delta queue
as a properly separated series of quilt patches in the
source package that you upload to the archive (unlike with
dgit-maint-merge(7)). 

&bull;

Avoid the git tree being dirtied by the application or
unapplication of patches, as they are always applied.

&bull;

Benefit from dgit&rsquo;s safety catches. In particular,
ensure that your upload always matches exactly your git
HEAD. 

&bull;

Provide your full git history in a standard format on
dgit-repos, where it can benefit downstream dgit
users, such as people using dgit to do an NMU
(see dgit-nmu-simple(7) and dgit-user(7)).

&bull;

Minimise the amount you need to know about 3.0 (quilt)
in order to maintain Debian source packages which use that
format. 

This workflow
is appropriate for packages where the Debian delta contains
multiple pieces which interact, or which you don&rsquo;t
expect to be able to upstream soon. For packages with simple
and/or short-lived Debian deltas, use of
git-debrebase(1) introduces unneeded complexity. For
such packages, consider the workflow described in
dgit-maint-merge(7).

INITIAL DEBIANISATION

This section
explains how to start using this workflow with a new
package. It should be skipped when converting an existing
package to this workflow.

When
upstream tags releases in git 
Suppose that the latest stable upstream release is 1.2.2,
and this has been tagged &rsquo;1.2.2&rsquo; by
upstream.

    % git clone -oupstream https://some.upstream/foo.git
    % cd foo
    % git verify-tag 1.2.2
    % git reset --hard 1.2.2
    % git branch --unset-upstream

The final
command detaches your master branch from the upstream
remote, so that git doesn&rsquo;t try to push anything
there, or merge unreleased upstream commits. To maintain a
copy of your packaging branch on salsa.debian.org in
addition to dgit-repos, you can do something like
this:

    % git remote add -f origin salsa.debian.org:Debian/foo.git
    % git push --follow-tags -u origin master

Now go ahead
and Debianise your package. Make commits on the master
branch, adding things in the debian/ directory, or
patching the upstream source. For technical reasons, it
is essential that your first commit introduces the debian/
directory containing at least one file, and does nothing
else. In other words, make a commit introducing
debian/ before patching the upstream source.

Finally, you
need an orig tarball:

    % git deborig

See
git-deborig(1) if this fails.

This tarball is
ephemeral and easily regenerated, so we don&rsquo;t commit
it anywhere (e.g. with tools like
pristine-tar(1)).

Comparing
upstream&rsquo;s tarball releases

The above
assumes that you know how to build the package from git and
that doing so is straightforward.

If, as a user
of the upstream source, you usually build from upstream
tarball releases, rather than upstream git tags, you will
sometimes find that the git tree doesn&rsquo;t contain
everything that is in the tarball.

Additional
build steps may be needed. For example, you may need your
debian/rules to run autotools.

You can compare
the upstream tarball release, and upstream git tag, within
git, by importing the tarball into git as described in the
next section, using a different value for
&rsquo;upstream-tag&rsquo;, and then using
git-diff(1) to compare the imported tarball to the
release tag.

Using
untagged upstream commits

Sometimes
upstream does not tag their releases, or you want to package
an unreleased git snapshot. In such a case you can create
your own upstream release tag, of the form
upstream/ver, where ver is the upstream
version you plan to put in debian/changelog. The
upstream/ prefix ensures that your tag will not clash
with any tags upstream later creates.

For example,
suppose that the latest upstream release is 1.2.2 and you
want to package git commit ab34c21 which was made on
2013-12-11. A common convention is to use the upstream
version number 1.2.2+git20131211.ab34c21 and so you could
use

    % git tag -s upstream/1.2.2+git20131211.ab34c21 ab34c21

to obtain a
release tag, and then proceed as above.

When
upstream releases only tarballs 
Because we want to work in git, we need a virtual upstream
branch with virtual release tags. gbp-import-orig(1)
can manage this for us. To begin

    % mkdir foo
    % cd foo
    % git init
    % git checkout -b upstream
    % gbp import-orig \
        --upstream-branch=upstream --debian-branch=master \
        --upstream-tag='upstream/%(version)s' \
        --sign-tags --no-pristine-tar \
        ../foo_1.2.2.orig.tar.xz
    % git branch -f upstream

This should
leave you on the master branch. Next, our upstream branch
cannot be pushed to dgit-repos, but since we will
need it whenever we import a new upstream version, we must
push it somewhere. The usual choice is
salsa.debian.org:

    % git remote add -f origin salsa.debian.org:Debian/foo.git
    % git push --follow-tags -u origin master upstream

You are now
ready to proceed as above, making commits to the
debian/ directory and to the upstream source. As
above, for technical reasons, it is essential that your
first commit introduces the debian/ directory containing at
least one file, and does nothing else. In other words,
make a commit introducing debian/ before patching the
upstream source.

A convenient
way to ensure this requirement is satisfied is to start by
creating debian/gbp.conf:

    [DEFAULT]
    upstream-branch = upstream
    debian-branch = master
    upstream-tag = upstream/%(version)s
    sign-tags = True
    pristine-tar = False
    pristine-tar-commit = False
    [import-orig]
    merge = False

and commit
that:

    % git add debian/gbp.conf && git commit -m "create gbp.conf"

Note that we
couldn&rsquo;t create debian/gbp.conf before now for
the same technical reasons which require our first commit to
introduce debian/ without patching the upstream
source. That&rsquo;s why we had to pass a lot of options to
our first call to gbp-import-orig(1).

CONVERTING AN EXISTING PACKAGE

This section
explains how to convert an existing Debian package to this
workflow. It should be skipped when debianising a new
package.

If you have an
existing git history that you have pushed to an ordinary git
server like salsa.debian.org, we start with that. If
you don&rsquo;t already have it locally, you&rsquo;ll need
to clone it, and obtain the corresponding orig.tar from the
archive:

    % git clone salsa.debian.org:Debian/foo
    % cd foo
    % dgit setup-new-tree
    % origtargz

If you
don&rsquo;t have any existing git history, or you have
history only on the special dgit-repos server, we
start with dgit clone:

    % dgit clone foo
    % cd foo

Then we make
new upstream tags available:

    % git remote add -f upstream https://some.upstream/foo.git

We now use a
git debrebase convert-from-* command to convert your
existing history to the git-debrebase(5) data model.
Which command you should use depends on some facts about
your repository: 
(A) There is no delta queue.

If there do not exist any
Debian patches, use

    % git debrebase convert-from-gbp

(B) There is a delta queue, and
patches are unapplied.

This is the standard
git-buildpackage(1) workflow: there are Debian
patches, but the upstream source is committed to git without
those patches applied. Use

    % git debrebase convert-from-gbp

If you were not
previously using dgit to upload your package (i.e. you were
not using the workflow described in
dgit-maint-gbp(7)), and you happen to have run
dgit fetch sid in this clone of the repository, you
will need to pass --fdiverged to this command.

(C) There is a delta queue, and
patches are applied.

Use

    % git debrebase convert-from-dgit-view

Finally, you
need to ensure that your git HEAD is
dgit-compatible, i.e., it is exactly what you would get if
you deleted .git, invoked dpkg-buildpackage -S, and
then unpacked the resultant source package.

To achieve
this, you might need to delete
debian/source/local-options. One way to have dgit
check your progress is to run dgit build-source.

GIT CONFIGURATION

git-debrebase(1)
does not yet support using git merge to merge
divergent branches of development (see " OTHER
MERGES" in git-debrebase(5)). You should
configure git such that git pull does not try to
merge:

    % git config --local pull.rebase true

Now when you
pull work from other Debian contributors, git will rebase
your work on top of theirs.

If you use this
clone for upstream development in addition to Debian
packaging work, you may not want to set this global setting.
Instead, see the branch.autoSetupRebase and
branch..rebase settings in
git-config(5).

IMPORTING NEW UPSTREAM RELEASES

There are two
steps: obtaining git refs that correspond to the new
release, and importing that release using
git-debrebase(1).

Obtaining
the release 
When upstream tags releases in git

    % git fetch --tags upstream

If you want to
package an untagged upstream commit (because upstream does
not tag releases or because you want to package an upstream
development snapshot), see "Using untagged upstream
commits" above.

When
upstream releases only tarballs

You will need
the debian/gbp.conf from "When upstream releases
only tarballs", above. You will also need your upstream
branch. Above, we pushed this to salsa.debian.org.
You will need to clone or fetch from there, instead of
relying on dgit clone/dgit fetch alone.

Then,
either

    % gbp import-orig ../foo_1.2.3.orig.tar.xz

or if you have
a working watch file

    % gbp import-orig --uscan

Importing
the release

    % git debrebase new-upstream 1.2.3

This invocation
of git-debrebase(1) involves a git rebase. You may
need to resolve conflicts if the Debian delta queue does not
apply cleanly to the new upstream source.

If all went
well, you can now review the merge of the new upstream
release:

    git diff debian/1.2.2-1..HEAD -- . ':!debian'

Also, diff with
--name-status and --diff-filter=ADR to see
just the list of added or removed files, which is useful to
determine whether there are any new or deleted files that
may need accounting for in your copyright file.

If you obtained
a tarball from upstream, you are ready to try a build. If
you merged a git tag from upstream, you will first need to
generate a tarball:

    % git deborig

EDITING THE DEBIAN PACKAGING

Just make
commits on master that change the contents of
debian/.

EDITING THE DELTA QUEUE

Adding new
patches 
Adding new patches is straightforward: just make commits
touching only files outside of the debian/ directory.
You can also use tools like git-revert(1),
git-am(1) and git-cherry-pick(1).

Editing
patches: starting a debrebase 
git-debrebase(1) is a wrapper around
git-rebase(1) which allows us to edit, re-order and
delete patches. Run

    % git debrebase -i

to start an
interactive rebase. You can edit, re-order and delete
commits just as you would during git rebase -i.

Editing
patches: finishing a debrebase 
After completing the git rebase, your branch will not be a
fast-forward of the git HEAD you had before
the rebase. This means that we cannot push the branch
anywhere. If you are ready to upload, dgit push or
dgit push-source will take care of fixing this up for
you.

If you are not
yet ready to upload, and want to push your branch to a git
remote such as salsa.debian.org,

    % git debrebase conclude

Note that each
time you conclude a debrebase you introduce a pseudomerge
into your git history, which may make it harder to read. Try
to do all of the editing of the delta queue that you think
will be needed for this editing session in a single
debrebase, so that there is a single debrebase stitch.

BUILDING AND UPLOADING

You can use
dpkg-buildpackage(1) for test builds. When you are
ready to build for an upload, use dgit sbuild,
dgit pbuilder or dgit cowbuilder.

Upload with
dgit push or dgit push-source. Remember to
pass --new if the package is new in the target
suite.

In some cases
where you used git debrebase convert-from-gbp since
the last upload, it is not possible for dgit to make your
history fast-forwarding from the history on
dgit-repos. In such cases you will have to pass
--overwrite to dgit. git-debrebase will normally tell
you if this will be needed.

Right before
uploading, if you did not just already do so, you might want
to have git-debrebase(1) shuffle your branch such
that the Debian delta queue appears right at the tip of the
branch you will push:

    % git debrebase
    % dgit push-source

Note that this
will introduce a new pseudomerge.

After dgit
pushing, be sure to git push to salsa.debian.org, if
you&rsquo;re using that.

HANDLING DFSG-NON-FREE MATERIAL

Illegal
material 
Here we explain how to handle material that is merely
DFSG-non-free. Material which is legally dangerous (for
example, files which are actually illegal) cannot be handled
this way.

If you
encounter possibly-legally-dangerous material in the
upstream source code you should seek advice. It is often
best not to make a fuss on a public mailing list (at least,
not at first). Instead, email your archive administrators.
For Debian that is 
To: dgit-owner [AT] debian.org,
ftpmaster [AT] ftp-master.org

DFSG-non-free:
When upstream tags releases in git 
Our approach is to maintain a DFSG-clean upstream branch,
and create tags on this branch for each release that we want
to import. We then import those tags per "Importing the
release", above. In the case of a new package, we base
our initial Debianisation on our first DFSG-clean tag.

For the first
upstream release that requires DFSG
filtering:

    % git checkout -b upstream-dfsg 1.2.3
    % git rm evil.bin
    % git commit -m "upstream version 1.2.3 DFSG-cleaned"
    % git tag -s 1.2.3+dfsg
    % git checkout master

Now either
proceed with "Importing the release" on the
1.2.3+dfsg tag, or in the case of a new package,

    % git branch --unset-upstream
    % git reset --hard 1.2.3+dfsg

and proceed
with " INITIAL DEBIANISATION".

For subsequent
releases (whether or not they require additional
filtering):

    % git checkout upstream-dfsg
    % git merge 1.2.4
    % git rm further-evil.bin # if needed
    % git commit -m "upstream version 1.2.4 DFSG-cleaned" # if needed
    % git tag -s 1.2.4+dfsg
    % git checkout master
    % # proceed with "Importing the release" on 1.2.4+dfsg tag

Our
upstream-dfsg branch cannot be pushed to dgit-repos,
but since we will need it whenever we import a new upstream
version, we must push it somewhere. Assuming that you have
already set up an origin remote per the above,

    % git push --follow-tags -u origin master upstream-dfsg

DFSG-non-free:
When upstream releases only tarballs 
The easiest way to handle this is to add a
Files-Excluded field to debian/copyright, and
a uversionmangle setting in debian/watch. See
uscan(1). Alternatively, see the --filter
option detailed in gbp-import-orig(1).

INCORPORATING NMUS

In the simplest
case,

    % dgit fetch
    % git merge --ff-only dgit/dgit/sid

If that fails,
because your branch and the NMUers&rsquo; work represent
divergent branches of development, you have a number of
options. Here we describe the two simplest.

Note that you
should not try to resolve the divergent branches by editing
files in debian/patches. Changes there would either
cause trouble, or be overwritten by
git-debrebase(1).

Rebasing
your work onto the NMU

    % git rebase dgit/dgit/sid

If the NMUer
added new commits modifying the upstream source, you will
probably want to debrebase before your next upload to tidy
those up.

For example,
the NMUer might have used git-revert(1) to unapply
one of your patches. A debrebase can be used to strip both
the patch and the reversion from the delta queue.

Manually
applying the debdiff 
If you cannot rebase because you have already pushed to
salsa.debian.org, say, you can manually apply the
NMU debdiff, commit and debrebase. The next
dgit push will require --overwrite.

HINTS AND TIPS

Minimising
pseudomerges 
Above we noted that each time you conclude a debrebase, you
introduce a pseudomerge into your git history, which may
make it harder to read.

A simple
convention you can use to minimise the number of
pseudomerges is to git debrebase conclude only right
before you upload or push to salsa.debian.org.

It is possible,
though much less convenient, to reduce the number of
pseudomerges yet further. We debrebase only (i) when
importing a new release, and (ii) right before uploading.
Instead of editing the existing delta queue, you append
fixup commits (and reversions of commits) that alter the
upstream source to the required state. You can push and pull
to and from salsa.debian.org during this. Just before
uploading, you debrebase, once, to tidy everything up.

The
debian/patches directory 
In this workflow, debian/patches is purely an output
of git-debrebase(1). You should not make changes
there. They will either cause trouble, or be ignored and
overwritten by git-debrebase(1).

debian/patches
will often be out-of-date because git-debrebase(1)
will only regenerate it when it needs to. So you should not
rely on the information in that directory. When preparing
patches to forward upstream, you should use
git-format-patch(1) on git commits, rather than
sending files from debian/patches.

Upstream
branches 
In this workflow, we specify upstream tags rather than any
branches.

Except when (i)
upstream releases only tarballs, (ii) we require
DFSG filtering, or (iii) you also happen to
be involved in upstream development, we do not maintain any
local branch corresponding to upstream, except temporary
branches used to prepare patches for forwarding, and the
like.

The idea here
is that from Debian&rsquo;s point of view, upstream releases
are immutable points in history. We want to make sure that
we are basing our Debian package on a properly identified
upstream version, rather than some arbitrary commit on some
branch. Tags are more useful for this.

Upstream&rsquo;s
branches remain available as the git remote tracking
branches for your upstream remote, e.g.
remotes/upstream/master.

The first
ever dgit push 
If this is the first ever dgit push of the package, consider
passing --deliberately-not-fast-forward instead of
--overwrite. This avoids introducing a new origin
commit into your git history. (This origin commit would
represent the most recent non-dgit upload of the package,
but this should already be represented in your git
history.)

Inspecting
the history 
The git history made by git-debrebase can seem complicated.
Here are some suggestions for helpful invocations of gitk
and git. They can be adapted for other tools like
tig(1), git-log(1), magit, etc.

History of
package in Debian, disregarding history from upstream:

    % gitk --first-parent

In a laundered
branch, the delta queue is at the top.

History of the
packaging, excluding the delta queue:

    % gitk :/debian :!/debian/patches

Just the delta
queue (i.e. Debian&rsquo;s changes to upstream):

    % gitk --first-parent -- :/ :!/debian

Full history
including old versions of the delta queue:

    % gitk --date-order

The
"Declare fast forward" commits you see have an
older history (usually, an older delta queue) as one parent,
and a newer history as the other. --date-order makes gitk
show the delta queues in the right order.

Complete diff
since the last upload:

    % git diff dgit/dgit/sid..HEAD -- :/ :!/debian/patches

This includes
changes to upstream files.

Interdiff of
delta queue since last upload, if you really want it:

    % git debrebase make-patches
    % git diff dgit/dgit/sid..HEAD -- debian/patches

And of course
there is:

    % git debrebase status

Alternative
ways to start a debrebase 
Above we started an interactive debrebase by invoking
git-debrebase(1) like this:

    % git debrebase -i

It is also
possible to perform a non-interactive rebase, like this:

    % git debrebase -- [git-rebase options...]

A third
alternative is to have git-debrebase(1) shuffle all
the Debian changes to the end of your branch, and then
manipulate them yourself using git-rebase(1)
directly. For example,

    % git debrebase
    % git rebase -i HEAD~5      # there are 4 Debian patches

If you take
this approach, you should be very careful not to start the
rebase too early, including before the most recent
pseudomerge. git-rebase without a base argument will often
start the rebase too early, and should be avoided. Run
git-debrebase instead. See also " ILLEGAL
OPERATIONS" in git-debrebase(5).

SEE ALSO

dgit(1),
dgit(7), git-debrebase(1),
git-debrebase(5)

AUTHOR

This tutorial
was written and is maintained by Sean Whitton
spwhitton [AT] spwhitton.name>. It contains contributions
from other dgit contributors too - see the dgit copyright
file.