NAME

vec -
distributed vector (rheolef-7.2)

DESCRIPTION

This vector
class supports both the sequential and the
distributed memory model. In addition, standard
linear algebra is supported.

EXAMPLE

vec
x (100, 3.14); 
vec y (100, 6.28); 
vec z = 2.5*x + y; 
dout 

IMPLEMENTATION

This
documentation has been generated from file
linalg/lib/vec.h

The
vec class is a template class with both the
floating type and the memory model as parameters. The
implementation bases on the disarray(4)
container.

template

class vec : public disarray { 
public:

// typedef:

typedef
disarray base; 
typedef T value_type; 
typedef typename base::size_type size_type; 
typedef std::ptrdiff_t difference_type; 
typedef range range_type; 
typedef typename base::reference reference; 
typedef typename base::const_reference const_reference; 
typedef typename base::iterator iterator; 
typedef typename base::const_iterator const_iterator; 
typedef typename float_traits ::type
float_type;

//
allocator/deallocator:

vec (const
vec&); 
vec& operator= (const vec&
x);

vec (const
distributor& ownership, 
const T& init_val =
std::numeric_limits::max());

vec (const
std::initializer_list
>& init_list);

vec&
operator= (const
std::initializer_list
>& init_list); 
vec(size_type dis_size = 0, 
const T& init_val =
std::numeric_limits::max());

void resize (

const distributor& ownership, 
const T& init_val =
std::numeric_limits::max());

void resize (

size_type size = 0, 
const T& init_val =
std::numeric_limits::max());

//
accessors:

const_reference
operator[] (size_type i) const; 
reference operator[] (size_type i);

T min () const;

T max () const; 
T max_abs () const;

int
constraint_process_rank() const;

// range:

vec(const
vec_range& vr); 
vec(const vec_range_const& vr); 
vec& operator= (const
vec_range& vr); 
vec& operator= (const
vec_range_const& vr);

vec_range_const
operator[] (const range_type& r) const; 
vec_range operator[] (const range_type&
r);

// assignment
to a constant:

vec&
operator= (const int& expr); 
vec& operator= (const T& expr);

// expression
template:

template

class Sfinae 
= typename std::enable_if
details::is_vec_expr_v2_arg::value 
&& ! details::is_vec::value 
>::type> 
vec (const Expr& expr);

template

class Sfinae 
= typename std::enable_if
details::is_vec_expr_v2_arg::value 
&& ! details::is_vec::value 
>::type> 
vec& operator= (const Expr& expr); 
};

AUTHOR

Pierre Saramito
Pierre.Saramito [AT] imag.fr>

COPYRIGHT

Copyright (C)
2000-2018 Pierre Saramito Pierre.Saramito [AT] imag.fr>
GPLv3+: GNU GPL version 3 or later
http://gnu.org/licenses/gpl.html>. This is free
software: you are free to change and redistribute it. There
is NO WARRANTY, to the extent permitted by law.