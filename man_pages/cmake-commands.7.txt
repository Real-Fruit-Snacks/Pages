NAME

cmake-commands
- CMake Language Command Reference

SCRIPTING COMMANDS

These commands
are always available.

break

Break from an enclosing foreach or while loop.
break()

Breaks from an
enclosing foreach() or while() loop.

See also the
continue() command.

cmake_host_system_information

Query host system specific information.

cmake_host_system_information(RESULT  QUERY  ...)

Queries system
information of the host system on which cmake runs. One or
more  can be provided to select the
information to be queried. The list of queried values is
stored in .

can be one of the following values:

FOOTNOTES

[1]

One MiB (mebibyte) is equal to
1024x1024 bytes.

cmake_language

Call meta-operations on CMake commands.

Synopsis

cmake_language(CALL
 [...]) 
cmake_language(EVAL CODE
...)

Introduction

This command will call meta-operations on built-in CMake
commands or those created via the macro() or
function() commands.

cmake_language
does not introduce a new variable or policy scope.

Calling
Commands

cmake_language(CALL  [...])

Calls the named
 with the given arguments (if any).
For example, the code:

set(message_command "message")
cmake_language(CALL ${message_command} STATUS "Hello World!")

is equivalent
to

message(STATUS "Hello World!")

NOTE:

To ensure consistency of the
code, the following commands are not allowed:

•

if / elseif /
else / endif

•

while / endwhile

•

foreach / endforeach

•

function / endfunction

•

macro / endmacro

Evaluating
Code

cmake_language(EVAL CODE ...)

Evaluates the
... as CMake code.

For example,
the code:
set(A TRUE)
set(B TRUE)
set(C TRUE)
set(condition "(A AND B) OR C")

cmake_language(EVAL CODE "
  if (${condition})
    message(STATUS TRUE)
  else()
    message(STATUS FALSE)
  endif()"
)

is equivalent
to
set(A TRUE)
set(B TRUE)
set(C TRUE)
set(condition "(A AND B) OR C")

file(WRITE ${CMAKE_CURRENT_BINARY_DIR}/eval.cmake "
  if (${condition})
    message(STATUS TRUE)
  else()
    message(STATUS FALSE)
  endif()"
)

include(${CMAKE_CURRENT_BINARY_DIR}/eval.cmake)

cmake_minimum_required

Require a minimum version of cmake.

cmake_minimum_required(VERSION [...] [FATAL_ERROR])

Sets the
minimum required version of cmake for a project. Also
updates the policy settings as explained below.

and the optional  are each CMake versions
of the form major.minor[.patch[.tweak]], and the
... is literal.

If the running
version of CMake is lower than the 
required version it will stop processing the project and
report an error. The optional  version, if
specified, must be at least the  version
and affects policy settings as described below. If the
running version of CMake is older than 3.12, the extra
... dots will be seen as version component
separators, resulting in the ... part
being ignored and preserving the pre-3.12 behavior of basing
policies on .

The
FATAL_ERROR option is accepted but ignored by CMake
2.6 and higher. It should be specified so CMake versions 2.4
and lower fail with an error instead of just a warning.

NOTE:

Call the
cmake_minimum_required() command at the beginning of
the top-level CMakeLists.txt file even before calling
the project() command. It is important to establish
version and policy settings before invoking other commands
whose behavior they may affect. See also policy
CMP0000.

Calling
cmake_minimum_required() inside a function()
limits some effects to the function scope when invoked. Such
calls should not be made with the intention of having global
effects.

Policy
Settings 
The cmake_minimum_required(VERSION) command
implicitly invokes the cmake_policy(VERSION) command
to specify that the current project code is written for the
given range of CMake versions. All policies known to the
running version of CMake and introduced in the
 (or , if specified)
version or earlier will be set to use NEW behavior.
All policies introduced in later versions will be unset.
This effectively requests behavior preferred as of a given
CMake version and tells newer CMake versions to warn about
their new policies.

When a
 version higher than 2.4 is specified the
command implicitly invokes

cmake_policy(VERSION [...])

which sets
CMake policies based on the range of versions specified.
When a  version 2.4 or lower is given the
command implicitly invokes

cmake_policy(VERSION 2.4[...])

which enables
compatibility features for CMake 2.4 and lower.

cmake_parse_arguments

Parse function or macro arguments.
cmake_parse_arguments(  
                       ...)

cmake_parse_arguments(PARSE_ARGV   
                       )

This command is
for use in macros or functions. It processes the arguments
given to that macro or function, and defines a set of
variables which hold the values of the respective
options.

The first
signature reads processes arguments passed in the
.... This may be used in either a
macro() or a function().

The
PARSE_ARGV signature is only for use in a
function() body. In this case the arguments that are
parsed come from the ARGV# variables of the calling
function. The parsing starts with the -th
argument, where  is an unsigned integer.
This allows for the values to have special characters like
; in them.

The
 argument contains all options for the
respective macro, i.e. keywords which can be used when
calling the macro without any value following, like e.g. the
OPTIONAL keyword of the install() command.

The
 argument contains all
keywords for this macro which are followed by one value,
like e.g. DESTINATION keyword of the install()
command.

The
 argument contains all
keywords for this macro which can be followed by more than
one value, like e.g. the TARGETS or FILES
keywords of the install() command.

NOTE:

All keywords shall be unique.
I.e. every keyword shall only be specified once in either
,  or
. A warning will be
emitted if uniqueness is violated.

When done,
cmake_parse_arguments will consider for each of the
keywords listed in ,
 and
 a variable composed of
the given  followed by
"_" and the name of the respective keyword.
These variables will then hold the respective value from the
argument list or be undefined if the associated option could
not be found. For the  keywords, these
will always be defined, to TRUE or FALSE,
whether the option is in the argument list or not.

All remaining
arguments are collected in a variable
_UNPARSED_ARGUMENTS that will be
undefined if all arguments were recognized. This can be
checked afterwards to see whether your macro was called with
unrecognized parameters.

and  that were given no
values at all are collected in a variable
_KEYWORDS_MISSING_VALUES that will be
undefined if all keywords received values. This can be
checked to see if there were keywords without any values
given.

Consider the
following example macro, my_install(), which takes
similar arguments to the real install() command:
macro(my_install)
    set(options OPTIONAL FAST)
    set(oneValueArgs DESTINATION RENAME)
    set(multiValueArgs TARGETS CONFIGURATIONS)
    cmake_parse_arguments(MY_INSTALL "${options}" "${oneValueArgs}"
                          "${multiValueArgs}" ${ARGN} )

    # ...

Assume
my_install() has been called like this:

my_install(TARGETS foo bar DESTINATION bin OPTIONAL blub CONFIGURATIONS)

After the
cmake_parse_arguments call the macro will have set or
undefined the following variables:

MY_INSTALL_OPTIONAL = TRUE
MY_INSTALL_FAST = FALSE # was not used in call to my_install
MY_INSTALL_DESTINATION = "bin"
MY_INSTALL_RENAME  # was not used
MY_INSTALL_TARGETS = "foo;bar"
MY_INSTALL_CONFIGURATIONS  # was not used
MY_INSTALL_UNPARSED_ARGUMENTS = "blub" # nothing expected after "OPTIONAL"
MY_INSTALL_KEYWORDS_MISSING_VALUES = "CONFIGURATIONS"
         # No value for "CONFIGURATIONS" given

You can then
continue and process these variables.

Keywords
terminate lists of values, e.g. if directly after a
one_value_keyword another recognized keyword follows,
this is interpreted as the beginning of the new option. E.g.
my_install(TARGETS foo DESTINATION OPTIONAL) would
result in MY_INSTALL_DESTINATION set to
"OPTIONAL", but as OPTIONAL is a
keyword itself MY_INSTALL_DESTINATION will be empty
(but added to MY_INSTALL_KEYWORDS_MISSING_VALUES) and
MY_INSTALL_OPTIONAL will therefore be set to
TRUE.

cmake_policy

Manage CMake Policy settings. See the
cmake-policies(7) manual for defined policies.

As CMake
evolves it is sometimes necessary to change existing
behavior in order to fix bugs or improve implementations of
existing features. The CMake Policy mechanism is designed to
help keep existing projects building as new versions of
CMake introduce changes in behavior. Each new policy
(behavioral change) is given an identifier of the form
CMP where  is an
integer index. Documentation associated with each policy
describes the OLD and NEW behavior and the
reason the policy was introduced. Projects may set each
policy to select the desired behavior. When CMake needs to
know which behavior to use it checks for a setting specified
by the project. If no setting is available the OLD
behavior is assumed and a warning is produced requesting
that the policy be set.

Setting
Policies by CMake Version 
The cmake_policy command is used to set policies to
OLD or NEW behavior. While setting policies
individually is supported, we encourage projects to set
policies based on CMake versions:

cmake_policy(VERSION [...])

and the optional  are each CMake versions
of the form major.minor[.patch[.tweak]], and the
... is literal. The  version must
be at least 2.4 and at most the running version of
CMake. The  version, if specified, must be
at least the  version but may exceed the
running version of CMake. If the running version of CMake is
older than 3.12, the extra ... dots will be seen as
version component separators, resulting in the
... part being ignored and preserving the
pre-3.12 behavior of basing policies on
.

This specifies
that the current CMake code is written for the given range
of CMake versions. All policies known to the running version
of CMake and introduced in the  (or
, if specified) version or earlier will be
set to use NEW behavior. All policies introduced in
later versions will be unset (unless the
CMAKE_POLICY_DEFAULT_CMP variable sets a
default). This effectively requests behavior preferred as of
a given CMake version and tells newer CMake versions to warn
about their new policies.

Note that the
cmake_minimum_required(VERSION) command implicitly
calls cmake_policy(VERSION) too.

Setting
Policies Explicitly

cmake_policy(SET CMP NEW)
cmake_policy(SET CMP OLD)

Tell CMake to
use the OLD or NEW behavior for a given
policy. Projects depending on the old behavior of a given
policy may silence a policy warning by setting the policy
state to OLD. Alternatively one may fix the project
to work with the new behavior and set the policy state to
NEW.

NOTE:

The OLD behavior of a
policy is deprecated by definition and may be removed
in a future version of CMake.

Checking
Policy Settings

cmake_policy(GET CMP )

Check whether a
given policy is set to OLD or NEW behavior.
The output  value will be OLD
or NEW if the policy is set, and empty otherwise.

CMake Policy
Stack 
CMake keeps policy settings on a stack, so changes made by
the cmake_policy command affect only the top of the
stack. A new entry on the policy stack is managed
automatically for each subdirectory to protect its parents
and siblings. CMake also manages a new entry for scripts
loaded by include() and find_package()
commands except when invoked with the NO_POLICY_SCOPE
option (see also policy CMP0011). The
cmake_policy command provides an interface to manage
custom entries on the policy stack:

cmake_policy(PUSH)
cmake_policy(POP)

Each
PUSH must have a matching POP to erase any
changes. This is useful to make temporary changes to policy
settings. Calls to the
cmake_minimum_required(VERSION),
cmake_policy(VERSION), or cmake_policy(SET)
commands influence only the current top of the policy
stack.

Commands
created by the function() and macro() commands
record policy settings when they are created and use the
pre-record policies when they are invoked. If the function
or macro implementation sets policies, the changes
automatically propagate up through callers until they reach
the closest nested policy stack entry.

configure_file

Copy a file to another location and modify its contents.

configure_file( 
               [COPYONLY] [ESCAPE_QUOTES] [@ONLY]
               [NEWLINE_STYLE [UNIX|DOS|WIN32|LF|CRLF] ])

Copies an
 file to an  file
and substitutes variable values referenced as @VAR@
or ${VAR} in the input file content. Each variable
reference will be replaced with the current value of the
variable, or the empty string if the variable is not
defined. Furthermore, input lines of the form

#cmakedefine VAR ...

will be
replaced with either

#define VAR ...

or

/* #undef VAR */

depending on
whether VAR is set in CMake to any value not
considered a false constant by the if() command. The
“…” content on the line after the variable
name, if any, is processed as above. Input file lines of the
form #cmakedefine01 VAR will be replaced with either
#define VAR 1 or #define VAR 0 similarly. The
result lines (with the exception of the #undef
comments) can be indented using spaces and/or tabs between
the # character and the cmakedefine or
cmakedefine01 words. This whitespace indentation will
be preserved in the output lines:

#  cmakedefine VAR
#  cmakedefine01 VAR

will be
replaced, if VAR is defined, with

#  define VAR
#  define VAR 1

If the input
file is modified the build system will re-run CMake to
re-configure the file and generate the build system again.
The generated file is modified and its timestamp updated on
subsequent cmake runs only if its content is changed.

The arguments
are: 

Path to the input file. A
relative path is treated with respect to the value of
CMAKE_CURRENT_SOURCE_DIR. The input path must be a
file, not a directory.

Path to the output file or
directory. A relative path is treated with respect to the
value of CMAKE_CURRENT_BINARY_DIR. If the path names
an existing directory the output file is placed in that
directory with the same file name as the input file.

COPYONLY

Copy the file without replacing
any variable references or other content. This option may
not be used with NEWLINE_STYLE.

ESCAPE_QUOTES

Escape any substituted quotes
with backslashes (C-style).

@ONLY

Restrict variable replacement to references of the form
@VAR@. This is useful for configuring scripts that
use ${VAR} syntax.

NEWLINE_STYLE

Specify the newline style for
the output file. Specify UNIX or LF for
\n newlines, or specify DOS, WIN32, or
CRLF for \r\n newlines. This option may not be
used with COPYONLY.

Example

Consider a source tree containing a foo.h.in
file:

#cmakedefine FOO_ENABLE
#cmakedefine FOO_STRING "@FOO_STRING@"

An adjacent
CMakeLists.txt may use configure_file to
configure the header:

option(FOO_ENABLE "Enable Foo" ON)
if(FOO_ENABLE)
  set(FOO_STRING "foo")
endif()
configure_file(foo.h.in foo.h @ONLY)

This creates a
foo.h in the build directory corresponding to this
source directory. If the FOO_ENABLE option is on, the
configured file will contain:

#define FOO_ENABLE
#define FOO_STRING "foo"

Otherwise it
will contain:

/* #undef FOO_ENABLE */
/* #undef FOO_STRING */

One may then
use the include_directories() command to specify the
output directory as an include directory:

include_directories(${CMAKE_CURRENT_BINARY_DIR})

so that sources
may include the header as #include .

continue

Continue to the top of enclosing foreach or while loop.

continue()

The
continue command allows a cmake script to abort the
rest of a block in a foreach() or while()
loop, and start at the top of the next iteration.

See also the
break() command.

else

Starts the else portion of an if block.

else([])

See the
if() command.

elseif

Starts an elseif portion of an if block.

elseif()

See the
if() command, especially for the syntax and logic of
the .

endforeach

Ends a list of commands in a foreach block.

endforeach([])

See the
foreach() command.

The optional
 argument is supported for backward
compatibility only. If used it must be a verbatim repeat of
the  argument of the opening
foreach clause.

endfunction

Ends a list of commands in a function block.

endfunction([])

See the
function() command.

The optional
 argument is supported for backward
compatibility only. If used it must be a verbatim repeat of
the  argument of the opening
function command.

endif

Ends a list of commands in an if block.

endif([])

See the
if() command.

The optional
 argument is supported for backward
compatibility only. If used it must be a verbatim repeat of
the argument of the opening if clause.

endmacro

Ends a list of commands in a macro block.

endmacro([])

See the
macro() command.

The optional
 argument is supported for backward
compatibility only. If used it must be a verbatim repeat of
the  argument of the opening macro
command.

endwhile

Ends a list of commands in a while block.

endwhile([])

See the
while() command.

The optional
 argument is supported for backward
compatibility only. If used it must be a verbatim repeat of
the argument of the opening while clause.

execute_process

Execute one or more child processes.

execute_process(COMMAND  []
                [COMMAND  []]...
                [WORKING_DIRECTORY ]
                [TIMEOUT ]
                [RESULT_VARIABLE ]
                [RESULTS_VARIABLE ]
                [OUTPUT_VARIABLE ]
                [ERROR_VARIABLE ]
                [INPUT_FILE ]
                [OUTPUT_FILE ]
                [ERROR_FILE ]
                [OUTPUT_QUIET]
                [ERROR_QUIET]
                [COMMAND_ECHO ]
                [OUTPUT_STRIP_TRAILING_WHITESPACE]
                [ERROR_STRIP_TRAILING_WHITESPACE]
                [ENCODING ]
                [ECHO_OUTPUT_VARIABLE]
                [ECHO_ERROR_VARIABLE])

Runs the given
sequence of one or more commands.

Commands are
executed concurrently as a pipeline, with the standard
output of each process piped to the standard input of the
next. A single standard error pipe is used for all
processes.

Options:

COMMAND

A child process command
line.

CMake executes
the child process using operating system APIs directly. All
arguments are passed VERBATIM to the child process. No
intermediate shell is used, so shell operators such as
> are treated as normal arguments. (Use the
INPUT_*, OUTPUT_*, and ERROR_* options
to redirect stdin, stdout, and stderr.)

If a sequential
execution of multiple commands is required, use multiple
execute_process() calls with a single COMMAND
argument.

WORKING_DIRECTORY

The named directory will be set
as the current working directory of the child processes.

TIMEOUT

After the specified number of
seconds (fractions allowed), all unfinished child processes
will be terminated, and the RESULT_VARIABLE will be
set to a string mentioning the “timeout”.

RESULT_VARIABLE

The variable will be set to
contain the result of last child process. This will be an
integer return code from the last child or a string
describing an error condition.

RESULTS_VARIABLE

The variable will be set to
contain the result of all processes as a semicolon-separated
list, in order of the given COMMAND arguments. Each
entry will be an integer return code from the corresponding
child or a string describing an error condition.

OUTPUT_VARIABLE,
ERROR_VARIABLE

The variable named will be set
with the contents of the standard output and standard error
pipes, respectively. If the same variable is named for both
pipes their output will be merged in the order produced.

INPUT_FILE, OUTPUT_FILE,
ERROR_FILE

The file named will be attached
to the standard input of the first process, standard output
of the last process, or standard error of all processes,
respectively. If the same file is named for both output and
error then it will be used for both.

OUTPUT_QUIET,
ERROR_QUIET

The standard output or standard
error results will be quietly ignored.

COMMAND_ECHO

The command being run will be
echo’ed to  with
 being set to one of STDERR,
STDOUT or NONE. See the
CMAKE_EXECUTE_PROCESS_COMMAND_ECHO variable for a way
to control the default behavior when this option is not
present.

ENCODING

On Windows, the encoding that
is used to decode output from the process. Ignored on other
platforms. Valid encoding names are:

NONE

Perform no decoding. This assumes that the process
output is encoded in the same way as CMake’s internal
encoding (UTF-8). This is the default.

AUTO

Use the current active console’s codepage or if
that isn’t available then use ANSI.

ANSI

Use the ANSI codepage.

OEM

Use the original equipment manufacturer (OEM) code
page. 

UTF8 or UTF-8

Use the UTF-8 codepage. Prior
to CMake 3.11.0, only UTF8 was accepted for this
encoding. In CMake 3.11.0, UTF-8 was added for
consistency with the UTF-8 RFC naming convention.

ECHO_OUTPUT_VARIABLE,
ECHO_ERROR_VARIABLE

The standard output or standard
error will not be exclusively redirected to the configured
variables.

The output will
be duplicated, it will be sent into the configured variables
and also on standard output or standard error.

This is
analogous to the tee Unix command.

If more than
one OUTPUT_* or ERROR_* option is given for
the same pipe the precedence is not specified. If no
OUTPUT_* or ERROR_* options are given the
output will be shared with the corresponding pipes of the
CMake process itself.

The
execute_process() command is a newer more powerful
version of exec_program(), but the old command has
been kept for compatibility. Both commands run while CMake
is processing the project prior to build system generation.
Use add_custom_target() and
add_custom_command() to create custom commands that
run at build time.

file

File manipulation command.

Synopsis

Reading 
file(READ  
[...]) 
file(STRINGS 
 [...]) 
file( 
) 
file(TIMESTAMP 
 [...]) 
file(GET_RUNTIME_DEPENDENCIES
[...])

Writing

file({WRITE | APPEND}
 ...) 
file({TOUCH |
TOUCH_NOCREATE} [...]) 
file(GENERATE OUTPUT 
[...]) 
file(CONFIGURE OUTPUT 
CONTENT  [...])

Filesystem

file({GLOB | GLOB_RECURSE}
 [...] [...]) 
file(RENAME  )

file({REMOVE | REMOVE_RECURSE
} [...]) 
file(MAKE_DIRECTORY [...]) 
file({COPY | INSTALL}
... DESTINATION  [...]) 
file(SIZE  )

file(READ_SYMLINK 
) 
file(CREATE_LINK 
 [...])

Path
Conversion 
file(RELATIVE_PATH 
 ) 
file({TO_CMAKE_PATH |
TO_NATIVE_PATH} 
)

Transfer

file(DOWNLOAD  
[...]) 
file(UPLOAD  
[...])

Locking

file(LOCK  [...])

Archiving

file(ARCHIVE_CREATE OUTPUT 
PATHS ... [...]) 
file(ARCHIVE_EXTRACT INPUT 
[...])

Reading

file(READ  
     [OFFSET ] [LIMIT ] [HEX])

Read content
from a file called  and store it in a
. Optionally start from the given
 and read at most 
bytes. The HEX option causes data to be converted to
a hexadecimal representation (useful for binary data). If
the HEX option is specified, letters in the output
(a through f) are in lowercase.

file(STRINGS   [...])

Parse a list of
ASCII strings from  and store it in
. Binary data in the file are
ignored. Carriage return (\r, CR) characters are
ignored. The options are: 
LENGTH_MAXIMUM 

Consider only strings of at
most a given length.

LENGTH_MINIMUM

Consider only strings of at
least a given length.

LIMIT_COUNT

Limit the number of distinct
strings to be extracted.

LIMIT_INPUT

Limit the number of input bytes
to read from the file.

LIMIT_OUTPUT

Limit the number of total bytes
to store in the .

NEWLINE_CONSUME

Treat newline characters
(\n, LF) as part of string content instead of
terminating at them.

NO_HEX_CONVERSION

Intel Hex and Motorola S-record
files are automatically converted to binary while reading
unless this option is given.

REGEX 

Consider only strings that
match the given regular expression.

ENCODING

Consider strings of a given
encoding. Currently supported encodings are: UTF-8,
UTF-16LE, UTF-16BE, UTF-32LE, UTF-32BE. If the ENCODING
option is not provided and the file has a Byte Order Mark,
the ENCODING option will be defaulted to respect the Byte
Order Mark.

For example,
the code

file(STRINGS myfile.txt myfile)

stores a list
in the variable myfile in which each item is a line
from the input file.

file(  )

Compute a
cryptographic hash of the content of 
and store it in a . The supported
 algorithm names are those listed by the
string() command.

file(TIMESTAMP   [] [UTC])

Compute a
string representation of the modification time of
 and store it in
. Should the command be unable to
obtain a timestamp variable will be set to the empty string
(“”).

See the
string(TIMESTAMP) command for documentation of the
 and UTC options.

file(GET_RUNTIME_DEPENDENCIES
  [RESOLVED_DEPENDENCIES_VAR ]
  [UNRESOLVED_DEPENDENCIES_VAR ]
  [CONFLICTING_DEPENDENCIES_PREFIX ]
  [EXECUTABLES [...]]
  [LIBRARIES [...]]
  [MODULES [...]]
  [DIRECTORIES [...]]
  [BUNDLE_EXECUTABLE ]
  [PRE_INCLUDE_REGEXES [...]]
  [PRE_EXCLUDE_REGEXES [...]]
  [POST_INCLUDE_REGEXES [...]]
  [POST_EXCLUDE_REGEXES [...]]
  )

Recursively get
the list of libraries depended on by the given files.

Please note
that this sub-command is not intended to be used in project
mode. Instead, use it in an install(CODE) or
install(SCRIPT) block. For example:

install(CODE [[
  file(GET_RUNTIME_DEPENDENCIES
    # ...
    )
  ]])

The arguments
are as follows: 
RESOLVED_DEPENDENCIES_VAR 

Name of the variable in which
to store the list of resolved dependencies.

UNRESOLVED_DEPENDENCIES_VAR

Name of the variable in which
to store the list of unresolved dependencies. If this
variable is not specified, and there are any unresolved
dependencies, an error is issued.

CONFLICTING_DEPENDENCIES_PREFIX

Variable prefix in which to
store conflicting dependency information. Dependencies are
conflicting if two files with the same name are found in two
different directories. The list of filenames that conflict
are stored in
_FILENAMES. For each
filename, the list of paths that were found for that
filename are stored in
_.

EXECUTABLES

List of executable files to
read for dependencies. These are executables that are
typically created with add_executable(), but they do
not have to be created by CMake. On Apple platforms, the
paths to these files determine the value of
@executable_path when recursively resolving the
libraries. Specifying any kind of library (STATIC,
MODULE, or SHARED) here will result in
undefined behavior.

LIBRARIES

List of library files to read
for dependencies. These are libraries that are typically
created with add_library(SHARED), but they do not
have to be created by CMake. Specifying STATIC
libraries, MODULE libraries, or executables here will
result in undefined behavior.

MODULES

List of loadable module files
to read for dependencies. These are modules that are
typically created with add_library(MODULE), but they
do not have to be created by CMake. They are typically used
by calling dlopen() at runtime rather than linked at
link time with ld -l. Specifying STATIC
libraries, SHARED libraries, or executables here will
result in undefined behavior.

DIRECTORIES

List of additional directories
to search for dependencies. On Linux platforms, these
directories are searched if the dependency is not found in
any of the other usual paths. If it is found in such a
directory, a warning is issued, because it means that the
file is incomplete (it does not list all of the directories
that contain its dependencies). On Windows platforms, these
directories are searched if the dependency is not found in
any of the other search paths, but no warning is issued,
because searching other paths is a normal part of Windows
dependency resolution. On Apple platforms, this argument has
no effect.

BUNDLE_EXECUTABLE

Executable to treat as the
“bundle executable” when resolving libraries. On
Apple platforms, this argument determines the value of
@executable_path when recursively resolving libraries
for LIBRARIES and MODULES files. It has no
effect on EXECUTABLES files. On other platforms, it
has no effect. This is typically (but not always) one of the
executables in the EXECUTABLES argument which
designates the “main” executable of the
package.

The following
arguments specify filters for including or excluding
libraries to be resolved. See below for a full description
of how they work. 
PRE_INCLUDE_REGEXES 

List of pre-include regexes
through which to filter the names of not-yet-resolved
dependencies.

PRE_EXCLUDE_REGEXES

List of pre-exclude regexes
through which to filter the names of not-yet-resolved
dependencies.

POST_INCLUDE_REGEXES

List of post-include regexes
through which to filter the names of resolved
dependencies.

POST_EXCLUDE_REGEXES

List of post-exclude regexes
through which to filter the names of resolved
dependencies.

These arguments
can be used to exclude unwanted system libraries when
resolving the dependencies, or to include libraries from a
specific directory. The filtering works as follows:

1.

If the not-yet-resolved dependency matches any of the
PRE_INCLUDE_REGEXES, steps 2 and 3 are skipped, and
the dependency resolution proceeds to step 4.

2.

If the not-yet-resolved dependency matches any of the
PRE_EXCLUDE_REGEXES, dependency resolution stops for
that dependency.

3.

Otherwise, dependency resolution proceeds.

4.

file(GET_RUNTIME_DEPENDENCIES) searches for the
dependency according to the linking rules of the platform
(see below).

5.

If the dependency is found, and its full path matches
one of the POST_INCLUDE_REGEXES, the full path is
added to the resolved dependencies, and
file(GET_RUNTIME_DEPENDENCIES) recursively resolves
that library’s own dependencies. Otherwise, resolution
proceeds to step 6.

6.

If the dependency is found, but its full path matches
one of the POST_EXCLUDE_REGEXES, it is not added to
the resolved dependencies, and dependency resolution stops
for that dependency.

7.

If the dependency is found, and its full path does not
match either POST_INCLUDE_REGEXES or
POST_EXCLUDE_REGEXES, the full path is added to the
resolved dependencies, and
file(GET_RUNTIME_DEPENDENCIES) recursively resolves
that library’s own dependencies.

Different
platforms have different rules for how dependencies are
resolved. These specifics are described here.

On Linux
platforms, library resolution works as follows:

1.

If the depending file does not
have any RUNPATH entries, and the library exists in
one of the depending file’s RPATH entries, or
its parents’, in that order, the dependency is
resolved to that file.

2.

Otherwise, if the depending file has any RUNPATH
entries, and the library exists in one of those entries, the
dependency is resolved to that file.

3.

Otherwise, if the library exists in one of the
directories listed by ldconfig, the dependency is
resolved to that file.

4.

Otherwise, if the library exists in one of the
DIRECTORIES entries, the dependency is resolved to
that file. In this case, a warning is issued, because
finding a file in one of the DIRECTORIES means that
the depending file is not complete (it does not list all the
directories from which it pulls dependencies).

5.

Otherwise, the dependency is unresolved.

On Windows
platforms, library resolution works as follows:

1.

The dependent DLL name is
converted to lowercase. Windows DLL names are
case-insensitive, and some linkers mangle the case of the
DLL dependency names. However, this makes it more difficult
for PRE_INCLUDE_REGEXES, PRE_EXCLUDE_REGEXES,
POST_INCLUDE_REGEXES, and POST_EXCLUDE_REGEXES
to properly filter DLL names - every regex would have to
check for both uppercase and lowercase letters. For
example: 

file(GET_RUNTIME_DEPENDENCIES
  # ...
  PRE_INCLUDE_REGEXES "^[Mm][Yy][Ll][Ii][Bb][Rr][Aa][Rr][Yy]\\.[Dd][Ll][Ll]$"
  )

Converting the
DLL name to lowercase allows the regexes to only match
lowercase names, thus simplifying the regex. For
example:

file(GET_RUNTIME_DEPENDENCIES
  # ...
  PRE_INCLUDE_REGEXES "^mylibrary\\.dll$"
  )

This regex will
match mylibrary.dll regardless of how it is cased,
either on disk or in the depending file. (For example, it
will match mylibrary.dll, MyLibrary.dll, and
MYLIBRARY.DLL.)

Please note
that the directory portion of any resolved DLLs retains its
casing and is not converted to lowercase. Only the filename
portion is converted.

2.

(Not yet implemented) If
the depending file is a Windows Store app, and the
dependency is listed as a dependency in the
application’s package manifest, the dependency is
resolved to that file.

3.

Otherwise, if the library exists in the same directory
as the depending file, the dependency is resolved to that
file. 

4.

Otherwise, if the library exists in either the operating
system’s system32 directory or the
Windows directory, in that order, the dependency is
resolved to that file.

5.

Otherwise, if the library exists in one of the
directories specified by DIRECTORIES, in the order
they are listed, the dependency is resolved to that file. In
this case, a warning is not issued, because searching other
directories is a normal part of Windows library
resolution. 

6.

Otherwise, the dependency is unresolved.

On Apple
platforms, library resolution works as follows:

1.

If the dependency starts with
@executable_path/, and an EXECUTABLES argument
is in the process of being resolved, and replacing
@executable_path/ with the directory of the
executable yields an existing file, the dependency is
resolved to that file.

2.

Otherwise, if the dependency starts with
@executable_path/, and there is a
BUNDLE_EXECUTABLE argument, and replacing
@executable_path/ with the directory of the bundle
executable yields an existing file, the dependency is
resolved to that file.

3.

Otherwise, if the dependency starts with
@loader_path/, and replacing @loader_path/
with the directory of the depending file yields an existing
file, the dependency is resolved to that file.

4.

Otherwise, if the dependency starts with @rpath/,
and replacing @rpath/ with one of the RPATH
entries of the depending file yields an existing file, the
dependency is resolved to that file. Note that RPATH
entries that start with @executable_path/ or
@loader_path/ also have these items replaced with the
appropriate path.

5.

Otherwise, if the dependency is an absolute file that
exists, the dependency is resolved to that file.

6.

Otherwise, the dependency is unresolved.

This function
accepts several variables that determine which tool is used
for dependency resolution: 
CMAKE_GET_RUNTIME_DEPENDENCIES_PLATFORM

Determines which operating
system and executable format the files are built for. This
could be one of several values:

•

linux+elf

•

windows+pe

•

macos+macho

If this
variable is not specified, it is determined automatically by
system introspection.

CMAKE_GET_RUNTIME_DEPENDENCIES_TOOL

Determines the tool to use for
dependency resolution. It could be one of several values,
depending on the value of
CMAKE_GET_RUNTIME_DEPENDENCIES_PLATFORM:

If this
variable is not specified, it is determined automatically by
system introspection.

CMAKE_GET_RUNTIME_DEPENDENCIES_COMMAND

Determines the path to the tool
to use for dependency resolution. This is the actual path to
objdump, dumpbin, or otool.

If this
variable is not specified, it is determined by the value of
CMAKE_OBJDUMP if set, else by system
introspection.

Writing

file(WRITE  ...)
file(APPEND  ...)

Write
 into a file called
. If the file does not exist, it will
be created. If the file already exists, WRITE mode
will overwrite it and APPEND mode will append to the
end. Any directories in the path specified by
 that do not exist will be
created.

If the file is
a build input, use the configure_file() command to
update the file only when its content changes.

file(TOUCH [...])
file(TOUCH_NOCREATE [...])

Create a file
with no content if it does not yet exist. If the file
already exists, its access and/or modification will be
updated to the time when the function call is executed.

Use
TOUCH_NOCREATE to touch a file if it exists but not create
it. If a file does not exist it will be silently
ignored.

With TOUCH and
TOUCH_NOCREATE the contents of an existing file will not be
modified.

file(GENERATE OUTPUT output-file

     [CONDITION expression])

Generate an
output file for each build configuration supported by the
current CMake Generator. Evaluate generator
expressions from the input content to produce the output
content. The options are: 
CONDITION 

Generate the output file for a
particular configuration only if the condition is true. The
condition must be either 0 or 1 after
evaluating generator expressions.

CONTENT

Use the content given
explicitly as input.

INPUT

Use the content from a given
file as input. A relative path is treated with respect to
the value of CMAKE_CURRENT_SOURCE_DIR. See policy
CMP0070.

OUTPUT

Specify the output file name to
generate. Use generator expressions such as
$ to specify a configuration-specific
output file name. Multiple configurations may generate the
same output file only if the generated content is identical.
Otherwise, the  must evaluate to
an unique name for each configuration. A relative path
(after evaluating generator expressions) is treated with
respect to the value of CMAKE_CURRENT_BINARY_DIR. See
policy CMP0070.

Exactly one
CONTENT or INPUT option must be given. A
specific OUTPUT file may be named by at most one
invocation of file(GENERATE). Generated files are
modified and their timestamp updated on subsequent cmake
runs only if their content is changed.

Note also that
file(GENERATE) does not create the output file until
the generation phase. The output file will not yet have been
written when the file(GENERATE) command returns, it
is written only after processing all of a project’s
CMakeLists.txt files.

file(CONFIGURE OUTPUT output-file
     CONTENT content
     [ESCAPE_QUOTES] [@ONLY]
     [NEWLINE_STYLE [UNIX|DOS|WIN32|LF|CRLF] ])

Generate an
output file using the input given by CONTENT and
substitute variable values referenced as @VAR@ or
${VAR} contained therein. The substitution rules
behave the same as the configure_file() command. In
order to match configure_file()’s behavior,
generator expressions are not supported for both
OUTPUT and CONTENT.

The arguments
are: 
OUTPUT 

Specify the output file name to
generate. A relative path is treated with respect to the
value of CMAKE_CURRENT_BINARY_DIR.
 does not support generator
expressions.

CONTENT

Use the content given
explicitly as input.  does not support
generator expressions.

ESCAPE_QUOTES

Escape any substituted quotes
with backslashes (C-style).

@ONLY

Restrict variable replacement to references of the form
@VAR@. This is useful for configuring scripts that
use ${VAR} syntax.

NEWLINE_STYLE

Specify the newline style for
the output file. Specify UNIX or LF for
\n newlines, or specify DOS, WIN32, or
CRLF for \r\n newlines.

Filesystem

file(GLOB 
     [LIST_DIRECTORIES true|false] [RELATIVE ] [CONFIGURE_DEPENDS]
     [...])
file(GLOB_RECURSE  [FOLLOW_SYMLINKS]
     [LIST_DIRECTORIES true|false] [RELATIVE ] [CONFIGURE_DEPENDS]
     [...])

Generate a list
of files that match the 
and store it into the . Globbing
expressions are similar to regular expressions, but much
simpler. If RELATIVE flag is specified, the results
will be returned as relative paths to the given path. The
results will be ordered lexicographically.

On Windows and
macOS, globbing is case-insensitive even if the underlying
filesystem is case-sensitive (both filenames and globbing
expressions are converted to lowercase before matching). On
other platforms, globbing is case-sensitive.

If the
CONFIGURE_DEPENDS flag is specified, CMake will add
logic to the main build system check target to rerun the
flagged GLOB commands at build time. If any of the
outputs change, CMake will regenerate the build system.

By default
GLOB lists directories - directories are omitted in
result if LIST_DIRECTORIES is set to false.

NOTE:

We do not recommend using GLOB
to collect a list of source files from your source tree. If
no CMakeLists.txt file changes when a source is added or
removed then the generated build system cannot know when to
ask CMake to regenerate. The CONFIGURE_DEPENDS flag
may not work reliably on all generators, or if a new
generator is added in the future that cannot support it,
projects using it will be stuck. Even if
CONFIGURE_DEPENDS works reliably, there is still a
cost to perform the check on every rebuild.

Examples of
globbing expressions include:

*.cxx      - match all files with extension cxx
*.vt?      - match all files with extension vta,...,vtz
f[3-5].txt - match files f3.txt, f4.txt, f5.txt

The
GLOB_RECURSE mode will traverse all the
subdirectories of the matched directory and match the files.
Subdirectories that are symlinks are only traversed if
FOLLOW_SYMLINKS is given or policy CMP0009 is
not set to NEW.

By default
GLOB_RECURSE omits directories from result list -
setting LIST_DIRECTORIES to true adds directories to
result list. If FOLLOW_SYMLINKS is given or policy
CMP0009 is not set to NEW then
LIST_DIRECTORIES treats symlinks as directories.

Examples of
recursive globbing include:
/dir/*.py  - match all python files in /dir and subdirectories
file(RENAME  )

Move a file or
directory within a filesystem from  to
, replacing the destination
atomically.

file(REMOVE [...])
file(REMOVE_RECURSE [...])

Remove the
given files. The REMOVE_RECURSE mode will remove the
given files and directories, also non-empty directories. No
error is emitted if a given file does not exist. Relative
input paths are evaluated with respect to the current source
directory. Empty input paths are ignored with a warning.

file(MAKE_DIRECTORY [...])

Create the
given directories and their parents as needed.

file( ... DESTINATION 
     [FILE_PERMISSIONS ...]
     [DIRECTORY_PERMISSIONS ...]
     [NO_SOURCE_PERMISSIONS] [USE_SOURCE_PERMISSIONS]
     [FOLLOW_SYMLINK_CHAIN]
     [FILES_MATCHING]
     [[PATTERN  | REGEX ]
      [EXCLUDE] [PERMISSIONS ...]] [...])

The COPY
signature copies files, directories, and symlinks to a
destination folder. Relative input paths are evaluated with
respect to the current source directory, and a relative
destination is evaluated with respect to the current build
directory. Copying preserves input file timestamps, and
optimizes out a file if it exists at the destination with
the same timestamp. Copying preserves input permissions
unless explicit permissions or NO_SOURCE_PERMISSIONS
are given (default is USE_SOURCE_PERMISSIONS).

If
FOLLOW_SYMLINK_CHAIN is specified, COPY will
recursively resolve the symlinks at the paths given until a
real file is found, and install a corresponding symlink in
the destination for each symlink encountered. For each
symlink that is installed, the resolution is stripped of the
directory, leaving only the filename, meaning that the new
symlink points to a file in the same directory as the
symlink. This feature is useful on some Unix systems, where
libraries are installed as a chain of symlinks with version
numbers, with less specific versions pointing to more
specific versions. FOLLOW_SYMLINK_CHAIN will install
all of these symlinks and the library itself into the
destination directory. For example, if you have the
following directory structure:

•

/opt/foo/lib/libfoo.so.1.2.3

•

/opt/foo/lib/libfoo.so.1.2 ->
libfoo.so.1.2.3 

•

/opt/foo/lib/libfoo.so.1 -> libfoo.so.1.2

•

/opt/foo/lib/libfoo.so -> libfoo.so.1

and you do:

file(COPY /opt/foo/lib/libfoo.so DESTINATION lib FOLLOW_SYMLINK_CHAIN)

This will
install all of the symlinks and libfoo.so.1.2.3
itself into lib.

See the
install(DIRECTORY) command for documentation of
permissions, FILES_MATCHING, PATTERN,
REGEX, and EXCLUDE options. Copying
directories preserves the structure of their content even if
options are used to select a subset of files.

The
INSTALL signature differs slightly from COPY:
it prints status messages (subject to the
CMAKE_INSTALL_MESSAGE variable), and
NO_SOURCE_PERMISSIONS is default. Installation
scripts generated by the install() command use this
signature (with some undocumented options for internal
use).

file(SIZE  )

Determine the
file size of the  and put the result
in  variable. Requires that
 is a valid path pointing to a file
and is readable.

file(READ_SYMLINK  )

This subcommand
queries the symlink  and stores the
path it points to in the result . If
 does not exist or is not a symlink,
CMake issues a fatal error.

Note that this
command returns the raw symlink path and does not resolve a
relative path. The following is an example of how to ensure
that an absolute path is obtained:
set(linkname "/path/to/foo.sym")
file(READ_SYMLINK "${linkname}" result)
if(NOT IS_ABSOLUTE "${result}")
  get_filename_component(dir "${linkname}" DIRECTORY)
  set(result "${dir}/${result}")
endif()

file(CREATE_LINK  
     [RESULT ] [COPY_ON_ERROR] [SYMBOLIC])

Create a link
 that points to
. It will be a hard link by default,
but providing the SYMBOLIC option results in a
symbolic link instead. Hard links require that
original exists and is a file, not a directory. If
 already exists, it will be
overwritten.

The
 variable, if specified, receives the
status of the operation. It is set to 0 upon success
or an error message otherwise. If RESULT is not
specified and the operation fails, a fatal error is
emitted.

Specifying
COPY_ON_ERROR enables copying the file as a fallback
if creating the link fails. It can be useful for handling
situations such as  and
 being on different drives or mount
points, which would make them unable to support a hard
link.

Path
Conversion

file(RELATIVE_PATH   )

Compute the
relative path from a  to a
 and store it in the
.

file(TO_CMAKE_PATH "" )
file(TO_NATIVE_PATH "" )

The
TO_CMAKE_PATH mode converts a native
 into a cmake-style path with
forward-slashes (/). The input can be a single path
or a system search path like $ENV{PATH}. A search
path will be converted to a cmake-style list separated by
; characters.

The
TO_NATIVE_PATH mode converts a cmake-style
 into a native path with
platform-specific slashes (\ on Windows and /
elsewhere).

Always use
double quotes around the  to be sure it
is treated as a single argument to this command.

Transfer

file(DOWNLOAD   [...])
file(UPLOAD     [...])

The
DOWNLOAD mode downloads the given 
to a local . The UPLOAD mode
uploads a local  to a given
.

Options to both
DOWNLOAD and UPLOAD are: 
INACTIVITY_TIMEOUT 

Terminate the operation after a
period of inactivity.

LOG 

Store a human-readable log of
the operation in a variable.

SHOW_PROGRESS

Print progress information as
status messages until the operation is complete.

STATUS

Store the resulting status of
the operation in a variable. The status is a ;
separated list of length 2. The first element is the numeric
return value for the operation, and the second element is a
string value for the error. A 0 numeric error means
no error in the operation.

TIMEOUT

Terminate the operation after a
given total time has elapsed.

USERPWD
:

Set username and password for
operation.

HTTPHEADER

HTTP header for operation.
Suboption can be repeated several times.

NETRC 

Specify whether the .netrc file
is to be used for operation. If this option is not
specified, the value of the CMAKE_NETRC variable will
be used instead. Valid levels are: 
IGNORED

The .netrc file is ignored.
This is the default.

OPTIONAL

The .netrc file is optional,
and information in the URL is preferred. The file will be
scanned to find which ever information is not specified in
the URL.

REQUIRED

The .netrc file is required,
and information in the URL is ignored.

NETRC_FILE

Specify an alternative .netrc
file to the one in your home directory, if the NETRC
level is OPTIONAL or REQUIRED. If this option
is not specified, the value of the CMAKE_NETRC_FILE
variable will be used instead.

If neither
NETRC option is given CMake will check variables
CMAKE_NETRC and CMAKE_NETRC_FILE,
respectively. 
TLS_VERIFY 

Specify whether to verify the
server certificate for https:// URLs. The default is
to not verify.

TLS_CAINFO

Specify a custom Certificate
Authority file for https:// URLs.

For
https:// URLs CMake must be built with OpenSSL
support. TLS/SSL certificates are not checked by
default. Set TLS_VERIFY to ON to check
certificates. If neither TLS option is given CMake
will check variables CMAKE_TLS_VERIFY and
CMAKE_TLS_CAINFO, respectively.

Additional
options to DOWNLOAD are:

EXPECTED_HASH
ALGO=

Verify that the downloaded
content hash matches the expected value, where ALGO
is one of the algorithms supported by
file(). If it does not match, the
operation fails with an error.

EXPECTED_MD5

Historical short-hand for
EXPECTED_HASH MD5=.

Locking

file(LOCK  [DIRECTORY] [RELEASE]
     [GUARD ]
     [RESULT_VARIABLE ]
     [TIMEOUT ])

Lock a file
specified by  if no DIRECTORY
option present and file /cmake.lock
otherwise. File will be locked for scope defined by
GUARD option (default value is PROCESS).
RELEASE option can be used to unlock file explicitly.
If option TIMEOUT is not specified CMake will wait
until lock succeed or until fatal error occurs. If
TIMEOUT is set to 0 lock will be tried once
and result will be reported immediately. If TIMEOUT
is not 0 CMake will try to lock file for the period
specified by  value. Any errors will
be interpreted as fatal if there is no
RESULT_VARIABLE option. Otherwise result will be
stored in  and will be 0 on
success or error message on failure.

Note that lock
is advisory - there is no guarantee that other processes
will respect this lock, i.e. lock synchronize two or more
CMake instances sharing some modifiable resources. Similar
logic applied to DIRECTORY option - locking parent
directory doesn’t prevent other LOCK commands
to lock any child directory or file.

Trying to lock
file twice is not allowed. Any intermediate directories and
file itself will be created if they not exist. GUARD
and TIMEOUT options ignored on RELEASE
operation.

Archiving

file(ARCHIVE_CREATE OUTPUT 
  PATHS ...
  [FORMAT ]
  [COMPRESSION ]
  [MTIME ]
  [VERBOSE])

Creates the
specified  file with the files and
directories listed in . Note that
 must list actual files or directories,
wildcards are not supported.

Use the
FORMAT option to specify the archive format.
Supported values for  are 7zip,
gnutar, pax, paxr, raw and
zip. If FORMAT is not given, the default
format is paxr.

Some archive
formats allow the type of compression to be specified. The
7zip and zip archive formats already imply a
specific type of compression. The other formats use no
compression by default, but can be directed to do so with
the COMPRESSION option. Valid values for
 are None, BZip2,
GZip, XZ, and Zstd.

NOTE:

With FORMAT set to
raw only one file will be compressed with the
compression type specified by COMPRESSION.

The
VERBOSE option enables verbose output for the archive
operation.

To specify the
modification time recorded in tarball entries, use the
MTIME option.

file(ARCHIVE_EXTRACT INPUT 
  [DESTINATION ]
  [PATTERNS ...]
  [LIST_ONLY]
  [VERBOSE])

Extracts or
lists the content of the specified
.

The directory
where the content of the archive will be extracted to can be
specified using the DESTINATION option. If the
directory does not exist, it will be created. If
DESTINATION is not given, the current binary
directory will be used.

If required,
you may select which files and directories to list or
extract from the archive using the specified
. Wildcards are supported. If the
PATTERNS option is not given, the entire archive will
be listed or extracted.

LIST_ONLY
will list the files in the archive rather than extract
them.

With
VERBOSE, the command will produce verbose output.

find_file

A short-hand signature is:

find_file ( name1 [path1 path2 ...])

The general
signature is:

find_file (

          name | NAMES name1 [name2 ...]
          [HINTS path1 [path2 ... ENV var]]
          [PATHS path1 [path2 ... ENV var]]
          [PATH_SUFFIXES suffix1 [suffix2 ...]]
          [DOC "cache documentation string"]
          [REQUIRED]
          [NO_DEFAULT_PATH]
          [NO_PACKAGE_ROOT_PATH]
          [NO_CMAKE_PATH]
          [NO_CMAKE_ENVIRONMENT_PATH]
          [NO_SYSTEM_ENVIRONMENT_PATH]
          [NO_CMAKE_SYSTEM_PATH]
          [CMAKE_FIND_ROOT_PATH_BOTH |
           ONLY_CMAKE_FIND_ROOT_PATH |
           NO_CMAKE_FIND_ROOT_PATH]
         )

This command is
used to find a full path to named file. A cache entry named
by  is created to store the result of this
command. If the full path to a file is found the result is
stored in the variable and the search will not be repeated
unless the variable is cleared. If nothing is found, the
result will be -NOTFOUND. The
REQUIRED option stops processing with an error
message if nothing is found, otherwise the search will be
attempted again the next time find_file is invoked with the
same variable.

Options
include:

NAMES

Specify one or more possible names for the full path to
a file.

When using this
to specify names with and without a version suffix, we
recommend specifying the unversioned name first so that
locally-built packages can be found before those provided by
distributions.

HINTS, PATHS

Specify directories to search
in addition to the default locations. The ENV var
sub-option reads paths from a system environment
variable.

PATH_SUFFIXES

Specify additional
subdirectories to check below each directory location
otherwise considered.

DOC

Specify the documentation string for the
 cache entry.

REQUIRED

Stop processing with an error
message if nothing is found.

If
NO_DEFAULT_PATH is specified, then no additional
paths are added to the search. If NO_DEFAULT_PATH is
not specified, the search process is as follows:

1.

If called from within a find module or any other script
loaded by a call to
find_package(), search prefixes
unique to the current package being found. Specifically,
look in the _ROOT CMake variable
and the _ROOT environment
variable. The package root variables are maintained as a
stack, so if called from nested find modules or config
packages, root paths from the parent’s find module or
config package will be searched after paths from the current
module or package. In other words, the search order would be
_ROOT,
ENV{_ROOT},
_ROOT,
ENV{_ROOT}, etc. This can be
skipped if NO_PACKAGE_ROOT_PATH is passed or by
setting the CMAKE_FIND_USE_PACKAGE_ROOT_PATH to
FALSE. See policy CMP0074.

•

/include/
if CMAKE_LIBRARY_ARCHITECTURE is set, and
/include for each 
in the _ROOT CMake variable and
the _ROOT environment variable if
called from within a find module loaded by
find_package() 

2.

Search paths specified in cmake-specific cache
variables. These are intended to be used on the command line
with a -DVAR=value. The values are interpreted as
semicolon-separated lists. This can be skipped if
NO_CMAKE_PATH is passed or by setting the
CMAKE_FIND_USE_CMAKE_PATH to FALSE.

•

/include/
if CMAKE_LIBRARY_ARCHITECTURE is set, and
/include for each 
in CMAKE_PREFIX_PATH

•

CMAKE_INCLUDE_PATH

•

CMAKE_FRAMEWORK_PATH

3.

Search paths
specified in cmake-specific environment variables. These are
intended to be set in the user’s shell configuration,
and therefore use the host’s native path separator
(; on Windows and : on UNIX). This can be
skipped if NO_CMAKE_ENVIRONMENT_PATH is passed or by
setting the CMAKE_FIND_USE_CMAKE_ENVIRONMENT_PATH to
FALSE.

•

/include/
if CMAKE_LIBRARY_ARCHITECTURE is set, and
/include for each 
in CMAKE_PREFIX_PATH

•

CMAKE_INCLUDE_PATH

•

CMAKE_FRAMEWORK_PATH

4.

Search the
paths specified by the HINTS option. These should be
paths computed by system introspection, such as a hint
provided by the location of another item already found.
Hard-coded guesses should be specified with the PATHS
option.

5.

Search the standard system
environment variables. This can be skipped if
NO_SYSTEM_ENVIRONMENT_PATH is passed or by setting
the CMAKE_FIND_USE_SYSTEM_ENVIRONMENT_PATH to
FALSE. 

•

The directories in PATH
and INCLUDE.

•

On Windows hosts:
/include/ if
CMAKE_LIBRARY_ARCHITECTURE is set, and
/include for each
/[s]bin in PATH, and
/include for other entries in
PATH. 

6.

Search cmake
variables defined in the Platform files for the current
system. This can be skipped if NO_CMAKE_SYSTEM_PATH
is passed or by setting the
CMAKE_FIND_USE_CMAKE_SYSTEM_PATH to FALSE.

•

/include/
if CMAKE_LIBRARY_ARCHITECTURE is set, and
/include for each 
in CMAKE_SYSTEM_PREFIX_PATH

•

CMAKE_SYSTEM_INCLUDE_PATH

•

CMAKE_SYSTEM_FRAMEWORK_PATH

The platform
paths that these variables contain are locations that
typically include installed software. An example being
/usr/local for UNIX based platforms.

7.

Search the paths specified by
the PATHS option or in the short-hand version of the
command. These are typically hard-coded guesses.

On macOS the
CMAKE_FIND_FRAMEWORK and CMAKE_FIND_APPBUNDLE
variables determine the order of preference between
Apple-style and unix-style package components.

The CMake
variable CMAKE_FIND_ROOT_PATH specifies one or more
directories to be prepended to all other search directories.
This effectively “re-roots” the entire search
under given locations. Paths which are descendants of the
CMAKE_STAGING_PREFIX are excluded from this
re-rooting, because that variable is always a path on the
host system. By default the CMAKE_FIND_ROOT_PATH is
empty.

The
CMAKE_SYSROOT variable can also be used to specify
exactly one directory to use as a prefix. Setting
CMAKE_SYSROOT also has other effects. See the
documentation for that variable for more.

These variables
are especially useful when cross-compiling to point to the
root directory of the target environment and CMake will
search there too. By default at first the directories listed
in CMAKE_FIND_ROOT_PATH are searched, then the
CMAKE_SYSROOT directory is searched, and then the
non-rooted directories will be searched. The default
behavior can be adjusted by setting
CMAKE_FIND_ROOT_PATH_MODE_INCLUDE. This behavior can
be manually overridden on a per-call basis using options:

CMAKE_FIND_ROOT_PATH_BOTH

Search in the order described
above.

NO_CMAKE_FIND_ROOT_PATH

Do not use the
CMAKE_FIND_ROOT_PATH variable.

ONLY_CMAKE_FIND_ROOT_PATH

Search only the re-rooted
directories and directories below
CMAKE_STAGING_PREFIX.

The default
search order is designed to be most-specific to
least-specific for common use cases. Projects may override
the order by simply calling the command multiple times and
using the NO_* options:

find_file ( NAMES name PATHS paths... NO_DEFAULT_PATH)
find_file ( NAMES name)

Once one of the
calls succeeds the result variable will be set and stored in
the cache so that no call will search again.

find_library

A short-hand signature is:

find_library ( name1 [path1 path2 ...])

The general
signature is:

find_library (

          name | NAMES name1 [name2 ...] [NAMES_PER_DIR]
          [HINTS path1 [path2 ... ENV var]]
          [PATHS path1 [path2 ... ENV var]]
          [PATH_SUFFIXES suffix1 [suffix2 ...]]
          [DOC "cache documentation string"]
          [REQUIRED]
          [NO_DEFAULT_PATH]
          [NO_PACKAGE_ROOT_PATH]
          [NO_CMAKE_PATH]
          [NO_CMAKE_ENVIRONMENT_PATH]
          [NO_SYSTEM_ENVIRONMENT_PATH]
          [NO_CMAKE_SYSTEM_PATH]
          [CMAKE_FIND_ROOT_PATH_BOTH |
           ONLY_CMAKE_FIND_ROOT_PATH |
           NO_CMAKE_FIND_ROOT_PATH]
         )

This command is
used to find a library. A cache entry named by
 is created to store the result of this
command. If the library is found the result is stored in the
variable and the search will not be repeated unless the
variable is cleared. If nothing is found, the result will be
-NOTFOUND. The REQUIRED option
stops processing with an error message if nothing is found,
otherwise the search will be attempted again the next time
find_library is invoked with the same variable.

Options
include:

NAMES

Specify one or more possible names for the library.

When using this
to specify names with and without a version suffix, we
recommend specifying the unversioned name first so that
locally-built packages can be found before those provided by
distributions.

HINTS, PATHS

Specify directories to search
in addition to the default locations. The ENV var
sub-option reads paths from a system environment
variable.

PATH_SUFFIXES

Specify additional
subdirectories to check below each directory location
otherwise considered.

DOC

Specify the documentation string for the
 cache entry.

REQUIRED

Stop processing with an error
message if nothing is found.

If
NO_DEFAULT_PATH is specified, then no additional
paths are added to the search. If NO_DEFAULT_PATH is
not specified, the search process is as follows:

1.

If called from within a find module or any other script
loaded by a call to
find_package(), search prefixes
unique to the current package being found. Specifically,
look in the _ROOT CMake variable
and the _ROOT environment
variable. The package root variables are maintained as a
stack, so if called from nested find modules or config
packages, root paths from the parent’s find module or
config package will be searched after paths from the current
module or package. In other words, the search order would be
_ROOT,
ENV{_ROOT},
_ROOT,
ENV{_ROOT}, etc. This can be
skipped if NO_PACKAGE_ROOT_PATH is passed or by
setting the CMAKE_FIND_USE_PACKAGE_ROOT_PATH to
FALSE. See policy CMP0074.

•

/lib/
if CMAKE_LIBRARY_ARCHITECTURE is set, and
/lib for each  in
the _ROOT CMake variable and the
_ROOT environment variable if
called from within a find module loaded by
find_package() 

2.

Search paths specified in cmake-specific cache
variables. These are intended to be used on the command line
with a -DVAR=value. The values are interpreted as
semicolon-separated lists. This can be skipped if
NO_CMAKE_PATH is passed or by setting the
CMAKE_FIND_USE_CMAKE_PATH to FALSE.

•

/lib/
if CMAKE_LIBRARY_ARCHITECTURE is set, and
/lib for each  in
CMAKE_PREFIX_PATH 

•

CMAKE_LIBRARY_PATH

•

CMAKE_FRAMEWORK_PATH

3.

Search paths
specified in cmake-specific environment variables. These are
intended to be set in the user’s shell configuration,
and therefore use the host’s native path separator
(; on Windows and : on UNIX). This can be
skipped if NO_CMAKE_ENVIRONMENT_PATH is passed or by
setting the CMAKE_FIND_USE_CMAKE_ENVIRONMENT_PATH to
FALSE.

•

/lib/
if CMAKE_LIBRARY_ARCHITECTURE is set, and
/lib for each  in
CMAKE_PREFIX_PATH 

•

CMAKE_LIBRARY_PATH

•

CMAKE_FRAMEWORK_PATH

4.

Search the
paths specified by the HINTS option. These should be
paths computed by system introspection, such as a hint
provided by the location of another item already found.
Hard-coded guesses should be specified with the PATHS
option.

5.

Search the standard system
environment variables. This can be skipped if
NO_SYSTEM_ENVIRONMENT_PATH is passed or by setting
the CMAKE_FIND_USE_SYSTEM_ENVIRONMENT_PATH to
FALSE. 

•

The directories in PATH
and INCLUDE.

•

On Windows hosts: /lib/
if CMAKE_LIBRARY_ARCHITECTURE is set, and
/lib for each
/[s]bin in PATH, and
/lib for other entries in
PATH. 

6.

Search cmake
variables defined in the Platform files for the current
system. This can be skipped if NO_CMAKE_SYSTEM_PATH
is passed or by setting the
CMAKE_FIND_USE_CMAKE_SYSTEM_PATH to FALSE.

•

/lib/
if CMAKE_LIBRARY_ARCHITECTURE is set, and
/lib for each  in
CMAKE_SYSTEM_PREFIX_PATH 

•

CMAKE_SYSTEM_LIBRARY_PATH

•

CMAKE_SYSTEM_FRAMEWORK_PATH

The platform
paths that these variables contain are locations that
typically include installed software. An example being
/usr/local for UNIX based platforms.

7.

Search the paths specified by
the PATHS option or in the short-hand version of the
command. These are typically hard-coded guesses.

On macOS the
CMAKE_FIND_FRAMEWORK and CMAKE_FIND_APPBUNDLE
variables determine the order of preference between
Apple-style and unix-style package components.

The CMake
variable CMAKE_FIND_ROOT_PATH specifies one or more
directories to be prepended to all other search directories.
This effectively “re-roots” the entire search
under given locations. Paths which are descendants of the
CMAKE_STAGING_PREFIX are excluded from this
re-rooting, because that variable is always a path on the
host system. By default the CMAKE_FIND_ROOT_PATH is
empty.

The
CMAKE_SYSROOT variable can also be used to specify
exactly one directory to use as a prefix. Setting
CMAKE_SYSROOT also has other effects. See the
documentation for that variable for more.

These variables
are especially useful when cross-compiling to point to the
root directory of the target environment and CMake will
search there too. By default at first the directories listed
in CMAKE_FIND_ROOT_PATH are searched, then the
CMAKE_SYSROOT directory is searched, and then the
non-rooted directories will be searched. The default
behavior can be adjusted by setting
CMAKE_FIND_ROOT_PATH_MODE_LIBRARY. This behavior can
be manually overridden on a per-call basis using options:

CMAKE_FIND_ROOT_PATH_BOTH

Search in the order described
above.

NO_CMAKE_FIND_ROOT_PATH

Do not use the
CMAKE_FIND_ROOT_PATH variable.

ONLY_CMAKE_FIND_ROOT_PATH

Search only the re-rooted
directories and directories below
CMAKE_STAGING_PREFIX.

The default
search order is designed to be most-specific to
least-specific for common use cases. Projects may override
the order by simply calling the command multiple times and
using the NO_* options:

find_library ( NAMES name PATHS paths... NO_DEFAULT_PATH)
find_library ( NAMES name)

Once one of the
calls succeeds the result variable will be set and stored in
the cache so that no call will search again.

When more than
one value is given to the NAMES option this command
by default will consider one name at a time and search every
directory for it. The NAMES_PER_DIR option tells this
command to consider one directory at a time and search for
all names in it.

Each library
name given to the NAMES option is first considered as
a library file name and then considered with
platform-specific prefixes (e.g. lib) and suffixes
(e.g. .so). Therefore one may specify library file
names such as libfoo.a directly. This can be used to
locate static libraries on UNIX-like systems.

If the library
found is a framework, then  will be set to
the full path to the framework
/A.framework. When a full path to a
framework is used as a library, CMake will use a
-framework A, and a -F to link
the framework to the target.

If the
CMAKE_FIND_LIBRARY_CUSTOM_LIB_SUFFIX variable is set
all search paths will be tested as normal, with the suffix
appended, and with all matches of lib/ replaced with
lib${CMAKE_FIND_LIBRARY_CUSTOM_LIB_SUFFIX}/. This
variable overrides the FIND_LIBRARY_USE_LIB32_PATHS,
FIND_LIBRARY_USE_LIBX32_PATHS, and
FIND_LIBRARY_USE_LIB64_PATHS global properties.

If the
FIND_LIBRARY_USE_LIB32_PATHS global property is set
all search paths will be tested as normal, with 32/
appended, and with all matches of lib/ replaced with
lib32/. This property is automatically set for the
platforms that are known to need it if at least one of the
languages supported by the project() command is
enabled.

If the
FIND_LIBRARY_USE_LIBX32_PATHS global property is set
all search paths will be tested as normal, with x32/
appended, and with all matches of lib/ replaced with
libx32/. This property is automatically set for the
platforms that are known to need it if at least one of the
languages supported by the project() command is
enabled.

If the
FIND_LIBRARY_USE_LIB64_PATHS global property is set
all search paths will be tested as normal, with 64/
appended, and with all matches of lib/ replaced with
lib64/. This property is automatically set for the
platforms that are known to need it if at least one of the
languages supported by the project() command is
enabled.

find_package

Find an external project, and load its settings.

Basic
Signature and Module Mode

find_package( [version] [EXACT] [QUIET] [MODULE]
             [REQUIRED] [[COMPONENTS] [components...]]
             [OPTIONAL_COMPONENTS components...]
             [NO_POLICY_SCOPE])

Finds and loads
settings from an external project.
_FOUND will be set to indicate
whether the package was found. When the package is found
package-specific information is provided through variables
and Imported Targets documented by the package itself. The
QUIET option disables informational messages,
including those indicating that the package cannot be found
if it is not REQUIRED. The REQUIRED option
stops processing with an error message if the package cannot
be found.

A
package-specific list of required components may be listed
after the COMPONENTS option (or after the
REQUIRED option if present). Additional optional
components may be listed after OPTIONAL_COMPONENTS.
Available components and their influence on whether a
package is considered to be found are defined by the target
package.

The
[version] argument requests a version with which the
package found should be compatible (format is
major[.minor[.patch[.tweak]]]). The EXACT
option requests that the version be matched exactly. If no
[version] and/or component list is given to a
recursive invocation inside a find-module, the corresponding
arguments are forwarded automatically from the outer call
(including the EXACT flag for [version]).
Version support is currently provided only on a
package-by-package basis (see the Version Selection
section below).

See the
cmake_policy() command documentation for discussion
of the NO_POLICY_SCOPE option.

The command has
two modes by which it searches for packages:
“Module” mode and “Config” mode. The
above signature selects Module mode. If no module is found
the command falls back to Config mode, described below. This
fall back is disabled if the MODULE option is
given.

In Module mode,
CMake searches for a file called
Find.cmake. The file is first
searched in the CMAKE_MODULE_PATH, then among the
Find Modules provided by the CMake installation. If the file
is found, it is read and processed by CMake. It is
responsible for finding the package, checking the version,
and producing any needed messages. Some find-modules provide
limited or no support for versioning; check the module
documentation.

If the
MODULE option is not specified in the above
signature, CMake first searches for the package using Module
mode. Then, if the package is not found, it searches again
using Config mode. A user may set the variable
CMAKE_FIND_PACKAGE_PREFER_CONFIG to TRUE to
direct CMake first search using Config mode before falling
back to Module mode.

Full
Signature and Config Mode 
User code should generally look for packages using the above
basic signature. The remainder of this command
documentation specifies the full command signature and
details of the search process. Project maintainers wishing
to provide a package to be found by this command are
encouraged to read on.

The complete
Config mode command signature is

find_package( [version] [EXACT] [QUIET]
             [REQUIRED] [[COMPONENTS] [components...]]
             [OPTIONAL_COMPONENTS components...]
             [CONFIG|NO_MODULE]
             [NO_POLICY_SCOPE]
             [NAMES name1 [name2 ...]]
             [CONFIGS config1 [config2 ...]]
             [HINTS path1 [path2 ... ]]
             [PATHS path1 [path2 ... ]]
             [PATH_SUFFIXES suffix1 [suffix2 ...]]
             [NO_DEFAULT_PATH]
             [NO_PACKAGE_ROOT_PATH]
             [NO_CMAKE_PATH]
             [NO_CMAKE_ENVIRONMENT_PATH]
             [NO_SYSTEM_ENVIRONMENT_PATH]
             [NO_CMAKE_PACKAGE_REGISTRY]
             [NO_CMAKE_BUILDS_PATH] # Deprecated; does nothing.
             [NO_CMAKE_SYSTEM_PATH]
             [NO_CMAKE_SYSTEM_PACKAGE_REGISTRY]
             [CMAKE_FIND_ROOT_PATH_BOTH |
              ONLY_CMAKE_FIND_ROOT_PATH |
              NO_CMAKE_FIND_ROOT_PATH])

The
CONFIG option, the synonymous NO_MODULE
option, or the use of options not specified in the basic
signature all enforce pure Config mode. In pure Config
mode, the command skips Module mode search and proceeds at
once with Config mode search.

Config mode
search attempts to locate a configuration file provided by
the package to be found. A cache entry called
_DIR is created to hold the
directory containing the file. By default the command
searches for a package with the name
. If the NAMES option is
given the names following it are used instead of
. The command searches for a file
called Config.cmake or
-config.cmake for each
name specified. A replacement set of possible configuration
file names may be given using the CONFIGS option. The
search procedure is specified below. Once found, the
configuration file is read and processed by CMake. Since the
file is provided by the package it already knows the
location of package contents. The full path to the
configuration file is stored in the cmake variable
_CONFIG.

All
configuration files which have been considered by CMake
while searching for an installation of the package with an
appropriate version are stored in the cmake variable
_CONSIDERED_CONFIGS, the
associated versions in
_CONSIDERED_VERSIONS.

If the package
configuration file cannot be found CMake will generate an
error describing the problem unless the QUIET
argument is specified. If REQUIRED is specified and
the package is not found a fatal error is generated and the
configure step stops executing. If
_DIR has been set to a directory
not containing a configuration file CMake will ignore it and
search from scratch.

Package
maintainers providing CMake package configuration files are
encouraged to name and install them such that the Search
Procedure outlined below will find them without
requiring use of additional options.

Version
Selection 
When the [version] argument is given Config mode will
only find a version of the package that claims compatibility
with the requested version (format is
major[.minor[.patch[.tweak]]]). If the EXACT
option is given only a version of the package claiming an
exact match of the requested version may be found. CMake
does not establish any convention for the meaning of version
numbers. Package version numbers are checked by
“version” files provided by the packages
themselves. For a candidate package configuration file
.cmake the corresponding version
file is located next to it and named either
-version.cmake or
Version.cmake. If no such version
file is available then the configuration file is assumed to
not be compatible with any requested version. A basic
version file containing generic version matching code can be
created using the CMakePackageConfigHelpers module.
When a version file is found it is loaded to check the
requested version number. The version file is loaded in a
nested scope in which the following variables have been
defined: 
PACKAGE_FIND_NAME

the

PACKAGE_FIND_VERSION

full requested version
string

PACKAGE_FIND_VERSION_MAJOR

major version if requested,
else 0

PACKAGE_FIND_VERSION_MINOR

minor version if requested,
else 0

PACKAGE_FIND_VERSION_PATCH

patch version if requested,
else 0

PACKAGE_FIND_VERSION_TWEAK

tweak version if requested,
else 0

PACKAGE_FIND_VERSION_COUNT

number of version components, 0
to 4

The version
file checks whether it satisfies the requested version and
sets these variables: 
PACKAGE_VERSION

full provided version
string

PACKAGE_VERSION_EXACT

true if version is exact
match

PACKAGE_VERSION_COMPATIBLE

true if version is
compatible

PACKAGE_VERSION_UNSUITABLE

true if unsuitable as any
version

These variables
are checked by the find_package command to determine
whether the configuration file provides an acceptable
version. They are not available after the
find_package call returns. If the version is
acceptable the following variables are set: 
_VERSION

full provided version
string

_VERSION_MAJOR

major version if provided, else
0

_VERSION_MINOR

minor version if provided, else
0

_VERSION_PATCH

patch version if provided, else
0

_VERSION_TWEAK

tweak version if provided, else
0

_VERSION_COUNT

number of version components, 0
to 4

and the
corresponding package configuration file is loaded. When
multiple package configuration files are available whose
version files claim compatibility with the version requested
it is unspecified which one is chosen: unless the variable
CMAKE_FIND_PACKAGE_SORT_ORDER is set no attempt is
made to choose a highest or closest version number.

To control the
order in which find_package checks for compatibility
use the two variables CMAKE_FIND_PACKAGE_SORT_ORDER
and CMAKE_FIND_PACKAGE_SORT_DIRECTION. For instance
in order to select the highest version one can set

SET(CMAKE_FIND_PACKAGE_SORT_ORDER NATURAL)
SET(CMAKE_FIND_PACKAGE_SORT_DIRECTION DEC)

before calling
find_package.

Search
Procedure 
CMake constructs a set of possible installation prefixes for
the package. Under each prefix several directories are
searched for a configuration file. The tables below show the
directories searched. Each entry is meant for installation
trees following Windows (W), UNIX (U), or
Apple (A) conventions:

/                                                       (W)
/(cmake|CMake)/                                         (W)
/*/                                               (W)
/*/(cmake|CMake)/                                 (W)
/(lib/|lib*|share)/cmake/*/                 (U)
/(lib/|lib*|share)/*/                       (U)
/(lib/|lib*|share)/*/(cmake|CMake)/         (U)
/*/(lib/|lib*|share)/cmake/*/         (W/U)
/*/(lib/|lib*|share)/*/               (W/U)
/*/(lib/|lib*|share)/*/(cmake|CMake)/ (W/U)

On systems
supporting macOS FRAMEWORK and BUNDLE, the
following directories are searched for Frameworks or
Application Bundles containing a configuration file:

/.framework/Resources/                    (A)
/.framework/Resources/CMake/              (A)
/.framework/Versions/*/Resources/         (A)
/.framework/Versions/*/Resources/CMake/   (A)
/.app/Contents/Resources/                 (A)
/.app/Contents/Resources/CMake/           (A)

In all cases
the  is treated as case-insensitive and
corresponds to any of the names specified
( or names given by
NAMES).

Paths with
lib/ are enabled if the
CMAKE_LIBRARY_ARCHITECTURE variable is set.
lib* includes one or more of the values lib64,
lib32, libx32 or lib (searched in that
order).

•

Paths with lib64 are searched on 64 bit platforms
if the FIND_LIBRARY_USE_LIB64_PATHS property is set
to TRUE.

•

Paths with lib32 are searched on 32 bit platforms
if the FIND_LIBRARY_USE_LIB32_PATHS property is set
to TRUE.

•

Paths with libx32 are searched on platforms using
the x32 ABI if the FIND_LIBRARY_USE_LIBX32_PATHS
property is set to TRUE.

•

The lib path is always searched.

If
PATH_SUFFIXES is specified, the suffixes are appended
to each (W) or (U) directory entry
one-by-one.

This set of
directories is intended to work in cooperation with projects
that provide configuration files in their installation
trees. Directories above marked with (W) are intended
for installations on Windows where the prefix may point at
the top of an application’s installation directory.
Those marked with (U) are intended for installations
on UNIX platforms where the prefix is shared by multiple
packages. This is merely a convention, so all (W) and
(U) directories are still searched on all platforms.
Directories marked with (A) are intended for
installations on Apple platforms. The
CMAKE_FIND_FRAMEWORK and CMAKE_FIND_APPBUNDLE
variables determine the order of preference.

The set of
installation prefixes is constructed using the following
steps. If NO_DEFAULT_PATH is specified all
NO_* options are enabled.

1.

Search paths specified in the
_ROOT CMake variable and the
_ROOT environment variable, where
 is the package to be found. The
package root variables are maintained as a stack so if
called from within a find module, root paths from the
parent’s find module will also be searched after paths
for the current package. This can be skipped if
NO_PACKAGE_ROOT_PATH is passed or by setting the
CMAKE_FIND_USE_PACKAGE_ROOT_PATH to FALSE. See
policy CMP0074.

2.

Search paths specified in cmake-specific cache
variables. These are intended to be used on the command line
with a -DVAR=value. The values are interpreted as
semicolon-separated lists. This can be skipped if
NO_CMAKE_PATH is passed or by setting the
CMAKE_FIND_USE_CMAKE_PATH to FALSE:

•

CMAKE_PREFIX_PATH

•

CMAKE_FRAMEWORK_PATH

•

CMAKE_APPBUNDLE_PATH

3.

Search paths
specified in cmake-specific environment variables. These are
intended to be set in the user’s shell configuration,
and therefore use the host’s native path separator
(; on Windows and : on UNIX). This can be
skipped if NO_CMAKE_ENVIRONMENT_PATH is passed or by
setting the CMAKE_FIND_USE_CMAKE_ENVIRONMENT_PATH to
FALSE:

•

_DIR 

•

CMAKE_PREFIX_PATH

•

CMAKE_FRAMEWORK_PATH

•

CMAKE_APPBUNDLE_PATH

4.

Search paths
specified by the HINTS option. These should be paths
computed by system introspection, such as a hint provided by
the location of another item already found. Hard-coded
guesses should be specified with the PATHS
option.

5.

Search the standard system
environment variables. This can be skipped if
NO_SYSTEM_ENVIRONMENT_PATH is passed or by setting
the CMAKE_FIND_USE_SYSTEM_ENVIRONMENT_PATH to
FALSE. Path entries ending in /bin or
/sbin are automatically converted to their parent
directories: 

•

PATH

6.

Search paths stored in the CMake User Package Registry.
This can be skipped if NO_CMAKE_PACKAGE_REGISTRY is
passed or by setting the variable
CMAKE_FIND_USE_PACKAGE_REGISTRY to FALSE or
the deprecated variable
CMAKE_FIND_PACKAGE_NO_PACKAGE_REGISTRY to
TRUE. 

See the
cmake-packages(7) manual for details on the user
package registry.

7.

Search cmake variables defined
in the Platform files for the current system. This can be
skipped if NO_CMAKE_SYSTEM_PATH is passed or by
setting the CMAKE_FIND_USE_CMAKE_SYSTEM_PATH to
FALSE: 

•

CMAKE_SYSTEM_PREFIX_PATH 

•

CMAKE_SYSTEM_FRAMEWORK_PATH

•

CMAKE_SYSTEM_APPBUNDLE_PATH

The platform
paths that these variables contain are locations that
typically include installed software. An example being
/usr/local for UNIX based platforms.

8.

Search paths stored in the CMake
System Package Registry. This can be skipped if
NO_CMAKE_SYSTEM_PACKAGE_REGISTRY is passed or by
setting the CMAKE_FIND_USE_SYSTEM_PACKAGE_REGISTRY
variable to FALSE or the deprecated variable
CMAKE_FIND_PACKAGE_NO_SYSTEM_PACKAGE_REGISTRY to
TRUE. 

See the
cmake-packages(7) manual for details on the system
package registry.

9.

Search paths specified by the
PATHS option. These are typically hard-coded
guesses. 

The CMake
variable CMAKE_FIND_ROOT_PATH specifies one or more
directories to be prepended to all other search directories.
This effectively “re-roots” the entire search
under given locations. Paths which are descendants of the
CMAKE_STAGING_PREFIX are excluded from this
re-rooting, because that variable is always a path on the
host system. By default the CMAKE_FIND_ROOT_PATH is
empty.

The
CMAKE_SYSROOT variable can also be used to specify
exactly one directory to use as a prefix. Setting
CMAKE_SYSROOT also has other effects. See the
documentation for that variable for more.

These variables
are especially useful when cross-compiling to point to the
root directory of the target environment and CMake will
search there too. By default at first the directories listed
in CMAKE_FIND_ROOT_PATH are searched, then the
CMAKE_SYSROOT directory is searched, and then the
non-rooted directories will be searched. The default
behavior can be adjusted by setting
CMAKE_FIND_ROOT_PATH_MODE_PACKAGE. This behavior can
be manually overridden on a per-call basis using options:

CMAKE_FIND_ROOT_PATH_BOTH

Search in the order described
above.

NO_CMAKE_FIND_ROOT_PATH

Do not use the
CMAKE_FIND_ROOT_PATH variable.

ONLY_CMAKE_FIND_ROOT_PATH

Search only the re-rooted
directories and directories below
CMAKE_STAGING_PREFIX.

The default
search order is designed to be most-specific to
least-specific for common use cases. Projects may override
the order by simply calling the command multiple times and
using the NO_* options:

find_package ( PATHS paths... NO_DEFAULT_PATH)
find_package ()

Once one of the
calls succeeds the result variable will be set and stored in
the cache so that no call will search again.

By default the
value stored in the result variable will be the path at
which the file is found. The
CMAKE_FIND_PACKAGE_RESOLVE_SYMLINKS variable may be
set to TRUE before calling find_package in
order to resolve symbolic links and store the real path to
the file.

Every
non-REQUIRED find_package call can be disabled by
setting the
CMAKE_DISABLE_FIND_PACKAGE_
variable to TRUE.

Package File
Interface Variables 
When loading a find module or package configuration file
find_package defines variables to provide information
about the call arguments (and restores their original state
before returning): 
CMAKE_FIND_PACKAGE_NAME

the 
which is searched for

_FIND_REQUIRED

true if REQUIRED option
was given

_FIND_QUIETLY

true if QUIET option was
given

_FIND_VERSION

full requested version
string

_FIND_VERSION_MAJOR

major version if requested,
else 0

_FIND_VERSION_MINOR

minor version if requested,
else 0

_FIND_VERSION_PATCH

patch version if requested,
else 0

_FIND_VERSION_TWEAK

tweak version if requested,
else 0

_FIND_VERSION_COUNT

number of version components, 0
to 4

_FIND_VERSION_EXACT

true if EXACT option was
given

_FIND_COMPONENTS

list of requested
components

_FIND_REQUIRED_

true if component
 is required, false if component
 is optional

In Module mode
the loaded find module is responsible to honor the request
detailed by these variables; see the find module for
details. In Config mode find_package handles
REQUIRED, QUIET, and [version] options
automatically but leaves it to the package configuration
file to handle components in a way that makes sense for the
package. The package configuration file may set
_FOUND to false to tell
find_package that component requirements are not
satisfied.

find_path

A short-hand signature is:

find_path ( name1 [path1 path2 ...])

The general
signature is:

find_path (

          name | NAMES name1 [name2 ...]
          [HINTS path1 [path2 ... ENV var]]
          [PATHS path1 [path2 ... ENV var]]
          [PATH_SUFFIXES suffix1 [suffix2 ...]]
          [DOC "cache documentation string"]
          [REQUIRED]
          [NO_DEFAULT_PATH]
          [NO_PACKAGE_ROOT_PATH]
          [NO_CMAKE_PATH]
          [NO_CMAKE_ENVIRONMENT_PATH]
          [NO_SYSTEM_ENVIRONMENT_PATH]
          [NO_CMAKE_SYSTEM_PATH]
          [CMAKE_FIND_ROOT_PATH_BOTH |
           ONLY_CMAKE_FIND_ROOT_PATH |
           NO_CMAKE_FIND_ROOT_PATH]
         )

This command is
used to find a directory containing the named file. A cache
entry named by  is created to store the
result of this command. If the file in a directory is found
the result is stored in the variable and the search will not
be repeated unless the variable is cleared. If nothing is
found, the result will be -NOTFOUND. The
REQUIRED option stops processing with an error
message if nothing is found, otherwise the search will be
attempted again the next time find_path is invoked with the
same variable.

Options
include:

NAMES

Specify one or more possible names for the file in a
directory. 

When using this
to specify names with and without a version suffix, we
recommend specifying the unversioned name first so that
locally-built packages can be found before those provided by
distributions.

HINTS, PATHS

Specify directories to search
in addition to the default locations. The ENV var
sub-option reads paths from a system environment
variable.

PATH_SUFFIXES

Specify additional
subdirectories to check below each directory location
otherwise considered.

DOC

Specify the documentation string for the
 cache entry.

REQUIRED

Stop processing with an error
message if nothing is found.

If
NO_DEFAULT_PATH is specified, then no additional
paths are added to the search. If NO_DEFAULT_PATH is
not specified, the search process is as follows:

1.

If called from within a find module or any other script
loaded by a call to
find_package(), search prefixes
unique to the current package being found. Specifically,
look in the _ROOT CMake variable
and the _ROOT environment
variable. The package root variables are maintained as a
stack, so if called from nested find modules or config
packages, root paths from the parent’s find module or
config package will be searched after paths from the current
module or package. In other words, the search order would be
_ROOT,
ENV{_ROOT},
_ROOT,
ENV{_ROOT}, etc. This can be
skipped if NO_PACKAGE_ROOT_PATH is passed or by
setting the CMAKE_FIND_USE_PACKAGE_ROOT_PATH to
FALSE. See policy CMP0074.

•

/include/
if CMAKE_LIBRARY_ARCHITECTURE is set, and
/include for each 
in the _ROOT CMake variable and
the _ROOT environment variable if
called from within a find module loaded by
find_package() 

2.

Search paths specified in cmake-specific cache
variables. These are intended to be used on the command line
with a -DVAR=value. The values are interpreted as
semicolon-separated lists. This can be skipped if
NO_CMAKE_PATH is passed or by setting the
CMAKE_FIND_USE_CMAKE_PATH to FALSE.

•

/include/
if CMAKE_LIBRARY_ARCHITECTURE is set, and
/include for each 
in CMAKE_PREFIX_PATH

•

CMAKE_INCLUDE_PATH

•

CMAKE_FRAMEWORK_PATH

3.

Search paths
specified in cmake-specific environment variables. These are
intended to be set in the user’s shell configuration,
and therefore use the host’s native path separator
(; on Windows and : on UNIX). This can be
skipped if NO_CMAKE_ENVIRONMENT_PATH is passed or by
setting the CMAKE_FIND_USE_CMAKE_ENVIRONMENT_PATH to
FALSE.

•

/include/
if CMAKE_LIBRARY_ARCHITECTURE is set, and
/include for each 
in CMAKE_PREFIX_PATH

•

CMAKE_INCLUDE_PATH

•

CMAKE_FRAMEWORK_PATH

4.

Search the
paths specified by the HINTS option. These should be
paths computed by system introspection, such as a hint
provided by the location of another item already found.
Hard-coded guesses should be specified with the PATHS
option.

5.

Search the standard system
environment variables. This can be skipped if
NO_SYSTEM_ENVIRONMENT_PATH is passed or by setting
the CMAKE_FIND_USE_SYSTEM_ENVIRONMENT_PATH to
FALSE. 

•

The directories in PATH
and INCLUDE.

•

On Windows hosts:
/include/ if
CMAKE_LIBRARY_ARCHITECTURE is set, and
/include for each
/[s]bin in PATH, and
/include for other entries in
PATH. 

6.

Search cmake
variables defined in the Platform files for the current
system. This can be skipped if NO_CMAKE_SYSTEM_PATH
is passed or by setting the
CMAKE_FIND_USE_CMAKE_SYSTEM_PATH to FALSE.

•

/include/
if CMAKE_LIBRARY_ARCHITECTURE is set, and
/include for each 
in CMAKE_SYSTEM_PREFIX_PATH

•

CMAKE_SYSTEM_INCLUDE_PATH

•

CMAKE_SYSTEM_FRAMEWORK_PATH

The platform
paths that these variables contain are locations that
typically include installed software. An example being
/usr/local for UNIX based platforms.

7.

Search the paths specified by
the PATHS option or in the short-hand version of the
command. These are typically hard-coded guesses.

On macOS the
CMAKE_FIND_FRAMEWORK and CMAKE_FIND_APPBUNDLE
variables determine the order of preference between
Apple-style and unix-style package components.

The CMake
variable CMAKE_FIND_ROOT_PATH specifies one or more
directories to be prepended to all other search directories.
This effectively “re-roots” the entire search
under given locations. Paths which are descendants of the
CMAKE_STAGING_PREFIX are excluded from this
re-rooting, because that variable is always a path on the
host system. By default the CMAKE_FIND_ROOT_PATH is
empty.

The
CMAKE_SYSROOT variable can also be used to specify
exactly one directory to use as a prefix. Setting
CMAKE_SYSROOT also has other effects. See the
documentation for that variable for more.

These variables
are especially useful when cross-compiling to point to the
root directory of the target environment and CMake will
search there too. By default at first the directories listed
in CMAKE_FIND_ROOT_PATH are searched, then the
CMAKE_SYSROOT directory is searched, and then the
non-rooted directories will be searched. The default
behavior can be adjusted by setting
CMAKE_FIND_ROOT_PATH_MODE_INCLUDE. This behavior can
be manually overridden on a per-call basis using options:

CMAKE_FIND_ROOT_PATH_BOTH

Search in the order described
above.

NO_CMAKE_FIND_ROOT_PATH

Do not use the
CMAKE_FIND_ROOT_PATH variable.

ONLY_CMAKE_FIND_ROOT_PATH

Search only the re-rooted
directories and directories below
CMAKE_STAGING_PREFIX.

The default
search order is designed to be most-specific to
least-specific for common use cases. Projects may override
the order by simply calling the command multiple times and
using the NO_* options:

find_path ( NAMES name PATHS paths... NO_DEFAULT_PATH)
find_path ( NAMES name)

Once one of the
calls succeeds the result variable will be set and stored in
the cache so that no call will search again.

When searching
for frameworks, if the file is specified as A/b.h,
then the framework search will look for
A.framework/Headers/b.h. If that is found the path
will be set to the path to the framework. CMake will convert
this to the correct -F option to include the
file.

find_program

A short-hand signature is:

find_program ( name1 [path1 path2 ...])

The general
signature is:

find_program (

          name | NAMES name1 [name2 ...] [NAMES_PER_DIR]
          [HINTS path1 [path2 ... ENV var]]
          [PATHS path1 [path2 ... ENV var]]
          [PATH_SUFFIXES suffix1 [suffix2 ...]]
          [DOC "cache documentation string"]
          [REQUIRED]
          [NO_DEFAULT_PATH]
          [NO_PACKAGE_ROOT_PATH]
          [NO_CMAKE_PATH]
          [NO_CMAKE_ENVIRONMENT_PATH]
          [NO_SYSTEM_ENVIRONMENT_PATH]
          [NO_CMAKE_SYSTEM_PATH]
          [CMAKE_FIND_ROOT_PATH_BOTH |
           ONLY_CMAKE_FIND_ROOT_PATH |
           NO_CMAKE_FIND_ROOT_PATH]
         )

This command is
used to find a program. A cache entry named by
 is created to store the result of this
command. If the program is found the result is stored in the
variable and the search will not be repeated unless the
variable is cleared. If nothing is found, the result will be
-NOTFOUND. The REQUIRED option
stops processing with an error message if nothing is found,
otherwise the search will be attempted again the next time
find_program is invoked with the same variable.

Options
include:

NAMES

Specify one or more possible names for the program.

When using this
to specify names with and without a version suffix, we
recommend specifying the unversioned name first so that
locally-built packages can be found before those provided by
distributions.

HINTS, PATHS

Specify directories to search
in addition to the default locations. The ENV var
sub-option reads paths from a system environment
variable.

PATH_SUFFIXES

Specify additional
subdirectories to check below each directory location
otherwise considered.

DOC

Specify the documentation string for the
 cache entry.

REQUIRED

Stop processing with an error
message if nothing is found.

If
NO_DEFAULT_PATH is specified, then no additional
paths are added to the search. If NO_DEFAULT_PATH is
not specified, the search process is as follows:

1.

If called from within a find module or any other script
loaded by a call to
find_package(), search prefixes
unique to the current package being found. Specifically,
look in the _ROOT CMake variable
and the _ROOT environment
variable. The package root variables are maintained as a
stack, so if called from nested find modules or config
packages, root paths from the parent’s find module or
config package will be searched after paths from the current
module or package. In other words, the search order would be
_ROOT,
ENV{_ROOT},
_ROOT,
ENV{_ROOT}, etc. This can be
skipped if NO_PACKAGE_ROOT_PATH is passed or by
setting the CMAKE_FIND_USE_PACKAGE_ROOT_PATH to
FALSE. See policy CMP0074.

•

/[s]bin for
each  in the
_ROOT CMake variable and the
_ROOT environment variable if
called from within a find module loaded by
find_package() 

2.

Search paths specified in cmake-specific cache
variables. These are intended to be used on the command line
with a -DVAR=value. The values are interpreted as
semicolon-separated lists. This can be skipped if
NO_CMAKE_PATH is passed or by setting the
CMAKE_FIND_USE_CMAKE_PATH to FALSE.

•

/[s]bin for
each  in CMAKE_PREFIX_PATH

•

CMAKE_PROGRAM_PATH

•

CMAKE_APPBUNDLE_PATH

3.

Search paths
specified in cmake-specific environment variables. These are
intended to be set in the user’s shell configuration,
and therefore use the host’s native path separator
(; on Windows and : on UNIX). This can be
skipped if NO_CMAKE_ENVIRONMENT_PATH is passed or by
setting the CMAKE_FIND_USE_CMAKE_ENVIRONMENT_PATH to
FALSE.

•

/[s]bin for
each  in CMAKE_PREFIX_PATH

•

CMAKE_PROGRAM_PATH

•

CMAKE_APPBUNDLE_PATH

4.

Search the
paths specified by the HINTS option. These should be
paths computed by system introspection, such as a hint
provided by the location of another item already found.
Hard-coded guesses should be specified with the PATHS
option.

5.

Search the standard system
environment variables. This can be skipped if
NO_SYSTEM_ENVIRONMENT_PATH is passed or by setting
the CMAKE_FIND_USE_SYSTEM_ENVIRONMENT_PATH to
FALSE. 

•

The directories in PATH
itself. 

•

On Windows hosts no extra search paths are included

6.

Search cmake
variables defined in the Platform files for the current
system. This can be skipped if NO_CMAKE_SYSTEM_PATH
is passed or by setting the
CMAKE_FIND_USE_CMAKE_SYSTEM_PATH to FALSE.

•

/[s]bin for
each  in
CMAKE_SYSTEM_PREFIX_PATH 

•

CMAKE_SYSTEM_PROGRAM_PATH

•

CMAKE_SYSTEM_APPBUNDLE_PATH

The platform
paths that these variables contain are locations that
typically include installed software. An example being
/usr/local for UNIX based platforms.

7.

Search the paths specified by
the PATHS option or in the short-hand version of the
command. These are typically hard-coded guesses.

On macOS the
CMAKE_FIND_FRAMEWORK and CMAKE_FIND_APPBUNDLE
variables determine the order of preference between
Apple-style and unix-style package components.

The CMake
variable CMAKE_FIND_ROOT_PATH specifies one or more
directories to be prepended to all other search directories.
This effectively “re-roots” the entire search
under given locations. Paths which are descendants of the
CMAKE_STAGING_PREFIX are excluded from this
re-rooting, because that variable is always a path on the
host system. By default the CMAKE_FIND_ROOT_PATH is
empty.

The
CMAKE_SYSROOT variable can also be used to specify
exactly one directory to use as a prefix. Setting
CMAKE_SYSROOT also has other effects. See the
documentation for that variable for more.

These variables
are especially useful when cross-compiling to point to the
root directory of the target environment and CMake will
search there too. By default at first the directories listed
in CMAKE_FIND_ROOT_PATH are searched, then the
CMAKE_SYSROOT directory is searched, and then the
non-rooted directories will be searched. The default
behavior can be adjusted by setting
CMAKE_FIND_ROOT_PATH_MODE_PROGRAM. This behavior can
be manually overridden on a per-call basis using options:

CMAKE_FIND_ROOT_PATH_BOTH

Search in the order described
above.

NO_CMAKE_FIND_ROOT_PATH

Do not use the
CMAKE_FIND_ROOT_PATH variable.

ONLY_CMAKE_FIND_ROOT_PATH

Search only the re-rooted
directories and directories below
CMAKE_STAGING_PREFIX.

The default
search order is designed to be most-specific to
least-specific for common use cases. Projects may override
the order by simply calling the command multiple times and
using the NO_* options:

find_program ( NAMES name PATHS paths... NO_DEFAULT_PATH)
find_program ( NAMES name)

Once one of the
calls succeeds the result variable will be set and stored in
the cache so that no call will search again.

When more than
one value is given to the NAMES option this command
by default will consider one name at a time and search every
directory for it. The NAMES_PER_DIR option tells this
command to consider one directory at a time and search for
all names in it.

foreach

Evaluate a group of commands for each value in a list.

foreach( )

endforeach()

where
 is a list of items that are separated
by semicolon or whitespace. All commands between
foreach and the matching endforeach are
recorded without being invoked. Once the endforeach
is evaluated, the recorded list of commands is invoked once
for each item in . At the beginning of
each iteration the variable loop_var will be set to
the value of the current item.

The commands
break() and continue() provide means to escape
from the normal control flow.

Per legacy, the
endforeach() command admits an optional
 argument. If used, it must be a
verbatim repeat of the argument of the opening
foreach command.

foreach( RANGE )

In this
variant, foreach iterates over the numbers 0, 1,
… up to (and including) the nonnegative integer
.

foreach( RANGE   [])

In this
variant, foreach iterates over the numbers from
 up to at most  in
steps of . If  is not
specified, then the step size is 1. The three arguments
   must all be
nonnegative integers, and  must not be
smaller than ; otherwise you enter the
danger zone of undocumented behavior that may change in
future releases.

foreach( IN [LISTS []] [ITEMS []])

In this
variant,  is a whitespace or semicolon
separated list of list-valued variables. The foreach
command iterates over each item in each given list. The
 following the ITEMS keyword are
processed as in the first variant of the foreach
command. The forms LISTS A and ITEMS ${A} are
equivalent.

The following
example shows how the LISTS option is processed:

set(A 0;1)
set(B 2 3)
set(C "4 5")
set(D 6;7 8)
set(E "")
foreach(X IN LISTS A B C D E)
    message(STATUS "X=${X}")
endforeach()

yields
-- X=0
-- X=1
-- X=2
-- X=3
-- X=4 5
-- X=6
-- X=7
-- X=8

foreach(... IN ZIP_LISTS )

In this
variant,  is a whitespace or semicolon
separated list of list-valued variables. The foreach
command iterates over each list simultaneously setting the
iteration variables as follows:

•

if the only loop_var given, then it sets a series
of loop_var_N variables to the current item from the
corresponding list;

•

if multiple variable names passed, their count should
match the lists variables count;

•

if any of the lists are shorter, the corresponding
iteration variable is not defined for the current
iteration. 

list(APPEND English one two three four)
list(APPEND Bahasa satu dua tiga)

foreach(num IN ZIP_LISTS English Bahasa)
    message(STATUS "num_0=${num_0}, num_1=${num_1}")
endforeach()

foreach(en ba IN ZIP_LISTS English Bahasa)
    message(STATUS "en=${en}, ba=${ba}")
endforeach()

yields

-- num_0=one, num_1=satu
-- num_0=two, num_1=dua
-- num_0=three, num_1=tiga
-- num_0=four, num_1=
-- en=one, ba=satu
-- en=two, ba=dua
-- en=three, ba=tiga
-- en=four, ba=

function

Start recording a function for later invocation as a
command.

function( [ ...])

endfunction()

Defines a
function named  that takes arguments
named , … The
 in the function definition are
recorded; they are not executed until the function is
invoked.

Per legacy, the
endfunction() command admits an optional
 argument. If used, it must be a verbatim
repeat of the argument of the opening function
command.

A function
opens a new scope: see set(var PARENT_SCOPE) for
details.

See the
cmake_policy() command documentation for the behavior
of policies inside functions.

See the
macro() command documentation for differences between
CMake functions and macros.

Invocation

The function invocation is case-insensitive. A function
defined as

function(foo)

endfunction()

can be invoked
through any of

foo()
Foo()
FOO()
cmake_language(CALL foo)

and so on.
However, it is strongly recommended to stay with the case
chosen in the function definition. Typically functions use
all-lowercase names.

The
cmake_language(CALL ...) command can also be used to
invoke the function.

Arguments

When the function is invoked, the recorded
 are first modified by replacing
formal parameters (${arg1}, …) with the
arguments passed, and then invoked as normal commands.

In addition to
referencing the formal parameters you can reference the
ARGC variable which will be set to the number of
arguments passed into the function as well as ARGV0,
ARGV1, ARGV2, … which will have the
actual values of the arguments passed in. This facilitates
creating functions with optional arguments.

Furthermore,
ARGV holds the list of all arguments given to the
function and ARGN holds the list of arguments past
the last expected argument. Referencing to ARGV#
arguments beyond ARGC have undefined behavior.
Checking that ARGC is greater than # is the
only way to ensure that ARGV# was passed to the
function as an extra argument.

get_cmake_property

Get a global property of the CMake instance.

get_cmake_property( )

Gets a global
property from the CMake instance. The value of the
 is stored in the variable
. If the property is not found,
 will be set to NOTFOUND. See the
cmake-properties(7) manual for available
properties.

See also the
get_property() command GLOBAL option.

In addition to
global properties, this command (for historical reasons)
also supports the VARIABLES and MACROS
directory properties. It also supports a special
COMPONENTS global property that lists the components
given to the install() command.

get_directory_property

Get a property of DIRECTORY scope.

get_directory_property( [DIRECTORY ] )

Stores a
property of directory scope in the named
. The DIRECTORY argument
specifies another directory from which to retrieve the
property value instead of the current directory. The
specified directory must have already been traversed by
CMake.

If the property
is not defined for the nominated directory scope, an empty
string is returned. In the case of INHERITED
properties, if the property is not found for the nominated
directory scope, the search will chain to a parent scope as
described for the define_property() command.

get_directory_property( [DIRECTORY ]
                       DEFINITION )

Get a variable
definition from a directory. This form is useful to get a
variable definition from another directory.

See also the
more general get_property() command.

get_filename_component

Get a specific component of a full filename.

get_filename_component(   [CACHE])

Sets
 to a component of
, where  is one
of:

DIRECTORY = Directory without file name
NAME      = File name without directory
EXT       = File name longest extension (.b.c from d/a.b.c)
NAME_WE   = File name without directory or longest extension
LAST_EXT  = File name last extension (.c from d/a.b.c)
NAME_WLE  = File name without directory or last extension
PATH      = Legacy alias for DIRECTORY (use for CMake 

Paths are
returned with forward slashes and have no trailing slashes.
If the optional CACHE argument is specified, the
result variable is added to the cache.

get_filename_component(   [BASE_DIR ] [CACHE])

Sets
 to the absolute path of
, where  is one
of:

ABSOLUTE  = Full path to file
REALPATH  = Full path to existing file with symlinks resolved

If the provided
 is a relative path, it is evaluated
relative to the given base directory . If
no base directory is provided, the default base directory
will be CMAKE_CURRENT_SOURCE_DIR.

Paths are
returned with forward slashes and have no trailing slashes.
If the optional CACHE argument is specified, the
result variable is added to the cache.

get_filename_component(  PROGRAM [PROGRAM_ARGS ] [CACHE])

The program in
 will be found in the system search
path or left as a full path. If PROGRAM_ARGS is
present with PROGRAM, then any command-line arguments
present in the  string are split from
the program name and stored in . This
is used to separate a program name from its arguments in a
command line string.

get_property

Get a property.

get_property(
             ]  |
              TARGET     |
              SOURCE     |
                        [DIRECTORY  | TARGET_DIRECTORY ] |
              INSTALL      |
              TEST         |
              CACHE       |
              VARIABLE           >
             PROPERTY 
             [SET | DEFINED | BRIEF_DOCS | FULL_DOCS])

Gets one
property from one object in a scope.

The first
argument specifies the variable in which to store the
result. The second argument determines the scope from which
to get the property. It must be one of the following:

GLOBAL

Scope is unique and does not
accept a name.

DIRECTORY

Scope defaults to the current
directory but another directory (already processed by CMake)
may be named by the full or relative path
. See also the
get_directory_property() command.

TARGET

Scope must name one existing target. See also the
get_target_property() command.

SOURCE

Scope must name one source file. By default, the source
file’s property will be read from the current source
directory’s scope, but this can be overridden with one
of the following sub-options:

DIRECTORY

The source file property will
be read from the  directory’s scope.
CMake must already know about that source directory, either
by having added it through a call to
add_subdirectory() or  being the
top level source directory. Relative paths are treated as
relative to the current source directory.

TARGET_DIRECTORY

The source file property will
be read from the directory scope in which
 was created (
must therefore already exist).

See also the
get_source_file_property() command.

INSTALL

Scope must name one installed
file path.

TEST

Scope must name one existing test. See also the
get_test_property() command.

CACHE

Scope must name one cache entry.

VARIABLE

Scope is unique and does not
accept a name.

The required
PROPERTY option is immediately followed by the name
of the property to get. If the property is not set an empty
value is returned, although some properties support
inheriting from a parent scope if defined to behave that way
(see define_property()).

If the
SET option is given the variable is set to a boolean
value indicating whether the property has been set. If the
DEFINED option is given the variable is set to a
boolean value indicating whether the property has been
defined such as with the define_property()
command.

If
BRIEF_DOCS or FULL_DOCS is given then the
variable is set to a string containing documentation for the
requested property. If documentation is requested for a
property that has not been defined NOTFOUND is
returned.

if 
Conditionally execute a group of commands.

Synopsis

if()

elseif() # optional block, can be repeated

else()              # optional block

endif()

Evaluates the
condition argument of the if clause according
to the Condition syntax described below. If the
result is true, then the commands in the if
block are executed. Otherwise, optional elseif blocks
are processed in the same way. Finally, if no
condition is true, commands in the optional
else block are executed.

Per legacy, the
else() and endif() commands admit an optional
 argument. If used, it must be a
verbatim repeat of the argument of the opening if
command.

Condition
Syntax 
The following syntax applies to the condition
argument of the if, elseif and while()
clauses.

Compound
conditions are evaluated in the following order of
precedence: Innermost parentheses are evaluated first. Next
come unary tests such as EXISTS, COMMAND, and
DEFINED. Then binary tests such as EQUAL,
LESS, LESS_EQUAL, GREATER,
GREATER_EQUAL, STREQUAL, STRLESS,
STRLESS_EQUAL, STRGREATER,
STRGREATER_EQUAL, VERSION_EQUAL,
VERSION_LESS, VERSION_LESS_EQUAL,
VERSION_GREATER, VERSION_GREATER_EQUAL, and
MATCHES. Then the boolean operators in the order
NOT, AND, and finally OR.

Possible
conditions are: 
if()

True if the constant is
1, ON, YES, TRUE, Y, or a
non-zero number. False if the constant is 0,
OFF, NO, FALSE, N,
IGNORE, NOTFOUND, the empty string, or ends in
the suffix -NOTFOUND. Named boolean constants are
case-insensitive. If the argument is not one of these
specific constants, it is treated as a variable or string
and the following signature is used.

if()

True if given a variable that
is defined to a value that is not a false constant. False
otherwise. (Note macro arguments are not variables.)

if(NOT
)

True if the condition is not
true.

if( AND
)

True if both conditions would
be considered true individually.

if( OR
)

True if either condition would
be considered true individually.

if(COMMAND
command-name)

True if the given name is a
command, macro or function that can be invoked.

if(POLICY policy-id)

True if the given name is an
existing policy (of the form CMP).

if(TARGET
target-name)

True if the given name is an
existing logical target name created by a call to the
add_executable(), add_library(), or
add_custom_target() command that has already been
invoked (in any directory).

if(TEST test-name)

True if the given name is an
existing test name created by the add_test()
command.

if(EXISTS
path-to-file-or-directory)

True if the named file or
directory exists. Behavior is well-defined only for full
paths. Resolves symbolic links, i.e. if the named file or
directory is a symbolic link, returns true if the target of
the symbolic link exists.

if(file1 IS_NEWER_THAN
file2)

True if file1 is newer
than file2 or if one of the two files doesn’t
exist. Behavior is well-defined only for full paths. If the
file time stamps are exactly the same, an
IS_NEWER_THAN comparison returns true, so that any
dependent build operations will occur in the event of a tie.
This includes the case of passing the same file name for
both file1 and file2.

if(IS_DIRECTORY
path-to-directory)

True if the given name is a
directory. Behavior is well-defined only for full paths.

if(IS_SYMLINK
file-name)

True if the given name is a
symbolic link. Behavior is well-defined only for full
paths.

if(IS_ABSOLUTE path)

True if the given path is an
absolute path.

if(
MATCHES regex)

True if the given string or
variable’s value matches the given regular condition.
See Regex Specification for regex format. () groups
are captured in CMAKE_MATCH_ variables.

if(
LESS )

True if the given string or
variable’s value is a valid number and less than that
on the right.

if(
GREATER )

True if the given string or
variable’s value is a valid number and greater than
that on the right.

if(
EQUAL )

True if the given string or
variable’s value is a valid number and equal to that
on the right.

if(
LESS_EQUAL )

True if the given string or
variable’s value is a valid number and less than or
equal to that on the right.

if(
GREATER_EQUAL )

True if the given string or
variable’s value is a valid number and greater than or
equal to that on the right.

if(
STRLESS )

True if the given string or
variable’s value is lexicographically less than the
string or variable on the right.

if(
STRGREATER )

True if the given string or
variable’s value is lexicographically greater than the
string or variable on the right.

if(
STREQUAL )

True if the given string or
variable’s value is lexicographically equal to the
string or variable on the right.

if(
STRLESS_EQUAL )

True if the given string or
variable’s value is lexicographically less than or
equal to the string or variable on the right.

if(
STRGREATER_EQUAL )

True if the given string or
variable’s value is lexicographically greater than or
equal to the string or variable on the right.

if(
VERSION_LESS )

Component-wise integer version
number comparison (version format is
major[.minor[.patch[.tweak]]], omitted components are
treated as zero). Any non-integer version component or
non-integer trailing part of a version component effectively
truncates the string at that point.

if(
VERSION_GREATER )

Component-wise integer version
number comparison (version format is
major[.minor[.patch[.tweak]]], omitted components are
treated as zero). Any non-integer version component or
non-integer trailing part of a version component effectively
truncates the string at that point.

if(
VERSION_EQUAL )

Component-wise integer version
number comparison (version format is
major[.minor[.patch[.tweak]]], omitted components are
treated as zero). Any non-integer version component or
non-integer trailing part of a version component effectively
truncates the string at that point.

if(
VERSION_LESS_EQUAL )

Component-wise integer version
number comparison (version format is
major[.minor[.patch[.tweak]]], omitted components are
treated as zero). Any non-integer version component or
non-integer trailing part of a version component effectively
truncates the string at that point.

if(
VERSION_GREATER_EQUAL )

Component-wise integer version
number comparison (version format is
major[.minor[.patch[.tweak]]], omitted components are
treated as zero). Any non-integer version component or
non-integer trailing part of a version component effectively
truncates the string at that point.

if(
IN_LIST )

True if the given element is
contained in the named list variable.

if(DEFINED
|CACHE{}|ENV{})

True if a variable, cache
variable or environment variable with given
 is defined. The value of the variable
does not matter. Note that macro arguments are not
variables.

if((condition) AND
(condition OR (condition)))

The conditions inside the
parenthesis are evaluated first and then the remaining
condition is evaluated as in the previous examples. Where
there are nested parenthesis the innermost are evaluated as
part of evaluating the condition that contains them.

Variable
Expansion 
The if command was written very early in CMake’s
history, predating the ${} variable evaluation
syntax, and for convenience evaluates variables named by its
arguments as shown in the above signatures. Note that normal
variable evaluation with ${} applies before the if
command even receives the arguments. Therefore code like

set(var1 OFF)
set(var2 "var1")
if(${var2})

appears to the
if command as

if(var1)

and is
evaluated according to the if() case
documented above. The result is OFF which is false.
However, if we remove the ${} from the example then
the command sees

if(var2)

which is true
because var2 is defined to var1 which is not a
false constant.

Automatic
evaluation applies in the other cases whenever the
above-documented condition syntax accepts
:

•

The left hand argument to MATCHES is first
checked to see if it is a defined variable, if so the
variable’s value is used, otherwise the original value
is used.

•

If the left hand argument to MATCHES is missing
it returns false without error

•

Both left and right hand arguments to LESS,
GREATER, EQUAL, LESS_EQUAL, and
GREATER_EQUAL, are independently tested to see if
they are defined variables, if so their defined values are
used otherwise the original value is used.

•

Both left and right hand arguments to STRLESS,
STRGREATER, STREQUAL, STRLESS_EQUAL,
and STRGREATER_EQUAL are independently tested to see
if they are defined variables, if so their defined values
are used otherwise the original value is used.

•

Both left and right hand arguments to
VERSION_LESS, VERSION_GREATER,
VERSION_EQUAL, VERSION_LESS_EQUAL, and
VERSION_GREATER_EQUAL are independently tested to see
if they are defined variables, if so their defined values
are used otherwise the original value is used.

•

The right hand argument to NOT is tested to see
if it is a boolean constant, if so the value is used,
otherwise it is assumed to be a variable and it is
dereferenced. 

•

The left and right hand arguments to AND and
OR are independently tested to see if they are
boolean constants, if so they are used as such, otherwise
they are assumed to be variables and are dereferenced.

To prevent
ambiguity, potential variable or keyword names can be
specified in a Quoted Argument or a Bracket Argument. A
quoted or bracketed variable or keyword will be interpreted
as a string and not dereferenced or interpreted. See policy
CMP0054.

There is no
automatic evaluation for environment or cache Variable
References. Their values must be referenced as
$ENV{} or $CACHE{}
wherever the above-documented condition syntax accepts
.

include

Load and run CMake code from a file or module.

include( [OPTIONAL] [RESULT_VARIABLE ]
                      [NO_POLICY_SCOPE])

Loads and runs
CMake code from the file given. Variable reads and writes
access the scope of the caller (dynamic scoping). If
OPTIONAL is present, then no error is raised if the
file does not exist. If RESULT_VARIABLE is given the
variable  will be set to the full filename
which has been included or NOTFOUND if it failed.

If a module is
specified instead of a file, the file with name
.cmake is searched first in
CMAKE_MODULE_PATH, then in the CMake module
directory. There is one exception to this: if the file which
calls include() is located itself in the CMake
builtin module directory, then first the CMake builtin
module directory is searched and CMAKE_MODULE_PATH
afterwards. See also policy CMP0017.

See the
cmake_policy() command documentation for discussion
of the NO_POLICY_SCOPE option.

include_guard

Provides an include guard for the file currently being
processed by CMake.

include_guard([DIRECTORY|GLOBAL])

Sets up an
include guard for the current CMake file (see the
CMAKE_CURRENT_LIST_FILE variable documentation).

CMake will end
its processing of the current file at the location of the
include_guard() command if the current file has
already been processed for the applicable scope (see below).
This provides functionality similar to the include guards
commonly used in source headers or to the #pragma
once directive. If the current file has been processed
previously for the applicable scope, the effect is as though
return() had been called. Do not call this command
from inside a function being defined within the current
file.

An optional
argument specifying the scope of the guard may be provided.
Possible values for the option are: 
DIRECTORY

The include guard applies
within the current directory and below. The file will only
be included once within this directory scope, but may be
included again by other files outside of this directory
(i.e. a parent directory or another directory not pulled in
by add_subdirectory() or include() from the
current file or its children).

GLOBAL

The include guard applies globally to the whole build.
The current file will only be included once regardless of
the scope.

If no arguments
given, include_guard has the same scope as a
variable, meaning that the include guard effect is isolated
by the most recent function scope or current directory if no
inner function scopes exist. In this case the command
behavior is the same as:

if(__CURRENT_FILE_VAR__)
  return()
endif()
set(__CURRENT_FILE_VAR__ TRUE)

list

List operations.

Synopsis

Reading 
list(LENGTH  )

list(GET  
[ ...] ) 
list(JOIN  
) 
list(SUBLIST  
 )

Search

list(FIND  
)

Modification

list(APPEND 
[...]) 
list(FILTER  {INCLUDE | EXCLUDE}
REGEX ) 
list(INSERT  
[...]) 
list(POP_BACK 
[...]) 
list(POP_FRONT 
[...]) 
list(PREPEND 
[...]) 
list(REMOVE_ITEM 
...) 
list(REMOVE_AT 
...) 
list(REMOVE_DUPLICATES ) 
list(TRANSFORM  
[...])

Ordering

list(REVERSE ) 
list(SORT  [...])

Introduction

The list subcommands APPEND, INSERT,
FILTER, PREPEND, POP_BACK,
POP_FRONT, REMOVE_AT, REMOVE_ITEM,
REMOVE_DUPLICATES, REVERSE and SORT may
create new values for the list within the current CMake
variable scope. Similar to the set() command, the
LIST command creates new variable values in the current
scope, even if the list itself is actually defined in a
parent scope. To propagate the results of these operations
upwards, use set() with PARENT_SCOPE,
set() with CACHE INTERNAL, or some other means
of value propagation.

NOTE:

A list in cmake is a ;
separated group of strings. To create a list the set command
can be used. For example, set(var a b c d e) creates
a list with a;b;c;d;e, and set(var "a b c d
e") creates a string or a list with one item in it.
(Note macro arguments are not variables, and therefore
cannot be used in LIST commands.)

NOTE:

When specifying index values,
if  is 0 or greater, it is
indexed from the beginning of the list, with 0 representing
the first list element. If  is
-1 or lesser, it is indexed from the end of the list, with
-1 representing the last list element. Be careful when
counting with negative indices: they do not start from 0. -0
is equivalent to 0, the first list element.

Reading

list(LENGTH  )

Returns the
list’s length.

list(GET   [ ...] )

Returns the
list of elements specified by indices from the list.

list(JOIN   )

Returns a
string joining all list’s elements using the glue
string. To join multiple strings, which are not part of a
list, use JOIN operator from string()
command.

list(SUBLIST    )

Returns a
sublist of the given list. If  is 0, an
empty list will be returned. If  is -1
or the list is smaller than
+ then the remaining
elements of the list starting at  will
be returned.

Search

list(FIND   )

Returns the
index of the element specified in the list or -1 if it
wasn’t found.

Modification

list(APPEND  [ ...])

Appends
elements to the list.

list(FILTER   REGEX )

Includes or
removes items from the list that match the mode’s
pattern. In REGEX mode, items will be matched against
the given regular expression.

For more
information on regular expressions see also the
string() command.

list(INSERT    [ ...])

Inserts
elements to the list to the specified location.

list(POP_BACK  [...])

If no variable
name is given, removes exactly one element. Otherwise,
assign the last element’s value to the given variable
and removes it, up to the last variable name given.

list(POP_FRONT  [...])

If no variable
name is given, removes exactly one element. Otherwise,
assign the first element’s value to the given variable
and removes it, up to the last variable name given.

list(PREPEND  [ ...])

Insert elements
to the 0th position in the list.

list(REMOVE_ITEM   [ ...])

Removes all
instances of the given items from the list.

list(REMOVE_AT   [ ...])

Removes items
at given indices from the list.

list(REMOVE_DUPLICATES )

Removes
duplicated items in the list. The relative order of items is
preserved, but if duplicates are encountered, only the first
instance is preserved.

list(TRANSFORM   []
                      [OUTPUT_VARIABLE ])

Transforms the
list by applying an action to all or, by specifying a
, to the selected elements of the
list, storing the result in-place or in the specified output
variable.

NOTE:

The TRANSFORM
sub-command does not change the number of elements in the
list. If a  is specified, only some
elements will be changed, the other ones will remain the
same as before the transformation.

specifies the action to apply to the elements of the list.
The actions have exactly the same semantics as sub-commands
of the string() command.  must
be one of the following:

APPEND,
PREPEND: Append, prepend specified value to each
element of the list.

list(TRANSFORM    ...)

TOUPPER,
TOLOWER: Convert each element of the list to upper,
lower characters.

list(TRANSFORM   ...)

STRIP:
Remove leading and trailing spaces from each element of the
list.

list(TRANSFORM  STRIP ...)

GENEX_STRIP:
Strip any generator expressions from each element of
the list.

list(TRANSFORM  GENEX_STRIP ...)

REPLACE:
Match the regular expression as many times as possible and
substitute the replacement expression for the match for each
element of the list (Same semantic as REGEX REPLACE
from string() command).

list(TRANSFORM  REPLACE 
                               ...)

determines which elements of the list will be transformed.
Only one type of selector can be specified at a time. When
given,  must be one of the
following:

AT:
Specify a list of indexes.

list(TRANSFORM   AT  [ ...] ...)

FOR:
Specify a range with, optionally, an increment used to
iterate over the range.

list(TRANSFORM   FOR   [] ...)

REGEX:
Specify a regular expression. Only elements matching the
regular expression will be transformed.

list(TRANSFORM   REGEX  ...)

Ordering

list(REVERSE )

Reverses the
contents of the list in-place.

list(SORT  [COMPARE ] [CASE ] [ORDER ])

Sorts the list
in-place alphabetically. Use the COMPARE keyword to
select the comparison method for sorting. The
 option should be one of:

•

STRING: Sorts a list of
strings alphabetically. This is the default behavior if the
COMPARE option is not given.

•

FILE_BASENAME: Sorts a list of pathnames of files
by their basenames.

•

NATURAL: Sorts a list of strings using natural
order (see strverscmp(3) manual), i.e. such that
contiguous digits are compared as whole numbers. For
example: the following list 10.0 1.1 2.1 8.0 2.0 3.1
will be sorted as 1.1 2.0 2.1 3.1 8.0 10.0 if the
NATURAL comparison is selected where it will be
sorted as 1.1 10.0 2.0 2.1 3.1 8.0 with the
STRING comparison.

Use the
CASE keyword to select a case sensitive or case
insensitive sort mode. The  option should
be one of:

•

SENSITIVE: List items are
sorted in a case-sensitive manner. This is the default
behavior if the CASE option is not given.

•

INSENSITIVE: List items are sorted case
insensitively. The order of items which differ only by
upper/lowercase is not specified.

To control the
sort order, the ORDER keyword can be given. The
 option should be one of:

•

ASCENDING: Sorts the list
in ascending order. This is the default behavior when the
ORDER option is not given.

•

DESCENDING: Sorts the list in descending
order. 

macro

Start recording a macro for later invocation as a
command

macro( [ ...])

endmacro()

Defines a macro
named  that takes arguments named
, … Commands listed after macro,
but before the matching endmacro(), are not executed
until the macro is invoked.

Per legacy, the
endmacro() command admits an optional
 argument. If used, it must be a verbatim
repeat of the argument of the opening macro
command.

See the
cmake_policy() command documentation for the behavior
of policies inside macros.

See the
Macro vs Function section below for differences
between CMake macros and functions.

Invocation

The macro invocation is case-insensitive. A macro defined
as

macro(foo)

endmacro()

can be invoked
through any of

foo()
Foo()
FOO()
cmake_language(CALL foo)

and so on.
However, it is strongly recommended to stay with the case
chosen in the macro definition. Typically macros use
all-lowercase names.

The
cmake_language(CALL ...) command can also be used to
invoke the macro.

Arguments

When a macro is invoked, the commands recorded in the macro
are first modified by replacing formal parameters
(${arg1}, …) with the arguments passed, and
then invoked as normal commands.

In addition to
referencing the formal parameters you can reference the
values ${ARGC} which will be set to the number of
arguments passed into the function as well as
${ARGV0}, ${ARGV1}, ${ARGV2}, …
which will have the actual values of the arguments passed
in. This facilitates creating macros with optional
arguments.

Furthermore,
${ARGV} holds the list of all arguments given to the
macro and ${ARGN} holds the list of arguments past
the last expected argument. Referencing to ${ARGV#}
arguments beyond ${ARGC} have undefined behavior.
Checking that ${ARGC} is greater than # is the
only way to ensure that ${ARGV#} was passed to the
function as an extra argument.

Macro vs
Function 
The macro command is very similar to the
function() command. Nonetheless, there are a few
important differences.

In a function,
ARGN, ARGC, ARGV and ARGV0,
ARGV1, … are true variables in the usual CMake
sense. In a macro, they are not, they are string
replacements much like the C preprocessor would do with a
macro. This has a number of consequences, as explained in
the Argument Caveats section below.

Another
difference between macros and functions is the control flow.
A function is executed by transferring control from the
calling statement to the function body. A macro is executed
as if the macro body were pasted in place of the calling
statement. This has the consequence that a return()
in a macro body does not just terminate execution of the
macro; rather, control is returned from the scope of the
macro call. To avoid confusion, it is recommended to avoid
return() in macros altogether.

Unlike a
function, the CMAKE_CURRENT_FUNCTION,
CMAKE_CURRENT_FUNCTION_LIST_DIR,
CMAKE_CURRENT_FUNCTION_LIST_FILE,
CMAKE_CURRENT_FUNCTION_LIST_LINE variables are not
set for a macro.

Argument
Caveats 
Since ARGN, ARGC, ARGV, ARGV0
etc. are not variables, you will NOT be able to use commands
like

if(ARGV1) # ARGV1 is not a variable
if(DEFINED ARGV2) # ARGV2 is not a variable
if(ARGC GREATER 2) # ARGC is not a variable
foreach(loop_var IN LISTS ARGN) # ARGN is not a variable

In the first
case, you can use if(${ARGV1}). In the second and
third case, the proper way to check if an optional variable
was passed to the macro is to use if(${ARGC} GREATER
2). In the last case, you can use foreach(loop_var
${ARGN}) but this will skip empty arguments. If you need
to include them, you can use

set(list_var "${ARGN}")
foreach(loop_var IN LISTS list_var)

Note that if
you have a variable with the same name in the scope from
which the macro is called, using unreferenced names will use
the existing variable instead of the arguments. For
example:
macro(bar)
  foreach(arg IN LISTS ARGN)

  endforeach()
endmacro()

function(foo)
  bar(x y z)
endfunction()

foo(a b c)

Will loop over
a;b;c and not over x;y;z as one might have
expected. If you want true CMake variables and/or better
CMake scope control you should look at the function
command.

mark_as_advanced

Mark cmake cached variables as advanced.

mark_as_advanced([CLEAR|FORCE]  ...)

Sets the
advanced/non-advanced state of the named cached
variables.

An advanced
variable will not be displayed in any of the cmake GUIs
unless the show advanced option is on. In script
mode, the advanced/non-advanced state has no effect.

If the keyword
CLEAR is given then advanced variables are changed
back to unadvanced. If the keyword FORCE is given
then the variables are made advanced. If neither
FORCE nor CLEAR is specified, new values will
be marked as advanced, but if a variable already has an
advanced/non-advanced state, it will not be changed.

NOTE:

Policy CMP0102 affects
the behavior of the mark_as_advanced call. When set
to NEW, variables passed to this command which are
not already in the cache are ignored. See policy
CMP0102.

math

Evaluate a mathematical expression.

math(EXPR  "" [OUTPUT_FORMAT ])

Evaluates a
mathematical  and sets
 to the resulting value. The result
of the expression must be representable as a 64-bit signed
integer.

The
mathematical expression must be given as a string (i.e.
enclosed in double quotation marks). An example is
"5 * (10 + 13)". Supported operators are
+, -, *, /, %, |,
&, ^, ~, ,
>>, and (...); they have the same
meaning as in C code.

Hexadecimal
numbers are recognized when prefixed with 0x, as in C
code.

The result is
formatted according to the option OUTPUT_FORMAT,
where  is one of 
HEXADECIMAL

Hexadecimal notation as in C
code, i. e. starting with “0x”.

DECIMAL

Decimal notation. Which is also
used if no OUTPUT_FORMAT option is specified.

For example

math(EXPR value "100 * 0xA" OUTPUT_FORMAT DECIMAL)      # value is set to "1000"
math(EXPR value "100 * 0xA" OUTPUT_FORMAT HEXADECIMAL)  # value is set to "0x3e8"

message

Log a message.

Synopsis

General messages
  message([] "message text" ...)

Reporting checks
  message( "message text" ...)

General
messages

message([] "message text" ...)

Record the
specified message text in the log. If more than one message
string is given, they are concatenated into a single message
with no separator between the strings.

The optional
 keyword determines the type of message,
which influences the way the message is handled: 
FATAL_ERROR

CMake Error, stop processing
and generation.

SEND_ERROR

CMake Error, continue
processing, but skip generation.

WARNING

CMake Warning, continue
processing.

AUTHOR_WARNING

CMake Warning (dev), continue
processing.

DEPRECATION

CMake Deprecation Error or
Warning if variable CMAKE_ERROR_DEPRECATED or
CMAKE_WARN_DEPRECATED is enabled, respectively, else
no message.

(none) or NOTICE

Important message printed to
stderr to attract user’s attention.

STATUS

The main interesting messages that project users might
be interested in. Ideally these should be concise, no more
than a single line, but still informative.

VERBOSE

Detailed informational messages
intended for project users. These messages should provide
additional details that won’t be of interest in most
cases, but which may be useful to those building the project
when they want deeper insight into what’s
happening.

DEBUG

Detailed informational messages intended for developers
working on the project itself as opposed to users who just
want to build it. These messages will not typically be of
interest to other users building the project and will often
be closely related to internal implementation details.

TRACE

Fine-grained messages with very low-level implementation
details. Messages using this log level would normally only
be temporary and would expect to be removed before releasing
the project, packaging up the files, etc.

The CMake
command-line tool displays STATUS to TRACE
messages on stdout with the message preceded by two hyphens
and a space. All other message types are sent to stderr and
are not prefixed with hyphens. The CMake GUI displays
all messages in its log area. The curses interface
shows STATUS to TRACE messages one at a time
on a status line and other messages in an interactive pop-up
box. The --log-level command-line option to each of
these tools can be used to control which messages will be
shown. To make a log level persist between CMake runs, the
CMAKE_MESSAGE_LOG_LEVEL variable can be set instead.
Note that the command line option takes precedence over the
cache variable.

Messages of log
levels NOTICE and below will have each line preceded
by the content of the CMAKE_MESSAGE_INDENT variable
(converted to a single string by concatenating its list
items). For STATUS to TRACE messages, this
indenting content will be inserted after the hyphens.

Messages of log
levels NOTICE and below can also have each line
preceded with context of the form
[some.context.example]. The content between the
square brackets is obtained by converting the
CMAKE_MESSAGE_CONTEXT list variable to a
dot-separated string. The message context will always appear
before any indenting content but after any automatically
added leading hyphens. By default, message context is not
shown, it has to be explicitly enabled by giving the
cmake --log-context command-line option or by setting
the CMAKE_MESSAGE_CONTEXT_SHOW variable to true. See
the CMAKE_MESSAGE_CONTEXT documentation for usage
examples.

CMake Warning
and Error message text displays using a simple markup
language. Non-indented text is formatted in line-wrapped
paragraphs delimited by newlines. Indented text is
considered pre-formatted.

Reporting
checks 
A common pattern in CMake output is a message indicating the
start of some sort of check, followed by another message
reporting the result of that check. For example:

message(STATUS "Looking for someheader.h")
#... do the checks, set checkSuccess with the result
if(checkSuccess)
  message(STATUS "Looking for someheader.h - found")
else()
  message(STATUS "Looking for someheader.h - not found")
endif()

This can be
more robustly and conveniently expressed using the
CHECK_... keyword form of the message()
command:

message( "message" ...)

where
 must be one of the following:

CHECK_START

Record a concise message about
the check about to be performed.

CHECK_PASS

Record a successful result for
a check.

CHECK_FAIL

Record an unsuccessful result
for a check.

When recording
a check result, the command repeats the message from the
most recently started check for which no result has yet been
reported, then some separator characters and then the
message text provided after the CHECK_PASS or
CHECK_FAIL keyword. Check messages are always
reported at STATUS log level.

Checks may be
nested and every CHECK_START should have exactly one
matching CHECK_PASS or CHECK_FAIL. The
CMAKE_MESSAGE_INDENT variable can also be used to add
indenting to nested checks if desired. For example:
message(CHECK_START "Finding my things")
list(APPEND CMAKE_MESSAGE_INDENT "  ")
unset(missingComponents)

message(CHECK_START "Finding partA")
# ... do check, assume we find A
message(CHECK_PASS "found")

message(CHECK_START "Finding partB")
# ... do check, assume we don't find B
list(APPEND missingComponents B)
message(CHECK_FAIL "not found")

list(POP_BACK CMAKE_MESSAGE_INDENT)
if(missingComponents)
  message(CHECK_FAIL "missing components: ${missingComponents}")
else()
  message(CHECK_PASS "all components found")
endif()

Output from the
above would appear something like the following:

-- Finding my things
--   Finding partA
--   Finding partA - found
--   Finding partB
--   Finding partB - not found
-- Finding my things - missing components: B

option

Provide an option that the user can optionally select.

option( "" [value])

Provides an
option for the user to select as ON or OFF. If
no initial  is provided, OFF is
used. If  is already set as a normal
or cache variable, then the command does nothing (see policy
CMP0077).

If you have
options that depend on the values of other options, see the
module help for CMakeDependentOption.

return

Return from a file, directory or function.

return()

Returns from a
file, directory or function. When this command is
encountered in an included file (via include() or
find_package()), it causes processing of the current
file to stop and control is returned to the including file.
If it is encountered in a file which is not included by
another file, e.g. a CMakeLists.txt, control is
returned to the parent directory if there is one. If return
is called in a function, control is returned to the caller
of the function.

Note that a
macro, unlike a function, is expanded in place
and therefore cannot handle return().

separate_arguments

Parse command-line arguments into a semicolon-separated
list.

separate_arguments(  )

Parses a
space-separated string  into a list of
items, and stores this list in semicolon-separated standard
form in .

This function
is intended for parsing command-line arguments. The entire
command line must be passed as one string in the argument
.

The exact
parsing rules depend on the operating system. They are
specified by the  argument which must be
one of the following keywords: 
UNIX_COMMAND

Arguments are separated by
unquoted whitespace. Both single-quote and double-quote
pairs are respected. A backslash escapes the next literal
character (\" is "); there are no
special escapes (\n is just n).

WINDOWS_COMMAND

A Windows command-line is
parsed using the same syntax the runtime library uses to
construct argv at startup. It separates arguments by
whitespace that is not double-quoted. Backslashes are
literal unless they precede double-quotes. See the MSDN
article Parsing C Command-Line Arguments for
details.

NATIVE_COMMAND

Proceeds as in
WINDOWS_COMMAND mode if the host system is Windows.
Otherwise proceeds as in UNIX_COMMAND mode.

separate_arguments()

Convert the
value of  to a semi-colon separated list.
All spaces are replaced with ’;’. This helps
with generating command lines.

set 
Set a normal, cache, or environment variable to a given
value. See the cmake-language(7) variables documentation for
the scopes and interaction of normal variables and cache
entries.

Signatures of
this command that specify a ...
placeholder expect zero or more arguments. Multiple
arguments will be joined as a semicolon-separated list to
form the actual variable value to be set. Zero arguments
will cause normal variables to be unset. See the
unset() command to unset variables explicitly.

Set Normal
Variable

set( ... [PARENT_SCOPE])

Sets the given
 in the current function or directory
scope.

If the
PARENT_SCOPE option is given the variable will be set
in the scope above the current scope. Each new directory or
function creates a new scope. This command will set the
value of a variable into the parent directory or calling
function (whichever is applicable to the case at hand). The
previous state of the variable’s value stays the same
in the current scope (e.g., if it was undefined before, it
is still undefined and if it had a value, it is still that
value).

Set Cache
Entry

set( ... CACHE   [FORCE])

Sets the given
cache  (cache entry). Since cache
entries are meant to provide user-settable values this does
not overwrite existing cache entries by default. Use the
FORCE option to overwrite existing entries.

The
 must be specified as one of:

BOOL

Boolean ON/OFF value. cmake-gui(1) offers
a checkbox.

FILEPATH

Path to a file on disk.
cmake-gui(1) offers a file dialog.

PATH

Path to a directory on disk. cmake-gui(1) offers
a file dialog.

STRING

A line of text. cmake-gui(1) offers a text field
or a drop-down selection if the STRINGS cache entry
property is set.

INTERNAL

A line of text.
cmake-gui(1) does not show internal entries. They may
be used to store variables persistently across runs. Use of
this type implies FORCE.

The
 must be specified as a line of text
providing a quick summary of the option for presentation to
cmake-gui(1) users.

If the cache
entry does not exist prior to the call or the FORCE
option is given then the cache entry will be set to the
given value. Furthermore, any normal variable binding in the
current scope will be removed to expose the newly cached
value to any immediately following evaluation.

It is possible
for the cache entry to exist prior to the call but have no
type set if it was created on the cmake(1) command
line by a user through the
-D= option without specifying
a type. In this case the set command will add the
type. Furthermore, if the  is PATH
or FILEPATH and the  provided on
the command line is a relative path, then the set
command will treat the path as relative to the current
working directory and convert it to an absolute path.

Set
Environment Variable

set(ENV{} [])

Sets an
Environment Variable to the given value. Subsequent
calls of $ENV{} will return this new
value.

This command
affects only the current CMake process, not the process from
which CMake was called, nor the system environment at large,
nor the environment of subsequent build or test
processes.

If no argument
is given after ENV{} or if
 is an empty string, then this command
will clear any existing value of the environment
variable.

Arguments after
 are ignored. If extra arguments are
found, then an author warning is issued.

set_directory_properties

Set properties of the current directory and
subdirectories.

set_directory_properties(PROPERTIES prop1 value1 [prop2 value2] ...)

Sets properties
of the current directory and its subdirectories in key-value
pairs.

See also the
set_property(DIRECTORY) command.

See Directory
Properties for the list of properties known to CMake and
their individual documentation for the behavior of each
property.

set_property

Set a named property in a given scope.

set_property(]           |
              TARGET    [ ...]   |
              SOURCE    [ ...]
                        [DIRECTORY  ...] |
                        [TARGET_DIRECTORY  ...]
              INSTALL   [ ...]     |
              TEST      [ ...]     |
              CACHE     [ ...]    >
             [APPEND] [APPEND_STRING]
             PROPERTY  [ ...])

Sets one
property on zero or more objects of a scope.

The first
argument determines the scope in which the property is set.
It must be one of the following:

GLOBAL

Scope is unique and does not accept a name.

DIRECTORY

Scope defaults to the current
directory but another directory (already processed by CMake)
may be named by full or relative path. See also the
set_directory_properties() command.

TARGET

Scope may name zero or more existing targets. See also
the set_target_properties() command.

SOURCE

Scope may name zero or more source files. By default,
source file properties are only visible to targets added in
the same directory (CMakeLists.txt). Visibility can
be set in other directory scopes using one or both of the
following sub-options:

DIRECTORY
...

The source file property will
be set in each of the  directories’
scopes. CMake must already know about each of these source
directories, either by having added them through a call to
add_subdirectory() or it being the top level source
directory. Relative paths are treated as relative to the
current source directory.

TARGET_DIRECTORY
...

The source file property will
be set in each of the directory scopes where any of the
specified  were created (the
 must therefore already exist).

See also the
set_source_files_properties() command.

INSTALL

Scope may name zero or more
installed file paths. These are made available to CPack to
influence deployment.

Both the
property key and value may use generator expressions.
Specific properties may apply to installed files and/or
directories.

Path components
have to be separated by forward slashes, must be normalized
and are case sensitive.

To reference
the installation prefix itself with a relative path use
..

Currently
installed file properties are only defined for the WIX
generator where the given paths are relative to the
installation prefix.

TEST

Scope may name zero or more existing tests. See also the
set_tests_properties() command.

CACHE

Scope must name zero or more cache existing entries.

The required
PROPERTY option is immediately followed by the name
of the property to set. Remaining arguments are used to
compose the property value in the form of a
semicolon-separated list.

If the
APPEND option is given the list is appended to any
existing property value (except that empty values are
ignored and not appended). If the APPEND_STRING
option is given the string is appended to any existing
property value as string, i.e. it results in a longer string
and not a list of strings. When using APPEND or
APPEND_STRING with a property defined to support
INHERITED behavior (see define_property()), no
inheriting occurs when finding the initial value to append
to. If the property is not already directly set in the
nominated scope, the command will behave as though
APPEND or APPEND_STRING had not been
given.

See the
cmake-properties(7) manual for a list of properties
in each scope.

site_name

Set the given variable to the name of the computer.

site_name(variable)

string

String operations.

Synopsis

Search and Replace

string(FIND  
 [...]) 
string(REPLACE 
  ...)

string(REGEX MATCH 
 ...) 
string(REGEX MATCHALL 
 ...) 
string(REGEX REPLACE 

...)

Manipulation

string(APPEND 
[...]) 
string(PREPEND 
[...]) 
string(CONCAT 
[...]) 
string(JOIN  
[...]) 
string(TOLOWER 
) 
string(TOUPPER 
) 
string(LENGTH 
) 
string(SUBSTRING 
  ) 
string(STRIP  )

string(GENEX_STRIP 
) 
string(REPEAT  
)

Comparison

string(COMPARE  
 )

Hashing

string( 
)

Generation

string(ASCII ...
) 
string(HEX  )

string(CONFIGURE 
 [...]) 
string(MAKE_C_IDENTIFIER 
) 
string(RANDOM [...]
) 
string(TIMESTAMP  [] [UTC]) 
string(UUID  ...)

Search and
Replace 
Search and Replace With Plain Strings

string(FIND    [REVERSE])

Return the
position where the given  was found
in the supplied . If the REVERSE
flag was used, the command will search for the position of
the last occurrence of the specified
. If the  is
not found, a position of -1 is returned.

The
string(FIND) subcommand treats all strings as
ASCII-only characters. The index stored in
 will also be counted in
bytes, so strings containing multi-byte characters may lead
to unexpected results.

string(REPLACE 

        [...])

Replace all
occurrences of  in the
 with  and
store the result in the .

Search and
Replace With Regular Expressions

string(REGEX MATCH 
         [...])

Match the
 once and store the match
in the . All
 arguments are concatenated before
matching. Regular expressions are specified in the
subsection just below.

string(REGEX MATCHALL 
         [...])

Match the
 as many times as possible
and store the matches in the 
as a list. All  arguments are
concatenated before matching.

string(REGEX REPLACE 

        [...])

Match the
 as many times as possible
and substitute the  for
the match in the output. All  arguments
are concatenated before matching.

The
 may refer to
parenthesis-delimited subexpressions of the match using
\1, \2, …, \9. Note that two
backslashes (\\1) are required in CMake code to get a
backslash through argument parsing.

Regex
Specification 
The following characters have special meaning in regular
expressions:

^

Matches at beginning of
input 

$

Matches at end of input

.

Matches any single character

\

Matches the single character
specified by . Use this to match special
regex characters, e.g. \. for a literal . or
\\ for a literal backslash \. Escaping a
non-special character is unnecessary but allowed, e.g.
\a matches a.

[ ]

Matches any character(s) inside the brackets

[^ ]

Matches any character(s) not inside the brackets

-

Inside brackets, specifies an inclusive range between
characters on either side e.g. [a-f] is
[abcdef] To match a literal - using brackets,
make it the first or the last character e.g. [+*/-]
matches basic mathematical operators.

*

Matches preceding pattern zero or more times

+

Matches preceding pattern one or more times

?

Matches preceding pattern zero or once only

|

Matches a pattern on either side of the |

()

Saves a matched subexpression, which can be referenced
in the REGEX REPLACE operation. Additionally it is
saved by all regular expression-related commands, including
e.g. if(MATCHES), in the variables
CMAKE_MATCH_ for  0..9.

*,
+ and ? have higher precedence than
concatenation. | has lower precedence than
concatenation. This means that the regular expression
^ab+d$ matches abbd but not ababd, and
the regular expression ^(ab|cd)$ matches ab
but not abd.

CMake language
Escape Sequences such as \t, \r, \n,
and \\ may be used to construct literal tabs,
carriage returns, newlines, and backslashes (respectively)
to pass in a regex. For example:

•

The quoted argument "[
\t\r\n]" specifies a regex that matches any single
whitespace character.

•

The quoted argument "[/\\]" specifies a
regex that matches a single forward slash / or
backslash \.

•

The quoted argument "[A-Za-z0-9_]"
specifies a regex that matches any single “word”
character in the C locale.

•

The quoted argument "\\(\\a\\+b\\)"
specifies a regex that matches the exact string
(a+b). Each \\ is parsed in a quoted argument
as just \, so the regex itself is actually
\(\a\+\b\). This can alternatively be specified in a
bracket argument without having to escape the backslashes,
e.g. [[\(\a\+\b\)]].

Manipulation

string(APPEND  [...])

Append all the
 arguments to the string.

string(PREPEND  [...])

Prepend all the
 arguments to the string.

string(CONCAT  [...])

Concatenate all
the  arguments together and store the
result in the named .

string(JOIN   [...])

Join all the
 arguments together using the
 string and store the result in the named
.

To join a
list’s elements, prefer to use the JOIN
operator from the list() command. This allows for the
elements to have special characters like ; in
them.

string(TOLOWER  )

Convert
 to lower characters.

string(TOUPPER  )

Convert
 to upper characters.

string(LENGTH  )

Store in an
 a given string’s length
in bytes. Note that this means if 
contains multi-byte characters, the result stored in
 will not be the number
of characters.

string(SUBSTRING    )

Store in an
 a substring of a given
. If  is -1
the remainder of the string starting at 
will be returned. If  is shorter than
 then the end of the string is used
instead.

Both
 and  are counted
in bytes, so care must be exercised if 
could contain multi-byte characters.

NOTE:

CMake 3.1 and below reported an
error if  pointed past the end of
.

string(STRIP  )

Store in an
 a substring of a given
 with leading and trailing spaces
removed.

string(GENEX_STRIP  )

Strip any
generator expressions from the input
 and store the result in the
.

string(REPEAT   )

Produce the
output string as the input  repeated
 times.

Comparison

string(COMPARE LESS   )
string(COMPARE GREATER   )
string(COMPARE EQUAL   )
string(COMPARE NOTEQUAL   )
string(COMPARE LESS_EQUAL   )
string(COMPARE GREATER_EQUAL   )

Compare the
strings and store true or false in the
.

Hashing

string(  )

Compute a
cryptographic hash of the  string. The
supported  algorithm names are:

MD5

Message-Digest Algorithm 5, RFC
1321. 

SHA1

US Secure Hash Algorithm 1, RFC 3174.

SHA224

US Secure Hash Algorithms, RFC 4634.

SHA256

US Secure Hash Algorithms, RFC 4634.

SHA384

US Secure Hash Algorithms, RFC 4634.

SHA512

US Secure Hash Algorithms, RFC 4634.

SHA3_224

Keccak SHA-3.

SHA3_256

Keccak SHA-3.

SHA3_384

Keccak SHA-3.

SHA3_512

Keccak SHA-3.

Generation

string(ASCII  [ ...] )

Convert all
numbers into corresponding ASCII characters.

string(HEX  )

Convert each
byte in the input  to its hexadecimal
representation and store the concatenated hex digits in the
. Letters in the output
(a through f) are in lowercase.

string(CONFIGURE  
       [@ONLY] [ESCAPE_QUOTES])

Transform a
 like configure_file()
transforms a file.

string(MAKE_C_IDENTIFIER  )

Convert each
non-alphanumeric character in the input
 to an underscore and store the result
in the . If the first
character of the  is a digit, an
underscore will also be prepended to the result.

string(RANDOM [LENGTH ] [ALPHABET ]
       [RANDOM_SEED ] )

Return a random
string of given  consisting of
characters from the given . Default
length is 5 characters and default alphabet is all numbers
and upper and lower case letters. If an integer
RANDOM_SEED is given, its value will be used to seed
the random number generator.

string(TIMESTAMP  [] [UTC])

Write a string
representation of the current date and/or time to the
.

If the command
is unable to obtain a timestamp, the
 will be set to the empty
string "".

The optional
UTC flag requests the current date/time
representation to be in Coordinated Universal Time (UTC)
rather than local time.

The optional
 may contain the following
format specifiers:

%%        A literal percent sign (%).
%d        The day of the current month (01-31).
%H        The hour on a 24-hour clock (00-23).
%I        The hour on a 12-hour clock (01-12).
%j        The day of the current year (001-366).
%m        The month of the current year (01-12).
%b        Abbreviated month name (e.g. Oct).
%B        Full month name (e.g. October).
%M        The minute of the current hour (00-59).
%s        Seconds since midnight (UTC) 1-Jan-1970 (UNIX time).
%S        The second of the current minute.
          60 represents a leap second. (00-60)
%U        The week number of the current year (00-53).
%w        The day of the current week. 0 is Sunday. (0-6)
%a        Abbreviated weekday name (e.g. Fri).
%A        Full weekday name (e.g. Friday).
%y        The last two digits of the current year (00-99)
%Y        The current year.

Unknown format
specifiers will be ignored and copied to the output
as-is.

If no explicit
 is given, it will default
to:

%Y-%m-%dT%H:%M:%S    for local time.
%Y-%m-%dT%H:%M:%SZ   for UTC.

NOTE:

If the SOURCE_DATE_EPOCH
environment variable is set, its value will be used instead
of the current time. See
https://reproducible-builds.org/specs/source-date-epoch/
for details.

string(UUID  NAMESPACE  NAME 
       TYPE  [UPPER])

Create a
universally unique identifier (aka GUID) as per RFC4122
based on the hash of the combined values of
 (which itself has to be a valid
UUID) and . The hash algorithm can be
either MD5 (Version 3 UUID) or SHA1 (Version 5
UUID). A UUID has the format
xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx where each
x represents a lower case hexadecimal character.
Where required, an uppercase representation can be requested
with the optional UPPER flag.

unset

Unset a variable, cache variable, or environment
variable.

Unset Normal
Variable or Cache Entry

unset( [CACHE | PARENT_SCOPE])

Removes a
normal variable from the current scope, causing it to become
undefined. If CACHE is present, then a cache variable
is removed instead of a normal variable. Note that when
evaluating Variable References of the form ${VAR},
CMake first searches for a normal variable with that name.
If no such normal variable exists, CMake will then search
for a cache entry with that name. Because of this unsetting
a normal variable can expose a cache variable that was
previously hidden. To force a variable reference of the form
${VAR} to return an empty string, use
set( ""), which clears the
normal variable but leaves it defined.

If
PARENT_SCOPE is present then the variable is removed
from the scope above the current scope. See the same option
in the set() command for further details.

Unset
Environment Variable

unset(ENV{})

Removes
 from the currently available
Environment Variables. Subsequent calls of
$ENV{} will return the empty
string.

This command
affects only the current CMake process, not the process from
which CMake was called, nor the system environment at large,
nor the environment of subsequent build or test
processes.

variable_watch

Watch the CMake variable for change.

variable_watch( [])

If the
specified  changes, a message will be
printed to inform about the change.

Additionally,
if  is given, this command will be
executed. The command will receive the following arguments:
COMMAND(  
 )

while

Evaluate a group of commands while a condition is true

while()

endwhile()

All commands
between while and the matching endwhile() are
recorded without being invoked. Once the endwhile()
is evaluated, the recorded list of commands is invoked as
long as the  is true.

The
 has the same syntax and is
evaluated using the same logic as described at length for
the if() command.

The commands
break() and continue() provide means to escape
from the normal control flow.

Per legacy, the
endwhile() command admits an optional
 argument. If used, it must be a
verbatim repeat of the argument of the opening while
command.

PROJECT COMMANDS

These commands
are available only in CMake projects.

add_compile_definitions

Add preprocessor definitions to the compilation of source
files.

add_compile_definitions( ...)

Adds
preprocessor definitions to the compiler command line.

The
preprocessor definitions are added to the
COMPILE_DEFINITIONS directory property for the
current CMakeLists file. They are also added to the
COMPILE_DEFINITIONS target property for each target
in the current CMakeLists file.

Definitions are
specified using the syntax VAR or VAR=value.
Function-style definitions are not supported. CMake will
automatically escape the value correctly for the native
build system (note that CMake language syntax may require
escapes to specify some values).

Arguments to
add_compile_definitions may use “generator
expressions” with the syntax $. See
the cmake-generator-expressions(7) manual for
available expressions. See the cmake-buildsystem(7)
manual for more on defining buildsystem properties.

add_compile_options

Add options to the compilation of source files.

add_compile_options( ...)

Adds options to
the COMPILE_OPTIONS directory property. These options
are used when compiling targets from the current directory
and below.

Arguments

Arguments to add_compile_options may use
“generator expressions” with the syntax
$. See the
cmake-generator-expressions(7) manual for available
expressions. See the cmake-buildsystem(7) manual for
more on defining buildsystem properties.

The final set
of compile or link options used for a target is constructed
by accumulating options from the current target and the
usage requirements of its dependencies. The set of options
is de-duplicated to avoid repetition. While beneficial for
individual options, the de-duplication step can break up
option groups. For example, -D A -D B becomes -D A
B. One may specify a group of options using shell-like
quoting along with a SHELL: prefix. The SHELL:
prefix is dropped, and the rest of the option string is
parsed using the separate_arguments() UNIX_COMMAND
mode. For example, "SHELL:-D A" "SHELL:-D
B" becomes -D A -D B.

Example

Since different compilers support different options, a
typical use of this command is in a compiler-specific
conditional clause:

if (MSVC)
    # warning level 4 and all warnings as errors
    add_compile_options(/W4 /WX)
else()
    # lots of warnings and all warnings as errors
    add_compile_options(-Wall -Wextra -pedantic -Werror)
endif()

See Also

This command can be used to add any options. However, for
adding preprocessor definitions and include directories it
is recommended to use the more specific commands
add_compile_definitions() and
include_directories().

The command
target_compile_options() adds target-specific
options.

The source file
property COMPILE_OPTIONS adds options to one source
file.

add_custom_command

Add a custom build rule to the generated build system.

There are two
main signatures for add_custom_command.

Generating
Files 
The first signature is for adding a custom command to
produce an output:

add_custom_command(OUTPUT output1 [output2 ...]
                   COMMAND command1 [ARGS] [args1...]
                   [COMMAND command2 [ARGS] [args2...] ...]
                   [MAIN_DEPENDENCY depend]
                   [DEPENDS [depends...]]
                   [BYPRODUCTS [files...]]
                   [IMPLICIT_DEPENDS  depend1
                                    [ depend2] ...]
                   [WORKING_DIRECTORY dir]
                   [COMMENT comment]
                   [DEPFILE depfile]
                   [JOB_POOL job_pool]
                   [VERBATIM] [APPEND] [USES_TERMINAL]
                   [COMMAND_EXPAND_LISTS])

This defines a
command to generate specified OUTPUT file(s). A
target created in the same directory (CMakeLists.txt
file) that specifies any output of the custom command as a
source file is given a rule to generate the file using the
command at build time. Do not list the output in more than
one independent target that may build in parallel or the two
instances of the rule may conflict (instead use the
add_custom_target() command to drive the command and
make the other targets depend on that one). In makefile
terms this creates a new target in the following form:

OUTPUT: MAIN_DEPENDENCY DEPENDS
        COMMAND

The options
are:

APPEND

Append the COMMAND and DEPENDS option
values to the custom command for the first output specified.
There must have already been a previous call to this command
with the same output. The COMMENT,
MAIN_DEPENDENCY, and WORKING_DIRECTORY options
are currently ignored when APPEND is given, but may be used
in the future.

BYPRODUCTS

Specify the files the command
is expected to produce but whose modification time may or
may not be newer than the dependencies. If a byproduct name
is a relative path it will be interpreted relative to the
build tree directory corresponding to the current source
directory. Each byproduct file will be marked with the
GENERATED source file property automatically.

Explicit
specification of byproducts is supported by the Ninja
generator to tell the ninja build tool how to
regenerate byproducts when they are missing. It is also
useful when other build rules (e.g. custom commands) depend
on the byproducts. Ninja requires a build rule for any
generated file on which another rule depends even if there
are order-only dependencies to ensure the byproducts will be
available before their dependents build.

The Makefile
Generators will remove BYPRODUCTS and other
GENERATED files during make clean.

COMMAND

Specify the command-line(s) to
execute at build time. If more than one COMMAND is
specified they will be executed in order, but not
necessarily composed into a stateful shell or batch script.
(To run a full script, use the configure_file()
command or the file(GENERATE) command to create it,
and then specify a COMMAND to launch it.) The
optional ARGS argument is for backward compatibility
and will be ignored.

If
COMMAND specifies an executable target name (created
by the add_executable() command), it will
automatically be replaced by the location of the executable
created at build time if either of the following is
true:

•

The target is not being cross-compiled (i.e. the
CMAKE_CROSSCOMPILING variable is not set to
true). 

•

The target is being cross-compiled and an emulator is
provided (i.e. its CROSSCOMPILING_EMULATOR target
property is set). In this case, the contents of
CROSSCOMPILING_EMULATOR will be prepended to the
command before the location of the target executable.

If neither of
the above conditions are met, it is assumed that the command
name is a program to be found on the PATH at build
time.

Arguments to
COMMAND may use generator expressions. Use the
TARGET_FILE generator expression to refer to the
location of a target later in the command line (i.e. as a
command argument rather than as the command to execute).

Whenever a
target is used as a command to execute or is mentioned in a
generator expression as a command argument, a target-level
dependency will be added automatically so that the mentioned
target will be built before any target using this custom
command. However this does NOT add a file-level dependency
that would cause the custom command to re-run whenever the
executable is recompiled. List target names with the
DEPENDS option to add such file-level
dependencies.

COMMENT

Display the given message
before the commands are executed at build time.

DEPENDS

Specify files on which the
command depends. Each argument is converted to a dependency
as follows:

1.

If the argument is the name of a target (created by the
add_custom_target(), add_executable(), or
add_library() command) a target-level dependency is
created to make sure the target is built before any target
using this custom command. Additionally, if the target is an
executable or library, a file-level dependency is created to
cause the custom command to re-run whenever the target is
recompiled. 

2.

If the argument is an absolute path, a file-level
dependency is created on that path.

3.

If the argument is the name of a source file that has
been added to a target or on which a source file property
has been set, a file-level dependency is created on that
source file.

4.

If the argument is a relative path and it exists in the
current source directory, a file-level dependency is created
on that file in the current source directory.

5.

Otherwise, a file-level dependency is created on that
path relative to the current binary directory.

If any
dependency is an OUTPUT of another custom command in
the same directory (CMakeLists.txt file), CMake
automatically brings the other custom command into the
target in which this command is built. A target-level
dependency is added if any dependency is listed as
BYPRODUCTS of a target or any of its build events in
the same directory to ensure the byproducts will be
available.

If
DEPENDS is not specified, the command will run
whenever the OUTPUT is missing; if the command does
not actually create the OUTPUT, the rule will always
run.

Arguments to
DEPENDS may use generator expressions.

COMMAND_EXPAND_LISTS

Lists in COMMAND
arguments will be expanded, including those created with
generator expressions, allowing COMMAND
arguments such as ${CC}
"-I$,;-I>"
foo.cc to be properly expanded.

IMPLICIT_DEPENDS

Request scanning of implicit
dependencies of an input file. The language given specifies
the programming language whose corresponding dependency
scanner should be used. Currently only C and
CXX language scanners are supported. The language has
to be specified for every file in the
IMPLICIT_DEPENDS list. Dependencies discovered from
the scanning are added to those of the custom command at
build time. Note that the IMPLICIT_DEPENDS option is
currently supported only for Makefile generators and will be
ignored by other generators.

JOB_POOL

Specify a pool for the
Ninja generator. Incompatible with
USES_TERMINAL, which implies the console pool.
Using a pool that is not defined by JOB_POOLS causes
an error by ninja at build time.

MAIN_DEPENDENCY

Specify the primary input
source file to the command. This is treated just like any
value given to the DEPENDS option but also suggests
to Visual Studio generators where to hang the custom
command. Each source file may have at most one command
specifying it as its main dependency. A compile command
(i.e. for a library or an executable) counts as an implicit
main dependency which gets silently overwritten by a custom
command specification.

OUTPUT

Specify the output files the command is expected to
produce. If an output name is a relative path it will be
interpreted relative to the build tree directory
corresponding to the current source directory. Each output
file will be marked with the GENERATED source file
property automatically. If the output of the custom command
is not actually created as a file on disk it should be
marked with the SYMBOLIC source file property.

USES_TERMINAL

The command will be given
direct access to the terminal if possible. With the
Ninja generator, this places the command in the
console pool.

VERBATIM

All arguments to the commands
will be escaped properly for the build tool so that the
invoked command receives each argument unchanged. Note that
one level of escapes is still used by the CMake language
processor before add_custom_command even sees the arguments.
Use of VERBATIM is recommended as it enables correct
behavior. When VERBATIM is not given the behavior is
platform specific because there is no protection of
tool-specific special characters.

WORKING_DIRECTORY

Execute the command with the
given current working directory. If it is a relative path it
will be interpreted relative to the build tree directory
corresponding to the current source directory.

Arguments to
WORKING_DIRECTORY may use generator
expressions.

DEPFILE

Specify a .d depfile for
the Ninja generator. A .d file holds
dependencies usually emitted by the custom command itself.
Using DEPFILE with other generators than Ninja is an
error.

Build
Events 
The second signature adds a custom command to a target such
as a library or executable. This is useful for performing an
operation before or after building the target. The command
becomes part of the target and will only execute when the
target itself is built. If the target is already built, the
command will not execute.

add_custom_command(TARGET 
                   PRE_BUILD | PRE_LINK | POST_BUILD
                   COMMAND command1 [ARGS] [args1...]
                   [COMMAND command2 [ARGS] [args2...] ...]
                   [BYPRODUCTS [files...]]
                   [WORKING_DIRECTORY dir]
                   [COMMENT comment]
                   [VERBATIM] [USES_TERMINAL]
                   [COMMAND_EXPAND_LISTS])

This defines a
new command that will be associated with building the
specified . The 
must be defined in the current directory; targets defined in
other directories may not be specified.

When the
command will happen is determined by which of the following
is specified: 
PRE_BUILD

On Visual Studio Generators,
run before any other rules are executed within the target.
On other generators, run just before PRE_LINK
commands.

PRE_LINK

Run after sources have been
compiled but before linking the binary or running the
librarian or archiver tool of a static library. This is not
defined for targets created by the
add_custom_target() command.

POST_BUILD

Run after all other rules
within the target have been executed.

NOTE:

Because generator expressions
can be used in custom commands, it is possible to define
COMMAND lines or whole custom commands which evaluate
to empty strings for certain configurations. For Visual
Studio 2010 (and newer) generators these command lines
or custom commands will be omitted for the specific
configuration and no “empty-string-command” will
be added.

This allows to
add individual build events for every configuration.

add_custom_target

Add a target with no output so it will always be built.

add_custom_target(Name [ALL] [command1 [args1...]]
                  [COMMAND command2 [args2...] ...]
                  [DEPENDS depend depend depend ... ]
                  [BYPRODUCTS [files...]]
                  [WORKING_DIRECTORY dir]
                  [COMMENT comment]
                  [JOB_POOL job_pool]
                  [VERBATIM] [USES_TERMINAL]
                  [COMMAND_EXPAND_LISTS]
                  [SOURCES src1 [src2...]])

Adds a target
with the given name that executes the given commands. The
target has no output file and is always considered out of
date even if the commands try to create a file with the
name of the target. Use the add_custom_command()
command to generate a file with dependencies. By default
nothing depends on the custom target. Use the
add_dependencies() command to add dependencies to or
from other targets.

The options
are:

ALL

Indicate that this target should be added to the default
build target so that it will be run every time (the command
cannot be called ALL).

BYPRODUCTS

Specify the files the command
is expected to produce but whose modification time may or
may not be updated on subsequent builds. If a byproduct name
is a relative path it will be interpreted relative to the
build tree directory corresponding to the current source
directory. Each byproduct file will be marked with the
GENERATED source file property automatically.

Explicit
specification of byproducts is supported by the Ninja
generator to tell the ninja build tool how to
regenerate byproducts when they are missing. It is also
useful when other build rules (e.g. custom commands) depend
on the byproducts. Ninja requires a build rule for any
generated file on which another rule depends even if there
are order-only dependencies to ensure the byproducts will be
available before their dependents build.

The Makefile
Generators will remove BYPRODUCTS and other
GENERATED files during make clean.

COMMAND

Specify the command-line(s) to
execute at build time. If more than one COMMAND is
specified they will be executed in order, but not
necessarily composed into a stateful shell or batch script.
(To run a full script, use the configure_file()
command or the file(GENERATE) command to create it,
and then specify a COMMAND to launch it.)

If
COMMAND specifies an executable target name (created
by the add_executable() command), it will
automatically be replaced by the location of the executable
created at build time if either of the following is
true:

•

The target is not being cross-compiled (i.e. the
CMAKE_CROSSCOMPILING variable is not set to
true). 

•

The target is being cross-compiled and an emulator is
provided (i.e. its CROSSCOMPILING_EMULATOR target
property is set). In this case, the contents of
CROSSCOMPILING_EMULATOR will be prepended to the
command before the location of the target executable.

If neither of
the above conditions are met, it is assumed that the command
name is a program to be found on the PATH at build
time.

Arguments to
COMMAND may use generator expressions. Use the
TARGET_FILE generator expression to refer to the
location of a target later in the command line (i.e. as a
command argument rather than as the command to execute).

Whenever a
target is used as a command to execute or is mentioned in a
generator expression as a command argument, a target-level
dependency will be added automatically so that the mentioned
target will be built before this custom target.

The command and
arguments are optional and if not specified an empty target
will be created.

COMMENT

Display the given message
before the commands are executed at build time.

DEPENDS

Reference files and outputs of
custom commands created with add_custom_command()
command calls in the same directory (CMakeLists.txt
file). They will be brought up to date when the target is
built. A target-level dependency is added if any dependency
is a byproduct of a target or any of its build events in the
same directory to ensure the byproducts will be available
before this target is built.

Use the
add_dependencies() command to add dependencies on
other targets.

COMMAND_EXPAND_LISTS

Lists in COMMAND
arguments will be expanded, including those created with
generator expressions, allowing COMMAND
arguments such as ${CC}
"-I$,;-I>"
foo.cc to be properly expanded.

JOB_POOL

Specify a pool for the
Ninja generator. Incompatible with
USES_TERMINAL, which implies the console pool.
Using a pool that is not defined by JOB_POOLS causes
an error by ninja at build time.

SOURCES

Specify additional source files
to be included in the custom target. Specified source files
will be added to IDE project files for convenience in
editing even if they have no build rules.

VERBATIM

All arguments to the commands
will be escaped properly for the build tool so that the
invoked command receives each argument unchanged. Note that
one level of escapes is still used by the CMake language
processor before add_custom_target even sees the
arguments. Use of VERBATIM is recommended as it
enables correct behavior. When VERBATIM is not given
the behavior is platform specific because there is no
protection of tool-specific special characters.

USES_TERMINAL

The command will be given
direct access to the terminal if possible. With the
Ninja generator, this places the command in the
console pool.

WORKING_DIRECTORY

Execute the command with the
given current working directory. If it is a relative path it
will be interpreted relative to the build tree directory
corresponding to the current source directory.

Arguments to
WORKING_DIRECTORY may use generator
expressions.

add_definitions

Add -D define flags to the compilation of source files.

add_definitions(-DFOO -DBAR ...)

Adds
definitions to the compiler command line for targets in the
current directory, whether added before or after this
command is invoked, and for the ones in sub-directories
added after. This command can be used to add any flags, but
it is intended to add preprocessor definitions.

NOTE:

This command has been
superseded by alternatives:

•

Use add_compile_definitions() to add preprocessor
definitions. 

•

Use include_directories() to add include
directories. 

•

Use add_compile_options() to add other
options. 

Flags beginning
in -D or /D that look like preprocessor
definitions are automatically added to the
COMPILE_DEFINITIONS directory property for the
current directory. Definitions with non-trivial values may
be left in the set of flags instead of being converted for
reasons of backwards compatibility. See documentation of the
directory, target, source file
COMPILE_DEFINITIONS properties for details on adding
preprocessor definitions to specific scopes and
configurations.

See the
cmake-buildsystem(7) manual for more on defining
buildsystem properties.

add_dependencies

Add a dependency between top-level targets.

add_dependencies( []...)

Makes a
top-level  depend on other top-level
targets to ensure that they build before
 does. A top-level target is one
created by one of the add_executable(),
add_library(), or add_custom_target() commands
(but not targets generated by CMake like
install).

Dependencies
added to an imported target or an interface library are
followed transitively in its place since the target itself
does not build.

See the
DEPENDS option of add_custom_target() and
add_custom_command() commands for adding file-level
dependencies in custom rules. See the OBJECT_DEPENDS
source file property to add file-level dependencies to
object files.

add_executable

Add an executable to the project using the specified source
files.

Normal
Executables

add_executable( [WIN32] [MACOSX_BUNDLE]
               [EXCLUDE_FROM_ALL]
               [source1] [source2 ...])

Adds an
executable target called  to be built
from the source files listed in the command invocation. (The
source files can be omitted here if they are added later
using target_sources().) The 
corresponds to the logical target name and must be globally
unique within a project. The actual file name of the
executable built is constructed based on conventions of the
native platform (such as .exe or just
).

By default the
executable file will be created in the build tree directory
corresponding to the source tree directory in which the
command was invoked. See documentation of the
RUNTIME_OUTPUT_DIRECTORY target property to change
this location. See documentation of the OUTPUT_NAME
target property to change the  part of
the final file name.

If WIN32
is given the property WIN32_EXECUTABLE will be set on
the target created. See documentation of that target
property for details.

If
MACOSX_BUNDLE is given the corresponding property
will be set on the created target. See documentation of the
MACOSX_BUNDLE target property for details.

If
EXCLUDE_FROM_ALL is given the corresponding property
will be set on the created target. See documentation of the
EXCLUDE_FROM_ALL target property for details.

Source
arguments to add_executable may use “generator
expressions” with the syntax $. See
the cmake-generator-expressions(7) manual for
available expressions. See the cmake-buildsystem(7)
manual for more on defining buildsystem properties.

See also
HEADER_FILE_ONLY on what to do if some sources are
pre-processed, and you want to have the original sources
reachable from within IDE.

Imported
Executables

add_executable( IMPORTED [GLOBAL])

An IMPORTED
executable target references an executable file located
outside the project. No rules are generated to build it, and
the IMPORTED target property is True. The
target name has scope in the directory in which it is
created and below, but the GLOBAL option extends
visibility. It may be referenced like any target built
within the project. IMPORTED executables are useful
for convenient reference from commands like
add_custom_command(). Details about the imported
executable are specified by setting properties whose names
begin in IMPORTED_. The most important such property
is IMPORTED_LOCATION (and its per-configuration
version IMPORTED_LOCATION_) which
specifies the location of the main executable file on disk.
See documentation of the IMPORTED_* properties for
more information.

Alias
Executables

add_executable( ALIAS )

Creates an
Alias Target, such that  can be used to
refer to  in subsequent commands. The
 does not appear in the generated
buildsystem as a make target. The  may
not be an ALIAS.

An ALIAS
to a non-GLOBAL Imported Target has scope in the
directory in which the alias is created and below. The
ALIAS_GLOBAL target property can be used to check if
the alias is global or not.

ALIAS
targets can be used as targets to read properties from,
executables for custom commands and custom targets. They can
also be tested for existence with the regular
if(TARGET) subcommand. The  may
not be used to modify properties of ,
that is, it may not be used as the operand of
set_property(), set_target_properties(),
target_link_libraries() etc. An ALIAS target
may not be installed or exported.

add_library

Add a library to the project using the specified source
files.

Normal
Libraries

add_library( [STATIC | SHARED | MODULE]
            [EXCLUDE_FROM_ALL]
            [source1] [source2 ...])

Adds a library
target called  to be built from the
source files listed in the command invocation. (The source
files can be omitted here if they are added later using
target_sources().) The 
corresponds to the logical target name and must be globally
unique within a project. The actual file name of the library
built is constructed based on conventions of the native
platform (such as lib.a or
.lib).

STATIC,
SHARED, or MODULE may be given to specify the
type of library to be created. STATIC libraries are
archives of object files for use when linking other targets.
SHARED libraries are linked dynamically and loaded at
runtime. MODULE libraries are plugins that are not
linked into other targets but may be loaded dynamically at
runtime using dlopen-like functionality. If no type is given
explicitly the type is STATIC or SHARED based
on whether the current value of the variable
BUILD_SHARED_LIBS is ON. For SHARED and
MODULE libraries the POSITION_INDEPENDENT_CODE
target property is set to ON automatically. A
SHARED or STATIC library may be marked with
the FRAMEWORK target property to create an macOS
Framework.

If a library
does not export any symbols, it must not be declared as a
SHARED library. For example, a Windows resource DLL
or a managed C++/CLI DLL that exports no unmanaged symbols
would need to be a MODULE library. This is because
CMake expects a SHARED library to always have an
associated import library on Windows.

By default the
library file will be created in the build tree directory
corresponding to the source tree directory in which the
command was invoked. See documentation of the
ARCHIVE_OUTPUT_DIRECTORY,
LIBRARY_OUTPUT_DIRECTORY, and
RUNTIME_OUTPUT_DIRECTORY target properties to change
this location. See documentation of the OUTPUT_NAME
target property to change the  part of
the final file name.

If
EXCLUDE_FROM_ALL is given the corresponding property
will be set on the created target. See documentation of the
EXCLUDE_FROM_ALL target property for details.

Source
arguments to add_library may use “generator
expressions” with the syntax $. See
the cmake-generator-expressions(7) manual for
available expressions. See the cmake-buildsystem(7)
manual for more on defining buildsystem properties.

See also
HEADER_FILE_ONLY on what to do if some sources are
pre-processed, and you want to have the original sources
reachable from within IDE.

Imported
Libraries

add_library(  IMPORTED
            [GLOBAL])

An IMPORTED
library target references a library file located outside the
project. No rules are generated to build it, and the
IMPORTED target property is True. The target
name has scope in the directory in which it is created and
below, but the GLOBAL option extends visibility. It
may be referenced like any target built within the project.
IMPORTED libraries are useful for convenient
reference from commands like target_link_libraries().
Details about the imported library are specified by setting
properties whose names begin in IMPORTED_ and
INTERFACE_.

The most
important properties are:

•

IMPORTED_LOCATION (and
its per-configuration variant
IMPORTED_LOCATION_) which specifies the
location of the main library file on disk.

•

IMPORTED_OBJECTS (and
IMPORTED_OBJECTS_) for object
libraries, specifies the locations of object files on
disk. 

•

PUBLIC_HEADER files to be installed during
install() invocation

See
documentation of the IMPORTED_* and
INTERFACE_* properties for more information.

An
UNKNOWN library type is typically only used in the
implementation of Find Modules. It allows the path to an
imported library (often found using the
find_library() command) to be used without having to
know what type of library it is. This is especially useful
on Windows where a static library and a DLL’s import
library both have the same file extension.

Object
Libraries

add_library( OBJECT ...)

Creates an
Object Library. An object library compiles source files but
does not archive or link their object files into a library.
Instead other targets created by add_library() or
add_executable() may reference the objects using an
expression of the form $
as a source, where objlib is the object library name.
For example:

add_library(... $ ...)
add_executable(... $ ...)

will include
objlib’s object files in a library and an executable
along with those compiled from their own sources. Object
libraries may contain only sources that compile, header
files, and other files that would not affect linking of a
normal library (e.g. .txt). They may contain custom
commands generating such sources, but not PRE_BUILD,
PRE_LINK, or POST_BUILD commands. Some native
build systems (such as Xcode) may not like targets that have
only object files, so consider adding at least one real
source file to any target that references
$.

Alias
Libraries

add_library( ALIAS )

Creates an
Alias Target, such that  can be used to
refer to  in subsequent commands. The
 does not appear in the generated
buildsystem as a make target. The  may
not be an ALIAS.

An ALIAS
to a non-GLOBAL Imported Target has scope in the
directory in which the alias is created and below. The
ALIAS_GLOBAL target property can be used to check if
the alias is global or not.

ALIAS
targets can be used as linkable targets and as targets to
read properties from. They can also be tested for existence
with the regular if(TARGET) subcommand. The
 may not be used to modify properties of
, that is, it may not be used as the
operand of set_property(),
set_target_properties(),
target_link_libraries() etc. An ALIAS target
may not be installed or exported.

Interface
Libraries

add_library( INTERFACE [IMPORTED [GLOBAL]])

Creates an
Interface Library. An INTERFACE library target does
not directly create build output, though it may have
properties set on it and it may be installed, exported and
imported. Typically the INTERFACE_* properties are
populated on the interface target using the commands:

•

set_property(),

•

target_link_libraries(INTERFACE),

•

target_link_options(INTERFACE),

•

target_include_directories(INTERFACE),

•

target_compile_options(INTERFACE),

•

target_compile_definitions(INTERFACE), and

•

target_sources(INTERFACE),

and then it is
used as an argument to target_link_libraries() like
any other target.

An
INTERFACE Imported Target may also be created with
this signature. An IMPORTED library target references
a library defined outside the project. The target name has
scope in the directory in which it is created and below, but
the GLOBAL option extends visibility. It may be
referenced like any target built within the project.
IMPORTED libraries are useful for convenient
reference from commands like
target_link_libraries().

add_link_options

Add options to the link step for executable, shared library
or module library targets in the current directory and below
that are added after this command is invoked.

add_link_options( ...)

This command
can be used to add any link options, but alternative
commands exist to add libraries
(target_link_libraries() or link_libraries()).
See documentation of the directory and target
LINK_OPTIONS properties.

NOTE:

This command cannot be used to
add options for static library targets, since they do not
use a linker. To add archiver or MSVC librarian flags, see
the STATIC_LIBRARY_OPTIONS target property.

Arguments to
add_link_options may use “generator
expressions” with the syntax $. See
the cmake-generator-expressions(7) manual for
available expressions. See the cmake-buildsystem(7)
manual for more on defining buildsystem properties.

When a device
link step is involved, which is controlled by
CUDA_SEPARABLE_COMPILATION and
CUDA_RESOLVE_DEVICE_SYMBOLS properties and policy
CMP0105, the raw options will be delivered to the
host and device link steps (wrapped in -Xcompiler or
equivalent for device link). Options wrapped with
$ generator expression will be
used only for the device link step. Options wrapped with
$ generator expression will be
used only for the host link step.

The final set
of compile or link options used for a target is constructed
by accumulating options from the current target and the
usage requirements of its dependencies. The set of options
is de-duplicated to avoid repetition. While beneficial for
individual options, the de-duplication step can break up
option groups. For example, -D A -D B becomes -D A
B. One may specify a group of options using shell-like
quoting along with a SHELL: prefix. The SHELL:
prefix is dropped, and the rest of the option string is
parsed using the separate_arguments() UNIX_COMMAND
mode. For example, "SHELL:-D A" "SHELL:-D
B" becomes -D A -D B.

To pass options
to the linker tool, each compiler driver has its own syntax.
The LINKER: prefix and , separator can be used
to specify, in a portable way, options to pass to the linker
tool. LINKER: is replaced by the appropriate driver
option and , by the appropriate driver separator. The
driver prefix and driver separator are given by the values
of the CMAKE__LINKER_WRAPPER_FLAG and
CMAKE__LINKER_WRAPPER_FLAG_SEP
variables.

For example,
"LINKER:-z,defs" becomes -Xlinker -z
-Xlinker defs for Clang and -Wl,-z,defs
for GNU GCC.

The
LINKER: prefix can be specified as part of a
SHELL: prefix expression.

The
LINKER: prefix supports, as an alternative syntax,
specification of arguments using the SHELL: prefix
and space as separator. The previous example then becomes
"LINKER:SHELL:-z defs".

NOTE:

Specifying the SHELL:
prefix anywhere other than at the beginning of the
LINKER: prefix is not supported.

add_subdirectory

Add a subdirectory to the build.

add_subdirectory(source_dir [binary_dir] [EXCLUDE_FROM_ALL])

Adds a
subdirectory to the build. The source_dir specifies the
directory in which the source CMakeLists.txt and code files
are located. If it is a relative path it will be evaluated
with respect to the current directory (the typical usage),
but it may also be an absolute path. The binary_dir
specifies the directory in which to place the output files.
If it is a relative path it will be evaluated with respect
to the current output directory, but it may also be an
absolute path. If binary_dir is not specified, the
value of source_dir, before expanding any relative
path, will be used (the typical usage). The CMakeLists.txt
file in the specified source directory will be processed
immediately by CMake before processing in the current input
file continues beyond this command.

If the
EXCLUDE_FROM_ALL argument is provided then targets in
the subdirectory will not be included in the ALL
target of the parent directory by default, and will be
excluded from IDE project files. Users must explicitly build
targets in the subdirectory. This is meant for use when the
subdirectory contains a separate part of the project that is
useful but not necessary, such as a set of examples.
Typically the subdirectory should contain its own
project() command invocation so that a full build
system will be generated in the subdirectory (such as a VS
IDE solution file). Note that inter-target dependencies
supersede this exclusion. If a target built by the parent
project depends on a target in the subdirectory, the
dependee target will be included in the parent project build
system to satisfy the dependency.

add_test

Add a test to the project to be run by ctest(1).

add_test(NAME  COMMAND  [...]
         [CONFIGURATIONS ...]
         [WORKING_DIRECTORY ]
         [COMMAND_EXPAND_LISTS])

Adds a test
called . The test name may not contain
spaces, quotes, or other characters special in CMake syntax.
The options are: 
COMMAND

Specify the test command-line.
If  specifies an executable target
(created by add_executable()) it will automatically
be replaced by the location of the executable created at
build time.

CONFIGURATIONS

Restrict execution of the test
only to the named configurations.

WORKING_DIRECTORY

Set the
WORKING_DIRECTORY test property to specify the
working directory in which to execute the test. If not
specified the test will be run with the current working
directory set to the build directory corresponding to the
current source directory.

COMMAND_EXPAND_LISTS

Lists in COMMAND
arguments will be expanded, including those created with
generator expressions.

The given test
command is expected to exit with code 0 to pass and
non-zero to fail, or vice-versa if the WILL_FAIL test
property is set. Any output written to stdout or stderr will
be captured by ctest(1) but does not affect the
pass/fail status unless the PASS_REGULAR_EXPRESSION,
FAIL_REGULAR_EXPRESSION or
SKIP_REGULAR_EXPRESSION test property is used.

The
COMMAND and WORKING_DIRECTORY options may use
“generator expressions” with the syntax
$. See the
cmake-generator-expressions(7) manual for available
expressions.

Example
usage:

add_test(NAME mytest
         COMMAND testDriver --config $
                            --exe $)

This creates a
test mytest whose command runs a testDriver
tool passing the configuration name and the full path to the
executable file produced by target myexe.

NOTE:

CMake will generate tests only
if the enable_testing() command has been invoked. The
CTest module invokes the command automatically unless
the BUILD_TESTING option is turned OFF.

----

add_test(  [...])

Add a test
called  with the given command-line.
Unlike the above NAME signature no transformation is
performed on the command-line to support target names or
generator expressions.

aux_source_directory

Find all source files in a directory.

aux_source_directory( )

Collects the
names of all the source files in the specified directory and
stores the list in the  provided.
This command is intended to be used by projects that use
explicit template instantiation. Template instantiation
files can be stored in a Templates subdirectory and
collected automatically using this command to avoid manually
listing all instantiations.

It is tempting
to use this command to avoid writing the list of source
files for a library or executable target. While this seems
to work, there is no way for CMake to generate a build
system that knows when a new source file has been added.
Normally the generated build system knows when it needs to
rerun CMake because the CMakeLists.txt file is
modified to add a new source. When the source is just added
to the directory without modifying this file, one would have
to manually rerun CMake to generate a build system
incorporating the new file.

build_command

Get a command line to build the current project. This is
mainly intended for internal use by the CTest
module.

build_command(
              [CONFIGURATION ]
              [TARGET ]
              [PROJECT_NAME ] # legacy, causes warning
             )

Sets the given
 to a command-line string of the
form:

 --build . [--config ] [--target ...] [-- -i]

where
 is the location of the cmake(1)
command-line tool, and  and
 are the values provided to the
CONFIGURATION and TARGET options, if any. The
trailing -- -i option is added for Makefile
Generators if policy CMP0061 is not set to
NEW.

When invoked,
this cmake --build command line will launch the
underlying build system tool.

build_command( )

This second
signature is deprecated, but still available for backwards
compatibility. Use the first signature instead.

It sets the
given  to a command-line string
as above but without the --target option. The
 is ignored but should be the full
path to devenv, nmake, make or one of the end user build
tools for legacy invocations.

NOTE:

In CMake versions prior to 3.0
this command returned a command line that directly invokes
the native build tool for the current generator. Their
implementation of the PROJECT_NAME option had no
useful effects, so CMake now warns on use of the option.

create_test_sourcelist

Create a test driver and source list for building test
programs.

create_test_sourcelist(sourceListName driverName
                       test1 test2 test3
                       EXTRA_INCLUDE include.h
                       FUNCTION function)

A test driver
is a program that links together many small tests into a
single executable. This is useful when building static
executables with large libraries to shrink the total
required size. The list of source files needed to build the
test driver will be in sourceListName.
driverName is the name of the test driver program.
The rest of the arguments consist of a list of test source
files, can be semicolon separated. Each test source file
should have a function in it that is the same name as the
file with no extension (foo.cxx should have int foo(int,
char*[]);) driverName will be able to call each of
the tests by name on the command line. If
EXTRA_INCLUDE is specified, then the next argument is
included into the generated file. If FUNCTION is
specified, then the next argument is taken as a function
name that is passed a pointer to ac and av. This can be used
to add extra command line processing to each test. The
CMAKE_TESTDRIVER_BEFORE_TESTMAIN cmake variable can
be set to have code that will be placed directly before
calling the test main function.
CMAKE_TESTDRIVER_AFTER_TESTMAIN can be set to have
code that will be placed directly after the call to the test
main function.

define_property

Define and document custom properties.

define_property(
                 PROPERTY  [INHERITED]
                 BRIEF_DOCS  [docs...]
                 FULL_DOCS  [docs...])

Defines one
property in a scope for use with the set_property()
and get_property() commands. This is primarily useful
to associate documentation with property names that may be
retrieved with the get_property() command. The first
argument determines the kind of scope in which the property
should be used. It must be one of the following:

GLOBAL    = associated with the global namespace
DIRECTORY = associated with one directory
TARGET    = associated with one target
SOURCE    = associated with one source file
TEST      = associated with a test named with add_test
VARIABLE  = documents a CMake language variable
CACHED_VARIABLE = documents a CMake cache variable

Note that
unlike set_property() and get_property() no
actual scope needs to be given; only the kind of scope is
important.

The required
PROPERTY option is immediately followed by the name
of the property being defined.

If the
INHERITED option is given, then the
get_property() command will chain up to the next
higher scope when the requested property is not set in the
scope given to the command.

•

DIRECTORY scope chains to its parent
directory’s scope, continuing the walk up parent
directories until a directory has the property set or there
are no more parents. If still not found at the top level
directory, it chains to the GLOBAL scope.

•

TARGET, SOURCE and TEST properties
chain to DIRECTORY scope, including further chaining
up the directories, etc. as needed.

Note that this
scope chaining behavior only applies to calls to
get_property(), get_directory_property(),
get_target_property(),
get_source_file_property() and
get_test_property(). There is no inheriting behavior
when setting properties, so using APPEND or
APPEND_STRING with the set_property() command
will not consider inherited values when working out the
contents to append to.

The
BRIEF_DOCS and FULL_DOCS options are followed
by strings to be associated with the property as its brief
and full documentation. Corresponding options to the
get_property() command will retrieve the
documentation.

enable_language

Enable a language (CXX/C/OBJC/OBJCXX/Fortran/etc)

enable_language( [OPTIONAL] )

Enables support
for the named language in CMake. This is the same as the
project() command but does not create any of the
extra variables that are created by the project command.
Example languages are CXX, C, CUDA,
OBJC, OBJCXX, Fortran, and
ASM.

If enabling
ASM, enable it last so that CMake can check whether
compilers for other languages like C work for
assembly too.

This command
must be called in file scope, not in a function call.
Furthermore, it must be called in the highest directory
common to all targets using the named language directly for
compiling sources or indirectly through link dependencies.
It is simplest to enable all needed languages in the
top-level directory of a project.

The
OPTIONAL keyword is a placeholder for future
implementation and does not currently work. Instead you can
use the CheckLanguage module to verify support before
enabling.

enable_testing

Enable testing for current directory and below.

enable_testing()

Enables testing
for this directory and below.

This command
should be in the source directory root because ctest expects
to find a test file in the build directory root.

This command is
automatically invoked when the CTest module is
included, except if the BUILD_TESTING option is
turned off.

See also the
add_test() command.

export

Export targets from the build tree for use by outside
projects.

export(EXPORT  [NAMESPACE ] [FILE ])

Creates a file
 that may be included by outside
projects to import targets from the current project’s
build tree. This is useful during cross-compiling to build
utility executables that can run on the host platform in one
project and then import them into another project being
compiled for the target platform. If the NAMESPACE
option is given the  string will be
prepended to all target names written to the file.

Target
installations are associated with the export
 using the EXPORT option of
the install(TARGETS) command.

The file
created by this command is specific to the build tree and
should never be installed. See the install(EXPORT)
command to export targets from an installation tree.

The properties
set on the generated IMPORTED targets will have the same
values as the final values of the input TARGETS.

export(TARGETS [target1 [target2 [...]]] [NAMESPACE ]
       [APPEND] FILE  [EXPORT_LINK_INTERFACE_LIBRARIES])

This signature
is similar to the EXPORT signature, but targets are
listed explicitly rather than specified as an export-name.
If the APPEND option is given the generated code will be
appended to the file instead of overwriting it. The
EXPORT_LINK_INTERFACE_LIBRARIES keyword, if present, causes
the contents of the properties matching
(IMPORTED_)?LINK_INTERFACE_LIBRARIES(_)?
to be exported, when policy CMP0022 is NEW. If a library
target is included in the export but a target to which it
links is not included the behavior is unspecified.

NOTE:

Object Libraries under
Xcode have special handling if multiple architectures
are listed in CMAKE_OSX_ARCHITECTURES. In this case
they will be exported as Interface Libraries with no object
files available to clients. This is sufficient to satisfy
transitive usage requirements of other targets that link to
the object libraries in their implementation.

export(PACKAGE )

Store the
current build directory in the CMake user package registry
for package . The
find_package() command may consider the directory
while searching for package . This
helps dependent projects find and use a package from the
current project’s build tree without help from the
user. Note that the entry in the package registry that this
command creates works only in conjunction with a package
configuration file (Config.cmake)
that works with the build tree. In some cases, for example
for packaging and for system wide installations, it is not
desirable to write the user package registry.

By default the
export(PACKAGE) command does nothing (see policy
CMP0090) because populating the user package registry
has effects outside the source and build trees. Set the
CMAKE_EXPORT_PACKAGE_REGISTRY variable to add build
directories to the CMake user package registry.

export(TARGETS [target1 [target2 [...]]]  [ANDROID_MK ])

This signature
exports cmake built targets to the android ndk build system
by creating an Android.mk file that references the prebuilt
targets. The Android NDK supports the use of prebuilt
libraries, both static and shared. This allows cmake to
build the libraries of a project and make them available to
an ndk build system complete with transitive dependencies,
include flags and defines required to use the libraries. The
signature takes a list of targets and puts them in the
Android.mk file specified by the 
given. This signature can only be used if policy CMP0022 is
NEW for all targets given. A error will be issued if that
policy is set to OLD for one of the targets.

fltk_wrap_ui

Create FLTK user interfaces Wrappers.

fltk_wrap_ui(resultingLibraryName source1
             source2 ... sourceN )

Produce .h and
.cxx files for all the .fl and .fld files listed. The
resulting .h and .cxx files will be added to a variable
named resultingLibraryName_FLTK_UI_SRCS which should
be added to your library.

get_source_file_property

Get a property for a source file.

get_source_file_property( 
                         [DIRECTORY  | TARGET_DIRECTORY ]
                         )

Gets a property
from a source file. The value of the property is stored in
the specified . If the source
property is not found, the behavior depends on whether it
has been defined to be an INHERITED property or not
(see define_property()). Non-inherited properties
will set variable to NOTFOUND, whereas
inherited properties will search the relevant parent scope
as described for the define_property() command and if
still unable to find the property, variable will be
set to an empty string.

By default, the
source file’s property will be read from the current
source directory’s scope, but this can be overridden
with one of the following sub-options: 
DIRECTORY 

The source file property will
be read from the  directory’s scope.
CMake must already know about that source directory, either
by having added it through a call to
add_subdirectory() or  being the
top level source directory. Relative paths are treated as
relative to the current source directory.

TARGET_DIRECTORY

The source file property will
be read from the directory scope in which
 was created (
must therefore already exist).

Use
set_source_files_properties() to set property values.
Source file properties usually control how the file is
built. One property that is always there is
LOCATION.

See also the
more general get_property() command.

get_target_property

Get a property from a target.

get_target_property( target property)

Get a property
from a target. The value of the property is stored in the
variable . If the target property is not
found, the behavior depends on whether it has been defined
to be an INHERITED property or not (see
define_property()). Non-inherited properties will set
 to -NOTFOUND, whereas
inherited properties will search the relevant parent scope
as described for the define_property() command and if
still unable to find the property,  will
be set to an empty string.

Use
set_target_properties() to set target property
values. Properties are usually used to control how a target
is built, but some query the target instead. This command
can get properties for any target so far created. The
targets do not need to be in the current
CMakeLists.txt file.

See also the
more general get_property() command.

See Target
Properties for the list of properties known to CMake.

get_test_property

Get a property of the test.

get_test_property(test property VAR)

Get a property
from the test. The value of the property is stored in the
variable VAR. If the test property is not found, the
behavior depends on whether it has been defined to be an
INHERITED property or not (see
define_property()). Non-inherited properties will set
VAR to “NOTFOUND”, whereas inherited
properties will search the relevant parent scope as
described for the define_property() command and if
still unable to find the property, VAR will be set to
an empty string.

For a list of
standard properties you can type cmake
--help-property-list.

See also the
more general get_property() command.

include_directories

Add include directories to the build.

include_directories([AFTER|BEFORE] [SYSTEM] dir1 [dir2 ...])

Add the given
directories to those the compiler uses to search for include
files. Relative paths are interpreted as relative to the
current source directory.

The include
directories are added to the INCLUDE_DIRECTORIES
directory property for the current CMakeLists file.
They are also added to the INCLUDE_DIRECTORIES target
property for each target in the current CMakeLists
file. The target property values are the ones used by the
generators.

By default the
directories specified are appended onto the current list of
directories. This default behavior can be changed by setting
CMAKE_INCLUDE_DIRECTORIES_BEFORE to ON. By
using AFTER or BEFORE explicitly, you can
select between appending and prepending, independent of the
default.

If the
SYSTEM option is given, the compiler will be told the
directories are meant as system include directories on some
platforms. Signalling this setting might achieve effects
such as the compiler skipping warnings, or these
fixed-install system files not being considered in
dependency calculations - see compiler docs.

Arguments to
include_directories may use “generator
expressions” with the syntax
“$”. See the
cmake-generator-expressions(7) manual for available
expressions. See the cmake-buildsystem(7) manual for
more on defining buildsystem properties.

NOTE:

Prefer the
target_include_directories() command to add include
directories to individual targets and optionally
propagate/export them to dependents.

include_external_msproject

Include an external Microsoft project file in a
workspace.

include_external_msproject(projectname location
                           [TYPE projectTypeGUID]
                           [GUID projectGUID]
                           [PLATFORM platformName]
                           dep1 dep2 ...)

Includes an
external Microsoft project in the generated workspace file.
Currently does nothing on UNIX. This will create a target
named [projectname]. This can be used in the
add_dependencies() command to make things depend on
the external project.

TYPE,
GUID and PLATFORM are optional parameters that
allow one to specify the type of project, id (GUID)
of the project and the name of the target platform. This is
useful for projects requiring values other than the default
(e.g. WIX projects).

If the imported
project has different configuration names than the current
project, set the MAP_IMPORTED_CONFIG_
target property to specify the mapping.

include_regular_expression

Set the regular expression used for dependency checking.

include_regular_expression(regex_match [regex_complain])

Sets the
regular expressions used in dependency checking. Only files
matching regex_match will be traced as dependencies.
Only files matching regex_complain will generate
warnings if they cannot be found (standard header paths are
not searched). The defaults are:

regex_match    = "^.*$" (match everything)
regex_complain = "^$" (match empty string only)

install

Specify rules to run at install time.

Synopsis

install(TARGETS
... [...]) 
install({FILES | PROGRAMS}
... [...]) 
install(DIRECTORY ... [...]) 
install(SCRIPT  [...]) 
install(CODE  [...]) 
install(EXPORT 
[...])

Introduction

This command generates installation rules for a project.
Install rules specified by calls to the install()
command within a source directory are executed in order
during installation. Install rules in subdirectories added
by calls to the add_subdirectory() command are
interleaved with those in the parent directory to run in the
order declared (see policy CMP0082).

There are
multiple signatures for this command. Some of them define
installation options for files and targets. Options common
to multiple signatures are covered here but they are valid
only for signatures that specify them. The common options
are: 
DESTINATION

Specify the directory on disk
to which a file will be installed. Arguments can be relative
or absolute paths.

If a relative
path is given it is interpreted relative to the value of the
CMAKE_INSTALL_PREFIX variable. The prefix can be
relocated at install time using the DESTDIR mechanism
explained in the CMAKE_INSTALL_PREFIX variable
documentation.

If an absolute
path (with a leading slash or drive letter) is given it is
used verbatim.

As absolute
paths are not supported by cpack installer
generators, it is preferable to use relative paths
throughout.

PERMISSIONS

Specify permissions for
installed files. Valid permissions are OWNER_READ,
OWNER_WRITE, OWNER_EXECUTE, GROUP_READ,
GROUP_WRITE, GROUP_EXECUTE, WORLD_READ,
WORLD_WRITE, WORLD_EXECUTE, SETUID, and
SETGID. Permissions that do not make sense on certain
platforms are ignored on those platforms.

CONFIGURATIONS

Specify a list of build
configurations for which the install rule applies (Debug,
Release, etc.). Note that the values specified for this
option only apply to options listed AFTER the
CONFIGURATIONS option. For example, to set separate
install paths for the Debug and Release configurations, do
the following:

install(TARGETS target
        CONFIGURATIONS Debug
        RUNTIME DESTINATION Debug/bin)
install(TARGETS target
        CONFIGURATIONS Release
        RUNTIME DESTINATION Release/bin)

Note that
CONFIGURATIONS appears BEFORE RUNTIME
DESTINATION.

COMPONENT

Specify an installation
component name with which the install rule is associated,
such as “runtime” or “development”.
During component-specific installation only install rules
associated with the given component name will be executed.
During a full installation all components are installed
unless marked with EXCLUDE_FROM_ALL. If
COMPONENT is not provided a default component
“Unspecified” is created. The default component
name may be controlled with the
CMAKE_INSTALL_DEFAULT_COMPONENT_NAME variable.

EXCLUDE_FROM_ALL

Specify that the file is
excluded from a full installation and only installed as part
of a component-specific installation

RENAME

Specify a name for an installed file that may be
different from the original file. Renaming is allowed only
when a single file is installed by the command.

OPTIONAL

Specify that it is not an error
if the file to be installed does not exist.

Command
signatures that install files may print messages during
installation. Use the CMAKE_INSTALL_MESSAGE variable
to control which messages are printed.

Many of the
install() variants implicitly create the directories
containing the installed files. If
CMAKE_INSTALL_DEFAULT_DIRECTORY_PERMISSIONS is set,
these directories will be created with the permissions
specified. Otherwise, they will be created according to the
uname rules on Unix-like platforms. Windows platforms are
unaffected.

Installing
Targets

install(TARGETS targets... [EXPORT ]
        [[ARCHIVE|LIBRARY|RUNTIME|OBJECTS|FRAMEWORK|BUNDLE|
          PRIVATE_HEADER|PUBLIC_HEADER|RESOURCE]
         [DESTINATION ]
         [PERMISSIONS permissions...]
         [CONFIGURATIONS [Debug|Release|...]]
         [COMPONENT ]
         [NAMELINK_COMPONENT ]
         [OPTIONAL] [EXCLUDE_FROM_ALL]
         [NAMELINK_ONLY|NAMELINK_SKIP]
        ] [...]
        [INCLUDES DESTINATION [ ...]]
        )

The
TARGETS form specifies rules for installing targets
from a project. There are several kinds of target Output
Artifacts that may be installed: 
ARCHIVE

Target artifacts of this kind
include:

•

Static libraries (except on macOS when marked as
FRAMEWORK, see below);

•

DLL import libraries (on all Windows-based
systems including Cygwin; they have extension .lib,
in contrast to the .dll libraries that go to
RUNTIME); 

•

On AIX, the linker import file created for
executables with ENABLE_EXPORTS enabled.

LIBRARY

Target artifacts of this kind
include:

•

Shared libraries, except

•

DLLs (these go to
RUNTIME, see below),

•

on macOS when marked as FRAMEWORK (see
below). 

RUNTIME

Target artifacts of this kind
include:

•

Executables (except on macOS when marked as
MACOSX_BUNDLE, see BUNDLE below);

•

DLLs (on all Windows-based systems including Cygwin;
note that the accompanying import libraries are of kind
ARCHIVE). 

OBJECTS

Object files associated with
object libraries.

FRAMEWORK

Both static and shared
libraries marked with the FRAMEWORK property are
treated as FRAMEWORK targets on macOS.

BUNDLE

Executables marked with the MACOSX_BUNDLE
property are treated as BUNDLE targets on macOS.

PUBLIC_HEADER

Any PUBLIC_HEADER files
associated with a library are installed in the destination
specified by the PUBLIC_HEADER argument on non-Apple
platforms. Rules defined by this argument are ignored for
FRAMEWORK libraries on Apple platforms because the
associated files are installed into the appropriate
locations inside the framework folder. See
PUBLIC_HEADER for details.

PRIVATE_HEADER

Similar to
PUBLIC_HEADER, but for PRIVATE_HEADER files.
See PRIVATE_HEADER for details.

RESOURCE

Similar to PUBLIC_HEADER
and PRIVATE_HEADER, but for RESOURCE files.
See RESOURCE for details.

For each of
these arguments given, the arguments following them only
apply to the target or file type specified in the argument.
If none is given, the installation properties apply to all
target types. If only one is given then only targets of that
type will be installed (which can be used to install just a
DLL or just an import library.)

For regular
executables, static libraries and shared libraries, the
DESTINATION argument is not required. For these
target types, when DESTINATION is omitted, a default
destination will be taken from the appropriate variable from
GNUInstallDirs, or set to a built-in default value if
that variable is not defined. The same is true for the
public and private headers associated with the installed
targets through the PUBLIC_HEADER and
PRIVATE_HEADER target properties. A destination must
always be provided for module libraries, Apple bundles and
frameworks. A destination can be omitted for interface and
object libraries, but they are handled differently (see the
discussion of this topic toward the end of this
section).

The following
table shows the target types with their associated variables
and built-in defaults that apply when no destination is
given:

Projects
wishing to follow the common practice of installing headers
into a project-specific subdirectory will need to provide a
destination rather than rely on the above.

To make
packages compliant with distribution filesystem layout
policies, if projects must specify a DESTINATION, it
is recommended that they use a path that begins with the
appropriate GNUInstallDirs variable. This allows
package maintainers to control the install destination by
setting the appropriate cache variables. The following
example shows a static library being installed to the
default destination provided by GNUInstallDirs, but
with its headers installed to a project-specific
subdirectory that follows the above recommendation:

add_library(mylib STATIC ...)
set_target_properties(mylib PROPERTIES PUBLIC_HEADER mylib.h)
include(GNUInstallDirs)
install(TARGETS mylib
        PUBLIC_HEADER
          DESTINATION ${CMAKE_INSTALL_INCLUDEDIR}/myproj
)

In addition to
the common options listed above, each target can accept the
following additional arguments: 
NAMELINK_COMPONENT

On some platforms a versioned
shared library has a symbolic link such as:

lib.so -> lib.so.1

where
lib.so.1 is the soname of the library and
lib.so is a “namelink”
allowing linkers to find the library when given
-l. The NAMELINK_COMPONENT option
is similar to the COMPONENT option, but it changes
the installation component of a shared library namelink if
one is generated. If not specified, this defaults to the
value of COMPONENT. It is an error to use this
parameter outside of a LIBRARY block.

Consider the
following example:

install(TARGETS mylib
        LIBRARY
          COMPONENT Libraries
          NAMELINK_COMPONENT Development
        PUBLIC_HEADER
          COMPONENT Development
       )

In this
scenario, if you choose to install only the
Development component, both the headers and namelink
will be installed without the library. (If you don’t
also install the Libraries component, the namelink
will be a dangling symlink, and projects that link to the
library will have build errors.) If you install only the
Libraries component, only the library will be
installed, without the headers and namelink.

This option is
typically used for package managers that have separate
runtime and development packages. For example, on Debian
systems, the library is expected to be in the runtime
package, and the headers and namelink are expected to be in
the development package.

See the
VERSION and SOVERSION target properties for
details on creating versioned shared libraries.

NAMELINK_ONLY

This option causes the
installation of only the namelink when a library target is
installed. On platforms where versioned shared libraries do
not have namelinks or when a library is not versioned, the
NAMELINK_ONLY option installs nothing. It is an error
to use this parameter outside of a LIBRARY block.

When
NAMELINK_ONLY is given, either
NAMELINK_COMPONENT or COMPONENT may be used to
specify the installation component of the namelink, but
COMPONENT should generally be preferred.

NAMELINK_SKIP

Similar to
NAMELINK_ONLY, but it has the opposite effect: it
causes the installation of library files other than the
namelink when a library target is installed. When neither
NAMELINK_ONLY or NAMELINK_SKIP are given, both
portions are installed. On platforms where versioned shared
libraries do not have symlinks or when a library is not
versioned, NAMELINK_SKIP installs the library. It is
an error to use this parameter outside of a LIBRARY
block.

If
NAMELINK_SKIP is specified, NAMELINK_COMPONENT
has no effect. It is not recommended to use
NAMELINK_SKIP in conjunction with
NAMELINK_COMPONENT.

The
install(TARGETS) command can also accept the
following options at the top level:

EXPORT

This option associates the installed target files with
an export called . It must appear
before any target options. To actually install the export
file itself, call install(EXPORT), documented below.
See documentation of the EXPORT_NAME target property
to change the name of the exported target.

INCLUDES DESTINATION

This option specifies a list of
directories which will be added to the
INTERFACE_INCLUDE_DIRECTORIES target property of the
 when exported by the
install(EXPORT) command. If a relative path is
specified, it is treated as relative to the
$.

One or more
groups of properties may be specified in a single call to
the TARGETS form of this command. A target may be
installed more than once to different locations. Consider
hypothetical targets myExe, mySharedLib, and
myStaticLib. The code:

install(TARGETS myExe mySharedLib myStaticLib
        RUNTIME DESTINATION bin
        LIBRARY DESTINATION lib
        ARCHIVE DESTINATION lib/static)
install(TARGETS mySharedLib DESTINATION /some/full/path)

will install
myExe to /bin and
myStaticLib to /lib/static. On
non-DLL platforms mySharedLib will be installed to
/lib and /some/full/path. On DLL
platforms the mySharedLib DLL will be installed to
/bin and /some/full/path and its
import library will be installed to
/lib/static and
/some/full/path.

Interface
Libraries may be listed among the targets to install. They
install no artifacts but will be included in an associated
EXPORT. If Object Libraries are listed but given no
destination for their object files, they will be exported as
Interface Libraries. This is sufficient to satisfy
transitive usage requirements of other targets that link to
the object libraries in their implementation.

Installing a
target with the EXCLUDE_FROM_ALL target property set
to TRUE has undefined behavior.

install(TARGETS)
can install targets that were created in other directories.
When using such cross-directory install rules, running
make install (or similar) from a subdirectory will
not guarantee that targets from other directories are
up-to-date. You can use target_link_libraries() or
add_dependencies() to ensure that such
out-of-directory targets are built before the
subdirectory-specific install rules are run.

An install
destination given as a DESTINATION argument may use
“generator expressions” with the syntax
$. See the
cmake-generator-expressions(7) manual for available
expressions.

Installing
Files

install( files...
        TYPE  | DESTINATION 
        [PERMISSIONS permissions...]
        [CONFIGURATIONS [Debug|Release|...]]
        [COMPONENT ]
        [RENAME ] [OPTIONAL] [EXCLUDE_FROM_ALL])

The
FILES form specifies rules for installing files for a
project. File names given as relative paths are interpreted
with respect to the current source directory. Files
installed by this form are by default given permissions
OWNER_WRITE, OWNER_READ, GROUP_READ,
and WORLD_READ if no PERMISSIONS argument is
given.

The
PROGRAMS form is identical to the FILES form
except that the default permissions for the installed file
also include OWNER_EXECUTE, GROUP_EXECUTE, and
WORLD_EXECUTE. This form is intended to install
programs that are not targets, such as shell scripts. Use
the TARGETS form to install targets built within the
project.

The list of
files... given to FILES or PROGRAMS may
use “generator expressions” with the syntax
$. See the
cmake-generator-expressions(7) manual for available
expressions. However, if any item begins in a generator
expression it must evaluate to a full path.

Either a
TYPE or a DESTINATION must be provided, but
not both. A TYPE argument specifies the generic file
type of the files being installed. A destination will then
be set automatically by taking the corresponding variable
from GNUInstallDirs, or by using a built-in default
if that variable is not defined. See the table below for the
supported file types and their corresponding variables and
built-in defaults. Projects can provide a DESTINATION
argument instead of a file type if they wish to explicitly
define the install destination.

Projects
wishing to follow the common practice of installing headers
into a project-specific subdirectory will need to provide a
destination rather than rely on the above.

Note that some
of the types’ built-in defaults use the
DATAROOT directory as a prefix. The DATAROOT
prefix is calculated similarly to the types, with
CMAKE_INSTALL_DATAROOTDIR as the variable and
share as the built-in default. You cannot use
DATAROOT as a TYPE parameter; please use
DATA instead.

To make
packages compliant with distribution filesystem layout
policies, if projects must specify a DESTINATION, it
is recommended that they use a path that begins with the
appropriate GNUInstallDirs variable. This allows
package maintainers to control the install destination by
setting the appropriate cache variables. The following
example shows how to follow this advice while installing
headers to a project-specific subdirectory:

include(GNUInstallDirs)
install(FILES mylib.h
        DESTINATION ${CMAKE_INSTALL_INCLUDEDIR}/myproj
)

An install
destination given as a DESTINATION argument may use
“generator expressions” with the syntax
$. See the
cmake-generator-expressions(7) manual for available
expressions.

Installing
Directories

install(DIRECTORY dirs...
        TYPE  | DESTINATION 
        [FILE_PERMISSIONS permissions...]
        [DIRECTORY_PERMISSIONS permissions...]
        [USE_SOURCE_PERMISSIONS] [OPTIONAL] [MESSAGE_NEVER]
        [CONFIGURATIONS [Debug|Release|...]]
        [COMPONENT ] [EXCLUDE_FROM_ALL]
        [FILES_MATCHING]
        [[PATTERN  | REGEX ]
         [EXCLUDE] [PERMISSIONS permissions...]] [...])

The
DIRECTORY form installs contents of one or more
directories to a given destination. The directory structure
is copied verbatim to the destination. The last component of
each directory name is appended to the destination directory
but a trailing slash may be used to avoid this because it
leaves the last component empty. Directory names given as
relative paths are interpreted with respect to the current
source directory. If no input directory names are given the
destination directory will be created but nothing will be
installed into it. The FILE_PERMISSIONS and
DIRECTORY_PERMISSIONS options specify permissions
given to files and directories in the destination. If
USE_SOURCE_PERMISSIONS is specified and
FILE_PERMISSIONS is not, file permissions will be
copied from the source directory structure. If no
permissions are specified files will be given the default
permissions specified in the FILES form of the
command, and the directories will be given the default
permissions specified in the PROGRAMS form of the
command.

The
MESSAGE_NEVER option disables file installation
status output.

Installation of
directories may be controlled with fine granularity using
the PATTERN or REGEX options. These
“match” options specify a globbing pattern or
regular expression to match directories or files encountered
within input directories. They may be used to apply certain
options (see below) to a subset of the files and directories
encountered. The full path to each input file or directory
(with forward slashes) is matched against the expression. A
PATTERN will match only complete file names: the
portion of the full path matching the pattern must occur at
the end of the file name and be preceded by a slash. A
REGEX will match any portion of the full path but it
may use / and $ to simulate the PATTERN
behavior. By default all files and directories are installed
whether or not they are matched. The FILES_MATCHING
option may be given before the first match option to disable
installation of files (but not directories) not matched by
any expression. For example, the code

install(DIRECTORY src/ DESTINATION include/myproj
        FILES_MATCHING PATTERN "*.h")

will extract
and install header files from a source tree.

Some options
may follow a PATTERN or REGEX expression and
are applied only to files or directories matching them. The
EXCLUDE option will skip the matched file or
directory. The PERMISSIONS option overrides the
permissions setting for the matched file or directory. For
example the code

install(DIRECTORY icons scripts/ DESTINATION share/myproj
        PATTERN "CVS" EXCLUDE
        PATTERN "scripts/*"
        PERMISSIONS OWNER_EXECUTE OWNER_WRITE OWNER_READ
                    GROUP_EXECUTE GROUP_READ)

will install
the icons directory to share/myproj/icons and
the scripts directory to share/myproj. The
icons will get default file permissions, the scripts will be
given specific permissions, and any CVS directories
will be excluded.

Either a
TYPE or a DESTINATION must be provided, but
not both. A TYPE argument specifies the generic file
type of the files within the listed directories being
installed. A destination will then be set automatically by
taking the corresponding variable from
GNUInstallDirs, or by using a built-in default if
that variable is not defined. See the table below for the
supported file types and their corresponding variables and
built-in defaults. Projects can provide a DESTINATION
argument instead of a file type if they wish to explicitly
define the install destination.

Note that some
of the types’ built-in defaults use the
DATAROOT directory as a prefix. The DATAROOT
prefix is calculated similarly to the types, with
CMAKE_INSTALL_DATAROOTDIR as the variable and
share as the built-in default. You cannot use
DATAROOT as a TYPE parameter; please use
DATA instead.

To make
packages compliant with distribution filesystem layout
policies, if projects must specify a DESTINATION, it
is recommended that they use a path that begins with the
appropriate GNUInstallDirs variable. This allows
package maintainers to control the install destination by
setting the appropriate cache variables.

The list of
dirs... given to DIRECTORY and an install
destination given as a DESTINATION argument may use
“generator expressions” with the syntax
$. See the
cmake-generator-expressions(7) manual for available
expressions.

Custom
Installation Logic

install([[SCRIPT ] [CODE ]]
        [COMPONENT ] [EXCLUDE_FROM_ALL] [...])

The
SCRIPT form will invoke the given CMake script files
during installation. If the script file name is a relative
path it will be interpreted with respect to the current
source directory. The CODE form will invoke the given
CMake code during installation. Code is specified as a
single argument inside a double-quoted string. For example,
the code

install(CODE "MESSAGE(\"Sample install message.\")")

will print a
message during installation.

or  may use “generator
expressions” with the syntax $ (in
the case of , this refers to their use in
the file name, not the file’s contents). See the
cmake-generator-expressions(7) manual for available
expressions.

Installing
Exports

install(EXPORT  DESTINATION 
        [NAMESPACE ] [[FILE .cmake]|
        [PERMISSIONS permissions...]
        [CONFIGURATIONS [Debug|Release|...]]
        [EXPORT_LINK_INTERFACE_LIBRARIES]
        [COMPONENT ]
        [EXCLUDE_FROM_ALL])
install(EXPORT_ANDROID_MK  DESTINATION  [...])

The
EXPORT form generates and installs a CMake file
containing code to import targets from the installation tree
into another project. Target installations are associated
with the export  using the
EXPORT option of the install(TARGETS)
signature documented above. The NAMESPACE option will
prepend  to the target names as they
are written to the import file. By default the generated
file will be called .cmake but the
FILE option may be used to specify a different name.
The value given to the FILE option must be a file
name with the .cmake extension. If a
CONFIGURATIONS option is given then the file will
only be installed when one of the named configurations is
installed. Additionally, the generated import file will
reference only the matching target configurations. The
EXPORT_LINK_INTERFACE_LIBRARIES keyword, if present,
causes the contents of the properties matching
(IMPORTED_)?LINK_INTERFACE_LIBRARIES(_)?
to be exported, when policy CMP0022 is
NEW.

NOTE:

The installed
.cmake file may come with
additional per-configuration
-*.cmake files to be loaded by
globbing. Do not use an export name that is the same as the
package name in combination with installing a
-config.cmake file or the latter
may be incorrectly matched by the glob and loaded.

When a
COMPONENT option is given, the listed
 implicitly depends on all
components mentioned in the export set. The exported
.cmake file will require each of the
exported components to be present in order for dependent
projects to build properly. For example, a project may
define components Runtime and Development,
with shared libraries going into the Runtime
component and static libraries and headers going into the
Development component. The export set would also
typically be part of the Development component, but
it would export targets from both the Runtime and
Development components. Therefore, the Runtime
component would need to be installed if the
Development component was installed, but not vice
versa. If the Development component was installed
without the Runtime component, dependent projects
that try to link against it would have build errors. Package
managers, such as APT and RPM, typically handle this by
listing the Runtime component as a dependency of the
Development component in the package metadata,
ensuring that the library is always installed if the headers
and CMake export file are present.

In addition to
cmake language files, the EXPORT_ANDROID_MK mode
maybe used to specify an export to the android ndk build
system. This mode accepts the same options as the normal
export mode. The Android NDK supports the use of prebuilt
libraries, both static and shared. This allows cmake to
build the libraries of a project and make them available to
an ndk build system complete with transitive dependencies,
include flags and defines required to use the libraries.

The
EXPORT form is useful to help outside projects use
targets built and installed by the current project. For
example, the code

install(TARGETS myexe EXPORT myproj DESTINATION bin)
install(EXPORT myproj NAMESPACE mp_ DESTINATION lib/myproj)
install(EXPORT_ANDROID_MK myproj DESTINATION share/ndk-modules)

will install
the executable myexe to /bin and
code to import it in the file
/lib/myproj/myproj.cmake and
/share/ndk-modules/Android.mk. An
outside project may load this file with the include command
and reference the myexe executable from the
installation tree using the imported target name
mp_myexe as if the target were built in its own
tree.

NOTE:

This command supercedes the
install_targets() command and the
PRE_INSTALL_SCRIPT and POST_INSTALL_SCRIPT
target properties. It also replaces the FILES forms
of the install_files() and install_programs()
commands. The processing order of these install rules
relative to those generated by install_targets(),
install_files(), and install_programs()
commands is not defined.

Generated
Installation Script 
NOTE:

Use of this feature is not
recommended. Please consider using the --install
argument of cmake(1) instead.

The
install() command generates a file,
cmake_install.cmake, inside the build directory,
which is used internally by the generated install target and
by CPack. You can also invoke this script manually with
cmake -P. This script accepts several variables:

COMPONENT

Set this variable to install
only a single CPack component as opposed to all of them. For
example, if you only want to install the Development
component, run cmake -DCOMPONENT=Development -P
cmake_install.cmake.

BUILD_TYPE

Set this variable to change the
build type if you are using a multi-config generator. For
example, to install with the Debug configuration, run
cmake -DBUILD_TYPE=Debug -P cmake_install.cmake.

DESTDIR

This is an environment variable
rather than a CMake variable. It allows you to change the
installation prefix on UNIX systems. See DESTDIR for
details.

link_directories

Add directories in which the linker will look for
libraries.

link_directories([AFTER|BEFORE] directory1 [directory2 ...])

Adds the paths
in which the linker should search for libraries. Relative
paths given to this command are interpreted as relative to
the current source directory, see CMP0015.

The directories
are added to the LINK_DIRECTORIES directory property
for the current CMakeLists.txt file, converting
relative paths to absolute as needed. The command will apply
only to targets created after it is called.

By default the
directories specified are appended onto the current list of
directories. This default behavior can be changed by setting
CMAKE_LINK_DIRECTORIES_BEFORE to ON. By using
AFTER or BEFORE explicitly, you can select
between appending and prepending, independent of the
default.

Arguments to
link_directories may use “generator
expressions” with the syntax
“$”. See the
cmake-generator-expressions(7) manual for available
expressions. See the cmake-buildsystem(7) manual for
more on defining buildsystem properties.

NOTE:

This command is rarely
necessary and should be avoided where there are other
choices. Prefer to pass full absolute paths to libraries
where possible, since this ensures the correct library will
always be linked. The find_library() command provides
the full path, which can generally be used directly in calls
to target_link_libraries(). Situations where a
library search path may be needed include:

•

Project generators like Xcode where the user can switch
target architecture at build time, but a full path to a
library cannot be used because it only provides one
architecture (i.e. it is not a universal binary).

•

Libraries may themselves have other private library
dependencies that expect to be found via RPATH
mechanisms, but some linkers are not able to fully decode
those paths (e.g. due to the presence of things like
$ORIGIN). 

If a library
search path must be provided, prefer to localize the effect
where possible by using the target_link_directories()
command rather than link_directories(). The
target-specific command can also control how the search
directories propagate to other dependent targets.

link_libraries

Link libraries to all targets added later.

link_libraries([item1 [item2 [...]]]
               [[debug|optimized|general] ] ...)

Specify
libraries or flags to use when linking any targets created
later in the current directory or below by commands such as
add_executable() or add_library(). See the
target_link_libraries() command for meaning of
arguments.

NOTE:

The
target_link_libraries() command should be preferred
whenever possible. Library dependencies are chained
automatically, so directory-wide specification of link
libraries is rarely needed.

load_cache

Load in the values from another project’s CMake
cache.

load_cache(pathToBuildDirectory READ_WITH_PREFIX prefix entry1...)

Reads the cache
and store the requested entries in variables with their name
prefixed with the given prefix. This only reads the values,
and does not create entries in the local project’s
cache.

load_cache(pathToBuildDirectory [EXCLUDE entry1...]
           [INCLUDE_INTERNALS entry1...])

Loads in the
values from another cache and store them in the local
project’s cache as internal entries. This is useful
for a project that depends on another project built in a
different tree. EXCLUDE option can be used to provide
a list of entries to be excluded. INCLUDE_INTERNALS
can be used to provide a list of internal entries to be
included. Normally, no internal entries are brought in. Use
of this form of the command is strongly discouraged, but it
is provided for backward compatibility.

project

Set the name of the project.

Synopsis

project( [...])
project(
        [VERSION [.[.[.]]]]
        [DESCRIPTION ]
        [HOMEPAGE_URL ]
        [LANGUAGES ...])

Sets the name
of the project, and stores it in the variable
PROJECT_NAME. When called from the top-level
CMakeLists.txt also stores the project name in the
variable CMAKE_PROJECT_NAME.

Also sets the
variables

•

PROJECT_SOURCE_DIR,
_SOURCE_DIR 

•

PROJECT_BINARY_DIR,
_BINARY_DIR 

Further
variables are set by the optional arguments described in the
following. If any of these arguments is not used, then the
corresponding variables are set to the empty string.

Options

The options are: 
VERSION 

Optional; may not be used
unless policy CMP0048 is set to NEW.

Takes a
 argument composed of non-negative
integer components, i.e.
[.[.[.]]],
and sets the variables

•

PROJECT_VERSION,
_VERSION 

•

PROJECT_VERSION_MAJOR,
_VERSION_MAJOR 

•

PROJECT_VERSION_MINOR,
_VERSION_MINOR 

•

PROJECT_VERSION_PATCH,
_VERSION_PATCH 

•

PROJECT_VERSION_TWEAK,
_VERSION_TWEAK. 

When the
project() command is called from the top-level
CMakeLists.txt, then the version is also stored in
the variable CMAKE_PROJECT_VERSION.

DESCRIPTION

Optional. Sets the
variables

•

PROJECT_DESCRIPTION,
_DESCRIPTION 

to
. It is recommended
that this description is a relatively short string, usually
no more than a few words.

When the
project() command is called from the top-level
CMakeLists.txt, then the description is also stored
in the variable CMAKE_PROJECT_DESCRIPTION.

HOMEPAGE_URL

Optional. Sets the
variables

•

PROJECT_HOMEPAGE_URL,
_HOMEPAGE_URL 

to
, which should be the canonical
home URL for the project.

When the
project() command is called from the top-level
CMakeLists.txt, then the URL also is stored in the
variable CMAKE_PROJECT_HOMEPAGE_URL.

LANGUAGES
...

Optional. Can also be specified
without LANGUAGES keyword per the first, short
signature.

Selects which
programming languages are needed to build the project.
Supported languages include C, CXX (i.e. C++),
CUDA, OBJC (i.e. Objective-C), OBJCXX,
Fortran, and ASM. By default C and
CXX are enabled if no language options are given.
Specify language NONE, or use the LANGUAGES
keyword and list no languages, to skip enabling any
languages.

If enabling
ASM, list it last so that CMake can check whether
compilers for other languages like C work for
assembly too.

The variables
set through the VERSION, DESCRIPTION and
HOMEPAGE_URL options are intended for use as default
values in package metadata and documentation.

Code
Injection 
If the CMAKE_PROJECT_INCLUDE_BEFORE or
CMAKE_PROJECT__INCLUDE_BEFORE
variables are set, the files they point to will be included
as the first step of the project() command. If both
are set, then CMAKE_PROJECT_INCLUDE_BEFORE will be
included before
CMAKE_PROJECT__INCLUDE_BEFORE.

If the
CMAKE_PROJECT_INCLUDE or
CMAKE_PROJECT__INCLUDE variables
are set, the files they point to will be included as the
last step of the project() command. If both are set,
then CMAKE_PROJECT_INCLUDE will be included before
CMAKE_PROJECT__INCLUDE.

Usage

The top-level CMakeLists.txt file for a project must
contain a literal, direct call to the project()
command; loading one through the include() command is
not sufficient. If no such call exists, CMake will issue a
warning and pretend there is a project(Project) at
the top to enable the default languages (C and
CXX).

NOTE:

Call the project()
command near the top of the top-level CMakeLists.txt,
but after calling cmake_minimum_required(). It
is important to establish version and policy settings before
invoking other commands whose behavior they may affect. See
also policy CMP0000.

remove_definitions

Remove -D define flags added by
add_definitions().

remove_definitions(-DFOO -DBAR ...)

Removes flags
(added by add_definitions()) from the compiler
command line for sources in the current directory and
below.

set_source_files_properties

Source files can have properties that affect how they are
built.

set_source_files_properties( ...
                            [DIRECTORY  ...]
                            [TARGET_DIRECTORY  ...]
                            PROPERTIES  
                            [ ] ...)

Sets properties
associated with source files using a key/value paired
list.

By default,
source file properties are only visible to targets added in
the same directory (CMakeLists.txt). Visibility can
be set in other directory scopes using one or both of the
following options: 
DIRECTORY ...

The source file properties will
be set in each of the  directories’
scopes. CMake must already know about each of these source
directories, either by having added them through a call to
add_subdirectory() or it being the top level source
directory. Relative paths are treated as relative to the
current source directory.

TARGET_DIRECTORY
...

The source file properties will
be set in each of the directory scopes where any of the
specified  were created (the
 must therefore already exist).

Use
get_source_file_property() to get property values.
See also the set_property(SOURCE) command.

See Source File
Properties for the list of properties known to CMake.

set_target_properties

Targets can have properties that affect how they are
built.

set_target_properties(target1 target2 ...
                      PROPERTIES prop1 value1
                      prop2 value2 ...)

Sets properties
on targets. The syntax for the command is to list all the
targets you want to change, and then provide the values you
want to set next. You can use any prop value pair you want
and extract it later with the get_property() or
get_target_property() command.

See also the
set_property(TARGET) command.

See Target
Properties for the list of properties known to CMake.

set_tests_properties

Set a property of the tests.

set_tests_properties(test1 [test2...] PROPERTIES prop1 value1 prop2 value2)

Sets a property
for the tests. If the test is not found, CMake will report
an error. Generator expressions will be expanded the
same as supported by the test’s add_test()
call.

See also the
set_property(TEST) command.

See Test
Properties for the list of properties known to CMake.

source_group

Define a grouping for source files in IDE project
generation. There are two different signatures to create
source groups.

source_group( [FILES ...] [REGULAR_EXPRESSION ])
source_group(TREE  [PREFIX ] [FILES ...])

Defines a group
into which sources will be placed in project files. This is
intended to set up file tabs in Visual Studio. The options
are:

TREE

CMake will automatically detect, from 
files paths, source groups it needs to create, to keep
structure of source groups analogically to the actual files
and directories structure in the project. Paths of
 files will be cut to be relative to
. 

PREFIX

Source group and files located directly in
 path, will be placed in
 source groups.

FILES

Any source file specified explicitly will be placed in
group . Relative paths are interpreted
with respect to the current source directory.

REGULAR_EXPRESSION

Any source file whose name
matches the regular expression will be placed in group
.

If a source
file matches multiple groups, the last group that
explicitly lists the file with FILES will be favored,
if any. If no group explicitly lists the file, the
last group whose regular expression matches the file
will be favored.

The
 of the group and 
argument may contain forward slashes or backslashes to
specify subgroups. Backslashes need to be escaped
appropriately:

source_group(base/subdir ...)
source_group(outer\\inner ...)
source_group(TREE  PREFIX sources\\inc ...)

For backwards
compatibility, the short-hand signature

source_group( )

is equivalent
to

source_group( REGULAR_EXPRESSION )

target_compile_definitions

Add compile definitions to a target.

target_compile_definitions(
   [items1...]
  [ [items2...] ...])

Specifies
compile definitions to use when compiling a given
. The named  must
have been created by a command such as
add_executable() or add_library() and must not
be an ALIAS target.

The
INTERFACE, PUBLIC and PRIVATE keywords
are required to specify the scope of the following
arguments. PRIVATE and PUBLIC items will
populate the COMPILE_DEFINITIONS property of
. PUBLIC and INTERFACE
items will populate the INTERFACE_COMPILE_DEFINITIONS
property of . (IMPORTED targets only
support INTERFACE items.) The following arguments
specify compile definitions. Repeated calls for the same
 append items in the order called.

Arguments to
target_compile_definitions may use “generator
expressions” with the syntax $. See
the cmake-generator-expressions(7) manual for
available expressions. See the cmake-buildsystem(7)
manual for more on defining buildsystem properties.

Any leading
-D on an item will be removed. Empty items are
ignored. For example, the following are all equivalent:

target_compile_definitions(foo PUBLIC FOO)
target_compile_definitions(foo PUBLIC -DFOO)  # -D removed
target_compile_definitions(foo PUBLIC "" FOO) # "" ignored
target_compile_definitions(foo PUBLIC -D FOO) # -D becomes "", then ignored

target_compile_features

Add expected compiler features to a target.

target_compile_features(   [...])

Specifies
compiler features required when compiling a given target. If
the feature is not listed in the
CMAKE_C_COMPILE_FEATURES,
CMAKE_CUDA_COMPILE_FEATURES, or
CMAKE_CXX_COMPILE_FEATURES variables, then an error
will be reported by CMake. If the use of the feature
requires an additional compiler flag, such as
-std=gnu++11, the flag will be added
automatically.

The
INTERFACE, PUBLIC and PRIVATE keywords
are required to specify the scope of the features.
PRIVATE and PUBLIC items will populate the
COMPILE_FEATURES property of .
PUBLIC and INTERFACE items will populate the
INTERFACE_COMPILE_FEATURES property of
. (IMPORTED targets only support
INTERFACE items.) Repeated calls for the same
 append items.

The named
 must have been created by a command
such as add_executable() or add_library() and
must not be an ALIAS target.

Arguments to
target_compile_features may use “generator
expressions” with the syntax $. See
the cmake-generator-expressions(7) manual for
available expressions. See the
cmake-compile-features(7) manual for information on
compile features and a list of supported compilers.

target_compile_options

Add compile options to a target.

target_compile_options( [BEFORE]
   [items1...]
  [ [items2...] ...])

Adds options to
the COMPILE_OPTIONS or
INTERFACE_COMPILE_OPTIONS target properties. These
options are used when compiling the given
, which must have been created by a
command such as add_executable() or
add_library() and must not be an ALIAS target.

Arguments

If BEFORE is specified, the content will be prepended
to the property instead of being appended.

The
INTERFACE, PUBLIC and PRIVATE keywords
are required to specify the scope of the following
arguments. PRIVATE and PUBLIC items will
populate the COMPILE_OPTIONS property of
. PUBLIC and INTERFACE
items will populate the INTERFACE_COMPILE_OPTIONS
property of . (IMPORTED targets only
support INTERFACE items.) The following arguments
specify compile options. Repeated calls for the same
 append items in the order called.

Arguments to
target_compile_options may use “generator
expressions” with the syntax $. See
the cmake-generator-expressions(7) manual for
available expressions. See the cmake-buildsystem(7)
manual for more on defining buildsystem properties.

The final set
of compile or link options used for a target is constructed
by accumulating options from the current target and the
usage requirements of its dependencies. The set of options
is de-duplicated to avoid repetition. While beneficial for
individual options, the de-duplication step can break up
option groups. For example, -D A -D B becomes -D A
B. One may specify a group of options using shell-like
quoting along with a SHELL: prefix. The SHELL:
prefix is dropped, and the rest of the option string is
parsed using the separate_arguments() UNIX_COMMAND
mode. For example, "SHELL:-D A" "SHELL:-D
B" becomes -D A -D B.

See Also

This command can be used to add any options. However, for
adding preprocessor definitions and include directories it
is recommended to use the more specific commands
target_compile_definitions() and
target_include_directories().

For
directory-wide settings, there is the command
add_compile_options().

For
file-specific settings, there is the source file property
COMPILE_OPTIONS.

target_include_directories

Add include directories to a target.

target_include_directories( [SYSTEM] [BEFORE]
   [items1...]
  [ [items2...] ...])

Specifies
include directories to use when compiling a given target.
The named  must have been created by a
command such as add_executable() or
add_library() and must not be an ALIAS target.

If
BEFORE is specified, the content will be prepended to
the property instead of being appended.

The
INTERFACE, PUBLIC and PRIVATE keywords
are required to specify the scope of the following
arguments. PRIVATE and PUBLIC items will
populate the INCLUDE_DIRECTORIES property of
. PUBLIC and INTERFACE
items will populate the INTERFACE_INCLUDE_DIRECTORIES
property of . (IMPORTED targets only
support INTERFACE items.) The following arguments
specify include directories.

Specified
include directories may be absolute paths or relative paths.
Repeated calls for the same  append items in
the order called. If SYSTEM is specified, the
compiler will be told the directories are meant as system
include directories on some platforms (signalling this
setting might achieve effects such as the compiler skipping
warnings, or these fixed-install system files not being
considered in dependency calculations - see compiler docs).
If SYSTEM is used together with PUBLIC or
INTERFACE, the
INTERFACE_SYSTEM_INCLUDE_DIRECTORIES target property
will be populated with the specified directories.

Arguments to
target_include_directories may use “generator
expressions” with the syntax $. See
the cmake-generator-expressions(7) manual for
available expressions. See the cmake-buildsystem(7)
manual for more on defining buildsystem properties.

Include
directories usage requirements commonly differ between the
build-tree and the install-tree. The BUILD_INTERFACE
and INSTALL_INTERFACE generator expressions can be
used to describe separate usage requirements based on the
usage location. Relative paths are allowed within the
INSTALL_INTERFACE expression and are interpreted
relative to the installation prefix. For example:

target_include_directories(mylib PUBLIC
  $
  $  # /include/mylib
)

Creating
Relocatable Packages 
Note that it is not advisable to populate the
INSTALL_INTERFACE of the
INTERFACE_INCLUDE_DIRECTORIES of a target with
absolute paths to the include directories of dependencies.
That would hard-code into installed packages the include
directory paths for dependencies as found on the machine
the package was made on.

The
INSTALL_INTERFACE of the
INTERFACE_INCLUDE_DIRECTORIES is only suitable for
specifying the required include directories for headers
provided with the target itself, not those provided by the
transitive dependencies listed in its
INTERFACE_LINK_LIBRARIES target property. Those
dependencies should themselves be targets that specify their
own header locations in
INTERFACE_INCLUDE_DIRECTORIES.

See the
Creating Relocatable Packages section of the
cmake-packages(7) manual for discussion of additional
care that must be taken when specifying usage requirements
while creating packages for redistribution.

target_link_directories

Add link directories to a target.

target_link_directories( [BEFORE]
   [items1...]
  [ [items2...] ...])

Specifies the
paths in which the linker should search for libraries when
linking a given target. Each item can be an absolute or
relative path, with the latter being interpreted as relative
to the current source directory. These items will be added
to the link command.

The named
 must have been created by a command
such as add_executable() or add_library() and
must not be an ALIAS target.

The
INTERFACE, PUBLIC and PRIVATE keywords
are required to specify the scope of the items that follow
them. PRIVATE and PUBLIC items will populate
the LINK_DIRECTORIES property of
. PUBLIC and INTERFACE
items will populate the INTERFACE_LINK_DIRECTORIES
property of  (IMPORTED targets only
support INTERFACE items). Each item specifies a link
directory and will be converted to an absolute path if
necessary before adding it to the relevant property.
Repeated calls for the same  append
items in the order called.

If
BEFORE is specified, the content will be prepended to
the relevant property instead of being appended.

Arguments to
target_link_directories may use “generator
expressions” with the syntax $. See
the cmake-generator-expressions(7) manual for
available expressions. See the cmake-buildsystem(7)
manual for more on defining buildsystem properties.

NOTE:

This command is rarely
necessary and should be avoided where there are other
choices. Prefer to pass full absolute paths to libraries
where possible, since this ensures the correct library will
always be linked. The find_library() command provides
the full path, which can generally be used directly in calls
to target_link_libraries(). Situations where a
library search path may be needed include:

•

Project generators like Xcode where the user can switch
target architecture at build time, but a full path to a
library cannot be used because it only provides one
architecture (i.e. it is not a universal binary).

•

Libraries may themselves have other private library
dependencies that expect to be found via RPATH
mechanisms, but some linkers are not able to fully decode
those paths (e.g. due to the presence of things like
$ORIGIN). 

target_link_libraries

Specify libraries or flags to use when linking a given
target and/or its dependents. Usage requirements from linked
library targets will be propagated. Usage requirements of a
target’s dependencies affect compilation of its own
sources.

Overview

This command has several signatures as detailed in
subsections below. All of them have the general form

target_link_libraries( ... ... ...)

The named
 must have been created by a command
such as add_executable() or add_library() and
must not be an ALIAS target. If policy CMP0079 is not
set to NEW then the target must have been created in
the current directory. Repeated calls for the same
 append items in the order called.

Each
 may be:

•

A library target name:
The generated link line will have the full path to the
linkable library file associated with the target. The
buildsystem will have a dependency to re-link
 if the library file changes.

The named
target must be created by add_library() within the
project or as an IMPORTED library. If it is created within
the project an ordering dependency will automatically be
added in the build system to make sure the named library
target is up-to-date before the 
links.

If an imported
library has the IMPORTED_NO_SONAME target property
set, CMake may ask the linker to search for the library
instead of using the full path (e.g.
/usr/lib/libfoo.so becomes -lfoo).

The full path
to the target’s artifact will be quoted/escaped for
the shell automatically.

•

A full path to a library
file: The generated link line will normally preserve the
full path to the file. The buildsystem will have a
dependency to re-link  if the library
file changes.

There are some
cases where CMake may ask the linker to search for the
library (e.g. /usr/lib/libfoo.so becomes
-lfoo), such as when a shared library is detected to
have no SONAME field. See policy CMP0060 for
discussion of another case.

If the library
file is in a macOS framework, the Headers directory
of the framework will also be processed as a usage
requirement. This has the same effect as passing the
framework directory as an include directory.

On Visual
Studio Generators for VS 2010 and above, library files
ending in .targets will be treated as MSBuild targets
files and imported into generated project files. This is not
supported by other generators.

The full path
to the library file will be quoted/escaped for the shell
automatically.

•

A plain library name: The
generated link line will ask the linker to search for the
library (e.g. foo becomes -lfoo or
foo.lib). 

The library
name/flag is treated as a command-line string fragment and
will be used with no extra quoting or escaping.

•

A link flag: Item names
starting with -, but not -l or
-framework, are treated as linker flags. Note that
such flags will be treated like any other library link item
for purposes of transitive dependencies, so they are
generally safe to specify only as private link items that
will not propagate to dependents.

Link flags
specified here are inserted into the link command in the
same place as the link libraries. This might not be correct,
depending on the linker. Use the LINK_OPTIONS target
property or target_link_options() command to add link
flags explicitly. The flags will then be placed at the
toolchain-defined flag position in the link command.

The link flag
is treated as a command-line string fragment and will be
used with no extra quoting or escaping.

•

A generator expression: A
$ generator expression may evaluate to any
of the above items or to a semicolon-separated list of them.
If the ... contains any ; characters, e.g.
after evaluation of a ${list} variable, be sure to
use an explicitly quoted argument
"$" so that this command
receives it as a single .

Additionally, a
generator expression may be used as a fragment of any of the
above items, e.g. foo$.

Note that
generator expressions will not be used in OLD handling of
policy CMP0003 or policy CMP0004.

•

A debug,
optimized, or general keyword immediately
followed by another . The item following
such a keyword will be used only for the corresponding build
configuration. The debug keyword corresponds to the
Debug configuration (or to configurations named in
the DEBUG_CONFIGURATIONS global property if it is
set). The optimized keyword corresponds to all other
configurations. The general keyword corresponds to
all configurations, and is purely optional. Higher
granularity may be achieved for per-configuration rules by
creating and linking to IMPORTED library targets. These
keywords are interpreted immediately by this command and
therefore have no special meaning when produced by a
generator expression.

Items
containing ::, such as Foo::Bar, are assumed
to be IMPORTED or ALIAS library target names and will cause
an error if no such target exists. See policy
CMP0028.

See the
cmake-buildsystem(7) manual for more on defining
buildsystem properties.

Libraries
for a Target and/or its Dependents

target_link_libraries(
                       ...
                     [ ...]...)

The
PUBLIC, PRIVATE and INTERFACE keywords
can be used to specify both the link dependencies and the
link interface in one command. Libraries and targets
following PUBLIC are linked to, and are made part of
the link interface. Libraries and targets following
PRIVATE are linked to, but are not made part of the
link interface. Libraries following INTERFACE are
appended to the link interface and are not used for linking
.

Libraries
for both a Target and its Dependents

target_link_libraries( ...)

Library
dependencies are transitive by default with this signature.
When this target is linked into another target then the
libraries linked to this target will appear on the link line
for the other target too. This transitive “link
interface” is stored in the
INTERFACE_LINK_LIBRARIES target property and may be
overridden by setting the property directly. When
CMP0022 is not set to NEW, transitive linking
is built in but may be overridden by the
LINK_INTERFACE_LIBRARIES property. Calls to other
signatures of this command may set the property making any
libraries linked exclusively by this signature private.

Libraries
for a Target and/or its Dependents (Legacy)

target_link_libraries(
                       ...
                     [ ...]...)

The
LINK_PUBLIC and LINK_PRIVATE modes can be used
to specify both the link dependencies and the link interface
in one command.

This signature
is for compatibility only. Prefer the PUBLIC or
PRIVATE keywords instead.

Libraries and
targets following LINK_PUBLIC are linked to, and are
made part of the INTERFACE_LINK_LIBRARIES. If policy
CMP0022 is not NEW, they are also made part of
the LINK_INTERFACE_LIBRARIES. Libraries and targets
following LINK_PRIVATE are linked to, but are not
made part of the INTERFACE_LINK_LIBRARIES (or
LINK_INTERFACE_LIBRARIES).

Libraries
for Dependents Only (Legacy)

target_link_libraries( LINK_INTERFACE_LIBRARIES ...)

The
LINK_INTERFACE_LIBRARIES mode appends the libraries
to the INTERFACE_LINK_LIBRARIES target property
instead of using them for linking. If policy CMP0022
is not NEW, then this mode also appends libraries to
the LINK_INTERFACE_LIBRARIES and its
per-configuration equivalent.

This signature
is for compatibility only. Prefer the INTERFACE mode
instead.

Libraries
specified as debug are wrapped in a generator
expression to correspond to debug builds. If policy
CMP0022 is not NEW, the libraries are also
appended to the LINK_INTERFACE_LIBRARIES_DEBUG
property (or to the properties corresponding to
configurations listed in the DEBUG_CONFIGURATIONS
global property if it is set). Libraries specified as
optimized are appended to the
INTERFACE_LINK_LIBRARIES property. If policy
CMP0022 is not NEW, they are also appended to
the LINK_INTERFACE_LIBRARIES property. Libraries
specified as general (or without any keyword) are
treated as if specified for both debug and
optimized.

Linking
Object Libraries 
Object Libraries may be used as the 
(first) argument of target_link_libraries to specify
dependencies of their sources on other libraries. For
example, the code
add_library(A SHARED a.c)
target_compile_definitions(A PUBLIC A)

add_library(obj OBJECT obj.c)
target_compile_definitions(obj PUBLIC OBJ)
target_link_libraries(obj PUBLIC A)

compiles
obj.c with -DA -DOBJ and establishes usage
requirements for obj that propagate to its
dependents.

Normal
libraries and executables may link to Object Libraries to
get their objects and usage requirements. Continuing the
above example, the code

add_library(B SHARED b.c)
target_link_libraries(B PUBLIC obj)

compiles
b.c with -DA -DOBJ, creates shared library
B with object files from b.c and obj.c,
and links B to A. Furthermore, the code

add_executable(main main.c)
target_link_libraries(main B)

compiles
main.c with -DA -DOBJ and links executable
main to B and A. The object
library’s usage requirements are propagated
transitively through B, but its object files are
not.

Object
Libraries may “link” to other object libraries
to get usage requirements, but since they do not have a link
step nothing is done with their object files. Continuing
from the above example, the code:
add_library(obj2 OBJECT obj2.c)
target_link_libraries(obj2 PUBLIC obj)

add_executable(main2 main2.c)
target_link_libraries(main2 obj2)

compiles
obj2.c with -DA -DOBJ, creates executable
main2 with object files from main2.c and
obj2.c, and links main2 to A.

In other words,
when Object Libraries appear in a target’s
INTERFACE_LINK_LIBRARIES property they will be
treated as Interface Libraries, but when they appear in a
target’s LINK_LIBRARIES property their object
files will be included in the link too.

Cyclic
Dependencies of Static Libraries 
The library dependency graph is normally acyclic (a DAG),
but in the case of mutually-dependent STATIC
libraries CMake allows the graph to contain cycles (strongly
connected components). When another target links to one of
the libraries, CMake repeats the entire connected component.
For example, the code

add_library(A STATIC a.c)
add_library(B STATIC b.c)
target_link_libraries(A B)
target_link_libraries(B A)
add_executable(main main.c)
target_link_libraries(main A)

links
main to A B A B. While one repetition is
usually sufficient, pathological object file and symbol
arrangements can require more. One may handle such cases by
using the LINK_INTERFACE_MULTIPLICITY target property
or by manually repeating the component in the last
target_link_libraries call. However, if two archives
are really so interdependent they should probably be
combined into a single archive, perhaps by using Object
Libraries.

Creating
Relocatable Packages 
Note that it is not advisable to populate the
INTERFACE_LINK_LIBRARIES of a target with absolute
paths to dependencies. That would hard-code into installed
packages the library file paths for dependencies as found
on the machine the package was made on.

See the
Creating Relocatable Packages section of the
cmake-packages(7) manual for discussion of additional
care that must be taken when specifying usage requirements
while creating packages for redistribution.

target_link_options

Add options to the link step for an executable, shared
library or module library target.

target_link_options( [BEFORE]
   [items1...]
  [ [items2...] ...])

The named
 must have been created by a command
such as add_executable() or add_library() and
must not be an ALIAS target.

This command
can be used to add any link options, but alternative
commands exist to add libraries
(target_link_libraries() or link_libraries()).
See documentation of the directory and target
LINK_OPTIONS properties.

NOTE:

This command cannot be used to
add options for static library targets, since they do not
use a linker. To add archiver or MSVC librarian flags, see
the STATIC_LIBRARY_OPTIONS target property.

If
BEFORE is specified, the content will be prepended to
the property instead of being appended.

The
INTERFACE, PUBLIC and PRIVATE keywords
are required to specify the scope of the following
arguments. PRIVATE and PUBLIC items will
populate the LINK_OPTIONS property of
. PUBLIC and INTERFACE
items will populate the INTERFACE_LINK_OPTIONS
property of . (IMPORTED targets only
support INTERFACE items.) The following arguments
specify link options. Repeated calls for the same
 append items in the order called.

Arguments to
target_link_options may use “generator
expressions” with the syntax $. See
the cmake-generator-expressions(7) manual for
available expressions. See the cmake-buildsystem(7)
manual for more on defining buildsystem properties.

When a device
link step is involved, which is controlled by
CUDA_SEPARABLE_COMPILATION and
CUDA_RESOLVE_DEVICE_SYMBOLS properties and policy
CMP0105, the raw options will be delivered to the
host and device link steps (wrapped in -Xcompiler or
equivalent for device link). Options wrapped with
$ generator expression will be
used only for the device link step. Options wrapped with
$ generator expression will be
used only for the host link step.

The final set
of compile or link options used for a target is constructed
by accumulating options from the current target and the
usage requirements of its dependencies. The set of options
is de-duplicated to avoid repetition. While beneficial for
individual options, the de-duplication step can break up
option groups. For example, -D A -D B becomes -D A
B. One may specify a group of options using shell-like
quoting along with a SHELL: prefix. The SHELL:
prefix is dropped, and the rest of the option string is
parsed using the separate_arguments() UNIX_COMMAND
mode. For example, "SHELL:-D A" "SHELL:-D
B" becomes -D A -D B.

To pass options
to the linker tool, each compiler driver has its own syntax.
The LINKER: prefix and , separator can be used
to specify, in a portable way, options to pass to the linker
tool. LINKER: is replaced by the appropriate driver
option and , by the appropriate driver separator. The
driver prefix and driver separator are given by the values
of the CMAKE__LINKER_WRAPPER_FLAG and
CMAKE__LINKER_WRAPPER_FLAG_SEP
variables.

For example,
"LINKER:-z,defs" becomes -Xlinker -z
-Xlinker defs for Clang and -Wl,-z,defs
for GNU GCC.

The
LINKER: prefix can be specified as part of a
SHELL: prefix expression.

The
LINKER: prefix supports, as an alternative syntax,
specification of arguments using the SHELL: prefix
and space as separator. The previous example then becomes
"LINKER:SHELL:-z defs".

NOTE:

Specifying the SHELL:
prefix anywhere other than at the beginning of the
LINKER: prefix is not supported.

target_precompile_headers

Add a list of header files to precompile.

Precompiling
header files can speed up compilation by creating a
partially processed version of some header files, and then
using that version during compilations rather than
repeatedly parsing the original headers.

Main
Form

target_precompile_headers(
   [header1...]
  [ [header2...] ...])

The command
adds header files to the PRECOMPILE_HEADERS and/or
INTERFACE_PRECOMPILE_HEADERS target properties of
. The named  must
have been created by a command such as
add_executable() or add_library() and must not
be an ALIAS target.

The
INTERFACE, PUBLIC and PRIVATE keywords
are required to specify the scope of the following
arguments. PRIVATE and PUBLIC items will
populate the PRECOMPILE_HEADERS property of
. PUBLIC and INTERFACE
items will populate the INTERFACE_PRECOMPILE_HEADERS
property of  (IMPORTED targets only
support INTERFACE items). Repeated calls for the same
 will append items in the order
called.

Projects should
generally avoid using PUBLIC or INTERFACE for
targets that will be exported, or they should at least use
the $ generator expression
to prevent precompile headers from appearing in an installed
exported target. Consumers of a target should typically be
in control of what precompile headers they use, not have
precompile headers forced on them by the targets being
consumed (since precompile headers are not typically usage
requirements). A notable exception to this is where an
interface library is created to define a commonly used set
of precompile headers in one place and then other targets
link to that interface library privately. In this case, the
interface library exists specifically to propagate the
precompile headers to its consumers and the consumer is
effectively still in control, since it decides whether to
link to the interface library or not.

The list of
header files is used to generate a header file named
cmake_pch.h|xx which is used to generate the
precompiled header file (.pch, .gch,
.pchi) artifact. The cmake_pch.h|xx header
file will be force included (-include for GCC,
/FI for MSVC) to all source files, so sources do not
need to have #include "pch.h".

Header file
names specified with angle brackets (e.g.
) or explicit double quotes
(escaped for the cmake-language(7), e.g.
[["other_header.h"]]) will be treated as
is, and include directories must be available for the
compiler to find them. Other header file names (e.g.
project_header.h) are interpreted as being relative
to the current source directory (e.g.
CMAKE_CURRENT_SOURCE_DIR) and will be included by
absolute path. For example:

target_precompile_headers(myTarget
  PUBLIC
    project_header.h
  PRIVATE
    [["other_header.h"]]

)

Arguments to
target_precompile_headers() may use “generator
expressions” with the syntax $. See
the cmake-generator-expressions(7) manual for
available expressions. The
$ generator expression is
particularly useful for specifying a language-specific
header to precompile for only one language (e.g. CXX
and not C). In this case, header file names that are
not explicitly in double quotes or angle brackets must be
specified by absolute path. Also, when specifying angle
brackets inside a generator expression, be sure to encode
the closing > as $. For
example:

target_precompile_headers(mylib PRIVATE
  "$:${CMAKE_CURRENT_SOURCE_DIR}/cxx_only.h>"
  "$:>"
  "$:>"
)

Reusing
Precompile Headers 
The command also supports a second signature which can be
used to specify that one target re-uses a precompiled header
file artifact from another target instead of generating its
own:

target_precompile_headers( REUSE_FROM )

This form sets
the PRECOMPILE_HEADERS_REUSE_FROM property to
 and adds a dependency such that
 will depend on
. CMake will halt with an error
if the PRECOMPILE_HEADERS property of
 is already set when the
REUSE_FROM form is used.

NOTE:

The REUSE_FROM form
requires the same set of compiler options, compiler flags
and compiler definitions for both  and
. Some compilers (e.g. GCC) may
issue a warning if the precompiled header file cannot be
used (-Winvalid-pch).

See Also

To disable precompile headers for specific targets, see the
DISABLE_PRECOMPILE_HEADERS target property.

To prevent
precompile headers from being used when compiling a specific
source file, see the SKIP_PRECOMPILE_HEADERS source
file property.

target_sources

Add sources to a target.

target_sources(
   [items1...]
  [ [items2...] ...])

Specifies
sources to use when compiling a given target. Relative
source file paths are interpreted as being relative to the
current source directory (i.e.
CMAKE_CURRENT_SOURCE_DIR). The named
 must have been created by a command
such as add_executable() or add_library() and
must not be an ALIAS target.

The
INTERFACE, PUBLIC and PRIVATE keywords
are required to specify the scope of the following
arguments. PRIVATE and PUBLIC items will
populate the SOURCES property of
. PUBLIC and INTERFACE
items will populate the INTERFACE_SOURCES property of
. (IMPORTED targets only support
INTERFACE items.) The following arguments specify
sources. Repeated calls for the same 
append items in the order called.

Arguments to
target_sources may use “generator
expressions” with the syntax $. See
the cmake-generator-expressions(7) manual for
available expressions. See the cmake-buildsystem(7)
manual for more on defining buildsystem properties.

See also the
CMP0076 policy for older behavior related to the
handling of relative source file paths.

try_compile

Try building some code.

Try
Compiling Whole Projects

try_compile(  
             [] [CMAKE_FLAGS ...]
            [OUTPUT_VARIABLE ])

Try building a
project. The success or failure of the try_compile,
i.e. TRUE or FALSE respectively, is returned
in .

In this form,
 should contain a complete CMake
project with a CMakeLists.txt file and all sources.
The  and  will not
be deleted after this command is run. Specify
 to build a specific target instead
of the all or ALL_BUILD target. See below for
the meaning of other options.

Try
Compiling Source Files

try_compile(  
            [CMAKE_FLAGS ...]
            [COMPILE_DEFINITIONS ...]
            [LINK_OPTIONS ...]
            [LINK_LIBRARIES ...]
            [OUTPUT_VARIABLE ]
            [COPY_FILE  [COPY_FILE_ERROR ]]
            [_STANDARD ]
            [_STANDARD_REQUIRED ]
            [_EXTENSIONS ]
            )

Try building an
executable or static library from one or more source files
(which one is determined by the
CMAKE_TRY_COMPILE_TARGET_TYPE variable). The success
or failure of the try_compile, i.e. TRUE or
FALSE respectively, is returned in
.

In this form,
one or more source files must be provided. If
CMAKE_TRY_COMPILE_TARGET_TYPE is unset or is set to
EXECUTABLE, the sources must include a definition for
main and CMake will create a CMakeLists.txt
file to build the source(s) as an executable. If
CMAKE_TRY_COMPILE_TARGET_TYPE is set to
STATIC_LIBRARY, a static library will be built
instead and no definition for main is required. For
an executable, the generated CMakeLists.txt file
would contain something like the following:

add_definitions()
include_directories(${INCLUDE_DIRECTORIES})
link_directories(${LINK_DIRECTORIES})
add_executable(cmTryCompileExec ...)
target_link_options(cmTryCompileExec PRIVATE )
target_link_libraries(cmTryCompileExec ${LINK_LIBRARIES})

The options
are: 
CMAKE_FLAGS ...

Specify flags of the form
-DVAR:TYPE=VALUE to be passed to the cmake
command-line used to drive the test build. The above example
shows how values for variables INCLUDE_DIRECTORIES,
LINK_DIRECTORIES, and LINK_LIBRARIES are
used.

COMPILE_DEFINITIONS
...

Specify -Ddefinition
arguments to pass to add_definitions() in the
generated test project.

COPY_FILE

Copy the built executable or
static library to the given .

COPY_FILE_ERROR

Use after COPY_FILE to
capture into variable  any error message
encountered while trying to copy the file.

LINK_LIBRARIES
...

Specify libraries to be linked
in the generated project. The list of libraries may refer to
system libraries and to Imported Targets from the calling
project.

If this option
is specified, any -DLINK_LIBRARIES=... value given to
the CMAKE_FLAGS option will be ignored.

LINK_OPTIONS
...

Specify link step options to
pass to target_link_options() or to set the
STATIC_LIBRARY_OPTIONS target property in the
generated project, depending on the
CMAKE_TRY_COMPILE_TARGET_TYPE variable.

OUTPUT_VARIABLE

Store the output from the build
process in the given variable.

_STANDARD

Specify the C_STANDARD,
CXX_STANDARD, OBJC_STANDARD,
OBJCXX_STANDARD, or CUDA_STANDARD target
property of the generated project.

_STANDARD_REQUIRED

Specify the
C_STANDARD_REQUIRED, CXX_STANDARD_REQUIRED,
OBJC_STANDARD_REQUIRED,
OBJCXX_STANDARD_REQUIRED,or
CUDA_STANDARD_REQUIRED target property of the
generated project.

_EXTENSIONS

Specify the
C_EXTENSIONS, CXX_EXTENSIONS,
OBJC_EXTENSIONS, OBJCXX_EXTENSIONS, or
CUDA_EXTENSIONS target property of the generated
project.

In this version
all files in /CMakeFiles/CMakeTmp will
be cleaned automatically. For debugging,
--debug-trycompile can be passed to cmake to
avoid this clean. However, multiple sequential
try_compile operations reuse this single output
directory. If you use --debug-trycompile, you can
only debug one try_compile call at a time. The
recommended procedure is to protect all try_compile
calls in your project by if(NOT DEFINED
) logic, configure with cmake all the
way through once, then delete the cache entry associated
with the try_compile call of interest, and then re-run cmake
again with --debug-trycompile.

Other
Behavior Settings 
If set, the following variables are passed in to the
generated try_compile CMakeLists.txt to initialize compile
target properties with default values:

•

CMAKE_CUDA_RUNTIME_LIBRARY

•

CMAKE_ENABLE_EXPORTS

•

CMAKE_LINK_SEARCH_START_STATIC

•

CMAKE_LINK_SEARCH_END_STATIC

•

CMAKE_MSVC_RUNTIME_LIBRARY

•

CMAKE_POSITION_INDEPENDENT_CODE

If
CMP0056 is set to NEW, then
CMAKE_EXE_LINKER_FLAGS is passed in as well.

If
CMP0083 is set to NEW, then in order to obtain
correct behavior at link time, the
check_pie_supported() command from the
CheckPIESupported module must be called before using
the try_compile() command.

The current
settings of CMP0065 and CMP0083 are propagated
through to the generated test project.

Set the
CMAKE_TRY_COMPILE_CONFIGURATION variable to choose a
build configuration.

Set the
CMAKE_TRY_COMPILE_TARGET_TYPE variable to specify the
type of target used for the source file signature.

Set the
CMAKE_TRY_COMPILE_PLATFORM_VARIABLES variable to
specify variables that must be propagated into the test
project. This variable is meant for use only in toolchain
files and is only honored by the try_compile()
command for the source files form, not when given a whole
project.

If
CMP0067 is set to NEW, or any of the
_STANDARD,
_STANDARD_REQUIRED, or
_EXTENSIONS options are used, then the
language standard variables are honored:

•

CMAKE_C_STANDARD

•

CMAKE_C_STANDARD_REQUIRED

•

CMAKE_C_EXTENSIONS

•

CMAKE_CXX_STANDARD

•

CMAKE_CXX_STANDARD_REQUIRED

•

CMAKE_CXX_EXTENSIONS

•

CMAKE_OBJC_STANDARD

•

CMAKE_OBJC_STANDARD_REQUIRED

•

CMAKE_OBJC_EXTENSIONS

•

CMAKE_OBJCXX_STANDARD

•

CMAKE_OBJCXX_STANDARD_REQUIRED

•

CMAKE_OBJCXX_EXTENSIONS

•

CMAKE_CUDA_STANDARD

•

CMAKE_CUDA_STANDARD_REQUIRED

•

CMAKE_CUDA_EXTENSIONS

Their values
are used to set the corresponding target properties in the
generated project (unless overridden by an explicit
option).

For the
Green Hills MULTI generator the GHS toolset and
target system customization cache variables are also
propagated into the test project.

try_run

Try compiling and then running some code.

Try
Compiling and Running Source Files

try_run( 
          [CMAKE_FLAGS ...]
        [COMPILE_DEFINITIONS ...]
        [LINK_OPTIONS ...]
        [LINK_LIBRARIES ...]
        [COMPILE_OUTPUT_VARIABLE ]
        [RUN_OUTPUT_VARIABLE ]
        [OUTPUT_VARIABLE ]
        [ARGS ...])

Try compiling a
. Returns TRUE or FALSE
for success or failure in .
If the compile succeeded, runs the executable and returns
its exit code in . If the
executable was built, but failed to run, then
 will be set to
FAILED_TO_RUN. See the try_compile() command
for information on how the test project is constructed to
build the source file.

The options
are: 
CMAKE_FLAGS ...

Specify flags of the form
-DVAR:TYPE=VALUE to be passed to the cmake
command-line used to drive the test build. The example in
try_compile() shows how values for variables
INCLUDE_DIRECTORIES, LINK_DIRECTORIES, and
LINK_LIBRARIES are used.

COMPILE_DEFINITIONS
...

Specify -Ddefinition
arguments to pass to add_definitions() in the
generated test project.

COMPILE_OUTPUT_VARIABLE

Report the compile step build
output in a given variable.

LINK_LIBRARIES
...

Specify libraries to be linked
in the generated project. The list of libraries may refer to
system libraries and to Imported Targets from the calling
project.

If this option
is specified, any -DLINK_LIBRARIES=... value given to
the CMAKE_FLAGS option will be ignored.

LINK_OPTIONS
...

Specify link step options to
pass to target_link_options() in the generated
project.

OUTPUT_VARIABLE

Report the compile build output
and the output from running the executable in the given
variable. This option exists for legacy reasons. Prefer
COMPILE_OUTPUT_VARIABLE and
RUN_OUTPUT_VARIABLE instead.

RUN_OUTPUT_VARIABLE

Report the output from running
the executable in a given variable.

Other
Behavior Settings 
Set the CMAKE_TRY_COMPILE_CONFIGURATION variable to
choose a build configuration.

Behavior
when Cross Compiling 
When cross compiling, the executable compiled in the first
step usually cannot be run on the build host. The
try_run command checks the
CMAKE_CROSSCOMPILING variable to detect whether CMake
is in cross-compiling mode. If that is the case, it will
still try to compile the executable, but it will not try to
run the executable unless the
CMAKE_CROSSCOMPILING_EMULATOR variable is set.
Instead it will create cache variables which must be filled
by the user or by presetting them in some CMake script file
to the values the executable would have produced if it had
been run on its actual target platform. These cache entries
are: 

Exit code if the executable
were to be run on the target platform.

__TRYRUN_OUTPUT

Output from stdout and stderr
if the executable were to be run on the target platform.
This is created only if the RUN_OUTPUT_VARIABLE or
OUTPUT_VARIABLE option was used.

In order to
make cross compiling your project easier, use try_run
only if really required. If you use try_run, use the
RUN_OUTPUT_VARIABLE or OUTPUT_VARIABLE options
only if really required. Using them will require that when
cross-compiling, the cache variables will have to be set
manually to the output of the executable. You can also
“guard” the calls to try_run with an
if() block checking the CMAKE_CROSSCOMPILING
variable and provide an easy-to-preset alternative for this
case.

CTEST COMMANDS

These commands
are available only in CTest scripts.

ctest_build

Perform the CTest Build Step as a Dashboard Client.

ctest_build([BUILD ] [APPEND]
            [CONFIGURATION ]
            [FLAGS ]
            [PROJECT_NAME ]
            [TARGET ]
            [NUMBER_ERRORS ]
            [NUMBER_WARNINGS ]
            [RETURN_VALUE ]
            [CAPTURE_CMAKE_ERROR ]
            )

Build the
project and store results in Build.xml for submission
with the ctest_submit() command.

The
CTEST_BUILD_COMMAND variable may be set to explicitly
specify the build command line. Otherwise the build command
line is computed automatically based on the options
given.

The options
are: 
BUILD 

Specify the top-level build
directory. If not given, the CTEST_BINARY_DIRECTORY
variable is used.

APPEND

Mark Build.xml for append to results previously
submitted to a dashboard server since the last
ctest_start() call. Append semantics are defined by
the dashboard server in use. This does not cause
results to be appended to a .xml file produced by a
previous call to this command.

CONFIGURATION

Specify the build configuration
(e.g. Debug). If not specified the
CTEST_BUILD_CONFIGURATION variable will be checked.
Otherwise the -C  option given to the
ctest(1) command will be used, if any.

FLAGS 

Pass additional arguments to
the underlying build command. If not specified the
CTEST_BUILD_FLAGS variable will be checked. This can,
e.g., be used to trigger a parallel build using the
-j option of make. See the ProcessorCount
module for an example.

PROJECT_NAME

Ignored. This was once used but
is no longer needed.

TARGET

Specify the name of a target to
build. If not specified the CTEST_BUILD_TARGET
variable will be checked. Otherwise the default target will
be built. This is the “all” target (called
ALL_BUILD in Visual Studio Generators).

NUMBER_ERRORS

Store the number of build
errors detected in the given variable.

NUMBER_WARNINGS

Store the number of build
warnings detected in the given variable.

RETURN_VALUE

Store the return value of the
native build tool in the given variable.

CAPTURE_CMAKE_ERROR

Store in the
 variable -1 if there are any
errors running the command and prevent ctest from returning
non-zero if an error occurs.

QUIET

Suppress any CTest-specific non-error output that would
have been printed to the console otherwise. The summary of
warnings / errors, as well as the output from the native
build tool is unaffected by this option.

ctest_configure

Perform the CTest Configure Step as a Dashboard Client.

ctest_configure([BUILD ] [SOURCE ] [APPEND]
                [OPTIONS ] [RETURN_VALUE ] [QUIET]
                [CAPTURE_CMAKE_ERROR ])

Configure the
project build tree and record results in
Configure.xml for submission with the
ctest_submit() command.

The options
are: 
BUILD 

Specify the top-level build
directory. If not given, the CTEST_BINARY_DIRECTORY
variable is used.

SOURCE

Specify the source directory.
If not given, the CTEST_SOURCE_DIRECTORY variable is
used.

APPEND

Mark Configure.xml for append to results
previously submitted to a dashboard server since the last
ctest_start() call. Append semantics are defined by
the dashboard server in use. This does not cause
results to be appended to a .xml file produced by a
previous call to this command.

OPTIONS

Specify command-line arguments
to pass to the configuration tool.

RETURN_VALUE

Store in the
 variable the return value of the
native configuration tool.

CAPTURE_CMAKE_ERROR

Store in the
 variable -1 if there are any
errors running the command and prevent ctest from returning
non-zero if an error occurs.

QUIET

Suppress any CTest-specific non-error messages that
would have otherwise been printed to the console. Output
from the underlying configure command is not affected.

ctest_coverage

Perform the CTest Coverage Step as a Dashboard Client.

ctest_coverage([BUILD ] [APPEND]
               [LABELS ...]
               [RETURN_VALUE ]
               [CAPTURE_CMAKE_ERROR ]
               [QUIET]
               )

Collect
coverage tool results and stores them in Coverage.xml
for submission with the ctest_submit() command.

The options
are: 
BUILD 

Specify the top-level build
directory. If not given, the CTEST_BINARY_DIRECTORY
variable is used.

APPEND

Mark Coverage.xml for append to results
previously submitted to a dashboard server since the last
ctest_start() call. Append semantics are defined by
the dashboard server in use. This does not cause
results to be appended to a .xml file produced by a
previous call to this command.

LABELS

Filter the coverage report to include only source files
labeled with at least one of the labels specified.

RETURN_VALUE

Store in the
 variable 0 if coverage
tools ran without error and non-zero otherwise.

CAPTURE_CMAKE_ERROR

Store in the
 variable -1 if there are any
errors running the command and prevent ctest from returning
non-zero if an error occurs.

QUIET

Suppress any CTest-specific non-error output that would
have been printed to the console otherwise. The summary
indicating how many lines of code were covered is unaffected
by this option.

ctest_empty_binary_directory

empties the binary directory

ctest_empty_binary_directory( directory )

Removes a
binary directory. This command will perform some checks
prior to deleting the directory in an attempt to avoid
malicious or accidental directory deletion.

ctest_memcheck

Perform the CTest MemCheck Step as a Dashboard Client.

ctest_memcheck([BUILD ] [APPEND]
               [START ]
               [END ]
               [STRIDE ]
               [EXCLUDE ]
               [INCLUDE ]
               [EXCLUDE_LABEL ]
               [INCLUDE_LABEL ]
               [EXCLUDE_FIXTURE ]
               [EXCLUDE_FIXTURE_SETUP ]
               [EXCLUDE_FIXTURE_CLEANUP ]
               [PARALLEL_LEVEL ]
               [TEST_LOAD ]
               [SCHEDULE_RANDOM ]
               [STOP_TIME ]
               [RETURN_VALUE ]
               [DEFECT_COUNT ]
               [QUIET]
               )

Run tests with
a dynamic analysis tool and store results in
MemCheck.xml for submission with the
ctest_submit() command.

Most options
are the same as those for the ctest_test()
command.

The options
unique to this command are: 
DEFECT_COUNT 

Store in the
 the number of defects
found.

ctest_read_custom_files

read CTestCustom files.

ctest_read_custom_files( directory ... )

Read all the
CTestCustom.ctest or CTestCustom.cmake files from the given
directory.

By default,
invoking ctest(1) without a script will read custom
files from the binary directory.

ctest_run_script

runs a ctest -S script

ctest_run_script([NEW_PROCESS] script_file_name script_file_name1
            script_file_name2 ... [RETURN_VALUE var])

Runs a script
or scripts much like if it was run from ctest -S. If no
argument is provided then the current script is run using
the current settings of the variables. If NEW_PROCESS
is specified then each script will be run in a separate
process.If RETURN_VALUE is specified the return value
of the last script run will be put into var.

ctest_sleep

sleeps for some amount of time

ctest_sleep()

Sleep for given
number of seconds.

ctest_sleep(  )

Sleep for
t=(time1 + duration - time2) seconds if t > 0.

ctest_start

Starts the testing for a given model
ctest_start( [ []] [GROUP ] [QUIET])

ctest_start([ [ []]] [GROUP ] APPEND [QUIET])

Starts the
testing for a given model. The command should be called
after the binary directory is initialized.

The parameters
are as follows: 

Set the dashboard model. Must
be one of Experimental, Continuous, or
Nightly. This parameter is required unless
APPEND is specified.

Set the source directory. If
not specified, the value of CTEST_SOURCE_DIRECTORY is
used instead.

Set the binary directory. If
not specified, the value of CTEST_BINARY_DIRECTORY is
used instead.

GROUP 

If GROUP is used, the
submissions will go to the specified group on the CDash
server. If no GROUP is specified, the name of the
model is used by default. This replaces the deprecated
option TRACK. Despite the name change its behavior is
unchanged.

APPEND

If APPEND is used, the existing TAG is
used rather than creating a new one based on the current
time stamp. If you use APPEND, you can omit the
 and GROUP 
parameters, because they will be read from the generated
TAG file. For example:

ctest_start(Experimental GROUP GroupExperimental)

Later, in
another ctest -S script:

ctest_start(APPEND)

When the second
script runs ctest_start(APPEND), it will read the
Experimental model and GroupExperimental group
from the TAG file generated by the first
ctest_start() command. Please note that if you call
ctest_start(APPEND) and specify a different model or
group than in the first ctest_start() command, a
warning will be issued, and the new model and group will be
used.

QUIET

If QUIET is used, CTest
will suppress any non-error messages that it otherwise would
have printed to the console.

The parameters
for ctest_start() can be issued in any order, with
the exception that ,
, and  have to
appear in that order with respect to each other. The
following are all valid and equivalent:
ctest_start(Experimental path/to/source path/to/binary GROUP SomeGroup QUIET APPEND)

ctest_start(GROUP SomeGroup Experimental QUIET path/to/source APPEND path/to/binary)

ctest_start(APPEND QUIET Experimental path/to/source GROUP SomeGroup path/to/binary)

However, for
the sake of readability, it is recommended that you order
your parameters in the order listed at the top of this
page.

If the
CTEST_CHECKOUT_COMMAND variable (or the
CTEST_CVS_CHECKOUT variable) is set, its content is
treated as command-line. The command is invoked with the
current working directory set to the parent of the source
directory, even if the source directory already exists. This
can be used to create the source tree from a version control
repository.

ctest_submit

Perform the CTest Submit Step as a Dashboard Client.

ctest_submit([PARTS ...] [FILES ...]
             [SUBMIT_URL ]
             [BUILD_ID ]
             [HTTPHEADER ]
             [RETRY_COUNT ]
             [RETRY_DELAY ]
             [RETURN_VALUE ]
             [CAPTURE_CMAKE_ERROR ]
             [QUIET]
             )

Submit results
to a dashboard server. By default all available parts are
submitted.

The options
are: 
PARTS ...

Specify a subset of parts to
submit. Valid part names are:

Start      = nothing
Update     = ctest_update results, in Update.xml
Configure  = ctest_configure results, in Configure.xml
Build      = ctest_build results, in Build.xml
Test       = ctest_test results, in Test.xml
Coverage   = ctest_coverage results, in Coverage.xml
MemCheck   = ctest_memcheck results, in DynamicAnalysis.xml
Notes      = Files listed by CTEST_NOTES_FILES, in Notes.xml
ExtraFiles = Files listed by CTEST_EXTRA_SUBMIT_FILES
Upload     = Files prepared for upload by ctest_upload(), in Upload.xml
Submit     = nothing
Done       = Build is complete, in Done.xml

FILES
...

Specify an explicit list of
specific files to be submitted. Each individual file must
exist at the time of the call.

SUBMIT_URL

The http or https
URL of the dashboard server to send the submission to. If
not given, the CTEST_SUBMIT_URL variable is used.

BUILD_ID

Store in the
 variable the ID assigned to this
build by CDash.

HTTPHEADER

Specify HTTP header to be
included in the request to CDash during submission. For
example, CDash can be configured to only accept submissions
from authenticated clients. In this case, you should provide
a bearer token in your header:

ctest_submit(HTTPHEADER "Authorization: Bearer ")

This suboption
can be repeated several times for multiple headers.

RETRY_COUNT

Specify how many times to retry
a timed-out submission.

RETRY_DELAY

Specify how long (in seconds)
to wait after a timed-out submission before attempting to
re-submit.

RETURN_VALUE

Store in the
 variable 0 for success and
non-zero on failure.

CAPTURE_CMAKE_ERROR

Store in the
 variable -1 if there are any
errors running the command and prevent ctest from returning
non-zero if an error occurs.

QUIET

Suppress all non-error messages that would have
otherwise been printed to the console.

Submit to
CDash Upload API

ctest_submit(CDASH_UPLOAD  [CDASH_UPLOAD_TYPE ]
             [SUBMIT_URL ]
             [HTTPHEADER ]
             [RETRY_COUNT ]
             [RETRY_DELAY ]
             [RETURN_VALUE ]
             [QUIET])

This second
signature is used to upload files to CDash via the CDash
file upload API. The API first sends a request to upload to
CDash along with a content hash of the file. If CDash does
not already have the file, then it is uploaded. Along with
the file, a CDash type string is specified to tell CDash
which handler to use to process the data.

This signature
accepts the SUBMIT_URL, BUILD_ID,
HTTPHEADER, RETRY_COUNT, RETRY_DELAY,
RETURN_VALUE and QUIET options as described
above.

ctest_test

Perform the CTest Test Step as a Dashboard Client.

ctest_test([BUILD ] [APPEND]
           [START ]
           [END ]
           [STRIDE ]
           [EXCLUDE ]
           [INCLUDE ]
           [EXCLUDE_LABEL ]
           [INCLUDE_LABEL ]
           [EXCLUDE_FIXTURE ]
           [EXCLUDE_FIXTURE_SETUP ]
           [EXCLUDE_FIXTURE_CLEANUP ]
           [PARALLEL_LEVEL ]
           [RESOURCE_SPEC_FILE ]
           [TEST_LOAD ]
           [SCHEDULE_RANDOM ]
           [STOP_ON_FAILURE]
           [STOP_TIME ]
           [RETURN_VALUE ]
           [CAPTURE_CMAKE_ERROR ]
           [REPEAT :]
           [QUIET]
           )

Run tests in
the project build tree and store results in Test.xml
for submission with the ctest_submit() command.

The options
are: 
BUILD 

Specify the top-level build
directory. If not given, the CTEST_BINARY_DIRECTORY
variable is used.

APPEND

Mark Test.xml for append to results previously
submitted to a dashboard server since the last
ctest_start() call. Append semantics are defined by
the dashboard server in use. This does not cause
results to be appended to a .xml file produced by a
previous call to this command.

START

Specify the beginning of a
range of test numbers.

END

Specify the end of a range of
test numbers.

STRIDE

Specify the stride by which to
step across a range of test numbers.

EXCLUDE

Specify a regular expression
matching test names to exclude.

INCLUDE

Specify a regular expression
matching test names to include. Tests not matching this
expression are excluded.

EXCLUDE_LABEL

Specify a regular expression
matching test labels to exclude.

INCLUDE_LABEL

Specify a regular expression
matching test labels to include. Tests not matching this
expression are excluded.

EXCLUDE_FIXTURE

If a test in the set of tests
to be executed requires a particular fixture, that
fixture’s setup and cleanup tests would normally be
added to the test set automatically. This option prevents
adding setup or cleanup tests for fixtures matching the
. Note that all other fixture behavior
is retained, including test dependencies and skipping tests
that have fixture setup tests that fail.

EXCLUDE_FIXTURE_SETUP

Same as EXCLUDE_FIXTURE
except only matching setup tests are excluded.

EXCLUDE_FIXTURE_CLEANUP

Same as EXCLUDE_FIXTURE
except only matching cleanup tests are excluded.

PARALLEL_LEVEL

Specify a positive number
representing the number of tests to be run in parallel.

RESOURCE_SPEC_FILE

Specify a resource
specification file. See ctest-resource-allocation for more
information.

TEST_LOAD

While running tests in
parallel, try not to start tests when they may cause the CPU
load to pass above a given threshold. If not specified the
CTEST_TEST_LOAD variable will be checked, and then
the --test-load command-line argument to
ctest(1). See also the TestLoad setting in the
CTest Test Step.

REPEAT
:

Run tests repeatedly based on
the given  up to  times.
The modes are: 
UNTIL_FAIL

Require each test to run
 times without failing in order to pass.
This is useful in finding sporadic failures in test
cases.

UNTIL_PASS

Allow each test to run up to
 times in order to pass. Repeats tests if
they fail for any reason. This is useful in tolerating
sporadic failures in test cases.

AFTER_TIMEOUT

Allow each test to run up to
 times in order to pass. Repeats tests only
if they timeout. This is useful in tolerating sporadic
timeouts in test cases on busy machines.

SCHEDULE_RANDOM

Launch tests in a random order.
This may be useful for detecting implicit test
dependencies.

STOP_ON_FAILURE

Stop the execution of the tests
once one has failed.

STOP_TIME

Specify a time of day at which
the tests should all stop running.

RETURN_VALUE

Store in the
 variable 0 if all tests
passed. Store non-zero if anything went wrong.

CAPTURE_CMAKE_ERROR

Store in the
 variable -1 if there are any
errors running the command and prevent ctest from returning
non-zero if an error occurs.

QUIET

Suppress any CTest-specific non-error messages that
would have otherwise been printed to the console. Output
from the underlying test command is not affected. Summary
info detailing the percentage of passing tests is also
unaffected by the QUIET option.

See also the
CTEST_CUSTOM_MAXIMUM_PASSED_TEST_OUTPUT_SIZE and
CTEST_CUSTOM_MAXIMUM_FAILED_TEST_OUTPUT_SIZE
variables.

ctest_update

Perform the CTest Update Step as a Dashboard Client.

ctest_update([SOURCE ]
             [RETURN_VALUE ]
             [CAPTURE_CMAKE_ERROR ]
             [QUIET])

Update the
source tree from version control and record results in
Update.xml for submission with the
ctest_submit() command.

The options
are: 
SOURCE 

Specify the source directory.
If not given, the CTEST_SOURCE_DIRECTORY variable is
used.

RETURN_VALUE

Store in the
 variable the number of files
updated or -1 on error.

CAPTURE_CMAKE_ERROR

Store in the
 variable -1 if there are any
errors running the command and prevent ctest from returning
non-zero if an error occurs.

QUIET

Tell CTest to suppress most non-error messages that it
would have otherwise printed to the console. CTest will
still report the new revision of the repository and any
conflicting files that were found.

The update
always follows the version control branch currently checked
out in the source directory. See the CTest Update Step
documentation for information about variables that change
the behavior of ctest_update().

ctest_upload

Upload files to a dashboard server as a Dashboard
Client.

ctest_upload(FILES ... [QUIET] [CAPTURE_CMAKE_ERROR ])

The options
are: 
FILES ...

Specify a list of files to be
sent along with the build results to the dashboard
server.

QUIET

Suppress any CTest-specific non-error output that would
have been printed to the console otherwise.

CAPTURE_CMAKE_ERROR

Store in the
 variable -1 if there are any
errors running the command and prevent ctest from returning
non-zero if an error occurs.

DEPRECATED COMMANDS

These commands
are deprecated and are only made available to maintain
backward compatibility. The documentation of each command
states the CMake version in which it was deprecated. Do not
use these commands in new code.

build_name

Disallowed since version 3.0. See CMake Policy
CMP0036.

Use
${CMAKE_SYSTEM} and ${CMAKE_CXX_COMPILER}
instead.

build_name(variable)

Sets the
specified variable to a string representing the platform and
compiler settings. These values are now available through
the CMAKE_SYSTEM and CMAKE_CXX_COMPILER
variables.

exec_program

Deprecated since version 3.0: Use the
execute_process() command instead.

Run an
executable program during the processing of the
CMakeList.txt file.

exec_program(Executable [directory in which to run]
             [ARGS ]
             [OUTPUT_VARIABLE ]
             [RETURN_VALUE ])

The executable
is run in the optionally specified directory. The executable
can include arguments if it is double quoted, but it is
better to use the optional ARGS argument to specify
arguments to the program. This is because cmake will then be
able to escape spaces in the executable path. An optional
argument OUTPUT_VARIABLE specifies a variable in
which to store the output. To capture the return value of
the execution, provide a RETURN_VALUE. If
OUTPUT_VARIABLE is specified, then no output will go
to the stdout/stderr of the console running cmake.

export_library_dependencies

Disallowed since version 3.0. See CMake Policy
CMP0033.

Use
install(EXPORT) or export() command.

This command
generates an old-style library dependencies file. Projects
requiring CMake 2.6 or later should not use the command. Use
instead the install(EXPORT) command to help export
targets from an installation tree and the export()
command to export targets from a build tree.

The old-style
library dependencies file does not take into account
per-configuration names of libraries or the
LINK_INTERFACE_LIBRARIES target property.

export_library_dependencies( [APPEND])

Create a file
named  that can be included into a CMake
listfile with the INCLUDE command. The file will contain a
number of SET commands that will set all the variables
needed for library dependency information. This should be
the last command in the top level CMakeLists.txt file of the
project. If the APPEND option is specified, the SET
commands will be appended to the given file instead of
replacing it.

install_files

Deprecated since version 3.0: Use the install(FILES)
command instead.

This command
has been superceded by the install() command. It is
provided for compatibility with older CMake code. The
FILES form is directly replaced by the FILES
form of the install() command. The regexp form can be
expressed more clearly using the GLOB form of the
file() command.

install_files( extension file file ...)

Create rules to
install the listed files with the given extension into the
given directory. Only files existing in the current source
tree or its corresponding location in the binary tree may be
listed. If a file specified already has an extension, that
extension will be removed first. This is useful for
providing lists of source files such as foo.cxx when you
want the corresponding foo.h to be installed. A typical
extension is .h.

install_files( regexp)

Any files in
the current source directory that match the regular
expression will be installed.

install_files( FILES file file ...)

Any files
listed after the FILES keyword will be installed
explicitly from the names given. Full paths are allowed in
this form.

The directory
 is relative to the installation prefix,
which is stored in the variable
CMAKE_INSTALL_PREFIX.

install_programs

Deprecated since version 3.0: Use the
install(PROGRAMS) command instead.

This command
has been superceded by the install() command. It is
provided for compatibility with older CMake code. The
FILES form is directly replaced by the
PROGRAMS form of the install() command. The
regexp form can be expressed more clearly using the
GLOB form of the file() command.

install_programs( file1 file2 [file3 ...])
install_programs( FILES file1 [file2 ...])

Create rules to
install the listed programs into the given directory. Use
the FILES argument to guarantee that the file list
version of the command will be used even when there is only
one argument.

install_programs( regexp)

In the second
form any program in the current source directory that
matches the regular expression will be installed.

This command is
intended to install programs that are not built by cmake,
such as shell scripts. See the TARGETS form of the
install() command to create installation rules for
targets built by cmake.

The directory
 is relative to the installation prefix,
which is stored in the variable
CMAKE_INSTALL_PREFIX.

install_targets

Deprecated since version 3.0: Use the
install(TARGETS) command instead.

This command
has been superceded by the install() command. It is
provided for compatibility with older CMake code.

install_targets( [RUNTIME_DIRECTORY dir] target target)

Create rules to
install the listed targets into the given directory. The
directory  is relative to the installation
prefix, which is stored in the variable
CMAKE_INSTALL_PREFIX. If RUNTIME_DIRECTORY is
specified, then on systems with special runtime files
(Windows DLL), the files will be copied to that
directory.

load_command

Disallowed since version 3.0. See CMake Policy
CMP0031.

Load a command
into a running CMake.

load_command(COMMAND_NAME  [loc2 ...])

The given
locations are searched for a library whose name is
cmCOMMAND_NAME. If found, it is loaded as a module and the
command is added to the set of available CMake commands.
Usually, try_compile() is used before this command to
compile the module. If the command is successfully loaded a
variable named

CMAKE_LOADED_COMMAND_

will be set to
the full path of the module that was loaded. Otherwise the
variable will not be set.

make_directory

Deprecated since version 3.0: Use the
file(MAKE_DIRECTORY) command instead.

make_directory(directory)

Creates the
specified directory. Full paths should be given. Any parent
directories that do not exist will also be created. Use with
care.

output_required_files

Disallowed since version 3.0. See CMake Policy
CMP0032.

Approximate C
preprocessor dependency scanning.

This command
exists only because ancient CMake versions provided it.
CMake handles preprocessor dependency scanning automatically
using a more advanced scanner.

output_required_files(srcfile outputfile)

Outputs a list
of all the source files that are required by the specified
srcfile. This list is written into outputfile.
This is similar to writing out the dependencies for
srcfile except that it jumps from .h files
into .cxx, .c and .cpp files if
possible.

qt_wrap_cpp

Deprecated since version 3.14: This command was originally
added to support Qt 3 before the add_custom_command()
command was sufficiently mature. The FindQt4 module
provides the qt4_wrap_cpp() macro, which should be
used instead for Qt 4 projects. For projects using Qt 5 or
later, use the equivalent macro provided by Qt itself (e.g.
Qt 5 provides qt5_wrap_cpp()).

Manually create
Qt Wrappers.

qt_wrap_cpp(resultingLibraryName DestName SourceLists ...)

Produces moc
files for all the .h files listed in the SourceLists. The
moc files will be added to the library using the
DestName source list.

Consider
updating the project to use the AUTOMOC target
property instead for a more automated way of invoking the
moc tool.

qt_wrap_ui

Deprecated since version 3.14: This command was originally
added to support Qt 3 before the add_custom_command()
command was sufficiently mature. The FindQt4 module
provides the qt4_wrap_ui() macro, which should be
used instead for Qt 4 projects. For projects using Qt 5 or
later, use the equivalent macro provided by Qt itself (e.g.
Qt 5 provides qt5_wrap_ui()).

Manually create
Qt user interfaces Wrappers.

qt_wrap_ui(resultingLibraryName HeadersDestName
           SourcesDestName SourceLists ...)

Produces .h and
.cxx files for all the .ui files listed in the
SourceLists. The .h files will be added to the
library using the HeadersDestNamesource list. The
.cxx files will be added to the library using the
SourcesDestNamesource list.

Consider
updating the project to use the AUTOUIC target
property instead for a more automated way of invoking the
uic tool.

remove

Deprecated since version 3.0: Use the
list(REMOVE_ITEM) command instead.

remove(VAR VALUE VALUE ...)

Removes
VALUE from the variable VAR. This is typically
used to remove entries from a vector (e.g. semicolon
separated list). VALUE is expanded.

subdir_depends

Disallowed since version 3.0. See CMake Policy
CMP0029.

Does
nothing.

subdir_depends(subdir dep1 dep2 ...)

Does not do
anything. This command used to help projects order parallel
builds correctly. This functionality is now automatic.

subdirs

Deprecated since version 3.0: Use the
add_subdirectory() command instead.

Add a list of
subdirectories to the build.

subdirs(dir1 dir2 ...[EXCLUDE_FROM_ALL exclude_dir1 exclude_dir2 ...]
        [PREORDER] )

Add a list of
subdirectories to the build. The add_subdirectory()
command should be used instead of subdirs although
subdirs will still work. This will cause any
CMakeLists.txt files in the sub directories to be processed
by CMake. Any directories after the PREORDER flag are
traversed first by makefile builds, the PREORDER flag
has no effect on IDE projects. Any directories after the
EXCLUDE_FROM_ALL marker will not be included in the
top level makefile or project file. This is useful for
having CMake create makefiles or projects for a set of
examples in a project. You would want CMake to generate
makefiles or project files for all the examples at the same
time, but you would not want them to show up in the top
level project or be built each time make is run from the
top.

use_mangled_mesa

Disallowed since version 3.0. See CMake Policy
CMP0030.

Copy mesa
headers for use in combination with system GL.

use_mangled_mesa(PATH_TO_MESA OUTPUT_DIRECTORY)

The path to
mesa includes, should contain gl_mangle.h. The mesa
headers are copied to the specified output directory. This
allows mangled mesa headers to override other GL headers by
being added to the include directory path earlier.

utility_source

Disallowed since version 3.0. See CMake Policy
CMP0034.

Specify the
source tree of a third-party utility.

utility_source(cache_entry executable_name
               path_to_source [file1 file2 ...])

When a
third-party utility’s source is included in the
distribution, this command specifies its location and name.
The cache entry will not be set unless the
path_to_source and all listed files exist. It is
assumed that the source tree of the utility will have been
built before it is needed.

When cross
compiling CMake will print a warning if a
utility_source() command is executed, because in many
cases it is used to build an executable which is executed
later on. This doesn’t work when cross compiling,
since the executable can run only on their target platform.
So in this case the cache entry has to be adjusted manually
so it points to an executable which is runnable on the build
host.

variable_requires

Disallowed since version 3.0. See CMake Policy
CMP0035.

Use the
if() command instead.

Assert
satisfaction of an option’s required variables.

variable_requires(TEST_VARIABLE RESULT_VARIABLE
                  REQUIRED_VARIABLE1
                  REQUIRED_VARIABLE2 ...)

The first
argument (TEST_VARIABLE) is the name of the variable
to be tested, if that variable is false nothing else is
done. If TEST_VARIABLE is true, then the next
argument (RESULT_VARIABLE) is a variable that is set
to true if all the required variables are set. The rest of
the arguments are variables that must be true or not set to
NOTFOUND to avoid an error. If any are not true, an
error is reported.

write_file

Deprecated since version 3.0: Use the file(WRITE)
command instead.

write_file(filename "message to write"... [APPEND])

The first
argument is the file name, the rest of the arguments are
messages to write. If the argument APPEND is
specified, then the message will be appended.

NOTE 1:
file(WRITE) and file(APPEND) do exactly the
same as this one but add some more functionality.

NOTE 2: When
using write_file the produced file cannot be used as
an input to CMake (CONFIGURE_FILE, source file …)
because it will lead to an infinite loop. Use
configure_file() if you want to generate input files
to CMake.

COPYRIGHT

2000-2020
Kitware, Inc. and Contributors