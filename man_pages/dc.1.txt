NAME

dc - desk
calculator

SYNOPSIS

dc [
file ]

DESCRIPTION

Dc is an
arbitrary precision desk calculator. Ordinarily it operates
on decimal integers, but one may specify an input base,
output base, and a number of fractional digits to be
maintained. The overall structure of dc is a stacking
(reverse Polish) calculator. If an argument is given, input
is taken from that file until its end, then from the
standard input. The following constructions are
recognized:

number

The value of the number is pushed on the stack. A number
is an unbroken string of the digits 0-9A-F or
0-9a-f. A hexadecimal number beginning with a lower
case letter must be preceded by a zero to distinguish it
from the command associated with the letter. It may be
preceded by an underscore _ to input a negative
number. Numbers may contain decimal points.

+ - / * % ^

Add subtract multiply divide
remainder or exponentiate the top two values on the stack.
The two entries are popped off the stack; the result is
pushed on the stack in their place. Any fractional part of
an exponent is ignored.

sx

Sx

Pop the top of the stack and store into a register named
x, where x may be any character. Under
operation S register x is treated as a stack
and the value is pushed on it.

lx

Lx

Push the value in register x onto the stack. The
register x is not altered. All registers start with
zero value. Under operation L register x is
treated as a stack and its top value is popped onto the main
stack. 

d

Duplicate the top value on the stack.

p

Print the top value on the stack. The top value remains
unchanged. P interprets the top of the stack as an
text string, removes it, and prints it.

f

Print the values on the stack.

q

Q

Exit the program. If executing a string, the recursion
level is popped by two. Under operation Q the top
value on the stack is popped and the string execution level
is popped by that value.

x

Treat the top element of the stack as a character string
and execute it as a string of dc commands.

X

Replace the number on the top of the stack with its
scale factor.

[ ... ]

Put the bracketed text string
on the top of the stack.

x

>x

=x

Pop and compare the top two elements of the stack.
Register x is executed if they obey the stated
relation. 

v

Replace the top element on the stack by its square root.
Any existing fractional part of the argument is taken into
account, but otherwise the scale factor is ignored.

!

Interpret the rest of the line as a shell command.

c

Clear the stack.

i

The top value on the stack is popped and used as the
number base for further input.

I

Push the input base on the top of the stack.

o

The top value on the stack is popped and used as the
number base for further output. In bases larger than 10,
each ’digit’ prints as a group of decimal
digits. 

O

Push the output base on the top of the stack.

k

Pop the top of the stack, and use that value as a
non-negative scale factor: the appropriate number of places
are printed on output, and maintained during multiplication,
division, and exponentiation. The interaction of scale
factor, input base, and output base will be reasonable if
all are changed together.

z

Push the stack level onto the stack.

Z

Replace the number on the top of the stack with its
length. 

?

A line of input is taken from the input source (usually
the terminal) and executed.

; :

Used by bc for array operations.

The scale
factor set by k determines how many digits are kept
to the right of the decimal point. If s is the
current scale factor, sa is the scale of the first
operand, sb is the scale of the second, and b
is the (integer) second operand, results are truncated to
the following scales.

+,-
max(sa,sb)

*

min(sa+sb , max(s,sa,sb))

/

s

%

so that dividend = divisor*quotient + remainder;
remainder has sign of dividend

^

min(sa×|b|, max(s,sa))

v

max(s,sa)

EXAMPLES

Print the first
ten values of n!

[la1+dsa*pla10>y]sy

0sa1 
lyx

SOURCE

/src/cmd/dc.c

SEE ALSO

bc(1),
hoc(1)

DIAGNOSTICS

x where
x is an octal number: an internal error. 
’Out of headers’ for too many numbers being kept
around. 
’Nesting depth’ for too many levels of nested
execution.

BUGS

When the input
base exceeds 16, there is no notation for digits greater
than F.

Past its
time.