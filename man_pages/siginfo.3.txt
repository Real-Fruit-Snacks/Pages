NAME

siginfo &minus;
signal generation information

SYNOPSIS

#include

DESCRIPTION

If a process is
catching a signal, it might request information that tells
why the system generated that signal. See
sigaction(2). If a process is monitoring its
children, it might receive information that tells why a
child changed state. See waitid(2). In either case,
the system returns the information in a structure of type
siginfo_t, which includes the following
information:

int            si_signo        /* signal number */
int            si_errno        /* error number */
int            si_code         /* signal code */
union sigval   si_value        /* signal value */

si_signo
contains the system-generated signal number. For the
waitid(2) function, si_signo is always
SIGCHLD.

If
si_errno is non-zero, it contains an error number
associated with this signal, as defined in
.

si_code
contains a code identifying the cause of the signal.

If the value of
the si_code member is SI_NOINFO, only the
si_signo member of siginfo_t is meaningful,
and the value of all other members is unspecified.

User
Signals 
If the value of si_code is less than or equal to 0,
then the signal was generated by a user process (see
kill(2), _lwp_kill(2), sigqueue(3RT),
sigsend(2), abort(3C), and raise(3C))
and the siginfo structure contains the following
additional information:

typedef   long pid_t   si_pid   /* sending process ID */
typedef   long uid_t   si_uid   /* sending user ID */

If the signal
was generated by a user process, the following values are
defined for si_code: 
SI_USER

The implementation sets
si_code to SI_USER if the signal was sent by
kill(2), sigsend(2), raise(3C) or
abort(3C).

SI_LWP

The signal was sent by
_lwp_kill(2).

SI_QUEUE

The signal was sent by
sigqueue(3RT).

SI_TIMER

The signal was generated by the
expiration of a timer created by
timer_settime(3RT).

SI_ASYNCIO

The signal was generated by the
completion of an asynchronous I/O request.

SI_MESGQ

The signal was generated by the
arrival of a message on an empty message queue. See
mq_notify(3RT).

si_value
contains the application specified value, which is passed to
the application&rsquo;s signal-catching function at the time
of the signal delivery if si_code is any of
SI_QUEUE, SI_TIMER, SI_ASYNCHIO, or
SI_MESGQ.

System
Signals 
Non-user generated signals can arise for a number of
reasons. For all of these cases, si_code contains a
positive value reflecting the reason why the system
generated the signal:

Signals can
also be generated from the resource control subsystem. Where
these signals do not already possess kernel-level
siginfo codes, the siginfo si_code will be
filled with SI_RCTL to indicate a kernel-generated
signal from an established resource control value.

The uncatchable
signals SIGSTOP and SIGKILL have undefined
siginfo codes.

Signals sent
with a siginfo code of SI_RCTL contain
code-dependent information for kernel-generated signals:

In addition,
the following signal-dependent information is available for
kernel-generated signals:

SEE ALSO

_lwp_kill(2),
kill(2), setrctl(2), sigaction(2),
sigsend(2), waitid(2), abort(3C),
aio_read(3RT), mq_notify(3RT),
raise(3C), signal(3HEAD),
sigqueue(3RT), timer_create(3RT),
timer_settime(3RT)

NOTES

For
SIGCHLD signals, if si_code is equal to
CLD_EXITED, then si_status is equal to the
exit value of the process; otherwise, it is equal to the
signal that caused the process to change state. For some
implementations, the exact value of si_addr might not
be available; in that case, si_addr is guaranteed to
be on the same page as the faulting instruction or memory
reference.