NG_BTSOCKET(4) BSD Kernel Interfaces Manual
NG_BTSOCKET(4)

NAME

ng_btsocket —
Bluetooth sockets layer

SYNOPSIS

#include 

#include  
#include  
#include  
#include  
#include

DESCRIPTION

The ng_btsocket module
implements three Netgraph node types. Each type in its turn
implements one protocol within PF_BLUETOOTH domain.

BLUETOOTH_PROTO_HCI protocol

SOCK_RAW HCI sockets 
Implemented by btsock_hci_raw Netgraph type. Raw HCI
sockets allow sending of raw HCI command datagrams only to
correspondents named in send(2) calls. Raw HCI datagrams
(HCI commands, events and data) are generally received with
recvfrom(2), which returns the next datagram with its return
address. Raw HCI sockets can also be used to control HCI
nodes.

The Bluetooth
raw HCI socket address is defined as follows:

/* Bluetooth
version of struct sockaddr for raw HCI sockets */ 
struct sockaddr_hci {

u_char

hci_len; /* total length */ 
u_char

hci_family; /* address family */

char

hci_node[32]; /* address (size == NG_NODESIZ ) */

};

Raw HCI sockets
support a number of ioctl(2) requests such as:

SIOC_HCI_RAW_NODE_GET_STATE

Returns current state for the
HCI node.

SIOC_HCI_RAW_NODE_INIT

Turn on
’’inited’’ bit for the HCI node.

SIOC_HCI_RAW_NODE_GET_DEBUG

Returns current debug level for
the HCI node.

SIOC_HCI_RAW_NODE_SET_DEBUG

Sets current debug level for
the HCI node.

SIOC_HCI_RAW_NODE_GET_BUFFER

Returns current state of data
buffers for the HCI node.

SIOC_HCI_RAW_NODE_GET_BDADDR

Returns BD_ADDR for the HCI
node.

SIOC_HCI_RAW_NODE_GET_FEATURES

Returns the list of features
supported by hardware for the HCI node.

SIOC_HCI_RAW_NODE_GET_STAT

Returns various statistic
counters for the HCI node.

SIOC_HCI_RAW_NODE_RESET_STAT

Resets all statistic counters
for the HCI node to zero.

SIOC_HCI_RAW_NODE_FLUSH_NEIGHBOR_CACHE

Remove all neighbor cache
entries for the HCI node.

SIOC_HCI_RAW_NODE_GET_NEIGHBOR_CACHE

Returns content of the neighbor
cache for the HCI node.

SIOC_HCI_RAW_NODE_GET_CON_LIST

Returns list of active baseband
connections (i.e., ACL and SCO links) for the HCI node.

SIOC_HCI_RAW_NODE_GET_LINK_POLICY_MASK

Returns current link policy
settings mask for the HCI node.

SIOC_HCI_RAW_NODE_SET_LINK_POLICY_MASK

Sets current link policy
settings mask for the HCI node.

SIOC_HCI_RAW_NODE_GET_PACKET_MASK

Returns current packet mask for
the HCI node.

SIOC_HCI_RAW_NODE_SET_PACKET_MASK

Sets current packet mask for
the HCI node.

SIOC_HCI_RAW_NODE_GET_ROLE_SWITCH

Returns current value of the
role switch parameter for the HCI node.

SIOC_HCI_RAW_NODE_SET_ROLE_SWITCH

Sets new value of the role
switch parameter for the HCI node.

The
net.bluetooth.hci.sockets.raw.ioctl_timeout variable,
that can be examined and set via sysctl(8), controls the
control request timeout (in seconds) for raw HCI
sockets.

Raw HCI sockets
support filters. The application can filter certain HCI
datagram types. For HCI event datagrams the application can
set additional filter. The raw HCI socket filter defined as
follows:

/* 
* Raw HCI socket filter. 
* 
* For packet mask use (1 
* For event mask use (1 
*/

struct
ng_btsocket_hci_raw_filter { 
bitstr_t bit_decl(packet_mask, 32); 
bitstr_t bit_decl(event_mask, (NG_HCI_EVENT_MASK_SIZE * 8));

};

The
SO_HCI_RAW_FILTER option defined at SOL_HCI_RAW level can be
used to obtain via getsockopt(2) or change via setsockopt(2)
raw HCI socket’s filter.

BLUETOOTH_PROTO_L2CAP
protocol

The Bluetooth L2CAP socket
address is defined as follows:

/* Bluetooth
version of struct sockaddr for L2CAP sockets */ 
struct sockaddr_l2cap { 
u_char l2cap_len; /* total length */ 
u_char l2cap_family; /* address family */ 
uint16_t l2cap_psm; /* Protocol/Service Multiplexor */ 
bdaddr_t l2cap_bdaddr; /* address */ 
};

SOCK_RAW L2CAP
sockets 
Implemented by btsock_l2c_raw Netgraph type. Raw
L2CAP sockets do not provide access to raw L2CAP datagrams.
These sockets used to control L2CAP nodes and to issue
special L2CAP requests such as ECHO_REQUEST and GET_INFO
request.

Raw L2CAP
sockets support number of ioctl(2) requests such as:

SIOC_L2CAP_NODE_GET_FLAGS

Returns current state for the
L2CAP node.

SIOC_L2CAP_NODE_GET_DEBUG

Returns current debug level for
the L2CAP node.

SIOC_L2CAP_NODE_SET_DEBUG

Sets current debug level for
the L2CAP node.

SIOC_L2CAP_NODE_GET_CON_LIST

Returns list of active baseband
connections (i.e., ACL links) for the L2CAP node.

SIOC_L2CAP_NODE_GET_CHAN_LIST

Returns list of active channels
for the L2CAP node.

SIOC_L2CAP_NODE_GET_AUTO_DISCON_TIMO

Returns current value of the
auto disconnect timeout for the L2CAP node.

SIOC_L2CAP_NODE_SET_AUTO_DISCON_TIMO

Sets current value of the auto
disconnect timeout for the L2CAP node.

SIOC_L2CAP_L2CA_PING

Issues L2CAP ECHO_REQUEST.

SIOC_L2CAP_L2CA_GET_INFO

Issues L2CAP GET_INFO
request.

The
net.bluetooth.l2cap.sockets.raw.ioctl_timeout
variable, that can be examined and set via sysctl(8),
controls the control request timeout (in seconds) for raw
L2CAP sockets.

SOCK_SEQPACKET
L2CAP sockets 
Implemented by btsock_l2c Netgraph type. L2CAP
sockets are either ’’active’’ or
’’passive’’. Active sockets initiate
connections to passive sockets. By default, L2CAP sockets
are created active; to create a passive socket, the
listen(2) system call must be used after binding the socket
with the bind(2) system call. Only passive sockets may use
the accept(2) call to accept incoming connections. Only
active sockets may use the connect(2) call to initiate
connections.

L2CAP sockets
support ’’wildcard addressing’’. In
this case, socket must be bound to NG_HCI_BDADDR_ANY
address. Note that PSM (Protocol/Service Multiplexor) field
is always required. Once a connection has been established,
the socket’s address is fixed by the peer
entity’s location. The address assigned to the socket
is the address associated with the Bluetooth device through
which packets are being transmitted and received, and PSM
(Protocol/Service Multiplexor).

L2CAP sockets
support number of options defined at SOL_L2CAP level which
can be set with setsockopt(2) and tested with
getsockopt(2):

SO_L2CAP_IMTU

Get (set) maximum payload size
the local socket is capable of accepting.

SO_L2CAP_OMTU

Get maximum payload size the
remote socket is capable of accepting.

SO_L2CAP_IFLOW

Get incoming flow specification
for the socket. Not implemented.

SO_L2CAP_OFLOW

Get (set) outgoing flow
specification for the socket. Not implemented.

SO_L2CAP_FLUSH

Get (set) value of the flush
timeout. Not implemented.

BLUETOOTH_PROTO_RFCOMM
protocol

The Bluetooth RFCOMM socket
address is defined as follows:

/* Bluetooth
version of struct sockaddr for RFCOMM sockets */ 
struct sockaddr_rfcomm { 
u_char rfcomm_len; /* total length */ 
u_char rfcomm_family; /* address family */ 
bdaddr_t rfcomm_bdaddr; /* address */ 
uint8_t rfcomm_channel; /* channel */ 
};

SOCK_STREAM
RFCOMM sockets 
Note that RFCOMM sockets do not have associated Netgraph
node type. RFCOMM sockets are implemented as additional
layer on top of L2CAP sockets. RFCOMM sockets are either
’’active’’ or
’’passive’’. Active sockets initiate
connections to passive sockets. By default, RFCOMM sockets
are created active; to create a passive socket, the
listen(2) system call must be used after binding the socket
with the bind(2) system call. Only passive sockets may use
the accept(2) call to accept incoming connections. Only
active sockets may use the connect(2) call to initiate
connections.

RFCOMM sockets
support ’’wildcard addressing’’. In
this case, socket must be bound to NG_HCI_BDADDR_ANY
address. Note that RFCOMM channel field is always required.
Once a connection has been established, the socket’s
address is fixed by the peer entity’s location. The
address assigned to the socket is the address associated
with the Bluetooth device through which packets are being
transmitted and received, and RFCOMM channel.

The following
options, which can be tested with getsockopt(2) call, are
defined at SOL_RFCOMM level for RFCOMM sockets:

SO_RFCOMM_MTU

Returns the maximum transfer
unit size (in bytes) for the underlying RFCOMM channel. Note
that application still can write/read bigger chunks to/from
the socket.

SO_RFCOMM_FC_INFO

Return the flow control
information for the underlying RFCOMM channel.

The
net.bluetooth.rfcomm.sockets.stream.timeout variable,
that can be examined and set via sysctl(8), controls the
connection timeout (in seconds) for RFCOMM sockets.

HOOKS

These node types support hooks
with arbitrary names (as long as they are unique) and always
accept hook connection requests.

NETGRAPH CONTROL
MESSAGES

These node types support the
generic control messages.

SHUTDOWN

These nodes are persistent and
cannot be shut down.

SEE ALSO

btsockstat(1), socket(2),
netgraph(4), ng_bluetooth(4), ng_hci(4), ng_l2cap(4),
ngctl(8), sysctl(8)

HISTORY

The ng_btsocket module
was implemented in FreeBSD 5.0.

AUTHORS

Maksim Yevmenkin
m_evmenkin [AT] yahoo.com>

BUGS

Most likely. Please report if
found.

BSD
November 13, 2012 BSD