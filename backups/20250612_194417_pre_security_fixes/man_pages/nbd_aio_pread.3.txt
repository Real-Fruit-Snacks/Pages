NAME

nbd_aio_pread -
read from the NBD server

SYNOPSIS

#include

typedef struct { 
int (*callback) (void *user_data, int *error); 
void *user_data; 
void (*free) (void *user_data); 
} nbd_completion_callback; 
int64_t nbd_aio_pread ( 
struct nbd_handle *h, void *buf, size_t count, 
uint64_t offset, 
nbd_completion_callback completion_callback, 
uint32_t flags 
);

DESCRIPTION

Issue a read
command to the NBD server.

To check if the
command completed, call nbd_aio_command_completed(3).
Or supply the optional "completion_callback" which
will be invoked as described in "Completion
callbacks" in libnbd(3).

Note that you
must ensure "buf" is valid until the command has
completed. Furthermore, if the "error" parameter
to "completion_callback" is set or if
nbd_aio_command_completed(3) reports failure, and if
nbd_get_pread_initialize(3) returns true, then libnbd
sanitized "buf", but it is unspecified whether the
contents of "buf" will read as zero or as partial
results from the server. If
nbd_get_pread_initialize(3) returns false, then
libnbd did not sanitize "buf", and the contents
are undefined on failure.

Other
parameters behave as documented in nbd_pread(3).

By default,
libnbd will reject attempts to use this function with
parameters that are likely to result in server failure, such
as requesting an unknown command flag. The
nbd_set_strict_mode(3) function can be used to alter
which scenarios should await a server reply rather than
failing fast.

RETURN VALUE

This call
returns the 64 bit cookie of the command. The cookie is ≥
1. Cookies are unique (per libnbd handle, not globally).

ERRORS

On error -1 is
returned.

Refer to
"ERROR HANDLING" in libnbd(3) for how to
get further details of the error.

The following
parameters must not be NULL: "h", "buf".
For more information see "Non-NULL parameters" in
libnbd(3).

HANDLE STATE

nbd_aio_pread
can be called when the handle is in the following state:

┌─────────────────────────────────────┬─────────────────────────┐

│ Handle created, before connecting │ ❌
error │ 
│ Connecting │ ❌ error │ 
│ Connecting & handshaking (opt_mode) │
❌ error │ 
│ Connected to the server │ ✅ allowed
│ 
│ Connection shut down │ ❌ error │

│ Handle dead │ ❌ error │ 

└─────────────────────────────────────┴─────────────────────────┘

VERSION

This function
first appeared in libnbd 1.0.

If you need to
test if this function is available at compile time check if
the following macro is defined:

#define
LIBNBD_HAVE_NBD_AIO_PREAD 1

EXAMPLE

This example is
also available as examples/aio-connect-read.c in the
libnbd source code.

/* This example
shows how to use the AIO (asynchronous) low 
* level API to connect to a server and read the disk. 
* 
* Here are a few ways to try this example: 
* 
* nbdkit -U - linuxdisk . \ 
* --run './aio-connect-read $unixsocket' 
* 
* nbdkit -U - floppy . \ 
* --run './aio-connect-read $unixsocket' 
* 
* nbdkit -U - pattern size=1M \ 
* --run './aio-connect-read $unixsocket' 
*/ 
#include  
#include  
#include  
#include  
#include  
#include  
#include  
#define NR_SECTORS 32 
#define SECTOR_SIZE 512 
struct data { 
uint64_t offset; 
char sector[SECTOR_SIZE]; 
}; 
static int 
hexdump (void *user_data, int *error) 
{ 
struct data *data = user_data; 
FILE *pp; 
if (*error) { 
errno = *error; 
perror ("failed to read"); 
exit (EXIT_FAILURE); 
} 
printf ("sector at offset 0x%" PRIx64
":\n", 
data->offset); 
pp = popen ("hexdump -C", "w"); 
if (pp == NULL) { 
perror ("popen: hexdump"); 
exit (EXIT_FAILURE); 
} 
fwrite (data->sector, SECTOR_SIZE, 1, pp); 
pclose (pp); 
printf ("\n"); 
/* Returning 1 from the callback automatically retires 
* the command. 
*/ 
return 1; 
} 
static struct data data[NR_SECTORS]; 
int 
main (int argc, char *argv[]) 
{ 
struct nbd_handle *nbd; 
size_t i; 
if (argc != 2) { 
fprintf (stderr, "%s socket\n", argv[0]); 
exit (EXIT_FAILURE); 
} 
/* Create the libnbd handle. */ 
nbd = nbd_create (); 
if (nbd == NULL) { 
fprintf (stderr, "%s\n", nbd_get_error ()); 
exit (EXIT_FAILURE); 
} 
/* Connect to the NBD server over a Unix domain socket. 
* This only starts the connection. 
*/ 
if (nbd_aio_connect_unix (nbd, argv[1]) == -1) { 
fprintf (stderr, "%s\n", nbd_get_error ()); 
exit (EXIT_FAILURE); 
} 
/* Wait for the connection to complete. The use of 
* nbd_poll here is only as an example. You could also 
* integrate this with poll(2), glib or another main 
* loop. Read libnbd(3) and the source file lib/poll.c. 
*/ 
while (!nbd_aio_is_ready (nbd)) { 
if (nbd_poll (nbd, -1) == -1) { 
fprintf (stderr, "%s\n", nbd_get_error ()); 
exit (EXIT_FAILURE); 
} 
} 
assert (nbd_get_size (nbd) >= NR_SECTORS * SECTOR_SIZE);

/* Issue read commands for the first NR sectors. */ 
for (i = 0; i 
data[i].offset = i * SECTOR_SIZE; 
/* The callback (hexdump) is called when the command 
* completes. The buffer must continue to exist while 
* the command is running. 
*/ 
if (nbd_aio_pread (nbd, data[i].sector, SECTOR_SIZE, 
data[i].offset, 
(nbd_completion_callback) { 
.callback = hexdump, 
.user_data = &data[i], 
}, 0) == -1) { 
fprintf (stderr, "%s\n", nbd_get_error ()); 
exit (EXIT_FAILURE); 
} 
} 
/* Run the main loop until all the commands have 
* completed and retired. Again the use of nbd_poll 
* here is only as an example. 
*/ 
while (nbd_aio_in_flight (nbd) > 0) { 
if (nbd_poll (nbd, -1) == -1) { 
fprintf (stderr, "%s\n", nbd_get_error ()); 
exit (EXIT_FAILURE); 
} 
} 
/* Close the libnbd handle. */ 
nbd_close (nbd); 
exit (EXIT_SUCCESS); 
}

SEE ALSO

nbd_aio_command_completed(3),
nbd_aio_pread_structured(3), nbd_create(3),
nbd_get_pread_initialize(3), nbd_pread(3),
nbd_set_pread_initialize(3),
nbd_set_strict_mode(3), "Issuing asynchronous
commands" in libnbd(3), libnbd(3).

AUTHORS

Eric Blake

Richard W.M.
Jones

COPYRIGHT

Copyright Red
Hat

LICENSE

This library is
free software; you can redistribute it and/or modify it
under the terms of the GNU Lesser General Public License as
published by the Free Software Foundation; either version 2
of the License, or (at your option) any later version.

This library is
distributed in the hope that it will be useful, but WITHOUT
ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
GNU Lesser General Public License for more details.

You should have
received a copy of the GNU Lesser General Public License
along with this library; if not, write to the Free Software
Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
MA 02110-1301 USA