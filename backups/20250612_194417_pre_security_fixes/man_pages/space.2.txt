NAME

space -
piecewise polynomial finite element space (rheolef-7.2)

DESCRIPTION

The
space class contains the numbering of the
degrees of freedoms. The degrees of freedoms are the
coefficients in the basis of the vectorial space of
piecewise polynomial finite element functions. The set of
degrees of freedom coefficients is splited in two subsets:
the unknowns and the blocked degrees of
freedoms. The blocked degrees of freedom are associated to
Dirichlet boundary conditions, where the values of the
function, and thus, of the coefficients, are prescribed. The
unknown degrees of freedom are all the others. Finally, the
space class is mainly a table of renumbering for
these coefficients.

The space is
characterized by two entities: its finite element, described
by the basis(2) class and its mesh, described by the
geo(2) class. By default, the space is scalar valued.
It extends to vector and tensor valued functions.

EXAMPLE

space Q (omega,
’P1’); 
space V (omega, ’P2’, ’vector’);

space T (omega, ’P1d’,
’tensor’);

PRODUCT OF SPACES

space X =
T*V*Q; 
space Q2 = pow(Q,2);

SPACE OF REALS

The
’space::real()’ function returns the space of
reals and could be used in a product of spaces as:

space IR =
space::real(); 
space Yh = Xh*IR;

This convention
is useful e.g. when a Lagrange multiplier is a real, not a
field. It extends to IR^n for any size_t n
as:

space IRn =
pow(IR,n);

IMPLEMENTATION

This
documentation has been generated from file
main/lib/space.h

The
space class is simply an alias to the
space_basic class

typedef
space_basic space;

The
space_basic class provides an interface to a data
container:

template

class space_basic : public
smart_pointer > { 
public:

//
typedefs:

typedef
space_rep rep; 
typedef smart_pointer base; 
typedef typename rep::size_type size_type; 
typedef typename rep::valued_type valued_type;

//
allocators:

space_basic
(const geo_basic& omega =
(geo_basic()), 
std::string approx = "", 
std::string prod_valued = "scalar"); 
space_basic (const geo_basic& omega,

const basis_basic& b); 
space_basic (const space_mult_list&
expr); 
space_basic (const
space_constitution& constit); 
static space_basic real();

//
accessors:

void block
(std::string dom_name); 
void unblock(std::string dom_name); 
void block (const
domain_indirect_basic& dom); 
void unblock(const
domain_indirect_basic& dom);

void block_n
(std::string dom_name); 
void unblock_n(std::string dom_name); 
void block_n (const
domain_indirect_basic& dom); 
void unblock_n(const
domain_indirect_basic& dom);

const
distributor& ownership() const; 
const communicator& comm() const; 
size_type ndof() const; 
size_type dis_ndof() const;

const
geo_basic& get_geo() const; 
const basis_basic& get_basis() const; 
size_type size() const; 
valued_type valued_tag() const; 
const std::string& valued() const; 
space_component operator[] (size_type
i_comp); 
space_component_const operator[]
(size_type i_comp) const; 
const space_constitution&
get_constitution() const; 
size_type degree() const; 
std::string get_approx() const; 
std::string name() const;

void dis_idof
(const geo_element& K, std::vector&
dis_idof) const;

const
distributor& iu_ownership() const; 
const distributor& ib_ownership() const;

bool is_blocked
(size_type idof) const; 
size_type dis_iub (size_type idof) const; 
bool dis_is_blocked (size_type dis_idof) const; 
size_type dis_idof2dis_iub (size_type dis_idof) const;

const
distributor& ios_ownership() const; 
size_type idof2ios_dis_idof (size_type idof) const; 
size_type ios_idof2dis_idof (size_type ios_idof) const;

const
point_basic& xdof (size_type idof) const; 
const disarray,sequential>&
get_xdofs() const;

template

T momentum (const Function& f, size_type idof)
const;

template

point_basic vector_momentum (const Function& f,
size_type idof) const;

template

tensor_basic tensor_momentum (const Function&
f, size_type idof) const;

disarray build_dom_dis_idof2bgd_dis_idof ( 
const space_basic& Wh, const
std::string& dom_name) const;

disarray build_dom_dis_idof2bgd_dis_idof ( 
const space_basic& Wh, const
geo_basic& bgd_gamma) const;

const
std::set& ext_iu_set() const { return
base::data().ext_iu_set(); } 
const std::set& ext_ib_set() const {
return base::data().ext_ib_set(); }

//
comparator:

bool operator==
(const space_basic& V2) const {
return base::data().operator==(V2.data()); } 
bool operator!= (const space_basic&
V2) const { return ! operator== (V2); } 
friend bool are_compatible (const
space_basic& V1, const
space_basic& V2) { 
return are_compatible (V1.data(), V2.data()); }

// for lazy
(un-assembled) on geo_domains:

template

void get_parent_subgeo_owner_dis_indexes (Set&
ext_dis_idofs) const 
{ base::data().get_parent_subgeo_owner_dis_indexes
(ext_dis_idofs); } 
size_type get_parent_subgeo_owner (size_type dis_idof) const

{ return base::data().get_parent_subgeo_owner (dis_idof); }

};

AUTHOR

Pierre Saramito
Pierre.Saramito [AT] imag.fr>

COPYRIGHT

Copyright (C)
2000-2018 Pierre Saramito Pierre.Saramito [AT] imag.fr>
GPLv3+: GNU GPL version 3 or later
http://gnu.org/licenses/gpl.html>. This is free
software: you are free to change and redistribute it. There
is NO WARRANTY, to the extent permitted by law.