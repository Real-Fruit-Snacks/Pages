PF.CONF(5) BSD File Formats Manual PF.CONF(5)

NAME

pf.conf â€” packet
filter configuration file

DESCRIPTION

The pf(4) packet filter
modifies, drops or passes packets according to rules or
definitions specified in pf.conf.

STATEMENT ORDER

There are seven types of
statements in pf.conf:

Macros

User-defined variables may be
defined and used later, simplifying the configuration file.
Macros must be defined before they are referenced in
pf.conf.

Tables

Tables provide a mechanism for
increasing the performance and flexibility of rules with
large numbers of source or destination addresses.

Options

Options tune the behaviour of
the packet filtering engine.

Traffic Normalization
(e.g. scrub)

Traffic normalization protects
internal machines against inconsistencies in Internet
protocols and implementations.

Queueing

Queueing provides rule-based
bandwidth control.

Translation (Various
forms of NAT)

Translation rules specify how
addresses are to be mapped or redirected to other
addresses.

Packet Filtering

Stateful and stateless packet
filtering provides rule-based blocking or passing of
packets.

With the
exception of macros and tables, the types of
statements should be grouped and appear in pf.conf in
the order shown above, as this matches the operation of the
underlying packet filtering engine. By default pfctl(8)
enforces this order (see set require-order
below).

MACROS

Much like cpp(1) or m4(1),
macros can be defined that will later be expanded in
context. Macro names must start with a letter, and may
contain letters, digits and underscores. Macro names may not
be reserved words (for example pass, in,
out). Macros are not expanded inside quotes.

For example,

ext_if =
"kue0" 
all_ifs = "{" $ext_if lo0 "}" 
pass out on $ext_if from any to any keep state 
pass in on $ext_if proto tcp from any to any port 25 keep
state

TABLES

Tables are named structures
which can hold a collection of addresses and networks.
Lookups against tables in pf(4) are relatively fast, making
a single rule with tables much more efficient, in terms of
processor usage and memory consumption, than a large number
of rules which differ only in IP address (either created
explicitly or automatically by rule expansion).

Tables can be
used as the source or destination of filter rules,
scrub rules or translation rules such as nat
or rdr (see below for details on the various rule
types). Tables can also be used for the redirect address of
nat and rdr rules and in the routing options
of filter rules, but only for round-robin pools.

Tables can be
defined with any of the following pfctl(8) mechanisms. As
with macros, reserved words may not be used as table
names.

manually

Persistent
tables can be manually created with the add or
replace option of pfctl(8), before or after the
ruleset has been loaded.

pf.conf

Table
definitions can be placed directly in this file, and loaded
at the same time as other rules are loaded, atomically.
Table definitions inside pf.conf use the table
statement, and are especially useful to define
non-persistent tables. The contents of a pre-existing table
defined without a list of addresses to initialize it is not
altered when pf.conf is loaded. A table initialized
with the empty list, { }, will be cleared on load.

Tables may be
defined with the following two attributes:

persist

The
persist flag forces the kernel to keep the table even
when no rules refer to it. If the flag is not set, the
kernel will automatically remove the table when the last
rule referring to it is flushed.

const

The
const flag prevents the user from altering the
contents of the table once it has been created. Without that
flag, pfctl(8) can be used to add or remove addresses from
the table at any time, even when running with securelevel(7)
= 2.

For example,

table
 const { 10/8, 172.16/12, 192.168/16 } 
table  persist 
block on fxp0 from { ,  } to
any

creates a table
called private, to hold RFC 1918 private network blocks, and
a table called badhosts, which is initially empty. A filter
rule is set up to block all traffic coming from addresses
listed in either table. The private table cannot have its
contents changed and the badhosts table will exist even when
no active filter rules reference it. Addresses may later be
added to the badhosts table, so that traffic from these
hosts can be blocked by using

# pfctl -t
badhosts -Tadd 204.92.77.111

A table can also
be initialized with an address list specified in one or more
external files, using the following syntax:

table
 persist file "/etc/spammers" file
"/etc/openrelays" 
block on fxp0 from  to any

The files
/etc/spammers and /etc/openrelays list IP
addresses, one per line. Any lines beginning with a # are
treated as comments and ignored. In addition to being
specified by IP address, hosts may also be specified by
their hostname. When the resolver is called to add a
hostname to a table, all resulting IPv4 and IPv6
addresses are placed into the table. IP addresses can also
be entered in a table by specifying a valid interface name
or the self keyword, in which case all addresses
assigned to the interface(s) will be added to the table.

OPTIONS

pf(4) may be tuned for various
situations using the set command.

set timeout

interval

Interval
between purging expired states and fragments.

frag

Seconds before
an unassembled fragment is expired.

src.track

Length of time to retain a
source tracking entry after the last state expires.

When a packet
matches a stateful connection, the seconds to live for the
connection will be updated to that of the
proto.modifier which corresponds to the connection
state. Each packet which matches this state will reset the
TTL. Tuning these values may improve the performance of the
firewall at the risk of dropping valid idle connections.

tcp.first

The state after the first
packet.

tcp.opening

The state before the
destination host ever sends a packet.

tcp.established

The fully established
state.

tcp.closing

The state after the first FIN
has been sent.

tcp.finwait

The state after both FINs have
been exchanged and the connection is closed. Some hosts
(notably web servers on Solaris) send TCP packets even after
closing the connection. Increasing tcp.finwait (and
possibly tcp.closing) can prevent blocking of such
packets.

tcp.closed

The state after one endpoint
sends an RST.

ICMP and UDP
are handled in a fashion similar to TCP, but with a much
more limited set of states:

udp.first

The state after the first
packet.

udp.single

The state if the source host
sends more than one packet but the destination host has
never sent one back.

udp.multiple

The state if both hosts have
sent packets.

icmp.first

The state after the first
packet.

icmp.error

The state after an ICMP error
came back in response to an ICMP packet.

Other protocols
are handled similarly to UDP:

other.first 
other.single 
other.multiple

Timeout values
can be reduced adaptively as the number of state table
entries grows.

adaptive.start

When the number of state
entries exceeds this value, adaptive scaling begins. All
timeout values are scaled linearly with factor (adaptive.end
- number of states) / (adaptive.end - adaptive.start).

adaptive.end

When reaching this number of
state entries, all timeout values become zero, effectively
purging all state entries immediately. This value is used to
define the scale factor, it should not actually be reached
(set a lower state limit, see below).

These values
can be defined both globally and for each rule. When used on
a per-rule basis, the values relate to the number of states
created by the rule, otherwise to the total number of
states.

For
example:

set timeout
tcp.first 120 
set timeout tcp.established 86400 
set timeout { adaptive.start 6000, adaptive.end 12000 } 
set limit states 10000

With 9000 state
table entries, the timeout values are scaled to 50%
(tcp.first 60, tcp.established 43200).

set loginterface

Enable collection of packet and
byte count statistics for the given interface. These
statistics can be viewed using

# pfctl -s
info

In this example
pf(4) collects statistics on the interface named dc0:

set
loginterface dc0

One can disable
the loginterface using:

set
loginterface none

set limit

Sets hard limits on the memory
pools used by the packet filter. See pool(9) for an
explanation of memory pools.

For
example,

set limit
states 20000

sets the
maximum number of entries in the memory pool used by state
table entries (generated by keep state rules) to
20000. Using

set limit frags
20000

sets the
maximum number of entries in the memory pool used for
fragment reassembly (generated by scrub rules) to
20000. Finally,

set limit
src-nodes 2000

sets the
maximum number of entries in the memory pool used for
tracking source IP addresses (generated by the
sticky-address and source-track options) to
2000.

These can be
combined:

set limit {
states 20000, frags 20000, src-nodes 2000 }

set optimization

Optimize the engine for one of
the following network environments:

normal

A normal network environment.
Suitable for almost all networks.

high-latency

A high-latency environment
(such as a satellite connection).

satellite

Alias for
high-latency.

aggressive

Aggressively expire
connections. This can greatly reduce the memory usage of the
firewall at the cost of dropping idle connections early.

conservative

Extremely conservative
settings. Avoid dropping legitimate connections at the
expense of greater memory utilization (possibly much greater
on a busy network) and slightly increased processor
utilization.

For
example:

set
optimization aggressive

set block-policy

The block-policy option
sets the default behaviour for the packet block
action:

drop

Packet is
silently dropped.

return

A TCP RST is
returned for blocked TCP packets, an ICMP UNREACHABLE is
returned for blocked UDP packets, and all other packets are
silently dropped.

For
example:

set
block-policy return

set state-policy

The state-policy option
sets the default behaviour for states:

if-bound

States are
bound to interface.

group-bound

States are
bound to interface group (i.e. ppp)

floating

States can
match packets on any interfaces (the default).

For
example:

set
state-policy if-bound

set require-order

By default pfctl(8) enforces an
ordering of the statement types in the ruleset to:
options, normalization, queueing,
translation, filtering. Setting this option to
no disables this enforcement. There may be
non-trivial and non-obvious implications to an out of order
ruleset. Consider carefully before disabling the order
enforcement.

set fingerprints

Load fingerprints of known
operating systems from the given filename. By default
fingerprints of known operating systems are automatically
loaded from pf.os(5) in /etc but can be overridden
via this option. Setting this option may leave a small
period of time where the fingerprints referenced by the
currently active ruleset are inconsistent until the new
ruleset finishes loading.

For
example:

set
fingerprints "/etc/pf.os.devel"

set debug

Set the debug level to
one of the following:

none

Donâ€™t
generate debug messages.

urgent

Generate debug
messages only for serious errors.

misc

Generate debug
messages for various errors.

loud

Generate debug
messages for common conditions.

TRAFFIC NORMALIZATION

Traffic normalization is used to
sanitize packet content in such a way that there are no
ambiguities in packet interpretation on the receiving side.
The normalizer does IP fragment reassembly to prevent
attacks that confuse intrusion detection systems by sending
overlapping IP fragments. Packet normalization is invoked
with the scrub directive.

scrub has
the following options:

no-df

Clears the dont-fragment
bit from a matching IP packet. Some operating systems are
known to generate fragmented packets with the
dont-fragment bit set. This is particularly true with
NFS. Scrub will drop such fragmented
dont-fragment packets unless no-df is
specified.

Unfortunately
some operating systems also generate their
dont-fragment packets with a zero IP identification
field. Clearing the dont-fragment bit on packets with
a zero IP ID may cause deleterious results if an upstream
router later fragments the packet. Using the
random-id modifier (see below) is recommended in
combination with the no-df modifier to ensure unique
IP identifiers.

min-ttl

Enforces a minimum TTL for
matching IP packets.

max-mss

Enforces a maximum MSS for
matching TCP packets.

random-id

Replaces the IP identification
field with random values to compensate for predictable
values generated by many hosts. This option only applies to
outgoing packets that are not fragmented after the optional
fragment reassembly.

fragment reassemble

Using scrub rules,
fragments can be reassembled by normalization. In this case,
fragments are buffered until they form a complete packet,
and only the completed packet is passed on to the filter.
The advantage is that filter rules have to deal only with
complete packets, and can ignore fragments. The drawback of
caching fragments is the additional memory cost. But the
full reassembly method is the only method that currently
works with NAT. This is the default behavior of a
scrub rule if no fragmentation modifier is
supplied.

fragment crop

The default fragment reassembly
method is expensive, hence the option to crop is provided.
In this case, pf(4) will track the fragments and cache a
small range descriptor. Duplicate fragments are dropped and
overlaps are cropped. Thus data will only occur once on the
wire with ambiguities resolving to the first occurrence.
Unlike the fragment reassemble modifier, fragments
are not buffered, they are passed as soon as they are
received. The fragment crop reassembly mechanism does
not yet work with NAT.

fragment drop-ovl

This option is similar to the
fragment crop modifier except that all overlapping or
duplicate fragments will be dropped, and all further
corresponding fragments will be dropped as well.

reassemble tcp

Statefully normalizes TCP
connections. scrub reassemble tcp rules may not have
the direction (in/out) specified. reassemble tcp
performs the following normalizations:

ttl

Neither side of
the connection is allowed to reduce their IP TTL. An
attacker may send a packet such that it reaches the
firewall, affects the firewall state, and expires before
reaching the destination host. reassemble tcp will
raise the TTL of all packets back up to the highest value
seen on the connection.

timeout modulation

Modern TCP stacks will send a
timestamp on every TCP packet and echo the other
endpointâ€™s timestamp back to them. Many operating
systems will merely start the timestamp at zero when first
booted, and increment it several times a second. The uptime
of the host can be deduced by reading the timestamp and
multiplying by a constant. Also observing several different
timestamps can be used to count hosts behind a NAT device.
And spoofing TCP packets into a connection requires knowing
or guessing valid timestamps. Timestamps merely need to be
monotonically increasing and not derived off a guessable
base time. reassemble tcp will cause scrub to
modulate the TCP timestamps with a random number.

For example,

scrub in on
$ext_if all fragment reassemble

QUEUEING/ALTQ

Packets can be assigned to
queues for the purpose of bandwidth control. At least two
declarations are required to configure queues, and later any
packet filtering rule can reference the defined queues by
name. During the filtering component of pf.conf, the
last referenced queue name is where any packets from
pass rules will be queued, while for block
rules it specifies where any resulting ICMP or TCP RST
packets should be queued. The scheduler defines the
algorithm used to decide which packets get delayed, dropped,
or sent out immediately. There are three schedulers
currently supported.

cbq

Class Based
Queueing. Queues attached to an interface build a
tree, thus each queue can have further child
queues. Each queue can have a priority and a
bandwidth assigned. Priority mainly controls
the time packets take to get sent out, while
bandwidth has primarily effects on throughput.

priq

Priority
Queueing. Queues are flat attached to the interface,
thus, queues cannot have further child queues.
Each queue has a unique priority assigned,
ranging from 0 to 15. Packets in the queue with the
highest priority are processed first.

hfsc

Hierarchical
Fair Service Curve. Queues attached to an interface
build a tree, thus each queue can have further child
queues. Each queue can have a priority and a
bandwidth assigned. Priority mainly controls
the time packets take to get sent out, while
bandwidth has primarily effects on throughput.

The interfaces
on which queueing should be activated are declared using the
altq on declaration. altq on has the following
keywords:

Queueing is enabled on the
named interface.

Specifies which queueing
scheduler to use. Currently supported values are cbq
for Class Based Queueing, priq for Priority Queueing
and hfsc for the Hierarchical Fair Service Curve
scheduler.

bandwidth 

The maximum bitrate for all
queues on an interface may be specified using the
bandwidth keyword. The value can be specified as an
absolute value or as a percentage of the interface
bandwidth. When using an absolute value, the suffixes
b, Kb, Mb, and Gb are used to
represent bits, kilobits, megabits, and gigabits per second,
respectively. The value must not exceed the interface
bandwidth. If bandwidth is not specified, the
interface bandwidth is used.

qlimit 

The maximum number of packets
held in the queue. The default is 50.

tbrsize 

Adjusts the size, in bytes, of
the token bucket regulator. If not specified, heuristics
based on the interface bandwidth are used to determine the
size.

queue 

Defines a list of subqueues to
create on an interface.

In the following
example, the interface dc0 should queue up to 5 Mbit/s in
four second-level queues using Class Based Queueing. Those
four queues will be shown in a later example.

altq on dc0 cbq
bandwidth 5Mb queue { std, http, mail, ssh }

Once interfaces
are activated for queueing using the altq directive,
a sequence of queue directives may be defined. The
name associated with a queue must match a queue
defined in the altq directive (e.g. mail), or, except
for the priq scheduler, in a parent queue
declaration. The following keywords can be used:

on 

Specifies the interface the
queue operates on. If not given, it operates on all matching
interfaces.

bandwidth 

Specifies the maximum bitrate
to be processed by the queue. This value must not exceed the
value of the parent queue and can be specified as an
absolute value or a percentage of the parent queueâ€™s
bandwidth. The priq scheduler does not support
bandwidth specification.

priority

Between queues a priority level
can be set. For cbq and hfsc, the range is 0
to 7 and for priq, the range is 0 to 15. The default
for all is 1. Priq queues with a higher priority are
always served first. Cbq and Hfsc queues with
a higher priority are preferred in the case of overload.

qlimit 

The maximum number of packets
held in the queue. The default is 50.

The
scheduler can get additional parameters with
(  ).
Parameters are as follows:

default

Packets not
matched by another queue are assigned to this one. Exactly
one default queue is required.

red

Enable RED
(Random Early Detection) on this queue. RED drops packets
with a probability proportional to the average queue
length.

rio

Enables RIO on
this queue. RIO is RED with IN/OUT, thus running RED two
times more than RIO would achieve the same effect. RIO is
currently not supported in the GENERIC kernel.

ecn

Enables ECN
(Explicit Congestion Notification) on this queue. ECN
implies RED.

The cbq
scheduler supports an additional option:

borrow

The queue can
borrow bandwidth from the parent.

The hfsc
scheduler supports some additional options:

realtime 

The minimum required bandwidth
for the queue.

upperlimit 

The maximum allowed bandwidth
for the queue.

linkshare 

The bandwidth share of a
backlogged queue.

 is an
acronym for service curve.

The format for
service curve specifications is (m1, d,
m2). m2 controls the bandwidth assigned to the
queue. m1 and d are optional and can be used
to control the initial bandwidth assignment. For the first
d milliseconds the queue gets the bandwidth given as
m1, afterwards the value given in m2.

Furthermore,
with cbq and hfsc, child queues can be
specified as in an altq declaration, thus building a
tree of queues using a part of their parentâ€™s
bandwidth.

Packets can be
assigned to queues based on filter rules by using the
queue keyword. Normally only one queue is
specified; when a second one is specified it will instead be
used for packets which have a TOS of lowdelay
and for TCP ACKs with no data payload.

To continue the
previous example, the examples below would specify the four
referenced queues, plus a few child queues. Interactive
ssh(1) sessions get priority over bulk transfers like scp(1)
and sftp(1). The queues may then be referenced by filtering
rules (see PACKET FILTERING below).

queue std
bandwidth 10% cbq(default) 
queue http bandwidth 60% priority 2 cbq(borrow red) \ 
{ employees, developers } 
queue developers bandwidth 75% cbq(borrow) 
queue employees bandwidth 15% 
queue mail bandwidth 10% priority 0 cbq(borrow ecn) 
queue ssh bandwidth 20% cbq(borrow) { ssh_interactive,
ssh_bulk } 
queue ssh_interactive priority 7 
queue ssh_bulk priority 0

block return out
on dc0 inet all queue std 
pass out on dc0 inet proto tcp from $developerhosts to any
port 80 \ 
keep state queue developers 
pass out on dc0 inet proto tcp from $employeehosts to any
port 80 \ 
keep state queue employees 
pass out on dc0 inet proto tcp from any to any port 22 \

keep state queue(ssh_bulk, ssh_interactive) 
pass out on dc0 inet proto tcp from any to any port 25 \

keep state queue mail

TRANSLATION

Translation rules modify either
the source or destination address of the packets associated
with a stateful connection. A stateful connection is
automatically created to track packets matching such a rule
as long as they are not blocked by the filtering section of
pf.conf. The translation engine modifies the
specified address and/or port in the packet, recalculates
IP, TCP and UDP checksums as necessary, and passes it to the
packet filter for evaluation.

Since
translation occurs before filtering the filter engine will
see packets as they look after any addresses and ports have
been translated. Filter rules will therefore have to filter
based on the translated address and port number. Packets
that match a translation rule are only automatically passed
if the pass modifier is given, otherwise they are
still subject to block and pass rules.

The state entry
created permits pf(4) to keep track of the original address
for traffic associated with that state and correctly direct
return traffic for that connection.

Various types of
translation are possible with pf:

binat

A binat rule specifies a
bidirectional mapping between an external IP netblock and an
internal IP netblock.

nat

A nat
rule specifies that IP addresses are to be changed as the
packet traverses the given interface. This technique allows
one or more IP addresses on the translating host to support
network traffic for a larger range of machines on an
"inside" network. Although in theory any IP
address can be used on the inside, it is strongly
recommended that one of the address ranges defined by RFC
1918 be used. These netblocks are:

10.0.0.0 -
10.255.255.255 (all of net 10, i.e., 10/8) 
172.16.0.0 - 172.31.255.255 (i.e., 172.16/12) 
192.168.0.0 - 192.168.255.255 (i.e., 192.168/16)

rdr

The packet is
redirected to another destination and possibly a different
port. rdr rules can optionally specify port ranges
instead of single ports. rdr ... port 2000:2999 -> ...
port 4000 redirects ports 2000 to 2999 (inclusive) to port
4000. rdr ... port 2000:2999 -> ... port 4000:* redirects
port 2000 to 4000, 2001 to 4001, ..., 2999 to 4999.

In addition to
modifying the address, some translation rules may modify
source or destination ports for tcp(4) or udp(4)
connections; implicitly in the case of nat rules and
explicitly in the case of rdr rules. Port numbers are
never translated with a binat rule.

For each packet
processed by the translator, the translation rules are
evaluated in sequential order, from first to last. The first
matching rule decides what action is taken.

The no
option prefixed to a translation rule causes packets to
remain untranslated, much in the same way as drop
quick works in the packet filter (see below). If no rule
matches the packet it is passed to the filter engine
unmodified.

Translation
rules apply only to packets that pass through the specified
interface, and if no interface is specified, translation is
applied to packets on all interfaces. For instance,
redirecting port 80 on an external interface to an internal
web server will only work for connections originating from
the outside. Connections to the address of the external
interface from local hosts will not be redirected, since
such packets do not actually pass through the external
interface. Redirections cannot reflect packets back through
the interface they arrive on, they can only be redirected to
hosts connected to different interfaces or to the firewall
itself.

Note that
redirecting external incoming connections to the loopback
address, as in

rdr on ne3 inet
proto tcp to port 8025 -> 127.0.0.1 port 25

will effectively
allow an external host to connect to daemons bound solely to
the loopback address, circumventing the traditional blocking
of such connections on a real interface. Unless this effect
is desired, any of the local non-loopback addresses should
be used as redirection target instead, which allows external
connections only to daemons bound to this address or not
bound to any address.

See
TRANSLATION EXAMPLES below.

PACKET FILTERING

pf(4) has the ability to
block and pass packets based on attributes of
their layer 3 (see ip(4) and ip6(4)) and layer 4 (see
icmp(4), icmp6(4), tcp(4), udp(4)) headers. In addition,
packets may also be assigned to queues for the purpose of
bandwidth control.

For each packet
processed by the packet filter, the filter rules are
evaluated in sequential order, from first to last. The last
matching rule decides what action is taken.

The following
actions can be used in the filter:

block

The packet is blocked. There
are a number of ways in which a block rule can behave
when blocking a packet. The default behaviour is to
drop packets silently, however this can be overridden
or made explicit either globally, by setting the
block-policy option, or on a per-rule basis with one
of the following options:

drop

The packet is
silently dropped.

return-rst

This applies only to tcp(4)
packets, and issues a TCP RST which closes the
connection.

return-icmp 
return-icmp6

This causes ICMP messages to be
returned for packets which match the rule. By default this
is an ICMP UNREACHABLE message, however this can be
overridden by specifying a message as a code or number.

return

This causes a TCP RST to be
returned for tcp(4) packets and an ICMP UNREACHABLE for UDP
and other packets.

Options
returning packets have no effect if pf(4) operates on a
bridge(4).

pass

The packet is
passed.

If no rule
matches the packet, the default action is pass.

To block
everything by default and only pass packets that match
explicit rules, one uses

block all

as the first
filter rule.

See FILTER
EXAMPLES below.

PARAMETERS

The rule parameters specify the
packets to which a rule applies. A packet always comes in
on, or goes out through, one interface. Most parameters are
optional. If a parameter is specified, the rule only applies
to packets with matching attributes. Certain parameters can
be expressed as lists, in which case pfctl(8) generates all
needed rule combinations.

in or out

This rule applies to incoming
or outgoing packets. If neither in nor out are
specified, the rule will match packets in both
directions.

log

In addition to
the action specified, a log message is generated. All
packets for that connection are logged, unless the keep
state, modulate state or synproxy state
options are specified, in which case only the packet that
establishes the state is logged. (See keep state,
modulate state and synproxy state below). The
logged packets are sent to the pflog(4) interface. This
interface is monitored by the pflogd(8) logging daemon,
which dumps the logged packets to the file
/var/log/pflog in pcap(3) binary format.

log-all

Used with keep state,
modulate state or synproxy state rules to
force logging of all packets for a connection. As with
log, packets are logged to pflog(4).

quick

If a packet matches a rule
which has the quick option set, this rule is
considered the last matching rule, and evaluation of
subsequent rules is skipped.

on 

This rule applies only to
packets coming in on, or going out through, this particular
interface. It is also possible to simply give the interface
driver name, like ppp or fxp, to make the rule match packets
flowing through a group of interfaces.

This rule
applies only to packets of this address family. Supported
values are inet and inet6.

proto

This rule applies only to
packets of this protocol. Common protocols are icmp(4),
icmp6(4), tcp(4), and udp(4). For a list of all the protocol
name to number mappings used by pfctl(8), see the file
/etc/protocols.

from  port
 os  to  port

This rule applies only to
packets with the specified source and destination addresses
and ports.

Addresses can
be specified in CIDR notation (matching netblocks), as
symbolic host names or interface names, or as any of the
following keywords:

any

Any
address.

no-route

Any address
which is not currently routable.

Any address
that matches the given table.

Interface names
can have modifiers appended:

:network

Translates to
the network(s) attached to the interface.

:broadcast

Translates to
the interfaceâ€™s broadcast address(es).

:peer

Translates to
the point to point interfaceâ€™s peer address(es).

:0

Do not include
interface aliases.

Host names may
also have the :0 option appended to restrict the name
resolution to the first of each v4 and v6 address found.

Host name
resolution and interface to address translation are done at
ruleset load-time. When the address of an interface (or host
name) changes (under DHCP or PPP, for instance), the ruleset
must be reloaded for the change to be reflected in the
kernel. Surrounding the interface name (and optional
modifiers) in parentheses changes this behaviour. When the
interface name is surrounded by parentheses, the rule is
automatically updated whenever the interface changes its
address. The ruleset does not need to be reloaded. This is
especially useful with nat.

Ports can be
specified either by number or by name. For example, port 80
can be specified as www. For a list of all port name
to number mappings used by pfctl(8), see the file
/etc/services.

Ports and
ranges of ports are specified by using these operators:

= (equal)

!=

(unequal)

(less than)

(less than or equal)

>

(greater than)

>=

(greater than or equal)

:

(range including boundaries)

>

(range excluding boundaries)

<>

(except range)

> and : are binary operators (they take two
arguments). For instance:

port 2000:2004

means â€™all ports >=
2000 and 

port 2000 >

means â€™all ports >
2000 and 

port 2000 <>
2004

means â€™all ports  2004â€™, hence ports 1-1999 and
2005-65535.

The operating
system of the source host can be specified in the case of
TCP rules with the OS modifier. See the OPERATING
SYSTEM FINGERPRINTING section for more information.

The host, port
and OS specifications are optional, as in the following
examples:

pass in all

pass in from any to any 
pass in proto tcp from any port 
pass in proto tcp from any to any port 25 
pass in proto tcp from 10.0.0.0/8 port > 1024 \ 
to ! 10.1.2.3 port != ssh 
pass in proto tcp from any os "OpenBSD" flags
S/SA

all

This is
equivalent to "from any to any".

group 

Similar to user, this
rule only applies to packets of sockets owned by the
specified group.

The use of
group or user in debug.mpsafenet=1
environments may result in a deadlock. Please see the
BUGS section for details.

user 

This rule only applies to
packets of sockets owned by the specified user. For outgoing
connections initiated from the firewall, this is the user
that opened the connection. For incoming connections to the
firewall itself, this is the user that listens on the
destination port. For forwarded connections, where the
firewall is not a connection endpoint, the user and group
are unknown.

All packets,
both outgoing and incoming, of one connection are associated
with the same user and group. Only TCP and UDP packets can
be associated with users; for other protocols these
parameters are ignored.

User and group
refer to the effective (as opposed to the real) IDs, in case
the socket is created by a setuid/setgid process. User and
group IDs are stored when a socket is created; when a
process creates a listening socket as root (for instance, by
binding to a privileged port) and subsequently changes to
another user ID (to drop privileges), the credentials will
remain root.

User and group
IDs can be specified as either numbers or names. The syntax
is similar to the one for ports. The value unknown
matches packets of forwarded connections. unknown can
only be used with the operators = and !=.
Other constructs like user >= unknown are invalid.
Forwarded packets with unknown user and group ID match only
rules that explicitly compare against unknown with
the operators = or !=. For instance user
>= 0 does not match forwarded packets. The following
example allows only selected users to open outgoing
connections:

block out proto
{ tcp, udp } all 
pass out proto { tcp, udp } all \ 
user { 

flags /
| /

This rule only applies to TCP
packets that have the flags  set out of set
. Flags not specified in 
are ignored. The flags are: (F)IN, (S)YN, (R)ST, (P)USH,
(A)CK, (U)RG, (E)CE, and C(W)R.

flags S/S

Flag SYN is
set. The other flags are ignored.

flags S/SA

Out of SYN and
ACK, exactly SYN may be set. SYN, SYN+PSH and SYN+RST match,
but SYN+ACK, ACK and ACK+RST do not. This is more
restrictive than the previous example.

flags /SFRA

If the first set is not
specified, it defaults to none. All of SYN, FIN, RST and ACK
must be unset.

icmp-type  code

icmp6-type  code

This rule only applies to ICMP
or ICMPv6 packets with the specified type and code. This
parameter is only valid for rules that cover protocols ICMP
or ICMP6. The protocol and the ICMP type indicator
(icmp-type or icmp6-type) must match.

allow-opts

By default, packets which
contain IP options are blocked. When allow-opts is
specified for a pass rule, packets that pass the
filter based on that rule (last matching) do so even if they
contain IP options. For packets that match state, the rule
that initially created the state is used. The implicit
pass rule that is used when a packet does not match
any rules does not allow IP options.

label 

Adds a label (name) to the
rule, which can be used to identify the rule. For instance,
pfctl -s labels shows per-rule statistics for rules that
have labels.

The following
macros can be used in labels:

$if

The
interface.

$srcaddr

The source IP
address.

$dstaddr

The destination
IP address.

$srcport

The source port
specification.

$dstport

The destination
port specification.

$proto

The protocol
name.

$nr

The rule
number.

For
example:

ips = "{
1.2.3.4, 1.2.3.5 }" 
pass in proto tcp from any to $ips \ 
port > 1023 label "$dstaddr:$dstport"

expands to

pass in inet
proto tcp from any to 1.2.3.4 \ 
port > 1023 label "1.2.3.4:>1023" 
pass in inet proto tcp from any to 1.2.3.5 \ 
port > 1023 label "1.2.3.5:>1023"

The macro
expansion for the label directive occurs only at
configuration file parse time, not during runtime.

queue  |
(, )

Packets matching this rule will
be assigned to the specified queue. If two queues are given,
packets which have a tos of lowdelay and TCP
ACKs with no data payload will be assigned to the second
one. See QUEUEING/ALTQ for setup details.

For
example:

pass in proto
tcp to port 25 queue mail 
pass in proto tcp to port 22 queue(ssh_bulk, ssh_prio)

tag 

Packets matching this rule will
be tagged with the specified string. The tag acts as an
internal marker that can be used to identify these packets
later on. This can be used, for example, to provide trust
between interfaces and to determine if packets have been
processed by translation rules. Tags are "sticky",
meaning that the packet will be tagged even if the rule is
not the last matching rule. Further matching rules can
replace the tag with a new one but will not remove a
previously applied tag. A packet is only ever assigned one
tag at a time. pass rules that use the tag
keyword must also use keep state, modulate
state or synproxy state. Packet tagging can be
done during nat, rdr, or binat rules in
addition to filter rules. Tags take the same macros as
labels (see above).

tagged 

Used with filter rules to
specify that packets must already be tagged with the given
tag in order to match the rule. Inverse tag matching can
also be done by specifying the ! operator before the
tagged keyword.

ROUTING

If a packet matches a rule with
a route option set, the packet filter will route the packet
according to the type of route option. When such a rule
creates state, the route option is also applied to all
packets matching the same connection.

fastroute

The fastroute option
does a normal route lookup to find the next hop for the
packet.

route-to

The route-to option
routes the packet to the specified interface with an
optional address for the next hop. When a route-to
rule creates state, only packets that pass in the same
direction as the filter rule specifies will be routed in
this way. Packets passing in the opposite direction
(replies) are not affected and are routed normally.

reply-to

The reply-to option is
similar to route-to, but routes packets that pass in
the opposite direction (replies) to the specified interface.
Opposite direction is only defined in the context of a state
entry, and route-to is useful only in rules that
create state. It can be used on systems with multiple
external connections to route all outgoing packets of a
connection through the interface the incoming connection
arrived through (symmetric routing enforcement).

dup-to

The dup-to option
creates a duplicate of the packet and routes it like
route-to. The original packet gets routed as it
normally would.

POOL OPTIONS

For nat and rdr
rules, (as well as for the route-to, reply-to
and dup-to rule options) for which there is a single
redirection address which has a subnet mask smaller than 32
for IPv4 or 128 for IPv6 (more than one IP address), a
variety of different methods for assigning this address can
be used:

bitmask

The bitmask option
applies the network portion of the redirection address to
the address to be modified (source with nat,
destination with rdr).

random

The random option
selects an address at random within the defined block of
addresses.

source-hash

The source-hash option
uses a hash of the source address to determine the
redirection address, ensuring that the redirection address
is always the same for a given source. An optional key can
be specified after this keyword either in hex or as a
string; by default pfctl(8) randomly generates a key for
source-hash every time the ruleset is reloaded.

round-robin

The round-robin option
loops through the redirection address(es).

When more than
one redirection address is specified, round-robin is
the only permitted pool type.

static-port

With nat rules, the
static-port option prevents pf(4) from modifying the
source port on TCP and UDP packets.

Additionally,
the sticky-address option can be specified to help
ensure that multiple connections from the same source are
mapped to the same redirection address. This option can be
used with the random and round-robin pool
options. Note that by default these associations are
destroyed as soon as there are no longer states which refer
to them; in order to make the mappings last beyond the
lifetime of the states, increase the global options with
set timeout source-track See STATEFUL TRACKING
OPTIONS for more ways to control the source
tracking.

STATEFUL INSPECTION

pf(4) is a stateful packet
filter, which means it can track the state of a connection.
Instead of passing all traffic to port 25, for instance, it
is possible to pass only the initial packet, and then begin
to keep state. Subsequent traffic will flow because the
filter is aware of the connection.

If a packet
matches a pass ... keep state rule, the filter
creates a state for this connection and automatically lets
pass all subsequent packets of that connection.

Before any rules
are evaluated, the filter checks whether the packet matches
any state. If it does, the packet is passed without
evaluation of any rules.

States are
removed after the connection is closed or has timed out.

This has several
advantages. Comparing a packet to a state involves checking
its sequence numbers. If the sequence numbers are outside
the narrow windows of expected values, the packet is
dropped. This prevents spoofing attacks, such as when an
attacker sends packets with a fake source address/port but
does not know the connectionâ€™s sequence numbers.

Also, looking up
states is usually faster than evaluating rules. If there are
50 rules, all of them are evaluated sequentially in O(n).
Even with 50000 states, only 16 comparisons are needed to
match a state, since states are stored in a binary search
tree that allows searches in O(log2 n).

For
instance:

block all 
pass out proto tcp from any to any flags S/SA keep state

pass in proto tcp from any to any port 25 flags S/SA keep
state

This ruleset
blocks everything by default. Only outgoing connections and
incoming connections to port 25 are allowed. The initial
packet of each connection has the SYN flag set, will be
passed and creates state. All further packets of these
connections are passed if they match a state.

By default,
packets coming in and out of any interface can match a
state, but it is also possible to change that behaviour by
assigning states to a single interface or a group of
interfaces.

The default
policy is specified by the state-policy global
option, but this can be adjusted on a per-rule basis by
adding one of the if-bound, group-bound or
floating keywords to the keep state option.
For example, if a rule is defined as:

pass out on ppp
from any to 10.12/16 keep state (group-bound)

A state created
on ppp0 would match packets an all PPP interfaces, but not
packets flowing through fxp0 or any other interface.

Keeping rules
floating is the more flexible option when the
firewall is in a dynamic routing environment. However, this
has some security implications since a state created by one
trusted network could allow potentially hostile packets
coming in from other interfaces.

Specifying
flags S/SA restricts state creation to the initial
SYN packet of the TCP handshake. One can also be less
restrictive, and allow state creation from intermediate
(non-SYN) packets. This will cause pf(4) to synchronize to
existing connections, for instance if one flushes the state
table.

For UDP, which
is stateless by nature, keep state will create state
as well. UDP packets are matched to states using only host
addresses and ports.

ICMP messages
fall into two categories: ICMP error messages, which always
refer to a TCP or UDP packet, are matched against the
referred to connection. If one keeps state on a TCP
connection, and an ICMP source quench message referring to
this TCP connection arrives, it will be matched to the right
state and get passed.

For ICMP
queries, keep state creates an ICMP state, and pf(4)
knows how to match ICMP replies to states. For example,

pass out inet
proto icmp all icmp-type echoreq keep state

allows echo
requests (such as those created by ping(8)) out, creates
state, and matches incoming echo replies correctly to
states.

Note:
nat, binat and rdr rules implicitly
create state for connections.

STATE MODULATION

Much of the security derived
from TCP is attributable to how well the initial sequence
numbers (ISNs) are chosen. Some popular stack
implementations choose very poor ISNs and thus are
normally susceptible to ISN prediction exploits. By applying
a modulate state rule to a TCP connection, pf(4) will
create a high quality random sequence number for each
connection endpoint.

The modulate
state directive implicitly keeps state on the rule and
is only applicable to TCP connections.

For
instance:

block all 
pass out proto tcp from any to any modulate state 
pass in proto tcp from any to any port 25 flags S/SA
modulate state

There are two
caveats associated with state modulation: A modulate
state rule can not be applied to a pre-existing but
unmodulated connection. Such an application would
desynchronize TCPâ€™s strict sequencing between the two
endpoints. Instead, pf(4) will treat the modulate
state modifier as a keep state modifier and the
pre-existing connection will be inferred without the
protection conferred by modulation.

The other caveat
affects currently modulated states when the state table is
lost (firewall reboot, flushing the state table, etc...).
pf(4) will not be able to infer a connection again after the
state table flushes the connectionâ€™s modulator. When
the state is lost, the connection may be left dangling until
the respective endpoints time out the connection. It is
possible on a fast local network for the endpoints to start
an ACK storm while trying to resynchronize after the loss of
the modulator. Using a flags S/SA modifier on
modulate state rules between fast networks is
suggested to prevent ACK storms.

SYN PROXY

By default, pf(4) passes packets
that are part of a tcp(4) handshake between the endpoints.
The synproxy state option can be used to cause pf(4)
itself to complete the handshake with the active endpoint,
perform a handshake with the passive endpoint, and then
forward packets between the endpoints.

No packets are
sent to the passive endpoint before the active endpoint has
completed the handshake, hence so-called SYN floods with
spoofed source addresses will not reach the passive
endpoint, as the sender canâ€™t complete the
handshake.

The proxy is
transparent to both endpoints, they each see a single
connection from/to the other endpoint. pf(4) chooses random
initial sequence numbers for both handshakes. Once the
handshakes are completed, the sequence number modulators
(see previous section) are used to translate further packets
of the connection. Hence, synproxy state includes
modulate state and keep state.

Rules with
synproxy will not work if pf(4) operates on a
bridge(4).

Example:

pass in proto
tcp from any to any port www flags S/SA synproxy state

STATEFUL TRACKING
OPTIONS

All three of keep state,
modulate state and synproxy state support the
following options:

max 

Limits the number of concurrent
states the rule may create. When this limit is reached,
further packets matching the rule that would create state
are dropped, until existing states time out.

no-sync

Prevent state changes for
states created by this rule from appearing on the pfsync(4)
interface.

Changes the timeout values used
for states created by this rule.

When the
source-track keyword is specified, the number of
states per source IP is tracked. The following limits can be
set:

max-src-nodes

Limits the maximum number of
source addresses which can simultaneously have state table
entries.

max-src-states

Limits the maximum number of
simultaneous state entries that a single source address can
create with this rule.

For a list of all valid timeout
names, see OPTIONS above.

Multiple
options can be specified, separated by commas:

pass in proto
tcp from any to any \ 
port www flags S/SA keep state \ 
(max 100, source-track rule, max-src-nodes 75, \ 
max-src-states 3, tcp.established 60, tcp.closing 5)

OPERATING SYSTEM
FINGERPRINTING

Passive OS Fingerprinting is a
mechanism to inspect nuances of a TCP connectionâ€™s
initial SYN packet and guess at the hostâ€™s operating
system. Unfortunately these nuances are easily spoofed by an
attacker so the fingerprint is not useful in making security
decisions. But the fingerprint is typically accurate enough
to make policy decisions upon.

The fingerprints
may be specified by operating system class, by version, or
by subtype/patchlevel. The class of an operating system is
typically the vender or genre and would be OpenBSD for the
pf(4) firewall itself. The version of the oldest available
OpenBSD release on the main ftp site would be 2.6 and the
fingerprint would be written

"OpenBSD
2.6"

The subtype of
an operating system is typically used to describe the
patchlevel if that patch led to changes in the TCP stack
behavior. In the case of OpenBSD, the only subtype is for a
fingerprint that was normalized by the no-df scrub
option and would be specified as

"OpenBSD
3.3 no-df"

Fingerprints for
most popular operating systems are provided by pf.os(5).
Once pf(4) is running, a complete list of known operating
system fingerprints may be listed by running:

# pfctl -so

Filter rules can
enforce policy at any level of operating system
specification assuming a fingerprint is present. Policy
could limit traffic to approved operating systems or even
ban traffic from hosts that arenâ€™t at the latest
service pack.

The
unknown class can also be used as the fingerprint
which will match packets for which no operating system
fingerprint is known.

Examples:

pass out proto
tcp from any os OpenBSD keep state 
block out proto tcp from any os Doors 
block out proto tcp from any os "Doors PT" 
block out proto tcp from any os "Doors PT SP3"

block out from any os "unknown" 
pass on lo0 proto tcp from any os "OpenBSD 3.3
lo0" keep state

Operating system
fingerprinting is limited only to the TCP SYN packet. This
means that it will not work on other protocols and will not
match a currently established connection.

Caveat:
operating system fingerprints are occasionally wrong. There
are three problems: an attacker can trivially craft his
packets to appear as any operating system he chooses; an
operating system patch could change the stack behavior and
no fingerprints will match it until the database is updated;
and multiple operating systems may have the same
fingerprint.

BLOCKING SPOOFED
TRAFFIC

"Spoofing" is the
faking of IP addresses, typically for malicious purposes.
The antispoof directive expands to a set of filter
rules which will block all traffic with a source IP from the
network(s) directly connected to the specified interface(s)
from entering the system through any other interface.

For example, the
line

antispoof for
lo0

expands to

block drop in
on ! lo0 inet from 127.0.0.1/8 to any 
block drop in on ! lo0 inet6 from ::1 to any

For non-loopback
interfaces, there are additional rules to block incoming
packets with a source IP address identical to the
interfaceâ€™s IP(s). For example, assuming the interface
wi0 had an IP address of 10.0.0.1 and a netmask of
255.255.255.0, the line

antispoof for
wi0 inet

expands to

block drop in
on ! wi0 inet from 10.0.0.0/24 to any 
block drop in inet from 10.0.0.1 to any

Caveat: Rules
created by the antispoof directive interfere with
packets sent over loopback interfaces to local addresses.
One should pass these explicitly.

FRAGMENT HANDLING

The size of IP datagrams
(packets) can be significantly larger than the maximum
transmission unit (MTU) of the network. In cases when it is
necessary or more efficient to send such large packets, the
large packet will be fragmented into many smaller packets
that will each fit onto the wire. Unfortunately for a
firewalling device, only the first logical fragment will
contain the necessary header information for the subprotocol
that allows pf(4) to filter on things such as TCP ports or
to perform NAT.

Besides the use
of scrub rules as described in TRAFFIC
NORMALIZATION above, there are three options for
handling fragments in the packet filter.

One alternative
is to filter individual fragments with filter rules. If no
scrub rule applies to a fragment, it is passed to the
filter. Filter rules with matching IP header parameters
decide whether the fragment is passed or blocked, in the
same way as complete packets are filtered. Without
reassembly, fragments can only be filtered based on IP
header fields (source/destination address, protocol), since
subprotocol header fields are not available (TCP/UDP port
numbers, ICMP code/type). The fragment option can be
used to restrict filter rules to apply only to fragments,
but not complete packets. Filter rules without the
fragment option still apply to fragments, if they
only specify IP header fields. For instance, the rule

pass in proto
tcp from any to any port 80

never applies to
a fragment, even if the fragment is part of a TCP packet
with destination port 80, because without reassembly this
information is not available for each fragment. This also
means that fragments cannot create new or match existing
state table entries, which makes stateful filtering and
address translation (NAT, redirection) for fragments
impossible.

Itâ€™s also
possible to reassemble only certain fragments by specifying
source or destination addresses or protocols as parameters
in scrub rules.

In most cases,
the benefits of reassembly outweigh the additional memory
cost, and itâ€™s recommended to use scrub rules
to reassemble all fragments via the fragment
reassemble modifier.

The memory
allocated for fragment caching can be limited using
pfctl(8). Once this limit is reached, fragments that would
have to be cached are dropped until other entries time out.
The timeout value can also be adjusted.

Currently, only
IPv4 fragments are supported and IPv6 fragments are blocked
unconditionally.

ANCHORS AND NAMED
RULESETS

Besides the main ruleset,
pfctl(8) can load named rulesets into anchor
attachment points. An anchor contains a list of named
rulesets. An anchor has a name which specifies where
pfctl(8) can be used to attach sub-rulesets. A named ruleset
contains filter and translation rules, like the main
ruleset. The main ruleset can reference anchor
attachment points using the following kinds of rules:

nat-anchor

Evaluates the nat rules
of all named rulesets in the specified anchor.

rdr-anchor

Evaluates the rdr rules
of all named rulesets in the specified anchor.

binat-anchor

Evaluates the binat
rules of all named rulesets in the specified
anchor.

anchor 

Evaluates the filter rules of
all named rulesets in the specified anchor.

load anchor
: from 

Loads the rules from the
specified file into the named ruleset 
attached to the anchor .

When evaluation
of the main ruleset reaches an anchor rule, pf(4)
will proceed to evaluate all rules specified in the named
rulesets attached to that anchor.

Matching filter
rules in named rulesets with the quick option and
matching translation rules are final and abort the
evaluation of both the rules in the anchor and the
main ruleset.

Only the main
ruleset can contain anchor rules.

When an
anchor contains more than one named ruleset, they are
evaluated in the alphabetical order of their names.

Rules may
contain anchor attachment points which do not contain
any rules when the main ruleset is loaded, and later such
named rulesets can be manipulated through pfctl(8) without
reloading the main ruleset. For example,

ext_if =
"kue0" 
block on $ext_if all 
anchor spam 
pass out on $ext_if all keep state 
pass in on $ext_if proto tcp from any \ 
to $ext_if port smtp keep state

blocks all
packets on the external interface by default, then evaluates
all rulesets in the anchor named "spam",
and finally passes all outgoing connections and incoming
connections to port 25.

# echo
"block in quick from 1.2.3.4 to any" | \ 
pfctl -a spam:manual -f -

loads a single
ruleset containing a single rule into the anchor,
which blocks all packets from a specific address.

The named
ruleset can also be populated by adding a load anchor
rule after the anchor rule:

anchor spam

load anchor spam:manual from
"/etc/pf-spam.conf"

When pfctl(8)
loads pf.conf, it will also load all the rules from
the file /etc/pf-spam.conf into the named
ruleset.

Optionally,
anchor rules can specify the parameterâ€™s
direction, interface, address family, protocol and
source/destination address/port using the same syntax as
filter rules. When parameters are used, the anchor
rule is only evaluated for matching packets. This allows
conditional evaluation of named rulesets, like:

block on
$ext_if all 
anchor spam proto tcp from any to any port smtp 
pass out on $ext_if all keep state 
pass in on $ext_if proto tcp from any to $ext_if port smtp
keep state

The rules inside
anchor spam are only evaluated for tcp packets
with destination port 25. Hence,

# echo
"block in quick from 1.2.3.4 to any" | \ 
pfctl -a spam:manual -f -

will only block
connections from 1.2.3.4 to port 25.

TRANSLATION EXAMPLES

This example maps incoming
requests on port 80 to port 8080, on which a daemon is
running (because, for example, it is not run as root, and
therefore lacks permission to bind to port 80).

# use a macro
for the interface name, so it can be changed easily 
ext_if = "ne3"

# map daemon on
8080 to appear to be on 80 
rdr on $ext_if proto tcp from any to any port 80 ->
127.0.0.1 port 8080

If the
pass modifier is given, packets matching the
translation rule are passed without inspecting the filter
rules:

rdr pass on
$ext_if proto tcp from any to any port 80 -> 127.0.0.1 \

port 8080

In the example
below, vlan12 is configured as 192.168.168.1; the machine
translates all packets coming from 192.168.168.0/24 to
204.92.77.111 when they are going out any interface except
vlan12. This has the net effect of making traffic from the
192.168.168.0/24 network appear as though it is the Internet
routable address 204.92.77.111 to nodes behind any interface
on the router except for the nodes on vlan12. (Thus,
192.168.168.1 can talk to the 192.168.168.0/24 nodes.)

nat on ! vlan12
from 192.168.168.0/24 to any -> 204.92.77.111

In the example
below, the machine sits between a fake internal 144.19.74.*
network, and a routable external IP of 204.92.77.100. The
no nat rule excludes protocol AH from being
translated.

# NO NAT 
no nat on $ext_if proto ah from 144.19.74.0/24 to any 
nat on $ext_if from 144.19.74.0/24 to any ->
204.92.77.100

In the example
below, packets bound for one specific server, as well as
those generated by the sysadmins are not proxied; all other
connections are.

# NO RDR 
no rdr on $int_if proto { tcp, udp } from any to $server
port 80 
no rdr on $int_if proto { tcp, udp } from $sysadmins to any
port 80 
rdr on $int_if proto { tcp, udp } from any to any port 80
-> 127.0.0.1 \ 
port 80

This longer
example uses both a NAT and a redirection. The external
interface has the address 157.161.48.183. On the internal
interface, we are running ftp-proxy(8), listening for
outbound ftp sessions captured to port 8021.

# NAT 
# Translate outgoing packetsâ€™ source addresses (any
protocol). 
# In this case, any address but the gatewayâ€™s external
address is mapped. 
nat on $ext_if inet from ! ($ext_if) to any ->
($ext_if)

# NAT PROXYING

# Map outgoing packetsâ€™ source port to an assigned
proxy port instead of 
# an arbitrary port. 
# In this case, proxy outgoing isakmp with port 500 on the
gateway. 
nat on $ext_if inet proto udp from any port = isakmp to any
-> ($ext_if) \ 
port 500

# BINAT 
# Translate outgoing packetsâ€™ source address (any
protocol). 
# Translate incoming packetsâ€™ destination address to
an internal machine 
# (bidirectional). 
binat on $ext_if from 10.1.2.150 to any -> ($ext_if)

# RDR 
# Translate incoming packetsâ€™ destination addresses.

# As an example, redirect a TCP and UDP port to an internal
machine. 
rdr on $ext_if inet proto tcp from any to ($ext_if) port
8080 \ 
-> 10.1.2.151 port 22 
rdr on $ext_if inet proto udp from any to ($ext_if) port
8080 \ 
-> 10.1.2.151 port 53

# RDR 
# Translate outgoing ftp control connections to send them to
localhost 
# for proxying with ftp-proxy(8) running on port 8021. 
rdr on $int_if proto tcp from any to any port 21 ->
127.0.0.1 port 8021

In this example,
a NAT gateway is set up to translate internal addresses
using a pool of public addresses (192.0.2.16/28) and to
redirect incoming web server connections to a group of web
servers on the internal network.

# NAT LOAD
BALANCE 
# Translate outgoing packetsâ€™ source addresses using
an address pool. 
# A given source address is always translated to the same
pool address by 
# using the source-hash keyword. 
nat on $ext_if inet from any to any -> 192.0.2.16/28
source-hash

# RDR ROUND
ROBIN 
# Translate incoming web server connections to a group of
web servers on 
# the internal network. 
rdr on $ext_if proto tcp from any to any port 80 \ 
-> { 10.1.2.155, 10.1.2.160, 10.1.2.161 } round-robin

FILTER EXAMPLES

# The external interface is kue0

# (157.161.48.183, the only routable address) 
# and the private network is 10.0.0.0/8, for which we are
doing NAT.

# use a macro
for the interface name, so it can be changed easily 
ext_if = "kue0"

# normalize all
incoming traffic 
scrub in on $ext_if all fragment reassemble

# block and log
everything by default 
block return log on $ext_if all

# block anything
coming from source we have no back routes for 
block in from no-route to any

# block and log
outgoing packets that do not have our address as source,

# they are either spoofed or something is misconfigured (NAT
disabled, 
# for instance), we want to be nice and do not send out
garbage. 
block out log quick on $ext_if from ! 157.161.48.183 to
any

# silently drop
broadcasts (cable modem noise) 
block in quick on $ext_if from any to 255.255.255.255

# block and log
incoming packets from reserved address space and invalid

# addresses, they are either spoofed or misconfigured, we
cannot reply to 
# them anyway (hence, no return-rst). 
block in log quick on $ext_if from { 10.0.0.0/8,
172.16.0.0/12, \ 
192.168.0.0/16, 255.255.255.255/32 } to any

# ICMP

# pass out/in
certain ICMP queries and keep state (ping) 
# state matching is done on host addresses and ICMP id (not
type/code), 
# so replies (like 0/0 for 8/0) will match queries 
# ICMP error messages (which always refer to a TCP/UDP
packet) are 
# handled by the TCP/UDP states 
pass on $ext_if inet proto icmp all icmp-type 8 code 0 keep
state

# UDP

# pass out all
UDP connections and keep state 
pass out on $ext_if proto udp all keep state

# pass in
certain UDP connections and keep state (DNS) 
pass in on $ext_if proto udp from any to any port domain
keep state

# TCP

# pass out all
TCP connections and modulate state 
pass out on $ext_if proto tcp all modulate state

# pass in
certain TCP connections and keep state (SSH, SMTP, DNS,
IDENT) 
pass in on $ext_if proto tcp from any to any port { ssh,
smtp, domain, \ 
auth } flags S/SA keep state

# pass in data
mode connections for ftp-proxy running on this host. 
# (see ftp-proxy(8) for details) 
pass in on $ext_if proto tcp from any to 157.161.48.183 port
>= 49152 \ 
flags S/SA keep state

# Do not allow
Windows 9x SMTP connections since they are typically 
# a viral worm. Alternately we could limit these OSes to 1
connection each. 
block in on $ext_if proto tcp from any os {"Windows
95", "Windows 98"} \ 
to any port smtp

# Packet
Tagging

# three
interfaces: $int_if, $ext_if, and $wifi_if (wireless). NAT
is 
# being done on $ext_if for all outgoing packets. tag
packets in on 
# $int_if and pass those tagged packets out on $ext_if. all
other 
# outgoing packets (i.e., packets from the wireless network)
are only 
# permitted to access port 80.

pass in on
$int_if from any to any tag INTNET keep state 
pass in on $wifi_if from any to any keep state

block out on
$ext_if from any to any 
pass out quick on $ext_if tagged INTNET keep state 
pass out on $ext_if from any to any port 80 keep state

# tag incoming
packets as they are redirected to spamd(8). use the tag 
# to pass those packets through the packet filter.

rdr on $ext_if
inet proto tcp from  to port smtp \

tag SPAMD -> 127.0.0.1 port spamd

block in on
$ext_if 
pass in on $ext_if inet proto tcp tagged SPAMD keep
state

GRAMMAR

Syntax for pf.conf in
BNF:

line = ( option
| pf-rule | nat-rule | binat-rule | rdr-rule | 
antispoof-rule | altq-rule | queue-rule | anchor-rule | 
trans-anchors | load-anchors | table-rule )

option =
"set" ( [ "timeout" ( timeout |
"{" timeout-list "}" ) ] | 
[ "optimization" [ "default" |
"normal" | 
"high-latency" | "satellite" | 
"aggressive" | "conservative" ] ] 
[ "limit" ( limit-item | "{" limit-list
"}" ) ] | 
[ "loginterface" ( interface-name |
"none" ) ] | 
[ "block-policy" ( "drop" |
"return" ) ] |

[ "state-policy" ( "if-bound" |
"group-bound" |

"floating" ) ] 
[ "require-order" ( "yes" |
"no" ) ] 
[ "fingerprints" filename ] | 
[ "debug" ( "none" | "urgent"
| "misc" | "loud" ) ] )

pf-rule = action
[ ( "in" | "out" ) ] 
[ "log" | "log-all" ] [
"quick" ] 
[ "on" ifspec ] [ route ] [ af ] [ protospec ]

hosts [ filteropt-list ]

filteropt-list =
filteropt-list filteropt | filteropt 
filteropt = user | group | flags | icmp-type | icmp6-type |
tos | 
( "keep" | "modulate" |
"synproxy" ) "state" 
[ "(" state-opts ")" ] | 
"fragment" | "no-df" |
"min-ttl" number | 
"max-mss" number | "random-id" |
"reassemble tcp" | 
fragmentation | "allow-opts" | 
"label" string | "tag" string | [ ! ]
"tagged" string 
"queue" ( string | "(" string [ [
"," ] string ] ")" )

nat-rule = [
"no" ] "nat" [ "pass" ] [
"on" ifspec ] [ af ] 
[ protospec ] hosts [ "tag" string ] 
[ "->" ( redirhost | "{"
redirhost-list "}" ) 
[ portspec ] [ pooltype ] [ "static-port" ] ]

binat-rule = [
"no" ] "binat" [ "pass" ] [
"on" interface-name ] 
[ af ] [ "proto" ( proto-name | proto-number ) ]

"from" address [ "/" mask-bits ]
"to" ipspec 
[ "tag" string ] 
[ "->" address [ "/" mask-bits ]
]

rdr-rule = [
"no" ] "rdr" [ "pass" ] [
"on" ifspec ] [ af ] 
[ protospec ] hosts [ "tag" string ] 
[ "->" ( redirhost | "{"
redirhost-list "}" ) 
[ portspec ] [ pooltype ] ]

antispoof-rule =
"antispoof" [ "log" ] [
"quick" ] 
"for" ( interface-name | "{"
interface-list "}" ) 
[ af ] [ "label" string ]

table-rule =
"table" "" [
tableopts-list ] 
tableopts-list = tableopts-list tableopts | tableopts 
tableopts = "persist" | "const" |
"file" string | 
"{" [ tableaddr-list ] "}" 
tableaddr-list = tableaddr-list [ "," ]
tableaddr-spec | tableaddr-spec 
tableaddr-spec = [ "!" ] tableaddr [ "/"
mask-bits ] 
tableaddr = hostname | ipv4-dotted-quad | ipv6-coloned-hex |

interface-name | "self"

altq-rule =
"altq on" interface-name queueopts-list 
"queue" subqueue 
queue-rule = "queue" string [ "on"
interface-name ] queueopts-list 
subqueue

anchor-rule =
"anchor" string [ ( "in" |
"out" ) ] [ "on" ifspec ] 
[ af ] [ "proto" ] [ protospec ] [ hosts ]

trans-anchors =
( "nat-anchor" | "rdr-anchor" |
"binat-anchor" ) string 
[ "on" ifspec ] [ af ] [ "proto" ] [
protospec ] [ hosts ]

load-anchor =
"load anchor" anchorname:rulesetname
"from" filename

queueopts-list =
queueopts-list queueopts | queueopts 
queueopts = [ "bandwidth" bandwidth-spec ] | 
[ "qlimit" number ] | [ "tbrsize" number
] | 
[ "priority" number ] | [ schedulers ] 
schedulers = ( cbq-def | priq-def | hfsc-def ) 
bandwidth-spec = "number" ( "b" |
"Kb" | "Mb" | "Gb" |
"%" )

action =
"pass" | "block" [ return ] |
"scrub" 
return = "drop" | "return" |
"return-rst" [ "( ttl" number
")" ] | 
"return-icmp" [ "(" icmpcode
["," icmp6code ] ")" ] | 
"return-icmp6" [ "(" icmp6code
")" ] 
icmpcode = ( icmp-code-name | icmp-code-number ) 
icmp6code = ( icmp6-code-name | icmp6-code-number )

ifspec = ( [
"!" ] interface-name ) | "{"
interface-list "}" 
interface-list = [ "!" ] interface-name [ [
"," ] interface-list ] 
route = "fastroute" | 
( "route-to" | "reply-to" |
"dup-to" ) 
( routehost | "{" routehost-list "}" )

[ pooltype ] 
af = "inet" | "inet6"

protospec =
"proto" ( proto-name | proto-number | 
"{" proto-list "}" ) 
proto-list = ( proto-name | proto-number ) [ [ ","
] proto-list ]

hosts =
"all" | 
"from" ( "any" | "no-route" |
"self" | host | 
"{" host-list "}" ) [ port ] [ os ] 
"to" ( "any" | "no-route" |
"self" | host | 
"{" host-list "}" ) [ port ]

ipspec =
"any" | host | "{" host-list
"}" 
host = [ "!" ] ( address [ "/" mask-bits
] | "" ) 
redirhost = address [ "/" mask-bits ] 
routehost = ( interface-name [ address [ "/"
mask-bits ] ] ) 
address = ( interface-name | "(" interface-name
")" | hostname | 
ipv4-dotted-quad | ipv6-coloned-hex ) 
host-list = host [ [ "," ] host-list ] 
redirhost-list = redirhost [ [ "," ]
redirhost-list ] 
routehost-list = routehost [ [ "," ]
routehost-list ]

port =
"port" ( unary-op | binary-op | "{"
op-list "}" ) 
portspec = "port" ( number | name ) [
":" ( "*" | number | name ) ] 
os = "os" ( os-name | "{" os-list
"}" ) 
user = "user" ( unary-op | binary-op |
"{" op-list "}" ) 
group = "group" ( unary-op | binary-op |
"{" op-list "}" )

unary-op = [
"=" | "!=" | "" | ">=" ]

( name | number ) 
binary-op = number ( "<>" |
">
op-list = ( unary-op | binary-op ) [ [ "," ]
op-list ]

os-name =
operating-system-name 
os-list = os-name [ [ "," ] os-list ]

flags =
"flags" [ flag-set ] "/" flag-set 
flag-set = [ "F" ] [ "S" ] [
"R" ] [ "P" ] [ "A" ] [
"U" ] [ "E" ] 
[ "W" ]

icmp-type =
"icmp-type" ( icmp-type-code | "{"
icmp-list "}" ) 
icmp6-type = "icmp6-type" ( icmp-type-code |
"{" icmp-list "}" ) 
icmp-type-code = ( icmp-type-name | icmp-type-number ) 
[ "code" ( icmp-code-name | icmp-code-number ) ]

icmp-list = icmp-type-code [ [ "," ] icmp-list
]

tos =
"tos" ( "lowdelay" |
"throughput" | "reliability" | 
[ "0x" ] number )

state-opts =
state-opt [ [ "," ] state-opts ] 
state-opt = ( "max" number | "no-sync" |
timeout | 
"source-track" [ ( "rule" |
"global" ) ] |

"max-src-nodes" number |
"max-src-states" number |

"if-bound" |
"group-bound" | "floating" )

fragmentation =
[ "fragment reassemble" | "fragment
crop" | 
"fragment drop-ovl" ]

timeout-list =
timeout [ [ "," ] timeout-list ] 
timeout = ( "tcp.first" | "tcp.opening"
| "tcp.established" | 
"tcp.closing" | "tcp.finwait" |
"tcp.closed" | 
"udp.first" | "udp.single" |
"udp.multiple" | 
"icmp.first" | "icmp.error" | 
"other.first" | "other.single" |
"other.multiple" | 
"frag" | "interval" |
"src.track" | 
"adaptive.start" | "adaptive.end" )
number

limit-list =
limit-item [ [ "," ] limit-list ] 
limit-item = ( "states" | "frags" |
"src-nodes" ) number

pooltype = (
"bitmask" | "random" | 
"source-hash" [ ( hex-key | string-key ) ] | 
"round-robin" ) [ sticky-address ]

subqueue =
string | "{" queue-list "}" 
queue-list = string [ [ "," ] string ] 
cbq-def = "cbq" [ "(" cbq-opt [ [
"," ] cbq-opt ] ")" ] 
priq-def = "priq" [ "(" priq-opt [ [
"," ] priq-opt ] ")" ] 
hfsc-def = "hfsc" [ "(" hfsc-opt [ [
"," ] hfsc-opt ] ")" ] 
cbq-opt = ( "default" | "borrow" |
"red" | "ecn" | "rio" ) 
priq-opt = ( "default" | "red" |
"ecn" | "rio" ) 
hfsc-opt = ( "default" | "red" |
"ecn" | "rio" | 
linkshare-sc | realtime-sc | upperlimit-sc ) 
linkshare-sc = "linkshare" sc-spec 
realtime-sc = "realtime" sc-spec 
upperlimit-sc = "upperlimit" sc-spec 
sc-spec = ( bandwidth-spec | 
"(" bandwidth-spec number bandwidth-spec
")" )

FILES 
/etc/hosts

Host name
database.

/etc/pf.conf

Default
location of the ruleset file.

/etc/pf.os

Default
location of OS fingerprints.

/etc/protocols

Protocol name
database.

/etc/services

Service name
database.

/usr/share/examples/pf

Example
rulesets.

BUGS

Due to a lock order reversal
(LOR) with the socket layer, the use of the group and
user filter parameter in conjuction with a Giant-free
netstack can result in a deadlock. If you have to use
group or user you must set
debug.mpsafenet to â€™â€™0â€™â€™ from
the loader(8), for the moment. This workaround will still
produce the LOR, but Giant will protect from the
deadlock.

SEE ALSO

icmp(4), icmp6(4), ip(4),
ip6(4), pf(4), pfsync(4), tcp(4), udp(4), hosts(5),
pf.os(5), protocols(5), services(5), ftp-proxy(8), pfctl(8),
pflogd(8)

HISTORY

The pf.conf file format
first appeared in OpenBSD 3.0.

BSD
October 3, 2004 BSD