NAME

geo_element -
geometrical element of a mesh (rheolef-7.2)

DESCRIPTION

This class
defines a geometrical element. This element is obtained
after the Piola geometrical transformation from a
reference_element(6). The geo_element is
mainly an array of indices for its nodes. These indices
refer to the node table of the geo(2) class. In
addition, this class provides a list of indexes for edges
(in 2D and 3D) and faces (in 3D). These indices refer to the
edge and face lists, respectively, of the geo(2)
class.

IMPLEMENTATION

This
documentation has been generated from file
fem/geo_element/geo_element.h

class
geo_element { 
public:

//
typedefs:

enum { 
_variant_offset = 0, // i.e. type, as triangle(t) or
tetra(T), etc 
_order_offset = 1, // i.e. k, when Pk curved element 
_dis_ie_offset = 2, // internal numbering, depend upon
partitionand nproc 
_ios_dis_ie_offset = 3, // i/o numbering, independent of
parition and nproc 
_master_offset = 4, // (d-1)-side has one or two master
d-element that contains it 
_last_offset = 6 // here starts node indexes, face indexes,
etc 
}; 
// Implementation note: _master_offset reserve 2 size_type
but is used only for sides, 
// i.e. tri or quad in 3d mesh, edge in 2d mesh, or point in
1d 
// => waste a lot of place 
// it would be better with a polymorphic class 
// and the geo class would define an array of smart_pointers
on this class 
// so, we could define edge with or without the 2 size_type
for master elements 
// then, hack_array will become obsolete (good thing) 
// and reference_element could be also polymorphic, avoiding
large swich (variant) 
// in all internal loops. This change of implementation will
be considered 
// in the future. 
typedef reference_element::size_type size_type; 
typedef reference_element::variant_type variant_type; 
typedef size_type* iterator; 
typedef const size_type* const_iterator; 
typedef size_type raw_type;

typedef
geo_element generic_type; 
typedef geo_element_auto
> automatic_type;

typedef
geo_element_indirect::orientation_type orientation_type; //
for sign (+1,-1) 
typedef geo_element_indirect::shift_type shift_type; // for
0..3 face shift 
struct parameter_type { 
variant_type variant; 
size_type order; 
parameter_type (variant_type v =
reference_element::max_variant, size_type o = 0) 
: variant(v), order(o) {} 
};

//
affectation:

geo_element&
operator= (const geo_element& K) 
{ 
reset (K.variant(), K.order()); // resize auto, nothing for
hack 
std::copy (K._data_begin(), K._data_begin() + _data_size(),
_data_begin()); 
reset (K.variant(), K.order()); // reset order=1 for hack,
resize nothing for auto 
return *this; 
} 
virtual ~geo_element() {} 
virtual void reset (variant_type variant, size_type order) =
0;

// implicit
conversion:

operator
reference_element () const { return
reference_element(variant()); }

// accessors
& modifiers:

variant_type
variant() const { return variant_type( *(_data_begin() +
_variant_offset)); } 
size_type order() const { return *(_data_begin() +
_order_offset); } 
size_type dis_ie() const { return *(_data_begin() +
_dis_ie_offset); } 
size_type ios_dis_ie() const { return *(_data_begin() +
_ios_dis_ie_offset); } 
size_type master (bool i) const { return *(_data_begin() +
_master_offset + i); }

size_type
dimension() const { return reference_element::dimension
(variant()); } 
size_type size() const { return reference_element::n_vertex
(variant()); } 
char name() const { return reference_element::name
(variant()); } 
size_type n_node() const { return reference_element::n_node
(variant(), order()); }

void set_dis_ie
(size_type dis_ie) { *(_data_begin() + _dis_ie_offset) =
dis_ie; } 
void set_ios_dis_ie (size_type ios_dis_ie) { *(_data_begin()
+ _ios_dis_ie_offset) = ios_dis_ie; } 
void set_master (bool i, size_type dis_ie) const { 
const_iterator p = _data_begin() + _master_offset + i; //
mutable member fct 
*(const_cast(p)) = dis_ie; 
}

iterator
begin() { return _data_begin() + _node_offset (variant(),
order()); } 
const_iterator begin() const { return _data_begin() +
_node_offset (variant(), order()); } 
iterator end() { return begin() + size(); } 
const_iterator end() const { return begin() + size(); } 
size_type& operator[] (size_type loc_inod) { return
*(begin() + loc_inod); } 
size_type operator[] (size_type loc_inod) const { return
*(begin() + loc_inod); } 
size_type& node (size_type loc_inod) { return operator[]
(loc_inod); } 
size_type node (size_type loc_inod) const { return
operator[] (loc_inod); }

iterator
begin(size_type node_subgeo_dim) { return begin() +
first_inod (node_subgeo_dim); } 
const_iterator begin(size_type node_subgeo_dim) const {
return begin() + first_inod (node_subgeo_dim); } 
iterator end (size_type node_subgeo_dim) { return begin() +
last_inod (node_subgeo_dim); } 
const_iterator end (size_type node_subgeo_dim) const {
return begin() + last_inod (node_subgeo_dim); }

const
geo_element_indirect& edge_indirect (size_type i) const
{ 
const_iterator p = _data_begin() + _edge_offset (variant(),
order()) + i; 
return *(reinterpret_cast(p)); 
} 
const geo_element_indirect& face_indirect (size_type i)
const { 
const_iterator p = _data_begin() + _face_offset (variant(),
order()) + i; 
return *(reinterpret_cast(p)); 
} 
geo_element_indirect& edge_indirect (size_type i) { 
iterator p = _data_begin() + _edge_offset (variant(),
order()) + i; 
return *(reinterpret_cast(p));

} 
geo_element_indirect& face_indirect (size_type i) { 
iterator p = _data_begin() + _face_offset (variant(),
order()) + i; 
return *(reinterpret_cast(p));

} 
size_type edge (size_type i) const { return (dimension()

size_type face (size_type i) const { return (dimension()

size_type
n_subgeo (size_type subgeo_dim) const { 
return reference_element::n_subgeo (variant(), subgeo_dim);
} 
size_type subgeo_dis_index (size_type subgeo_dim, size_type
i) const { 
return (subgeo_dim == 0) ? operator[](i) : (subgeo_dim == 1)
? edge(i) : (subgeo_dim == 2) ? face(i) : dis_ie(); }

size_type
subgeo_n_node (size_type subgeo_dim, size_type loc_isid)
const { 
return reference_element::subgeo_n_node (variant(), order(),
subgeo_dim, loc_isid); } 
size_type subgeo_local_node (size_type subgeo_dim, size_type
loc_isid, size_type loc_jsidnod) const { 
return reference_element::subgeo_local_node (variant(),
order(), subgeo_dim, loc_isid, loc_jsidnod); } 
size_type subgeo_size (size_type subgeo_dim, size_type
loc_isid) const { 
return reference_element::subgeo_n_node (variant(), 1,
subgeo_dim, loc_isid); } 
size_type subgeo_local_vertex(size_type subgeo_dim,
size_type i_subgeo, size_type i_subgeo_vertex) const { 
return reference_element::subgeo_local_node (variant(), 1,
subgeo_dim, i_subgeo, i_subgeo_vertex); } 
size_type first_inod (size_type subgeo_dim) const { 
return reference_element::first_inod (variant(), order(),
subgeo_dim); } 
size_type last_inod (size_type subgeo_dim) const { 
return reference_element::last_inod (variant(), order(),
subgeo_dim); }

size_type
n_edge () const { return n_subgeo (1); } 
size_type n_face () const { return n_subgeo (2); }

// orientation
accessors:

// search S in
all sides of K 
orientation_type get_side_informations ( 
const geo_element& S, 
size_type& loc_isid, 
size_type& shift) const;

void
get_side_informations ( 
const geo_element& S, 
side_information_type& sid) const;

orientation_type
get_side_orientation (const geo_element& S) const;

// compare two
sides: S and *this 
bool get_orientation_and_shift (const geo_element& S,

orientation_type& orient, shift_type& shift) const;

orientation_type get_edge_orientation (size_type dis_iv0,
size_type dis_iv1) const; 
void get_orientation_and_shift ( 
size_type dis_iv0, size_type dis_iv1, size_type dis_iv2,

orientation_type& orient, 
shift_type& shift) const; 
void get_orientation_and_shift ( 
size_type dis_iv0, size_type dis_iv1, size_type dis_iv2,
size_type dis_iv3, 
orientation_type& orient, 
shift_type& shift) const;

// i/o;

void put
(std::ostream& is) const; 
void get (std::istream& os);

};

AUTHOR

Pierre Saramito
Pierre.Saramito [AT] imag.fr>

COPYRIGHT

Copyright (C)
2000-2018 Pierre Saramito Pierre.Saramito [AT] imag.fr>
GPLv3+: GNU GPL version 3 or later
http://gnu.org/licenses/gpl.html>. This is free
software: you are free to change and redistribute it. There
is NO WARRANTY, to the extent permitted by law.