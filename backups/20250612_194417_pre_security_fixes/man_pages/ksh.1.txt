NAME

ksh −
Public domain Korn shell

SYNOPSIS

ksh
[+−abCefhikmnprsuvxX] [+−o
option] [ [ −c command-string
[command-name] | −s | file ]
[argument ...] ]

DESCRIPTION

ksh is a
command interpreter that is intended for both interactive
and shell script use. Its command language is a superset of
the sh(1) shell language.

Shell
Startup 
The following options can be specified only on the command
line: 
−c command-string

the shell executes the
command(s) contained in command-string

−i

interactive mode — see below

−l

login shell — see below interactive mode —
see below

−s

the shell reads commands from standard input; all
non-option arguments are positional parameters

−r

restricted mode — see below

In addition to
the above, the options described in the set built-in
command can also be used on the command line.

If neither the
−c nor the −s options are
specified, the first non-option argument specifies the name
of a file the shell reads commands from; if there are no
non-option arguments, the shell reads commands from standard
input. The name of the shell (i.e., the contents of
the $0) parameter is determined as follows: if the
−c option is used and there is a non-option
argument, it is used as the name; if commands are being read
from a file, the file is used as the name; otherwise the
name the shell was called with (i.e., argv[0]) is
used.

A shell is
interactive if the −i option is used or
if both standard input and standard error are attached to a
tty. An interactive shell has job control enabled (if
available), ignores the INT, QUIT and TERM signals, and
prints prompts before reading input (see PS1 and
PS2 parameters). For non-interactive shells, the
trackall option is on by default (see set
command below).

A shell is
restricted if the −r option is used or
if either the basename of the name the shell is invoked with
or the SHELL parameter match the pattern *r*sh
(e.g., rsh, rksh, rpdksh, etc.). The following
restrictions come into effect after the shell processes any
profile and $ENV files:

   •

the cd command is
disabled 

   •

the SHELL, ENV and PATH parameters
can’t be changed

   •

command names can’t be specified with absolute or
relative paths

   •

the −p option of the command
built-in can’t be used

   •

redirections that create files can’t be used
(i.e., >, >|, >>,
<>) 

A shell is
privileged if the −p option is used or
if the real user-id or group-id does not match the effective
user-id or group-id (see getuid(2),
getgid(2)). A privileged shell does not process
$HOME/.profile nor the ENV parameter (see below),
instead the file /etc/suid_profile is processed. Clearing
the privileged option causes the shell to set its effective
user-id (group-id) to its real user-id (group-id).

If the basename
of the name the shell is called with (i.e., argv[0])
starts with − or if the −l option
is used, the shell is assumed to be a login shell and the
shell reads and executes the contents of /etc/profile
and $HOME/.profile if they exist and are
readable.

If the
ENV parameter is set when the shell starts (or, in
the case of login shells, after any profiles are processed),
its value is subjected to parameter, command, arithmetic and
tilde substitution and the resulting file (if any) is read
and executed. If ENV parameter is not set (and not
null) and pdksh was compiled with the DEFAULT_ENV
macro defined, the file named in that macro is included
(after the above mentioned substitutions have been
performed).

The exit status
of the shell is 127 if the command file specified on the
command line could not be opened, or non-zero if a fatal
syntax error occurred during the execution of a script. In
the absence of fatal errors, the exit status is that of the
last command executed, or zero, if no command is
executed.

Command
Syntax 
The shell begins parsing its input by breaking it into
words. Words, which are sequences of characters, are
delimited by unquoted white-space characters (space,
tab and newline) or meta-characters (,
>, |, ;, &, ( and
)). Aside from delimiting words, spaces and tabs are
ignored, while newlines usually delimit commands. The
meta-characters are used in building the following tokens:
, , , >,
>&, >>, etc. are used to
specify redirections (see Input/Output Redirection below);
| is used to create pipelines; |& is used
to create co-processes (see Co-Processes below); ; is
used to separate commands; & is used to create
asynchronous pipelines; && and || are
used to specify conditional execution; ;; is used in
case statements; (( .. )) are used in
arithmetic expressions; and lastly, ( .. ) are
used to create subshells.

White-space and
meta-characters can be quoted individually using backslash
(\), or in groups using double (") or
single (’) quotes. Note that the following
characters are also treated specially by the shell and must
be quoted if they are to represent themselves: \,
", ’, #, $,
’, ~, {, }, *,
? and [. The first three of these are the
above mentioned quoting characters (see Quoting below);
#, if used at the beginning of a word, introduces a
comment — everything after the # up to the
nearest newline is ignored; $ is used to introduce
parameter, command and arithmetic substitutions (see
Substitution below); ’ introduces an old-style
command substitution (see Substitution below); ~
begins a directory expansion (see Tilde Expansion below);
{ and } delimit csh(1) style
alternations (see Brace Expansion below); and, finally,
*, ? and [ are used in file name
generation (see File Name Patterns below).

As words and
tokens are parsed, the shell builds commands, of which there
are two basic types: simple-commands, typically
programs that are executed, and compound-commands,
such as for and if statements, grouping
constructs and function definitions.

A
simple-command consists of some combination of parameter
assignments (see Parameters below), input/output
redirections (see Input/Output Redirections below), and
command words; the only restriction is that parameter
assignments come before any command words. The command
words, if any, define the command that is to be executed and
its arguments. The command may be a shell built-in command,
a function or an external command, i.e., a
separate executable file that is located using the
PATH parameter (see Command Execution below). Note
that all command constructs have an exit status: for
external commands, this is related to the status returned by
wait(2) (if the command could not be found, the exit
status is 127, if it could not be executed, the exit status
is 126); the exit status of other command constructs
(built-in commands, functions, compound-commands, pipelines,
lists, etc.) are all well defined and are described
where the construct is described. The exit status of a
command consisting only of parameter assignments is that of
the last command substitution performed during the parameter
assignment or zero if there were no command
substitutions.

Commands can be
chained together using the | token to form
pipelines, in which the standard output of each
command but the last is piped (see pipe(2)) to the
standard input of the following command. The exit status of
a pipeline is that of its last command. A pipeline may be
prefixed by the ! reserved word which causes the exit
status of the pipeline to be logically complemented: if the
original status was 0 the complemented status will be 1, and
if the original status was not 0, then the complemented
status will be 0.

Lists of
commands can be created by separating pipelines by any of
the following tokens: &&, ||,
&, |& and ;. The first two are
for conditional execution: cmd1 &&
cmd2 executes cmd2 only if the exit status of
cmd1 is zero; || is the opposite —
cmd2 is executed only if the exit status of
cmd1 is non-zero. && and ||
have equal precedence which is higher than that of
&, |& and ;, which also have
equal precedence. The & token causes the
preceding command to be executed asynchronously, that is,
the shell starts the command, but does not wait for it to
complete (the shell does keep track of the status of
asynchronous commands — see Job Control below). When
an asynchronous command is started when job control is
disabled (i.e., in most scripts), the command is
started with signals INT and QUIT ignored and with input
redirected from /dev/null (however, redirections specified
in the asynchronous command have precedence). The
|& operator starts a co-process which is
special kind of asynchronous process (see Co-Processes
below). Note that a command must follow the
&& and || operators, while a command
need not follow &, |& and ;.
The exit status of a list is that of the last command
executed, with the exception of asynchronous lists, for
which the exit status is 0.

Compound
commands are created using the following reserved words
— these words are only recognized if they are unquoted
and if they are used as the first word of a command
(i.e., they can’t be preceded by parameter
assignments or redirections):

Note: Some shells (but
not this one) execute control structure commands in a
subshell when one or more of their file descriptors are
redirected, so any environment changes inside them may fail.
To be portable, the exec statement should be used
instead to redirect file descriptors before the control
structure.

In the
following compound command descriptions, command lists
(denoted as list) that are followed by reserved words
must end with a semi-colon, a newline or a (syntactically
correct) reserved word. For example,

{ echo foo; echo bar; } 
{ echo foo; echo bar} 
{ { echo foo; echo bar; } }

are all valid, but

{ echo foo; echo bar
}

is not. 
( list )

Execute list in a
subshell. There is no implicit way to pass environment
changes from a subshell back to its parent.

{ list
}

Compound construct; list
is executed, but not in a subshell. Note that { and
} are reserved words, not meta-characters.

case word
in [ [(] pattern [|
pattern] ... ) list ;; ] ...
esac

The case statement
attempts to match word against the specified
patterns; the list associated with the first
successfully matched pattern is executed. Patterns used in
case statements are the same as those used for file
name patterns except that the restrictions regarding
. and / are dropped. Note that any unquoted
space before and after a pattern is stripped; any space with
a pattern must be quoted. Both the word and the patterns are
subject to parameter, command, and arithmetic substitution
as well as tilde substitution. For historical reasons, open
and close braces may be used instead of in and
esac (e.g., case $foo { *) echo bar;
}). The exit status of a case statement is that
of the executed list; if no list is executed,
the exit status is zero.

for name [
in word ... term ] do
list done

where term is either a
newline or a ;. For each word in the specified
word list, the parameter name is set to the word and
list is executed. If in is not used to specify
a word list, the positional parameters
("$1", "$2", etc.)
are used instead. For historical reasons, open and close
braces may be used instead of do and done
(e.g., for i; { echo $i; }). The exit status
of a for statement is the last exit status of
list; if list is never executed, the exit
status is zero.

if list
then list [elif list then
list] ... [else list] fi

If the exit status of the first
list is zero, the second list is executed;
otherwise the list following the elif, if any,
is executed with similar consequences. If all the lists
following the if and elifs fail (i.e.,
exit with non-zero status), the list following the
else is executed. The exit status of an if
statement is that of non-conditional list that is
executed; if no non-conditional list is executed, the
exit status is zero.

select name [
in word ... term ] do
list done

where term is either a
newline or a ;. The select statement provides
an automatic method of presenting the user with a menu and
selecting from it. An enumerated list of the specified
words is printed on standard error, followed by a
prompt (PS3, normally ’#? ’). A
number corresponding to one of the enumerated words is then
read from standard input, name is set to the selected
word (or is unset if the selection is not valid),
REPLY is set to what was read (leading/trailing space
is stripped), and list is executed. If a blank line
(i.e., zero or more IFS characters) is
entered, the menu is re-printed without executing
list. When list completes, the enumerated list
is printed if REPLY is null, the prompt is printed
and so on. This process is continues until an end-of-file is
read, an interrupt is received or a break statement is
executed inside the loop. If in word
... is omitted, the positional parameters are used
(i.e., "$1", "$2",
etc.). For historical reasons, open and close braces
may be used instead of do and done
(e.g., select i; { echo $i; }). The exit
status of a select statement is zero if a break
statement is used to exit the loop, non-zero otherwise.

until list
do list done

This works like while,
except that the body is executed only while the exit status
of the first list is non-zero.

while list
do list done

A while is a prechecked
loop. Its body is executed as often as the exit status of
the first list is zero. The exit status of a
while statement is the last exit status of the
list in the body of the loop; if the body is not
executed, the exit status is zero.

function name
{ list }

Defines the function
name. See Functions below. Note that redirections
specified after a function definition are performed whenever
the function is executed, not when the function definition
is executed.

name ()
command

Mostly the same as
function. See Functions below.

time [ -p ] [
pipeline ]

The time reserved word
is described in the Command Execution section.

(( expression
))

The arithmetic expression
expression is evaluated; equivalent to let
"expression". See Arithmetic
Expressions and the let command below.

[[ expression
]]

Similar to the test and
[ ... ] commands (described later), with the
following exceptions:

   •

Field splitting and file name generation are not
performed on arguments.

   •

The −a (and) and −o (or)
operators are replaced with && and ||,
respectively. 

   •

Operators (e.g., −f, =,
!, etc.) must be unquoted.

   •

The second operand of != and = expressions
are patterns (e.g., the comparison in

[[ foobar = f*r ]] succeeds).

   •

There are two additional binary
operators:  and > which return true if
their first string operand is less than, or greater than,
their second string operand, respectively.

   •

The single argument form of test, which tests if
the argument has non-zero length, is not valid - explicit
operators must be always be used, e.g., instead
of 

[ str ] use 
[[ −n str ]]

   •

Parameter, command and
arithmetic substitutions are performed as expressions are
evaluated and lazy expression evaluation is used for the
&& and || operators. This means that
in the statement

[[ -r foo && $( the $( is evaluated if and only if
the file foo exists and is readable.

Quoting 
Quoting is used to prevent the shell from treating
characters or words specially. There are three methods of
quoting: First, \ quotes the following character,
unless it is at the end of a line, in which case both the
\ and the newline are stripped. Second, a single
quote (’) quotes everything up to the next
single quote (this may span lines). Third, a double quote
(") quotes all characters, except $,
’ and \, up to the next unquoted double
quote. $ and ’ inside double quotes have
their usual meaning (i.e., parameter, command or
arithmetic substitution) except no field splitting is
carried out on the results of double-quoted substitutions.
If a \ inside a double-quoted string is followed by
\, $, ’ or ", it is
replaced by the second character; if it is followed by a
newline, both the \ and the newline are stripped;
otherwise, both the \ and the character following are
unchanged.

Note: see POSIX Mode below for a
special rule regarding sequences of the form
"...’...\"...’..".

Aliases 
There are two types of aliases: normal command aliases and
tracked aliases. Command aliases are normally used as a
short hand for a long or often used command. The shell
expands command aliases (i.e., substitutes the alias
name for its value) when it reads the first word of a
command. An expanded alias is re-processed to check for more
aliases. If a command alias ends in a space or tab, the
following word is also checked for alias expansion. The
alias expansion process stops when a word that is not an
alias is found, when a quoted word is found or when an alias
word that is currently being expanded is found.

The following command aliases
are defined automatically by the shell:

autoload=’typeset
−fu’ 
functions=’typeset −f’ 
hash=’alias −t’ 
history=’fc −l’ 
integer=’typeset −i’ 
local=’typeset’ 
login=’exec login’ 
newgrp=’exec newgrp’ 
nohup=’nohup ’ 
r=’fc −e −’ 
stop=’kill −STOP’ 
suspend=’kill −STOP $$’ 
type=’whence −v’

Tracked aliases
allow the shell to remember where it found a particular
command. The first time the shell does a path search for a
command that is marked as a tracked alias, it saves the full
path of the command. The next time the command is executed,
the shell checks the saved path to see that it is still
valid, and if so, avoids repeating the path search. Tracked
aliases can be listed and created using alias
−t. Note that changing the PATH parameter
clears the saved paths for all tracked aliases. If the
trackall option is set (i.e., set −o
trackall or set −h), the shell tracks all
commands. This option is set automatically for
non-interactive shells. For interactive shells, only the
following commands are automatically tracked: cat,
cc, chmod, cp, date, ed,
emacs, grep, ls, mail,
make, mv, pr, rm, sed,
sh, vi and who.

Substitution

The first step the shell takes in executing a simple-command
is to perform substitutions on the words of the command.
There are three kinds of substitution: parameter, command
and arithmetic. Parameter substitutions, which are described
in detail in the next section, take the form $name or
${...}; command substitutions take the form
$(command) or
’command’; and arithmetic
substitutions take the form
$((expression)).

If a
substitution appears outside of double quotes, the results
of the substitution are generally subject to word or field
splitting according to the current value of the IFS
parameter. The IFS parameter specifies a list of
characters which are used to break a string up into several
words; any characters from the set space, tab and newline
that appear in the IFS characters are called IFS white
space. Sequences of one or more IFS white space
characters, in combination with zero or one non-IFS white
space characters delimit a field. As a special case, leading
and trailing IFS white space is stripped (i.e., no
leading or trailing empty field is created by it); leading
or trailing non-IFS white space does create an empty field.
Example: if IFS is set to
’:’, the sequence of characters
’A:B::D’
contains four fields: ’A’, ’B’,
’’ and ’D’. Note that if the
IFS parameter is set to the null string, no field
splitting is done; if the parameter is unset, the default
value of space, tab and newline is used.

The results of
substitution are, unless otherwise specified, also subject
to brace expansion and file name expansion (see the relevant
sections below).

A command
substitution is replaced by the output generated by the
specified command, which is run in a subshell. For
$(command) substitutions, normal
quoting rules are used when command is parsed,
however, for the ’command’
form, a \ followed by any of $, ’
or \ is stripped (a \ followed by any other
character is unchanged). As a special case in command
substitutions, a command of the form  file
is interpreted to mean substitute the contents of
file ($(
NOTE: $(command) expressions are
currently parsed by finding the matching parenthesis,
regardless of quoting. This will hopefully be fixed
soon.

Arithmetic
substitutions are replaced by the value of the specified
expression. For example, the command echo $((2+3*4))
prints 14. See Arithmetic Expressions for a description of
an expression.

Parameters

Parameters are shell variables; they can be assigned values
and their values can be accessed using a parameter
substitution. A parameter name is either one of the special
single punctuation or digit character parameters described
below, or a letter followed by zero or more letters or
digits (’_’ counts as a letter). The later form
can be treated as arrays by appending an array index of the
form: [expr] where expr is an
arithmetic expression. Array indicies are currently limited
to the range 0 through 1023, inclusive. Parameter
substitutions take the form $name,
${name} or
${name[expr]}, where
name is a parameter name. If substitution is
performed on a parameter (or an array parameter element)
that is not set, a null string is substituted unless the
nounset option (set −o nounset or set
−u) is set, in which case an error occurs.

Parameters can
be assigned values in a number of ways. First, the shell
implicitly sets some parameters like #, PWD,
etc.; this is the only way the special single character
parameters are set. Second, parameters are imported from the
shell’s environment at startup. Third, parameters can
be assigned values on the command line, for example,
’FOO=bar’ sets the parameter FOO to bar;
multiple parameter assignments can be given on a single
command line and they can be followed by a simple-command,
in which case the assignments are in effect only for the
duration of the command (such assignments are also exported,
see below for implications of this). Note that both the
parameter name and the = must be unquoted for the
shell to recognize a parameter assignment. The fourth way of
setting a parameter is with the export,
readonly and typeset commands; see their
descriptions in the Command Execution section. Fifth,
for and select loops set parameters as well as
the getopts, read and set −A
commands. Lastly, parameters can be assigned values using
assignment operators inside arithmetic expressions (see
Arithmetic Expressions below) or using the
${name=value} form of
parameter substitution (see below).

Parameters with
the export attribute (set using the export or
typeset −x commands, or by parameter
assignments followed by simple commands) are put in the
environment (see environ(7)) of commands run by the
shell as name=value pairs. The order in
which parameters appear in the environment of a command is
unspecified. When the shell starts up, it extracts
parameters and their values from its environment and
automatically sets the export attribute for those
parameters.

Modifiers can
be applied to the ${name} form of
parameter substitution: 
${name:-word}

if name is set and not
null, it is substituted, otherwise word is
substituted.

${name:+word}

if name is set and not
null, word is substituted, otherwise nothing is
substituted.

${name:=word}

if name is set and not
null, it is substituted, otherwise it is assigned
word and the resulting value of name is
substituted.

${name:?word}

if name is set and not
null, it is substituted, otherwise word is printed on
standard error (preceded by name:) and an error
occurs (normally causing termination of a shell script,
function or .-script). If word is omitted the string
’parameter null or not set’ is used instead.

In the above
modifiers, the : can be omitted, in which case the
conditions only depend on name being set (as opposed
to set and not null). If word is needed, parameter,
command, arithmetic and tilde substitution are performed on
it; if word is not needed, it is not evaluated.

The following
forms of parameter substitution can also be used: 
${#name}

The number of positional
parameters if name is *, @ or is not
specified, or the length of the string value of parameter
name.

${#name[*]},
${#name[@]}

The number of elements in the
array name.

${name#pattern},
${name##pattern}

If pattern matches the
beginning of the value of parameter name, the matched
text is deleted from the result of substitution. A single
# results in the shortest match, two #’s
results in the longest match.

${name%pattern},
${name%%pattern}

Like
${..#..} substitution, but it deletes
from the end of the value.

The following
special parameters are implicitly set by the shell and
cannot be set directly using assignments:

!

Process id of the last background process started. If no
background processes have been started, the parameter is not
set. 

#

The number of positional parameters (i.e.,
$1, $2, etc.).

$

The process ID of the shell, or the PID of the original
shell if it is a subshell.

−

The concatenation of the current single letter options
(see set command below for list of options).

?

The exit status of the last non-asynchronous command
executed. If the last command was killed by a signal,
$? is set to 128 plus the signal number.

0

The name the shell was invoked with (i.e.,
argv[0]), or the command-name if it was
invoked with the −c option and the
command-name was supplied, or the file
argument, if it was supplied. If the posix option is
not set, $0 is the name of the current function or
script. 

1 ... 9

The first nine positional
parameters that were supplied to the shell, function or
.-script. Further positional parameters may be
accessed using ${number}.

*

All positional parameters (except parameter 0),
i.e., $1 $2 $3.... If used outside of double
quotes, parameters are separate words (which are subjected
to word splitting); if used within double quotes, parameters
are separated by the first character of the IFS
parameter (or the empty string if IFS is null).

@

Same as $*, unless it is used inside double
quotes, in which case a separate word is generated for each
positional parameter − if there are no positional
parameters, no word is generated ("$@" can be used
to access arguments, verbatim, without loosing null
arguments or splitting arguments with spaces).

The following
parameters are set and/or used by the shell: 
_ (underscore)

When an external command is
executed by the shell, this parameter is set in the
environment of the new process to the path of the executed
command. In interactive use, this parameter is also set in
the parent shell to the last word of the previous command.
When MAILPATH messages are evaluated, this parameter
contains the name of the file that changed (see
MAILPATH parameter below).

CDPATH

Search path for the cd built-in command. Works
the same way as PATH for those directories not
beginning with / in cd commands. Note that if
CDPATH is set and does not contain . nor an empty
path, the current directory is not searched.

COLUMNS

Set to the number of columns on
the terminal or window. Currently set to the cols
value as reported by stty(1) if that value is
non-zero. This parameter is used by the interactive line
editing modes, and by select, set −o and
kill −l commands to format information in
columns.

EDITOR

If the VISUAL parameter is not set, this
parameter controls the command line editing mode for
interactive shells. See VISUAL parameter below for
how this works.

ENV

If this parameter is found to be set after any profile
files are executed, the expanded value is used as a shell
start-up file. It typically contains function and alias
definitions. 

ERRNO

Integer value of the shell’s errno variable
— indicates the reason the last system call
failed. 

Not implemented
yet.

EXECSHELL

If set, this parameter is
assumed to contain the shell that is to be used to execute
commands that execve(2) fails to execute and which do
not start with a ’#! shell’
sequence.

FCEDIT

The editor used by the fc command (see
below). 

FPATH

Like PATH, but used when an undefined function is
executed to locate the file defining the function. It is
also searched when a command can’t be found using
PATH. See Functions below for more information.

HISTFILE

The name of the file used to
store history. When assigned to, history is loaded from the
specified file. Also, several invocations of the shell
running on the same machine will share history if their
HISTFILE parameters all point at the same file. 
NOTE: if HISTFILE isn’t set, no history file is used.
This is different from the original Korn shell, which uses
$HOME/.sh_history; in future, pdksh may also use a
default history file.

HISTSIZE

The number of commands normally
stored for history, default 128.

HOME

The default directory for the cd command and the
value substituted for an unqualified ~ (see Tilde
Expansion below).

IFS

Internal field separator, used during substitution and
by the read command, to split values into distinct
arguments; normally set to space, tab and newline. See
Substitution above for details.

Note: this parameter is
not imported from the environment when the shell is
started.

KSH_VERSION

The version of shell and the
date the version was created (readonly). See also the
version commands in Emacs Editing Mode and Vi Editing Mode
sections, below.

LINENO

The line number of the function or shell script that is
currently being executed.

LINES

Set to the number of lines on the terminal or
window. 

Not implemented
yet.

MAIL

If set, the user will be
informed of the arrival of mail in the named file. This
parameter is ignored if the MAILPATH parameter is
set. 

MAILCHECK

How often, in seconds, the
shell will check for mail in the file(s) specified by
MAIL or MAILPATH. If 0, the shell checks
before each prompt. The default is 600 (10 minutes).

MAILPATH

A list of files to be checked
for mail. The list is colon separated, and each file may be
followed by a ? and a message to be printed if new
mail has arrived. Command, parameter and arithmetic
substitution is performed on the message, and, during
substitution, the parameter $_ contains the name of
the file. The default message is you have mail in
$_.

OLDPWD

The previous working directory. Unset if cd has
not successfully changed directories since the shell
started, or if the shell doesn’t know where it is.

OPTARG

When using getopts, it contains the argument for
a parsed option, if it requires one.

OPTIND

The index of the last argument processed when using
getopts. Assigning 1 to this parameter causes
getopts to process arguments from the beginning the
next time it is invoked.

PATH

A colon separated list of directories that are searched
when looking for commands and .’d files. An
empty string resulting from a leading or trailing colon, or
two adjacent colons is treated as a ’.’, the
current directory.

POSIXLY_CORRECT

If set, this parameter causes
the posix option to be enabled. See POSIX Mode
below.

PPID

The process ID of the shell’s parent
(readonly). 

PS1

PS1 is the primary prompt for interactive shells.
Parameter, command and arithmetic substitutions are
performed, and ! is replaced with the current command
number (see fc command below). A literal ! can be put
in the prompt by placing !! in PS1. Note that since the
command line editors try to figure out how long the prompt
is (so they know how far it is to edge of the screen),
escape codes in the prompt tend to mess things up. You can
tell the shell not to count certain sequences (such as
escape codes) by prefixing your prompt with a non-printing
character (such as control-A) followed by a carriage return
and then delimiting the escape codes with this non-printing
character. If you don’t have any non-printing
characters, you’re out of luck... BTW, don’t
blame me for this hack; it’s in the original ksh.
Default is ’$ ’ for non-root users,
’# ’ for root..

PS2

Secondary prompt string, by default ’>
’, used when more input is needed to complete a
command. 

PS3

Prompt used by select statement when reading a
menu selection. Default is
’#? ’. 

PS4

Used to prefix commands that are printed during
execution tracing (see set −x command below).
Parameter, command and arithmetic substitutions are
performed before it is printed. Default is
’+ ’. 

PWD

The current working directory. Maybe unset or null if
shell doesn’t know where it is.

RANDOM

A simple random number generator. Every time
RANDOM is referenced, it is assigned the next number
in a random number series. The point in the series can be
set by assigning a number to RANDOM (see
rand(3)). 

REPLY

Default parameter for the read command if no
names are given. Also used in select loops to store
the value that is read from standard input.

SECONDS

The number of seconds since the
shell started or, if the parameter has been assigned an
integer value, the number of seconds since the assignment
plus the value that was assigned.

TMOUT

If set to a positive integer in an interactive shell, it
specifies the maximum number of seconds the shell will wait
for input after printing the primary prompt (PS1). If
the time is exceeded, the shell exits.

TMPDIR

The directory shell temporary files are created in. If
this parameter is not set, or does not contain the absolute
path of a writable directory, temporary files are created in
/tmp. 

VISUAL

If set, this parameter controls the command line editing
mode for interactive shells. If the last component of the
path specified in this parameter contains the string
vi, emacs or gmacs, the vi, emacs or
gmacs (Gosling emacs) editing mode is enabled,
respectively. 

Tilde
Expansion 
Tilde expansion, which is done in parallel with parameter
substitution, is done on words starting with an unquoted
~. The characters following the tilde, up to the
first /, if any, are assumed to be a login name. If
the login name is empty, + or −, the
value of the HOME, PWD, or OLDPWD
parameter is substituted, respectively. Otherwise, the
password file is searched for the login name, and the tilde
expression is substituted with the user’s home
directory. If the login name is not found in the password
file or if any quoting or parameter substitution occurs in
the login name, no substitution is performed.

In parameter
assignments (those preceding a simple-command or those
occurring in the arguments of alias, export,
readonly, and typeset), tilde expansion is
done after any unquoted colon (:), and login names
are also delimited by colons.

The home
directory of previously expanded login names are cached and
re-used. The alias −d command may be used to
list, change and add to this cache (e.g.,
’alias −d fac=/usr/local/facilities; cd
~fac/bin’).

Brace
Expansion (alternation) 
Brace expressions, which take the form

prefix{str1,...,strN}suffix

are expanded to N words, each
of which is the concatenation of prefix, stri
and suffix (e.g., ’a{c,b{X,Y},d}e’
expands to four word: ace, abXe, abYe, and ade). As noted in
the example, brace expressions can be nested and the
resulting words are not sorted. Brace expressions must
contain an unquoted comma (,) for expansion to occur
(i.e., {} and {foo} are not expanded).
Brace expansion is carried out after parameter substitution
and before file name generation.

File Name
Patterns 
A file name pattern is a word containing one or more
unquoted ? or * characters or
[..] sequences. Once brace expansion has been
performed, the shell replaces file name patterns with the
sorted names of all the files that match the pattern (if no
files match, the word is left unchanged). The pattern
elements have the following meaning:

?

matches any single
character. 

*

matches any sequence of characters.

[..]

matches any of the characters inside the brackets.
Ranges of characters can be specified by separating two
characters by a −, e.g.,
[a0−9] matches the letter a or any
digit. In order to represent itself, a − must
either be quoted or the first or last character in the
character list. Similarly, a ] must be quoted or the
first character in the list if it is represent itself
instead of the end of the list. Also, a ! appearing
at the start of the list has special meaning (see below), so
to represent itself it must be quoted or appear later in the
list. 

[!..]

like [..], except it matches any character
not inside the brackets.

*(pattern|
... |pattern)

matches any string of
characters that matches zero or more occurances of the
specified patterns. Example: the pattern *(foo|bar)
matches the strings ’’, ’foo’,
’bar’, ’foobarfoo’, etc..

+(pattern|
... |pattern)

matches any string of
characters that matches one or more occurances of the
specified patterns. Example: the pattern +(foo|bar)
matches the strings ’foo’, ’bar’,
’foobarfoo’, etc..

?(pattern|
... |pattern)

matches the empty string or a
string that matches one of the specified patterns. Example:
the pattern ?(foo|bar) only matches the strings
’’, ’foo’ and ’bar’.

@(pattern|
... |pattern)

matches a string that matches
one of the specified patterns. Example: the pattern
@(foo|bar) only matches the strings ’foo’
and ’bar’.

!(pattern|
... |pattern)

matches any string that does
not match one of the specified patterns. Examples: the
pattern !(foo|bar) matches all strings except
’foo’ and ’bar’; the pattern
!(*) matches no strings; the pattern !(?)*
matches all strings (think about it).

Note that pdksh
currently never matches . and .., but the
original ksh, Bourne sh and bash do, so this may have to
change (too bad).

Note that none
of the above pattern elements match either a period
(.) at the start of a file name or a slash
(/), even if they are explicitly used in a
[..] sequence; also, the names . and
.. are never matched, even by the pattern
.*.

If the
markdirs option is set, any directories that result
from file name generation are marked with a trailing
/.

The POSIX
character classes (i.e.,
[:class-name:] inside a
[..] expression) are not yet implemented.

Input/Output
Redirection 
When a command is executed, its standard input, standard
output and standard error (file descriptors 0, 1 and 2,
respectively) are normally inherited from the shell. Three
exceptions to this are commands in pipelines, for which
standard input and/or standard output are those set up by
the pipeline, asynchronous commands created when job control
is disabled, for which standard input is initially set to be
from /dev/null, and commands for which any of the
following redirections have been specified:

> file

standard output is redirected to file. If
file does not exist, it is created; if it does exist,
is a regular file and the noclobber option is set, an
error occurs, otherwise the file is truncated. Note that
this means the command cmd  foo will
open foo for reading and then truncate it when it
opens it for writing, before cmd gets a chance to
actually read foo.

>| file

same as >, except the
file is truncated, even if the noclobber option is
set.

>> file

same as >, except the
file an existing file is appended to instead of being
truncated. Also, the file is opened in append mode, so
writes always go to the end of the file (see
open(2)).

 file

standard input is redirected from file, which is
opened for reading.

<> file

same as , except the
file is opened for reading and writing.

marker

after reading the command line
containing this kind of redirection (called a here
document), the shell copies lines from the command source
into a temporary file until a line matching marker is
read. When the command is executed, standard input is
redirected from the temporary file. If marker
contains no quoted characters, the contents of the temporary
file are processed as if enclosed in double quotes each time
the command is executed, so parameter, command and
arithmetic substitutions are performed, along with backslash
(\) escapes for $, ’, \
and \newline. If multiple here documents are used on
the same command line, they are saved in order.

marker

same as , except
leading tabs are stripped from lines in the here
document.

 fd

standard input is duplicated from file descriptor
fd. fd can be a single digit, indicating the
number of an existing file descriptor, the letter p,
indicating the file descriptor associated with the output of
the current co-process, or the character −,
indicating standard input is to be closed.

>& fd

same as , except the operation is done
on standard output.

In any of the
above redirections, the file descriptor that is redirected
(i.e., standard input or standard output) can be
explicitly given by preceding the redirection with a single
digit. Parameter, command and arithmetic substitutions,
tilde substitutions and (if the shell is interactive) file
name generation are all performed on the file,
marker and fd arguments of redirections. Note
however, that the results of any file name generation are
only used if a single file is matched; if multiple files
match, the word with the unexpanded file name generation
characters is used. Note that in restricted shells,
redirections which can create files cannot be used.

For
simple-commands, redirections may appear anywhere in the
command, for compound-commands (if statements,
etc.), any redirections must appear at the end.
Redirections are processed after pipelines are created and
in the order they are given, so

cat /foo/bar 2>&1
> /dev/null | cat −n

will print an error with a line
number prepended to it.

Arithmetic
Expressions 
Integer arithmetic expressions can be used with the
let command, inside $((..))
expressions, inside array references (e.g.,
name[expr]), as numeric
arguments to the test command, and as the value of an
assignment to an integer parameter.

Expression may
contain alpha-numeric parameter identifiers, array
references, and integer constants and may be combined with
the following C operators (listed and grouped in increasing
order of precedence). 
Unary operators:

+ − ! ~ ++ --

Binary operators:

, 
= *= /= %= += −= >= &= ^= |= 
|| 
&& 
| 
^ 
& 
== != 
= > 
> 
+ − 
* / %

Ternary operator:

?: (precedence is
immediately higher than assignment)

Grouping operators:

( )

Integer
constants may be specified with arbitrary bases using the
notation base#number, where base
is a decimal integer specifying the base, and number
is a number in the specified base.

The operators
are evaluated as follows:

unary +

result is the argument
(included for completeness).

unary −

negation.

!

logical not; the result is 1 if argument is zero, 0 if
not. 

~

arithmetic (bit-wise) not.

++

increment; must be applied to a parameter (not a literal
or other expression) - the parameter is incremented by 1.
When used as a prefix operator, the result is the
incremented value of the parameter, when used as a postfix
operator, the result is the original value of the
parameter. 

--

similar to ++, except the parameter is
decremented by 1.

,

separates two arithmetic expressions; the left hand side
is evaluated first, then the right. The result is value of
the expression on the right hand side.

=

assignment; variable on the left is set to the value on
the right.

*= /= %= += −=
>= &= ^= |=

assignment operators;
 =  is
the same as  = 
 (  ).

||

logical or; the result is 1 if either argument is
non-zero, 0 if not. The right argument is evaluated only if
the left argument is zero.

&&

logical and; the result is 1 if both arguments are
non-zero, 0 if not. The right argument is evaluated only if
the left argument is non-zero.

|

arithmetic (bit-wise) or.

^

arithmetic (bit-wise) exclusive-or.

&

arithmetic (bit-wise) and.

==

equal; the result is 1 if both arguments are equal, 0 if
not. 

!=

not equal; the result is 0 if both arguments are equal,
1 if not.

less than; the result is 1 if the left argument is less
than the right, 0 if not.

= >

less than or equal, greater
than or equal, greater than. See 

>

shift left (right); the result is the left argument with
its bits shifted left (right) by the amount given in the
right argument.

+ - * /

addition, subtraction,
multiplication, and division.

%

remainder; the result is the remainder of the division
of the left argument by the right. The sign of the result is
unspecified if either argument is negative.

 ?
 : 

if  is
non-zero, the result is , otherwise
.

Co-Processes

A co-process, which is a pipeline created with the
|& operator, is an asynchronous process that the
shell can both write to (using print −p) and
read from (using read −p). The input and output
of the co-process can also be manipulated using
>&p and  redirections,
respectively. Once a co-process has been started, another
can’t be started until the co-process exits, or until
the co-process input has been redirected using an
exec n>&p redirection. If a
co-process’s input is redirected in this way, the next
co-process to be started will share the output with the
first co-process, unless the output of the initial
co-process has been redirected using an exec
n redirection.

Some notes
concerning co-processes:

   •

the only way to close the co-process input (so the
co-process reads an end-of-file) is to redirect the input to
a numbered file descriptor and then close that file
descriptor (e.g., exec 3>&p;exec
3>&-). 

   •

in order for co-processes to share a common output, the
shell must keep the write portion of the output pipe open.
This means that end of file will not be detected until all
co-processes sharing the co-process output have exited (when
they all exit, the shell closes its copy of the pipe). This
can be avoided by redirecting the output to a numbered file
descriptor (as this also causes the shell to close its
copy). Note that this behaviour is slightly different from
the original Korn shell which closes its copy of the write
portion of the co-processs output when the most recently
started co-process (instead of when all sharing
co-processes) exits.

   •

print −p will ignore SIGPIPE signals during
writes if the signal is not being trapped or ignored; the
same is not true if the co-process input has been duplicated
to another file descriptor and print −un
is used.

Functions

Functions are defined using either Korn shell
function name syntax or the Bourne/POSIX shell
name() syntax (see below for the difference
between the two forms). Functions are like .-scripts
in that they are executed in the current environment,
however, unlike .-scripts, shell arguments
(i.e., positional parameters, $1, etc.)
are never visible inside them. When the shell is determining
the location of a command, functions are searched after
special built-in commands, and before regular and
non-regular built-ins, and before the PATH is
searched.

An existing
function may be deleted using unset −f
function-name. A list of functions can be obtained
using typeset +f and the function definitions can be
listed using typeset −f. autoload (which
is an alias for typeset −fu) may be used to
create undefined functions; when an undefined function is
executed, the shell searches the path specified in the
FPATH parameter for a file with the same name as the
function, which, if found is read and executed. If after
executing the file, the named function is found to be
defined, the function is executed, otherwise, the normal
command search is continued (i.e., the shell searches
the regular built-in command table and PATH). Note
that if a command is not found using PATH, an attempt
is made to autoload a function using FPATH (this is
an undocumented feature of the original Korn shell).

Functions can
have two attributes, trace and export, which can be set with
typeset −ft and typeset −fx,
respectively. When a traced function is executed, the
shell’s xtrace option is turned on for the
functions duration, otherwise the xtrace option is
turned off. The export attribute of functions is currently
not used. In the original Korn shell, exported functions are
visible to shell scripts that are executed.

Since functions
are executed in the current shell environment, parameter
assignments made inside functions are visible after the
function completes. If this is not the desired effect, the
typeset command can be used inside a function to
create a local parameter. Note that special parameters
(e.g., $$, $!) can’t be scoped in
this way.

The exit status
of a function is that of the last command executed in the
function. A function can be made to finish immediately using
the return command; this may also be used to
explicitly specify the exit status.

Functions
defined with the function reserved word are treated
differently in the following ways from functions defined
with the () notation:

   •

the $0 parameter is set
to the name of the function (Bourne-style functions leave
$0 untouched).

   •

parameter assignments preceding function calls are not
kept in the shell environment (executing Bourne-style
functions will keep assignments).

   •

OPTIND is saved/reset and restored on entry and
exit from the function so getopts can be used
properly both inside and outside the function (Bourne-style
functions leave OPTIND untouched, so using
getopts inside a function interferes with using
getopts outside the function). In the future, the
following differences will also be added:

   •

A separate trap/signal environment will be used during
the execution of functions. This will mean that traps set
inside a function will not affect the shell’s traps
and signals that are not ignored in the shell (but may be
trapped) will have their default effect in a function.

   •

The EXIT trap, if set in a function, will be executed
after the function returns.

POSIX
Mode 
The shell is intended to be POSIX compliant, however, in
some cases, POSIX behaviour is contrary either to the
original Korn shell behaviour or to user convenience. How
the shell behaves in these cases is determined by the state
of the posix option (set −o posix) — if
it is on, the POSIX behaviour is followed, otherwise it is
not. The posix option is set automatically when the
shell starts up if the environment contains the
POSIXLY_CORRECT parameter. (The shell can also be
compiled so that it is in POSIX mode by default, however
this is usually not desirable).

The following
is a list of things that are affected by the state of the
posix option:

   •

\" inside double
quoted ’..’ command substitutions:
in posix mode, the \" is interpreted when the
command is interpreted; in non-posix mode, the backslash is
stripped before the command substitution is interpreted. For
example, echo "’echo
\"hi\"’" produces
’"hi"’ in posix mode, ’hi’
in non-posix mode. To avoid problems, use the $(...)
form of command substitution.

   •

kill −l output: in posix mode, signal names
are listed one a single line; in non-posix mode, signal
numbers, names and descriptions are printed in columns. In
future, a new option (−v perhaps) will be added
to distinguish the two behaviours.

   •

fg exit status: in posix mode, the exit status is
0 if no errors occur; in non-posix mode, the exit status is
that of the last foregrounded job.

   •

eval exit status: if eval gets to see an empty
command (e.g., eval
"’false’"), its exit status in
posix mode will be 0. In non-posix mode, it will be the exit
status of the last command substitution that was done in the
processing of the arguments to eval (or 0 if there were no
command substitutions).

   •

getopts: in posix mode, options must start with a
−; in non-posix mode, options can start with
either − or +.

   •

brace expansion (also known as alternation): in posix
mode, brace expansion is disabled; in non-posix mode, brace
expansion enabled. Note that set −o posix (or
setting the POSIXLY_CORRECT parameter) automatically
turns the braceexpand option off, however it can be
explicitly turned on later.

   •

set −: in posix mode, this does not clear
the verbose or xtrace options; in non-posix
mode, it does.

   •

set exit status: in posix mode, the exit status
of set is 0 if there are no errors; in non-posix mode, the
exit status is that of any command substitutions performed
in generating the set command. For example, ’set
−− ’false’; echo $?’
prints 0 in posix mode, 1 in non-posix mode. This construct
is used in most shell scripts that use the old
getopt(1) command.

(DEBIAN NOTE: This is no
longer true on Debian systems. For compatibility with ksh93,
set command always returns exit status set to 0,
regardless of posix or non-posix mode.)

   •

argument expansion of
alias, export, readonly, and
typeset commands: in posix mode, normal argument
expansion done; in non-posix mode, field splitting, file
globing, brace expansion and (normal) tilde expansion are
turned off, and assignment tilde expansion is turned on.

   •

signal specification: in posix mode, signals can be
specified as digits only if signal numbers match POSIX
values (i.e., HUP=1, INT=2, QUIT=3, ABRT=6, KILL=9,
ALRM=14, and TERM=15); in non-posix mode, signals can be
always digits.

   •

alias expansion: in posix mode, alias expansion is only
carried out when reading command words; in non-posix mode,
alias expansion is carried out on any word following an
alias that ended in a space. For example, the following for
loop 

alias a=’for ’
i=’j’ 
a i in 1 2; do echo i=$i j=$j; done

uses parameter i in
posix mode, j in non-posix mode.

   •

test: in posix mode, the
expression "-t" (preceded by some number of
"!" arguments) is always true as it is a
non-zero length string; in non-posix mode, it tests if file
descriptor 1 is a tty (i.e., the fd argument
to the -t test may be left out and defaults to
1). 

Command
Execution 
After evaluation of command line arguments, redirections and
parameter assignments, the type of command is determined: a
special built-in, a function, a regular built-in or the name
of a file to execute found using the PATH parameter.
The checks are made in the above order. Special built-in
commands differ from other commands in that the PATH
parameter is not used to find them, an error during their
execution can cause a non-interactive shell to exit and
parameter assignments that are specified before the command
are kept after the command completes. Just to confuse
things, if the posix option is turned off (see set
command below) some special commands are very special in
that no field splitting, file globing, brace expansion nor
tilde expansion is preformed on arguments that look like
assignments. Regular built-in commands are different only in
that the PATH parameter is not used to find them.

The original
ksh and POSIX differ somewhat in which commands are
considered special or regular: 
POSIX special commands

Additional ksh special
commands

Very special commands
(non-posix mode)

POSIX regular commands

Additional ksh regular
commands

In the future,
the additional ksh special and regular commands may be
treated differently from the POSIX special and regular
commands.

Once the type
of the command has been determined, any command line
parameter assignments are performed and exported for the
duration of the command.

The following
describes the special and regular built-in commands: 
. file [arg1 ...]

Execute the commands in
file in the current environment. The file is searched
for in the directories of PATH. If arguments are
given, the positional parameters may be used to access them
while file is being executed. If no arguments are
given, the positional parameters are those of the
environment the command is used in.

: [ ... ]

The null command. Exit status
is set to zero.

alias [ −d
| +−t [−r] ] [+−px]
[+−] [name1[=value1]
...]

Without arguments, alias
lists all aliases. For any name without a value, the
existing alias is listed. Any name with a value defines an
alias (see Aliases above).

When listing
aliases, one of two formats is used: normally, aliases are
listed as name=value, where
value is quoted; if options were preceded with
+ or a lone + is given on the command line,
only name is printed. In addition, if the
−p option is used, each alias is prefixed with
the string "alias ".

The
−x option sets (+x clears) the export
attribute of an alias, or, if no names are given, lists the
aliases with the export attribute (exporting an alias has no
affect).

The
−t option indicates that tracked aliases are to
be listed/set (values specified on the command line are
ignored for tracked aliases). The −r option
indicates that all tracked aliases are to be reset.

The
−d causes directory aliases, which are used in
tilde expansion, to be listed or set (see Tilde Expansion
above).

bg [job ...]

Resume the specified stopped
job(s) in the background. If no jobs are specified,
%+ is assumed. This command is only available on
systems which support job control. See Job Control below for
more information.

bind [−m]
[key[=editing-command] ...]

Set or view the current emacs
command editing key bindings/macros. See Emacs Editing Mode
below for a complete description.

break [level]

break exits the
levelth inner most for, select, until, or while loop.
level defaults to 1.

builtin command
[arg1 ...]

Execute the built-in command
command.

cd [−LP]
[dir]

Set the working directory to
dir. If the parameter CDPATH is set, it lists
directories to search in for dir. An empty entry in
the CDPATH entry means the current directory. If a
non-empty directory from CDPATH is used, the
resulting full path is printed to standard output. If
dir is missing, the home directory $HOME is
used. If dir is −, the previous working
directory is used (see OLDPWD parameter). If −L
option (logical path) is used or if the physical
option (see set command below) isn’t set,
references to .. in dir are relative to the
path used get to the directory. If −P option
(physical path) is used or if the physical option is
set, .. is relative to the filesystem directory tree.
The PWD and OLDPWD parameters are updated to
reflect the current and old wording directory,
respectively.

cd [−LP]
old new

The string new is
substituted for old in the current directory, and the
shell attempts to change to the new directory.

command
[−pvV] cmd [arg1 ...]

If neither the −v
nor −V options are given, cmd is
executed exactly as if the command had not been
specified, with two exceptions: first, cmd cannot be
a shell function, and second, special built-in commands lose
their specialness (i.e., redirection and utility
errors do not cause the shell to exit, and command
assignments are not permanent). If the −p
option is given, a default search path is used instead of
the current value of PATH (the actual value of the
default path is system dependent: on POSIXish systems, it is
the value returned by

getconf CS_PATH ).

If the −v option is
given, instead of executing cmd, information about
what would be executed is given (and the same is done for
arg1 ...): for special and regular built-in commands
and functions, their names are simply printed, for aliases,
a command that defines them is printed, and for commands
found by searching the PATH parameter, the full path
of the command is printed. If no command is be found,
(i.e., the path search fails), nothing is printed and
command exits with a non-zero status. The
−V option is like the −v option,
except it is more verbose.

continue
[levels]

continue jumps to the
beginning of the levelth inner most for, select,
until, or while loop. level defaults to 1.

echo [−neE]
[arg ...]

Prints its arguments (separated
by spaces) followed by a newline, to standard out. The
newline is suppressed if any of the arguments contain the
backslash sequence \c. See print command below
for a list of other backslash sequences that are
recognized.

The options are
provided for compatibility with BSD shell scripts:
−n suppresses the trailing newline,
−e enables backslash interpretation (a no-op,
since this is normally done), and −E which
suppresses backslash interpretation.

eval command
...

The arguments are concatenated
(with spaces between them) to form a single string which the
shell then parses and executes in the current
environment.

exec [command
[arg ...]]

The command is executed without
forking, replacing the shell process.

If no arguments
are given, any IO redirection is permanent and the shell is
not replaced. Any file descriptors greater than 2 which are
opened or dup(2)-ed in this way are not made
available to other executed commands (i.e., commands
that are not built-in to the shell). Note that the Bourne
shell differs here: it does pass these file descriptors on.

(DEBIAN NOTE: when the shell is called as
/bin/sh, it does pass these file descriptors on, like
the Bourne shell.)

exit [status]

The shell exits with the
specified exit status. If status is not specified,
the exit status is the current value of the ?
parameter.

export [−p]
[parameter[=value]] ...

Sets the export attribute of
the named parameters. Exported parameters are passed in the
environment to executed commands. If values are specified,
the named parameters also assigned.

If no
parameters are specified, the names of all parameters with
the export attribute are printed one per line, unless the
−p option is used, in which case export
commands defining all exported parameters, including their
values, are printed.

false

A command that exits with a non-zero status.

fc [−e
editor | −l [−n]]
[−r] [first [last]]

first and last
select commands from the history. Commands can be selected
by history number, or a string specifying the most recent
command starting with that string. The −l
option lists the command on stdout, and −n
inhibits the default command numbers. The −r
option reverses the order of the list. Without
−l, the selected commands are edited by the
editor specified with the −e option, or if no
−e is specified, the editor specified by the
FCEDIT parameter (if this parameter is not set,
/bin/ed is used), and then executed by the shell.

fc [−e
− | −s] [−g]
[old=new] [prefix]

Re-execute the selected command
(the previous command by default) after performing the
optional substitution of old with new. If
−g is specified, all occurrences of old
are replaced with new. This command is usually
accessed with the predefined alias r=’fc −e
−’.

fg [job ...]

Resume the specified job(s) in
the foreground. If no jobs are specified, %+ is
assumed. This command is only available on systems which
support job control. See Job Control below for more
information.

getopts optstring
name [arg ...]

getopts is used by shell
procedures to parse the specified arguments (or positional
parameters, if no arguments are given) and to check for
legal options. optstring contains the option letters
that getopts is to recognize. If a letter is followed
by a colon, the option is expected to have an argument.
Options that do not take arguments may be grouped in a
single argument. If an option takes an argument and the
option character is not the last character of the argument
it is found in, the remainder of the argument is taken to be
the option’s argument, otherwise, the next argument is
the option’s argument.

Each time
getopts is invoked, it places the next option in the
shell parameter name and the index of the next
argument to be processed in the shell parameter
OPTIND. If the option was introduced with a +,
the option placed in name is prefixed with a
+. When an option requires an argument,
getopts places it in the shell parameter
OPTARG. When an illegal option or a missing option
argument is encountered a question mark or a colon is placed
in name (indicating an illegal option or missing
argument, respectively) and OPTARG is set to the
option character that caused the problem. An error message
is also printed to standard error if optstring does
not begin with a colon.

When the end of
the options is encountered, getopts exits with a
non-zero exit status. Options end at the first (non-option
argument) argument that does not start with a −, or
when a −− argument is encountered.

Option parsing
can be reset by setting OPTIND to 1 (this is done
automatically whenever the shell or a shell procedure is
invoked).

Warning:
Changing the value of the shell parameter OPTIND to a
value other than 1, or parsing different sets of arguments
without resetting OPTIND may lead to unexpected
results.

hash [−r]
[name ...]

Without arguments, any hashed
executable command pathnames are listed. The −r
option causes all hashed commands to be removed from the
hash table. Each name is searched as if it where a
command name and added to the hash table if it is an
executable command.

jobs [−lpn]
[job ...]

Display information about the
specified jobs; if no jobs are specified, all jobs are
displayed. The −n option causes information to
be displayed only for jobs that have changed state since the
last notification. If the −l option is used,
the process-id of each process in a job is also listed. The
−p option causes only the process group of each
job to be printed. See Job Control below for the format of
job and the displayed job.

kill [−s
signame | −signum |
−signame ] { job | pid |
−pgrp } ...

Send the specified signal to
the specified jobs, process ids, or process groups. If no
signal is specified, the signal TERM is sent. If a job is
specified, the signal is sent to the job’s process
group. See Job Control below for the format of
job.

kill −l
[exit-status ...]

Print the name of the signal
that killed a process which exited with the specified
exit-statuses. If no arguments are specified, a list
of all the signals, their numbers and a short description of
them are printed.

let [expression
...]

Each expression is evaluated,
see Arithmetic Expressions above. If all expressions are
successfully evaluated, the exit status is 0 (1) if the last
expression evaluated to non-zero (zero). If an error occurs
during the parsing or evaluation of an expression, the exit
status is greater than 1. Since expressions may need to be
quoted, (( expr )) is syntactic sugar
for let "expr".

print
[−nprsun | −R
[−en]] [argument ...]

Print prints its
arguments on the standard output, separated by spaces, and
terminated with a newline. The −n option
suppresses the newline. By default, certain C escapes are
translated. These include \b, \f, \n, \r, \t, \v, and \0###
(# is an octal digit, of which there may be 0 to 3). \c is
equivalent to using the −n option. \ expansion
may be inhibited with the −r option. The
−s option prints to the history file instead of
standard output, the −u option prints to file
descriptor n (n defaults to 1 if omitted), and
the −p option prints to the co-process (see
Co-Processes above).

The
−R option is used to emulate, to some degree,
the BSD echo command, which does not process \ sequences
unless the −e option is given. As above, the
−n option suppresses the trailing newline.

pwd
[−LP]

Print the present working
directory. If −L option is used or if the
physical option (see set command below)
isn’t set, the logical path is printed (i.e.,
the path used to cd to the current directory). If
−P option (physical path) is used or if the
physical option is set, the path determined from the
filesystem (by following .. directories to the root
directory) is printed.

read
[−prsun] [parameter ...]

Reads a line of input from
standard input, separate the line into fields using the
IFS parameter (see Substitution above), and assign
each field to the specified parameters. If there are more
parameters than fields, the extra parameters are set to
null, or alternatively, if there are more fields than
parameters, the last parameter is assigned the remaining
fields (inclusive of any separating spaces). If no
parameters are specified, the REPLY parameter is
used. If the input line ends in a backslash and the
−r option was not used, the backslash and
newline are stripped and more input is read. If no input is
read, read exits with a non-zero status.

The first
parameter may have a question mark and a string appended to
it, in which case the string is used as a prompt (printed to
standard error before any input is read) if the input is a
tty (e.g., read nfoo?’number of foos:
’).

The
−un and −p options cause
input to be read from file descriptor n or the
current co-process (see Co-Processes above for comments on
this), respectively. If the −s option is used,
input is saved to the history file.

readonly
[−p] [parameter[=value]]
...

Sets the readonly attribute of
the named parameters. If values are given, parameters are
set to them before setting the attribute. Once a parameter
is made readonly, it cannot be unset and its value cannot be
changed.

If no
parameters are specified, the names of all parameters with
the readonly attribute are printed one per line, unless the
−p option is used, in which case
readonly commands defining all readonly parameters,
including their values, are printed.

return
[status]

Returns from a function or
. script, with exit status status. If no
status is given, the exit status of the last executed
command is used. If used outside of a function or .
script, it has the same effect as exit. Note that
pdksh treats both profile and $ENV files as .
scripts, while the original Korn shell only treats profiles
as . scripts.

set
[+−abCefhkmnpsuvxX] [+−o
[option]] [+−A name]
[−−] [arg ...]

The set command can be used to
set (−) or clear (+) shell options, set
the positional parameters, or set an array parameter.
Options can be changed using the +−o
option syntax, where option is the long name
of an option, or using the +−letter
syntax, where letter is the option’s single
letter name (not all options have a single letter name). The
following table lists both option letters (if they exist)
and long names along with a description of what the option
does.

These options
can also be used upon invocation of the shell. The current
set of options (with single letter names) can be found in
the parameter −. set -o with no option
name will list all the options and whether each is on or
off; set +o will print the long names of all options
that are currently on.

Remaining
arguments, if any, are positional parameters and are
assigned, in order, to the positional parameters
(i.e., 1, 2, etc.). If options
are ended with −− and there are no
remaining arguments, all positional parameters are cleared.
If no options or arguments are given, then the values of all
names are printed. For unknown historical reasons, a lone
− option is treated specially: it clears both
the −x and −v options.

shift
[number]

The positional parameters
number+1, number+2 etc. are renamed to
1, 2, etc. number defaults to 1.

test expression

[ expression ]

test evaluates the
expression and returns zero status if true, and 1
status if false and greater than 1 if there was an error. It
is normally used as the condition command of if and
while statements. The following basic expressions are
available:

The above basic
expressions, in which unary operators have precedence over
binary operators, may be combined with the following
operators (listed in increasing order of precedence):

On operating
systems not supporting /dev/fd/n devices
(where n is a file descriptor number), the
test command will attempt to fake it for all tests
that operate on files (except the -e test). I.e.,
[ -w /dev/fd/2 ] tests if file descriptor 2 is
writable.

Note that some
special rules are applied (courtesy of POSIX) if the number
of arguments to test or [ ... ] is less
than five: if leading ! arguments can be stripped
such that only one argument remains then a string length
test is performed (again, even if the argument is a unary
operator); if leading ! arguments can be stripped
such that three arguments remain and the second argument is
a binary operator, then the binary operation is performed
(even if first argument is a unary operator, including an
unstripped !).

Note: A
common mistake is to use if [ $foo = bar ] which
fails if parameter foo is null or unset, if it has
embedded spaces (i.e., IFS characters), or if
it is a unary operator like ! or −n. Use
tests like if [ "X$foo" = Xbar ]
instead.

time [-p] [
pipeline ]

If a pipeline is given, the
times used to execute the pipeline are reported. If no
pipeline is given, then the user and system time used by the
shell itself, and all the commands it has run since it was
started, are reported. The times reported are the real time
(elapsed time from start to finish), the user cpu time (time
spent running in user mode) and the system cpu time (time
spent running in kernel mode). Times are reported to
standard error; the format of the output is: 
0.00s real 0.00s user 0.00s system 
unless the -p option is given (only possible if
pipeline is a simple command), in which case the
output is slightly longer: 
real 0.00 
user 0.00 
sys 0.00 
(the number of digits after the decimal may vary from system
to system). Note that simple redirections of standard error
do not effect the output of the time command:

time sleep 1 2> afile

{ time sleep 1; } 2> afile times for the first
command do not go to afile, but those of the second
command do.

times

Print the accumulated user and system times used by the
shell and by processes which have exited that the shell
started. 

trap [handler signal
...]

Sets trap handler that is to be
executed when any of the specified signals are received.
Handler is either a null string, indicating the
signals are to be ignored, a minus (−),
indicating that the default action is to be taken for the
signals (see signal(2)), or a string containing shell
commands to be evaluated and executed at the first
opportunity (i.e., when the current command
completes, or before printing the next PS1 prompt)
after receipt of one of the signals. Signal is the
name of a signal (e.g., PIPE or ALRM) or the number
of the signal (see kill −l command above).
There are two special signals: EXIT (also known as
0), which is executed when the shell is about to
exit, and ERR which is executed after an error occurs
(an error is something that would cause the shell to exit if
the −e or errexit option were set
— see set command above). EXIT handlers
are executed in the environment of the last executed
command. Note that for non-interactive shells, the trap
handler cannot be changed for signals that were ignored when
the shell started.

With no
arguments, trap lists, as a series of trap
commands, the current state of the traps that have been set
since the shell started. Note that the output of trap
can not be usefully piped to another process (an artifact of
the fact that traps are cleared when subprocesses are
created).

The original
Korn shell’s DEBUG trap and the handling of
ERR and EXIT traps in functions are not yet
implemented.

true

A command that exits with a zero value.

typeset
[[+−Ulprtux] [−L[n]]
[−R[n]] [−Z[n]]
[−i[n]] | −f
[−tux]] 
[name[=value] ...]

Display or set parameter
attributes. With no name arguments, parameter
attributes are displayed: if no options arg used, the
current attributes of all parameters are printed as typeset
commands; if an option is given (or − with no
option letter) all parameters and their values with the
specified attributes are printed; if options are introduced
with +, parameter values are not printed.

If name
arguments are given, the attributes of the named parameters
are set (−) or cleared (+). Values for
parameters may optionally be specified. If typeset is used
inside a function, any newly created parameters are local to
the function.

When
−f is used, typeset operates on the attributes
of functions. As with parameters, if no names are
given, functions are listed with their values (i.e.,
definitions) unless options are introduced with +, in
which case only the function names are reported.

ulimit
[−acdfHlmnpsStvwL] [value]

Display or set process limits.
If no options are used, the file size limit
(−f) is assumed. value, if specified,
may be either be an arithmetic expression or the word
unlimited. The limits affect the shell and any
processes created by the shell after a limit is imposed.
Note that some systems may not allow limits to be increased
once they are set. Also note that the types of limits
available are system dependent − some systems have
only the −f limit.

−a

Displays all limits; unless −H is used,
soft limits are displayed.

−H

Set the hard limit only (default is to set both hard and
soft limits).

−S

Set the soft limit only (default is to set both hard and
soft limits).

−c

Impose a size limit of n blocks on the size of
core dumps.

−d

Impose a size limit of n kbytes on the size of
the data area.

−f

Impose a size limit of n blocks on files written
by the shell and its child processes (files of any size may
be read).

−l

Impose a limit of n kbytes on the amount of
locked (wired) physical memory.

−m

Impose a limit of n kbytes on the amount of
physical memory used.

−n

Impose a limit of n file descriptors that can be
open at once.

−p

Impose a limit of n processes that can be run by
the user at any one time.

−s

Impose a size limit of n kbytes on the size of
the stack area.

−t

Impose a time limit of n cpu seconds to be used
by each process.

−v

Impose a limit of n kbytes on the amount of
virtual memory used; on some systems this is the maximum
allowable virtual address (in bytes, not kbytes).

−w

Impose a limit of n kbytes on the amount of swap
space used.

−L

Impose a limit of n locks that can be held on
files. 

As far as
ulimit is concerned, a block is 512 bytes.

umask [−S]
[mask]

Display or set the file
permission creation mask, or umask (see umask(2)). If
the −S option is used, the mask displayed or
set is symbolic, otherwise it is an octal number.

Symbolic masks
are like those used by chmod(1):

[ugoa]{{=+-}{rwx}*}+[,...]

in which the first group of
characters is the who part, the second group is the
op part, and the last group is the perm part.
The who part specifies which part of the umask is to
be modified. The letters mean:

u

the user permissions

g

the group permissions

o

the other permissions (non-user, non-group)

a

all permissions (user, group and other)

The op
part indicates how the who permissions are to be
modified:

=

set

+

added to

−

removed from

The perm
part specifies which permissions are to be set, added or
removed:

r

read permission

w

write permission

x

execute permission

When symbolic
masks are used, they describe what permissions may be made
available (as opposed to octal masks in which a set bit
means the corresponding bit is to be cleared). Example:
’ug=rwx,o=’ sets the mask so files will not be
readable, writable or executable by ’others’,
and is equivalent (on most systems) to the octal mask
’07’.

unalias
[−adt] [name1 ...]

The aliases for the given names
are removed. If the −a option is used, all
aliases are removed. If the −t or
−d options are used, the indicated operations
are carried out on tracked or directory aliases,
respectively.

unset [−fv]
parameter ...

Unset the named parameters
(−v, the default) or functions
(−f). The exit status is non-zero if any of the
parameters were already unset, zero otherwise.

wait [job]

Wait for the specified job(s)
to finish. The exit status of wait is that of the last
specified job: if the last job is killed by a signal, the
exit status is 128 + the number of the signal (see kill
−l exit-status above); if the last
specified job can’t be found (because it never
existed, or had already finished), the exit status of wait
is 127. See Job Control below for the format of job.
Wait will return if a signal for which a trap has
been set is received, or if a HUP, INT or QUIT signal is
received.

If no jobs are
specified, wait waits for all currently running jobs
(if any) to finish and exits with a zero status. If job
monitoring is enabled, the completion status of jobs is
printed (this is not the case when jobs are explicitly
specified).

whence
[−pv] [name ...]

For each name, the type of
command is listed (reserved word, built-in, alias, function,
tracked alias or executable). If the −p option
is used, a path search done even if name is a
reserved word, alias, etc. Without the
−v option, whence is similar to
command −v except that whence will find
reserved words and won’t print aliases as alias
commands; with the −v option, whence is
the same as command −V. Note that for
whence, the −p option does not affect
the search path used, as it does for command. If the
type of one or more of the names could not be determined,
the exit status is non-zero.

Job
Control 
Job control refers to the shell’s ability to monitor
and control jobs, which are processes or groups of
processes created for commands or pipelines. At a minimum,
the shell keeps track of the status of the background
(i.e., asynchronous) jobs that currently exist; this
information can be displayed using the jobs command.
If job control is fully enabled (using set −m
or set −o monitor), as it is for interactive
shells, the processes of a job are placed in their own
process group, foreground jobs can be stopped by typing the
suspend character from the terminal (normally ^Z), jobs can
be restarted in either the foreground or background, using
the fg and bg commands, respectively, and the
state of the terminal is saved or restored when a foreground
job is stopped or restarted, respectively.

Note that only
commands that create processes (e.g., asynchronous
commands, subshell commands, and non-built-in, non-function
commands) can be stopped; commands like read cannot
be.

When a job is
created, it is assigned a job-number. For interactive
shells, this number is printed inside [..],
followed by the process-ids of the processes in the job when
an asynchronous command is run. A job may be referred to in
bg, fg, jobs, kill and
wait commands either by the process id of the last
process in the command pipeline (as stored in the $!
parameter) or by prefixing the job-number with a percent
sign (%). Other percent sequences can also be used to
refer to jobs:

When a job
changes state (e.g., a background job finishes or
foreground job is stopped), the shell prints the following
status information:

[number]
flag status command

where   
number

is the job-number of the
job.

  flag

is + or - if the job is the %+ or
%- job, respectively, or space if it is neither.

status

indicates the current state of
the job and can be 
Running

the job has neither stopped or
exited (note that running does not necessarily mean
consuming CPU time — the process could be blocked
waiting for some event).

Done
[(number)]

the job exited. number
is the exit status of the job, which is omitted if the
status is zero.

Stopped
[(signal)]

the job was stopped by the
indicated signal (if no signal is given, the job was
stopped by SIGTSTP).

signal-description
[(core dumped)]

the job was killed by a signal
(e.g., Memory fault, Hangup, etc. —
use kill −l for a list of signal descriptions).
The (core dumped) message indicates the process
created a core file.  

command

is the command that created the
process. If there are multiple processes in the job, then
each process will have a line showing its command and
possibly its status, if it is different from the
status of the previous process.

When an attempt
is made to exit the shell while there are jobs in the
stopped state, the shell warns the user that there are
stopped jobs and does not exit. If another attempt is
immediately made to exit the shell, the stopped jobs are
sent a HUP signal and the shell exits. Similarly, if
the nohup option is not set and there are running
jobs when an attempt is made to exit a login shell, the
shell warns the user and does not exit. If another attempt
is immediately made to exit the shell, the running jobs are
sent a HUP signal and the shell exits.

Interactive
Input Line Editing 
The shell supports three modes of reading command lines from
a tty in an interactive session. Which is used is controlled
by the emacs, gmacs and vi set options
(at most one of these can be set at once). If none of these
options is enabled, the shell simply reads lines using the
normal tty driver. If the emacs or gmacs
option is set, the shell allows emacs like editing of the
command; similarly, if the vi option is set, the
shell allows vi like editing of the command. These modes are
described in detail in the following sections.

In these
editing modes, if a line is longer that the screen width
(see COLUMNS parameter), a >, + or
 character is displayed in the last column
indicating that there are more characters after, before and
after, or before the current position, respectively. The
line is scrolled horizontally as necessary.

Emacs
Editing Mode 
When the emacs option is set, interactive input line
editing is enabled. Warning: This mode is slightly
different from the emacs mode in the original Korn shell and
the 8th bit is stripped in emacs mode. In this mode various
editing commands (typically bound to one or more control
characters) cause immediate actions without waiting for a
new-line. Several editing commands are bound to particular
control characters when the shell is invoked; these bindings
can be changed using the following commands:

bind

The current bindings are listed.

bind
string=[editing-command]

The specified editing command
is bound to the given string, which should consist of
a control character (which may be written using caret
notation ^X), optionally preceded by one of
the two prefix characters. Future input of the string
will cause the editing command to be immediately invoked.
Note that although only two prefix characters (usually ESC
and ^X) are supported, some multi-character sequences can be
supported. The following binds the arrow keys on an ANSI
terminal, or xterm (these are in the default bindings). Of
course some escape sequences won’t work out quite this
nicely:

bind
’^[[’=prefix−2 
bind ’^XA’=up−history 
bind ’^XB’=down−history 
bind ’^XC’=forward−char 
bind ’^XD’=backward−char

bind −l

Lists the names of the
functions to which keys may be bound.

bind −m
string=[substitute]

The specified input
string will afterwards be immediately replaced by the
given substitute string, which may contain editing
commands.

The following
is a list of editing commands available. Each description
starts with the name of the command, a n, if the
command can be prefixed with a count, and any keys the
command is bound to by default (written using caret
notation, e.g., ASCII ESC character is written as
^[). A count prefix for a command is entered using the
sequence ^[n, where n is a sequence of
1 or more digits; unless otherwise specified, if a count is
omitted, it defaults to 1. Note that editing command names
are used only with the bind command. Furthermore,
many editing commands are useful only on terminals with a
visible cursor. The default bindings were chosen to resemble
corresponding EMACS key bindings. The users tty characters
(e.g., ERASE) are bound to reasonable substitutes and
override the default bindings. 
abort ^G

Useful as a response to a
request for a search-history pattern in order to
abort the search.

auto-insert n

Simply causes the character to
appear as literal input. Most ordinary characters are bound
to this.

backward-char n
^B

Moves the cursor backward
n characters.

backward-word n
^[B

Moves the cursor backward to
the beginning of a word; words consist of alphanumerics,
underscore (_) and dollar ($).

beginning-of-history
^[

Moves to the beginning of the
history.

beginning-of-line ^A

Moves the cursor to the
beginning of the edited input line.

capitalize-word n
^[c, ^[C

Uppercase the first character
in the next n words, leaving the cursor past the end
of the last word. If the current line does not begin with a
comment character, one is added at the beginning of the line
and the line is entered (as if return had been pressed),
otherwise the existing comment characters are removed and
the cursor is placed at the beginning of the line.

complete ^[^[

Automatically completes as much
as is unique of the command name or the file name containing
the cursor. If the entire remaining command or file name is
unique a space is printed after its completion, unless it is
a directory name in which case / is appended. If
there is no command or file name with the current partial
word as its prefix, a bell character is output (usually
causing a audio beep).

complete-command
^X^[

Automatically completes as much
as is unique of the command name having the partial word up
to the cursor as its prefix, as in the complete
command described above.

complete-file ^[^X

Automatically completes as much
as is unique of the file name having the partial word up to
the cursor as its prefix, as in the complete command
described above.

complete-list ^[=

List the possible completions
for the current word.

delete-char-backward
n ERASE, ^?, ^H

Deletes n characters
before the cursor.

delete-char-forward
n

Deletes n characters
after the cursor.

delete-word-backward
n ^[ERASE, ^[^?, ^[^H,
^[h

Deletes n words before
the cursor.

delete-word-forward
n ^[d

Deletes characters after the
cursor up to the end of n words.

down-history n
^N

Scrolls the history buffer
forward n lines (later). Each input line originally
starts just after the last entry in the history buffer, so
down-history is not useful until either
search-history or up-history has been
performed.

downcase-word n
^[L, ^[l

Lowercases the next n
words.

end-of-history
^[>

Moves to the end of the
history.

end-of-line ^E

Moves the cursor to the end of
the input line.

eot ^_

Acts as an end-of-file; this is useful because edit-mode
input disables normal terminal input canonicalization.

eot-or-delete n
^D

Acts as eot if alone on a line;
otherwise acts as delete-char-forward.

error

Error (ring the bell).

exchange-point-and-mark
^X^X

Places the cursor where the
mark is, and sets the mark to where the cursor was.

expand-file ^[*

Appends a * to the current word
and replaces the word with the result of performing file
globbing on the word. If no files match the pattern, the
bell is rung.

forward-char n
^F

Moves the cursor forward
n characters.

forward-word n
^[f

Moves the cursor forward to the
end of the nth word.

goto-history n
^[g

Goes to history number
n.

kill-line KILL

Deletes the entire input
line.

kill-region ^W

Deletes the input between the
cursor and the mark.

kill-to-eol n
^K

Deletes the input from the
cursor to the end of the line if n is not specified,
otherwise deletes characters between the cursor and column
n.

list ^[?

Prints a sorted, columnated
list of command names or file names (if any) that can
complete the partial word containing the cursor. Directory
names have / appended to them.

list-command ^X?

Prints a sorted, columnated
list of command names (if any) that can complete the partial
word containing the cursor.

list-file ^X^Y

Prints a sorted, columnated
list of file names (if any) that can complete the partial
word containing the cursor. File type indicators are
appended as described under list above.

newline ^J,
^M

Causes the current input line
to be processed by the shell. The current cursor position
may be anywhere on the line.

newline-and-next ^O

Causes the current input line
to be processed by the shell, and the next line from history
becomes the current line. This is only useful after an
up-history or search-history.

no-op QUIT

This does nothing.

prefix-1 ^[

Introduces a 2-character
command sequence.

prefix-2 ^X 
prefix-2 ^[[

Introduces a 2-character
command sequence.

prev-hist-word n
^[., ^[_

The last (nth) word of
the previous command is inserted at the cursor.

quote ^^

The following character is
taken literally rather than as an editing command.

redraw ^L

Reprints the prompt string and
the current input line.

search-character-backward
n ^[^]

Search backward in the current
line for the nth occurance of the next character
typed.

search-character-forward
n ^]

Search forward in the current
line for the nth occurance of the next character
typed.

search-history ^R

Enter incremental search mode.
The internal history list is searched backwards for commands
matching the input. An initial ^ in the search string
anchors the search. The abort key will leave search mode.
Other commands will be executed after leaving search mode.
Successive search-history commands continue searching
backward to the next previous occurrence of the pattern. The
history buffer retains only a finite number of lines; the
oldest are discarded as necessary.

set-mark-command
^[

Set the mark at the cursor
position.

stuff

On systems supporting it, pushes the bound character
back onto the terminal input where it may receive special
processing by the terminal handler. This is useful for the
BRL ^T mini-systat feature, for example.

stuff-reset

Acts like stuff, then
aborts input the same as an interrupt.

transpose-chars ^T

If at the end of line, or if
the gmacs option is set, this exchanges the two
previous characters; otherwise, it exchanges the previous
and current characters and moves the cursor one character to
the right.

up-history n
^P

Scrolls the history buffer
backward n lines (earlier).

upcase-word n
^[U, ^[u

Uppercases the next n
words.

version ^V

Display the version of ksh. The
current edit buffer is restored as soon as any key is
pressed (the key is then processed, unless it is a
space).

yank ^Y

Inserts the most recently
killed text string at the current cursor position.

yank-pop ^[y

Immediately after a
yank, replaces the inserted text string with the next
previous killed text string.

Vi Editing
Mode 
The vi command line editor in ksh has basically the same
commands as the vi editor (see vi(1)), with the
following exceptions:

   •

you start out in insert mode,

   •

there are file name and command completion commands
(=, \, *, ^X, ^E,
^F and, optionally, ),

   •

the _ command is different (in ksh it is the last
argument command, in vi it goes to the start of the current
line), 

   •

the / and G commands move in the opposite
direction as the j command

   •

and commands which don’t make sense in a single
line editor are not available (e.g., screen movement
commands, ex : commands, etc.).

Note that the
^X stands for control-X; also ,
 and  are used for
escape, space and tab, respectively (no kidding).

Like vi, there
are two modes: insert mode and command mode. In insert mode,
most characters are simply put in the buffer at the current
cursor position as they are typed, however, some characters
are treated specially. In particular, the following
characters are taken from current tty settings (see
stty(1)) and have their usual meaning (normal values
are in parentheses): kill (^U), erase (^?),
werase (^W), eof (^D), intr (^C) and
quit (^\). In addition to the above, the following
characters are also treated specially in insert mode:

In command
mode, each character is interpreted as a command. Characters
that don’t correspond to commands, are illegal
combinations of commands or are commands that can’t be
carried out all cause beeps. In the following command
descriptions, a n indicates the command may be
prefixed by a number (e.g., 10l moves right 10
characters); if no number prefix is used, n is
assumed to be 1 unless otherwise specified. The term
’current position’ refers to the position
between the cursor and the character preceding the cursor. A
’word’ is a sequence of letters, digits and
underscore characters or a sequence of non-letter,
non-digit, non-underscore, non-white-space characters
(e.g., ab2*&^ contains two words) and a
’big-word’ is a sequence of non-white-space
characters. 
Special ksh vi commands

The following commands are not
in, or are different from, the normal vi file editor:

n_

insert a space followed by the nth big-word from
the last command in the history at the current position and
enter insert mode; if n is not specified, the last
word is inserted.

#

insert the comment character (#) at the start of
the current line and return the line to the shell
(equivalent to I#^J).

ng

like G, except if n is not specified, it
goes to the most recent remembered line.

nv

edit line n using the vi editor; if n is
not specified, the current line is edited. The actual
command executed is ’fc −e
${VISUAL:-${EDITOR:-vi}} n’.

* and ^X

command or file name expansion
is applied to the current big-word (with an appended *, if
the word contains no file globing characters) - the big-word
is replaced with the resulting words. If the current
big-word is the first on the line (or follows one of the
following characters: ;, |, &,
(, )) and does not contain a slash (/)
then command expansion is done, otherwise file name
expansion is done. Command expansion will match the big-word
against all aliases, functions and built-in commands as well
as any executable files found by searching the directories
in the PATH parameter. File name expansion matches
the big-word against the files in the current directory.
After expansion, the cursor is placed just past the last
word and the editor is in insert mode.

n\,
n^F, n and
n

command/file name completion:
replace the current big-word with the longest unique match
obtained after performing command/file name expansion.
 is only recognized if the
vi-tabcomplete option is set, while
 is only recognized if the
vi-esccomplete option is set (see set
−o). If n is specified, the nth
possible completion is selected (as reported by the
command/file name enumeration command).

= and ^E

command/file name enumeration:
list all the commands or files that match the current
big-word.

^V

display the version of pdksh; it is displayed until
another key is pressed (this key is ignored).

@c

macro expansion: execute the commands found in the alias
_c. 

Intra-line movement
commands

nh and
n^H

move left n
characters.

nl and
n

move right n
characters.

0

move to column 0.

^

move to the first non white-space character.

n|

move to column n.

$

move to the last character.

nb

move back n words.

nB

move back n big-words.

ne

move forward to the end the word, n times.

nE

move forward to the end the big-word, n
times. 

nw

move forward n words.

nW

move forward n big-words.

%

find match: the editor looks forward for the nearest
parenthesis, bracket or brace and then moves the to the
matching parenthesis, bracket or brace.

nfc

move forward to the nth occurrence of the
character c.

nFc

move backward to the nth occurrence of the
character c.

ntc

move forward to just before the nth occurrence of
the character c.

nTc

move backward to just before the nth occurrence
of the character c.

n;

repeats the last f, F, t or
T command.

n,

repeats the last f, F, t or
T command, but moves in the opposite direction.

Inter-line movement
commands

nj and
n+ and n^N

move to the nth next
line in the history.

nk and
n- and n^P

move to the nth previous
line in the history.

nG

move to line n in the history; if n is not
specified, the number first remembered line is used.

ng

like G, except if n is not specified, it
goes to the most recent remembered line.

n/string

search backward through the
history for the nth line containing string; if
string starts with ^, the remainder of the
string must appear at the start of the history line for it
to match.

n?string

same as /, except it
searches forward through the history.

nn

search for the nth occurrence of the last search
string; the direction of the search is the same as the last
search. 

nN

search for the nth occurrence of the last search
string; the direction of the search is the opposite of the
last search.

Edit commands

na

append text n times: goes into insert mode just
after the current position. The append is only replicated if
command mode is re-entered (i.e.,  is
used). 

nA

same as a, except it appends at the end of the
line. 

ni

insert text n times: goes into insert mode at the
current position. The insertion is only replicated if
command mode is re-entered (i.e.,  is
used). 

nI

same as i, except the insertion is done just
before the first non-blank character.

ns

substitute the next n characters (i.e.,
delete the characters and go into insert mode).

S

substitute whole line: all characters from the first
non-blank character to the end of line are deleted and
insert mode is entered.

ncmove-cmd

change from the current
position to the position resulting from n move-cmds
(i.e., delete the indicated region and go into insert
mode); if move-cmd is c, the line starting
from the first non-blank character is changed.

C

change from the current position to the end of the line
(i.e., delete to the end of the line and go into
insert mode).

nx

delete the next n characters.

nX

delete the previous n characters.

D

delete to the end of the line.

ndmove-cmd

delete from the current
position to the position resulting from n move-cmds;
move-cmd is a movement command (see above) or
d, in which case the current line is deleted.

nrc

replace the next n characters with the character
c. 

nR

replace: enter insert mode but overwrite existing
characters instead of inserting before existing characters.
The replacement is repeated n times.

n~

change the case of the next n characters.

nymove-cmd

yank from the current position
to the position resulting from n move-cmds into the
yank buffer; if move-cmd is y, the whole line
is yanked.

Y

yank from the current position to the end of the
line. 

np

paste the contents of the yank buffer just after the
current position, n times.

nP

same as p, except the buffer is pasted at the
current position.

Miscellaneous vi commands

^J and ^M

the current line is read,
parsed and executed by the shell.

^L and ^R

redraw the current line.

n.

redo the last edit command n times.

u

undo the last edit command.

U

undo all changes that have been made to the current
line. 

intr and quit

the interrupt and quit terminal
characters cause the current line to be deleted and a new
prompt to be printed.

FILES

~/.profile 
/etc/profile 
/etc/suid_profile

BUGS

Any bugs in
pdksh should be reported to pdksh [AT] cs.ca. Please include
the version of pdksh (echo $KSH_VERSION shows it), the
machine, operating system and compiler you are using and a
description of how to repeat the bug (a small shell script
that demonstrates the bug is best). The following, if
relevant (if you are not sure, include them), can also
helpful: options you are using (both options.h options and
set −o options) and a copy of your config.h (the file
generated by the configure script). New versions of pdksh
can be obtained from ftp://ftp.cs.mun.ca/pub/pdksh/.

BTW, the most
frequently reported bug is

echo hi | read a; echo
$a   # Does not print hi

I’m aware of this and
there is no need to report it.

VERSION

This page
documents version

@(#)PD KSH v5.2.14 99/07/13.2 of the
public domain korn shell.

AUTHORS

This shell is
based on the public domain 7th edition Bourne shell clone by
Charles Forsyth and parts of the BRL shell by Doug A. Gwyn,
Doug Kingston, Ron Natalie, Arnold Robbins, Lou Salkind and
others. The first release of pdksh was created by Eric
Gisin, and it was subsequently maintained by John R.
MacMillan (chance!john [AT] sq.com), and Simon J. Gerraty
(sjg [AT] zen.au). The current maintainer is Michael
Rendell (michael [AT] cs.ca). The CONTRIBUTORS file in the
source distribution contains a more complete list of people
and their part in the shell’s development.

SEE ALSO

awk(1), sh(1),
csh(1), ed(1), getconf(1), getopt(1), sed(1), stty(1),
vi(1), dup(2), execve(2), getgid(2), getuid(2), open(2),
pipe(2), wait(2), getopt(3), rand(3), signal(3), system(3),
environ(7)

The
KornShell Command and Programming Language, Morris
Bolsky and David Korn, 1989, ISBN 0-13-516972-0.

UNIX Shell
Programming, Stephen G. Kochan, Patrick H. Wood,
Hayden.

IEEE
Standard for information Technology − Portable
Operating System Interface (POSIX) − Part 2: Shell and
Utilities, IEEE Inc, 1993, ISBN 1-55937-255-9.