IPFW(8) BSD System Manager’s Manual IPFW(8)

NAME

ipfw — IP firewall
and traffic shaper control program

SYNOPSIS

ipfw [−q]
[

−p preproc [ 
−D macro[=value]]
[−U macro] ] pathname

ipfw
[−f | −q] flush 
ipfw [−q]
{zero | resetlog | delete}
[number ...] 
ipfw [−s [field]]
[−aftN] {list | show}
[number ...] 
ipfw [−q] add [number]
rule-body

DESCRIPTION

ipfw is the user
interface for controlling the ipfirewall(4)

Each incoming or
outgoing packet is passed through the ipfw rules. If
the host is acting as a gateway, packets forwarded by the
gateway are processed by ipfw twice. When the host is
acting as a bridge, packets forwarded by the bridge are
processed by ipfw once.

A firewall
configuration is made of a list of numbered rules, which is
scanned for each packet until a match is found and the
relevant action is performed. Depending on the action and
certain system settings, packets can be reinjected into the
firewall at the rule after the matching one for further
processing. All rules apply to all interfaces, so it is
responsibility of the system administrator to write the
ruleset in such a way as to minimize the number of
checks.

A configuration
always includes a DEFAULT rule (numbered 65535) which
cannot be modified by the programmer and always matches
packets. The action associated with the default rule can be
either deny or allow depending on how the
kernel is configured.

If the ruleset
includes one or more rules with the keep-state
option, then ipfw assumes a stateful
behaviour, i.e. upon a match will create dynamic rules
matching the exact parameters (addresses and ports) of the
matching packet.

These dynamic
rules, which have a limited lifetime, are checked at the
first occurrence of a check-state or
keep-state rule, and are typically used to open the
firewall on-demand to legitimate traffic only. See the
RULE FORMAT and EXAMPLES sections below for
more information on the stateful behaviour of
ipfw.

All rules
(including dynamic ones) have a few associated counters: a
packet count, a byte count, a log count and a timestamp
indicating the time of the last match. Counters can be
displayed or reset with ipfw commands.

Rules can be
added with the add command; deleted individually with
the delete command, and globally with the
flush command; displayed, optionally with the content
of the counters, using the show and list
commands. Finally, counters can be reset with the
zero and resetlog commands.

The following
options are available:

−a

While listing,
show counter values. See also the show command.

−f

Don’t ask
for confirmation for commands that can cause problems if
misused, i.e. flush. Note, if there is no tty
associated with the process, this is implied.

−q

While
adding, zeroing, resetlogging or
flushing, be quiet about actions (implies
−f). This is useful for adjusting rules by
executing multiple ipfw commands in a script (e.g.,
’sh /etc/rc.firewall’), or by processing a
file of many ipfw rules, across a remote login
session. If a flush is performed in normal (verbose)
mode (with the default kernel configuration), it prints a
message. Because all rules are flushed, the message cannot
be delivered to the login session. This causes the remote
login session to be closed and the remainder of the ruleset
is not processed. Access to the console is required to
recover.

−t

While listing,
show last match timestamp.

−N

Try to resolve
addresses and service names in output.

To ease
configuration, rules can be put into a file which is
processed using ipfw as shown in the first synopsis
line. An absolute pathname must be used. The file
will be read line by line and applied as arguments to the
ipfw utility.

Optionally, a
preprocessor can be specified using −p
preproc where pathname is to be piped through.
Useful preprocessors include cpp(1) and m4(1). If
preproc doesn’t start with a slash
(’/’) as its first character, the usual PATH
name search is performed. Care should be taken with this in
environments where not all filesystems are mounted (yet) by
the time ipfw is being run (e.g. when they are
mounted over NFS). Once −p has been specified,
optional −D and −U specifications
can follow and will be passed on to the preprocessor. This
allows for flexible configuration files (like
conditionalizing them on the local hostname) and the use of
macros to centralize frequently required arguments like IP
addresses.

RULE FORMAT

The ipfw rule format is
the following:

[prob
match_probability] action [log
[logamount number]] proto from
src to dst [interface-spec]
[options]

Each packet can
be filtered based on the following information that is
associated with it:

Transmit and receive
interface

(by name or
address)

Direction

(incoming or
outgoing)

Source and destination IP address

(possibly
masked)

Protocol

(TCP, UDP,
ICMP, etc.)

Source and destination port

(lists, ranges
or masks)

TCP flags 
IP fragment flag 
IP options 
ICMP types 
User ID of the socket associated with the packet

Note that it may
be dangerous to filter on the source IP address or source
TCP/UDP port because either or both could easily be
spoofed.

prob
match_probability

A match is only declared with
the specified probability (floating point number between 0
and 1). This can be useful for a number of applications such
as random packet drop.

action:

allow

Allow packets
that match rule. The search terminates. Aliases are
pass, permit and accept.

deny

Discard packets
that match this rule. The search terminates. drop is
an alias for deny.

reject

(Deprecated).
Discard packets that match this rule, and try to send an
ICMP host unreachable notice. The search terminates.

unreach code

Discard packets that match this
rule, and try to send an ICMP unreachable notice with code
code, where code is a number from 0 to 255, or
one of these aliases: net, host,
protocol, port, needfrag,
srcfail, net-unknown, host-unknown,
isolated, net-prohib, host-prohib,
tosnet, toshost, filter-prohib,
host-precedence or precedence-cutoff. The
search terminates.

reset

TCP packets
only. Discard packets that match this rule, and try to send
a TCP reset (RST) notice. The search terminates.

count

Update counters
for all packets that match rule. The search continues with
the next rule.

check-state

Checks the packet against the
dynamic ruleset. If a match is found then the search
terminates, otherwise we move to the next rule. If no
check-state rule is found, the dynamic ruleset is
checked at the first keep-state rule.

divert port

Divert packets that match this
rule to the divert(4) socket bound to port port. The
search terminates.

tee port

Send a copy of packets matching
this rule to the divert(4) socket bound to port port.
The search terminates and the original packet is accepted
(but see section BUGS below).

fwd ipaddr 
[,port]

Change the next-hop on matching
packets to ipaddr, which can be an IP address in
dotted quad or a host name. If ipaddr is not a
directly-reachable address, the route as found in the local
routing table for that IP is used instead. If ipaddr
is a local address, then on a packet entering the system
from a remote host it will be diverted to port on the
local machine, keeping the local address of the socket set
to the original IP address the packet was destined for. This
is intended for use with transparent proxy servers. If the
IP is not a local address then the port number (if
specified) is ignored and the rule only applies to packets
leaving the system. This will also map addresses to local
ports when packets are generated locally. The search
terminates if this rule matches. If the port number is not
given then the port number in the packet is used, so that a
packet for an external machine port Y would be forwarded to
local port Y. The kernel must have been compiled with the
IPFIREWALL_FORWARD option.

skipto number

Skip all subsequent rules
numbered less than number. The search continues with
the first rule numbered number or higher.

log [logamount
number]

If the kernel was compiled with
IPFIREWALL_VERBOSE, then when a packet matches a rule with
the log keyword a message will be logged to
syslogd(8) with a LOG_AUTHPRIV facility. Note: by
default, they are appended to the /var/log/system.log
file (see syslog.conf(5)). If the kernel was compiled with
the IPFIREWALL_VERBOSE_LIMIT option, then by default logging
will cease after the number of packets specified by the
option are received for that particular chain entry, and
net.inet.ip.fw.verbose_limit will be set to that
number. However, if logamount number is used,
that number will be the logging limit rather than
net.inet.ip.fw.verbose_limit, where the value
’’0’’ removes the logging limit.
Logging may then be re-enabled by clearing the logging
counter or the packet counter for that entry.

Console logging
and the log limit are adjustable dynamically through the
sysctl(8) interface in the MIB base of
net.inet.ip.fw.

proto

An IP protocol
specified by number or name (for a complete list see
/etc/protocols). The ip or all keywords
mean any protocol will match.

src and dst:

any | me |
[not] ⟨ address/mask⟩
[ports]

Specifying
any makes the rule match any IP number.

Specifying
me makes the rule match any IP number configured on
an interface in the system. This is a computationally
semi-expensive check which should be used with care.

The ⟨
address/mask⟩ may be specified as:

ipno

An IP number of
the form 1.2.3.4. Only this exact IP number will match the
rule.

ipno/bits

An IP number
with a mask width of the form 1.2.3.4/24. In this case all
IP numbers from 1.2.3.0 to 1.2.3.255 will match.

ipno:mask

An IP number
with a mask of the form 1.2.3.4:255.255.240.0. In this case
all IP numbers from 1.2.0.0 to 1.2.15.255 will match.

The sense of
the match can be inverted by preceding an address with the
not modifier, causing all other addresses to be
matched instead. This does not affect the selection of port
numbers.

With the TCP
and UDP protocols, optional ports may be specified
as:

{

port|port-port|port:mask
}[,port[,...]]

The
’-’ notation specifies a range of ports
(including boundaries).

The
’:’ notation specifies a port and a mask, a
match is declared if the port number in the packet matches
the one in the rule, limited to the bits which are set in
the mask.

Service names
(from /etc/services) may be used instead of numeric
port values. A range may only be specified as the first
value, and the length of the port list is limited to
IP_FW_MAX_PORTS ports (as defined in
/usr/src/sys/netinet/ip_fw.h). A backslash
(’\’) can be used to escape the dash
(’-’) character in a service name:

ipfw add count
tcp from any ftp\\-data-ftp to any

Fragmented
packets which have a non-zero offset (i.e. not the first
fragment) will never match a rule which has one or more port
specifications. See the frag option for details on
matching fragmented packets.

interface-spec

Some combinations of the
following specifiers are allowed:

in

Only match
incoming packets.

out

Only match
outgoing packets.

via ifX

Packet must be
going through interface ifX.

via if*

Packet must be
going through interface ifX, where X is any
unit number.

via any

Packet must be
going through some interface.

via ipno

Packet must be
going through the interface having IP address
ipno.

The via
keyword causes the interface to always be checked. If
recv or xmit is used instead of via,
then the only receive or transmit interface (respectively)
is checked. By specifying both, it is possible to match
packets based on both receive and transmit interface,
e.g.:

ipfw add 100
deny ip from any to any out recv ed0 xmit ed1

The recv
interface can be tested on either incoming or outgoing
packets, while the xmit interface can only be tested
on outgoing packets. So out is required (and
in is invalid) whenever xmit is used.
Specifying via together with xmit or
recv is invalid.

A packet may
not have a receive or transmit interface: packets
originating from the local host have no receive interface,
while packets destined for the local host have no transmit
interface.

options:

keep-state
[method]

Upon a match, the firewall will
create a dynamic rule, whose default behaviour is to
matching bidirectional traffic between source and
destination IP/port using the same protocol. The rule has a
limited lifetime (controlled by a set of sysctl(8)
variables), and the lifetime is refreshed every time a
matching packet is found.

The actual
behaviour can be modified by specifying a different
method, although at the moment only the default one
is specified.

bridged

Matches only bridged packets.
This can be useful for multicast or broadcast traffic, which
would otherwise pass through the firewall twice: once during
bridging, and a second time when the packet is delivered to
the local stack.

frag

Match if the
packet is a fragment and this is not the first fragment of
the datagram. frag may not be used in conjunction
with either tcpflags or TCP/UDP port
specifications.

ipoptions spec

Match if the IP header contains
the comma separated list of options specified in
spec. The supported IP options are:

ssrr
(strict source route), lsrr (loose source route),
rr (record packet route) and ts (timestamp).
The absence of a particular option may be denoted with a
’!’.

tcpoptions
spec

Match if the TCP header
contains the comma separated list of options specified in
spec. The supported TCP options are:

mss
(maximum segment size), window (tcp window
advertisement), sack (selective ack), ts
(rfc1323 timestamp) and cc (rfc1644 t/tcp connection
count). The absence of a particular option may be denoted
with a ’!’.

established

TCP packets only. Match packets
that have the RST or ACK bits set.

setup

TCP packets
only. Match packets that have the SYN bit set but no ACK
bit.

tcpflags spec

TCP packets only. Match if the
TCP header contains the comma separated list of flags
specified in spec. The supported TCP flags are:

fin,
syn, rst, psh, ack and
urg. The absence of a particular flag may be denoted
with a ’!’. A rule which contains a
tcpflags specification can never match a fragmented
packet which has a non-zero offset. See the frag
option for details on matching fragmented packets.

icmptypes
types

ICMP packets only. Match if the
ICMP type is in the list types. The list may be
specified as any combination of ranges or individual types
separated by commas. The supported ICMP types are:

echo reply
(0), destination unreachable (3), source
quench (4), redirect (5), echo request
(8), router advertisement (9), router
solicitation (10), time-to-live exceeded (11),
IP header bad (12), timestamp request (13),
timestamp reply (14), information request
(15), information reply (16), address mask
request (17) and address mask reply (18).

uid user

Match all TCP or UDP packets
sent by or received for a user. A user may be
matched by name or identification number.

CHECKLIST

Here are some important points
to consider when designing your rules:

•

Remember that you filter both
packets going in and out. Most connections
need packets going in both directions.

•

Remember to test very
carefully. It is a good idea to be near the console when
doing this. If you cannot be near the console, use an
auto-recovery script.

•

Don’t forget the loopback
interface.

FINE POINTS 
•

There is one kind of packet
that the firewall will always discard, that is a TCP
packet’s fragment with a fragment offset of one. This
is a valid packet, but it only has one use, to try to
circumvent firewalls. When logging is enabled, these packets
are reported as being dropped by rule -1.

•

The ipfw filter list may
not be modified if the system security level is set to 3 or
higher (see init(8) for information on system security
levels).

PACKET DIVERSION

A divert(4) socket bound to the
specified port will receive all packets diverted to that
port. If no socket is bound to the destination port, or if
the kernel wasn’t compiled with divert socket support,
the packets are dropped.

SYSCTL VARIABLES

A set of sysctl(8) variables
controls the behaviour of the firewall. These are shown
below together with their default value and meaning:

net.inet.ip.fw.debug:
1

Controls debugging messages
produced by ipfw.

net.inet.ip.fw.verbose:
1

Enables verbose messages.

net.inet.ip.fw.enable:
1

Enables the firewall. Setting
this variable to 0 lets you run your machine without
firewall even if compiled in.

net.inet.ip.fw.verbose_limit:
0

Limits the number of messages
produced by a verbose firewall.

net.inet.ip.fw.dyn_buckets:
256

net.inet.ip.fw.curr_dyn_buckets:
256

The configured and current size
of the hash table used to hold dynamic rules. This must be a
power of 2. The table can only be resized when empty, so in
order to resize it on the fly you will probably have to
flush and reload the ruleset.

net.inet.ip.fw.dyn_count:
3

Current number of dynamic rules
(read-only).

net.inet.ip.fw.dyn_max:
1000

Maximum number of dynamic
rules. When you hit this limit, no more dynamic rules can be
installed until old ones expire.

net.inet.ip.fw.dyn_ack_lifetime:
300

net.inet.ip.fw.dyn_syn_lifetime:
20

net.inet.ip.fw.dyn_fin_lifetime:
20

net.inet.ip.fw.dyn_rst_lifetime:
5

net.inet.ip.fw.dyn_short_lifetime:
30

These variables control the
lifetime, in seconds, of dynamic rules. Upon the initial SYN
exchange the lifetime is kept short, then increased after
both SYN have been seen, then decreased again during the
final FIN exchange or when a RST

EXAMPLES

This command adds an entry which
denies all tcp packets from cracker.evil.org to the
telnet port of wolf.tambov.su from being forwarded by
the host:

ipfw add deny
tcp from cracker.evil.org to wolf.tambov.su telnet

This one
disallows any connection from the entire crackers network to
my host:

ipfw add deny
ip from 123.45.67.0/24 to my.host.org

A fast and
efficient way to limit access (not using dynamic rules) is
the use of the following rules:

ipfw add allow
tcp from any to any established 
ipfw add allow tcp from net1 portlist1 to net2 portlist2
setup 
ipfw add allow tcp from net3 portlist3 to net3 portlist3
setup 
... 
ipfw add deny tcp from any to any

The first rule
will be a quick match for normal TCP packets, but it will
not match the initial SYN packet, which will be matched by
the setup rules only for selected source/destination
pairs. All other SYN packets will be rejected by the final
deny rule.

In order to
protect a site from flood attacks involving fake TCP
packets, it is safer to use dynamic rules:

ipfw add
check-state 
ipfw add deny tcp from any to any established 
ipfw add allow tcp from my-net to any setup keep-state

This will let
the firewall install dynamic rules only for those connection
which start with a regular SYN packet coming from the inside
of our network. Dynamic rules are checked when encountering
the first check-state or keep-state rule. A
check-state rule should be usually placed near the
beginning of the ruleset to minimize the amount of work
scanning the ruleset. Your mileage may vary.

BEWARE:
stateful rules can be subject to denial-of-service attacks
by a SYN-flood which opens a huge number of dynamic rules.
The effects of such attacks can be partially limited by
acting on a set of sysctl(8) variables which control the
operation of the firewall.

Here is a good
usage of the list command to see accounting records
and timestamp information:

ipfw -at
list

or in short form
without timestamps:

ipfw -a
list

Next rule
diverts all incoming packets from 192.168.2.0/24 to divert
port 5000:

ipfw divert
5000 ip from 192.168.2.0/24 to any in

SEE ALSO

cpp(1), m4(1), divert(4), ip(4),
ipfirewall(4), protocols(5), services(5), init(8),
reboot(8), sysctl(8), syslogd(8)

BUGS

The syntax has grown over the
years and it is not very clean.

WARNING!!WARNING!!WARNING!!WARNING!!WARNING!!WARNING!!WARNING!!

This program can
put your computer in rather unusable state. When using it
for the first time, work on the console of the computer, and
do NOT do anything you don’t understand.

When
manipulating/adding chain entries, service and protocol
names are not accepted.

Incoming packet
fragments diverted by divert or tee are
reassembled before delivery to the socket.

Packets that
match a tee rule should not be immediately accepted,
but should continue going through the rule list. This may be
fixed in a later version.

AUTHORS

Ugen J. S. Antsilevich, 
Poul-Henning Kamp, 
Alex Nash, 
Archie Cobbs, 
Luigi Rizzo.

API based upon
code written by Daniel Boulet for BSDI.

HISTORY

The ipfw utility first
appeared in FreeBSD 2.0. Stateful extensions were
introduced in FreeBSD 4.0.

Darwin
July 2, 2003 Darwin