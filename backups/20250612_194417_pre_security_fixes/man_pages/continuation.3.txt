NAME

continuation -
nonlinear solver (rheolef-7.2)

SYNOPSIS

template 
void continuation ( 
Problem& F, 
typename Problem::value_type& uh, 
odiststream* p_out, 
odiststream* p_err, 
const continuation_option& opts =
continuation_option())

DESCRIPTION

This function
implements a generic damped Newton method for the resolution
of the following problem:

F(lambda,u) =
0

where
lambda is a parameter and u is the
corresponding solution, that depends upon lambda.
The main idea is to follow a branch of solution denoted as
u(lambda) when the parameter lambda
varies. A simple call to the algorithm writes:

my_problem P;

field uh (Vh,0); 
continuation (P, uh, &dout, &derr);

The optional
argument continuation_option(3) allows one to control
some features of the algorithm.

The
continuation algorithm bases on the damped_newton(3)
method. In addition to the members required for the
damped_newton(3) method, several additional members
are required for the continuation one. The requirements
are:

class
my_problem { 
public: 
typedef float_type; 
typedef value_type; 
string parameter_name() const; 
float_type parameter() const; 
void set_parameter (float_type lambda); 
value_type residue (const value_type& uh) const; 
void update_derivative (const value_type& uh) const;

csr derivative (const value_type& uh)
const; 
value_type derivative_solve (const value_type& mrh)
const; 
value_type derivative_trans_mult (const value_type& mrh)
const; 
value_type derivative_versus_parameter (const field& uh)
const; 
bool stop (const value_type& xh) const; 
idiststream& get (idiststream& is, value_type&
uh); 
odiststream& put (odiststream& os, const
value_type& uh) const; 
float_type space_norm (const value_type& uh) const; 
float_type dual_space_norm (const value_type& mrh)
const; 
float_type space_dot (const value_type& xh, const
value_type& yh) const; 
float_type dual_space_dot (const value_type& mrh, const
value_type& msh) const; 
value_type massify (const value_type& uh) const; 
value_type unmassify (const value_type& mrh) const; 
};

EXAMPLE

See the example
combustion_continuation.cc example and the
usersguide for more.

ADAPTIVE MESH

There are two
versions of this algorithm:

•

one with imbedded mesh adaptation loop

•

one without this feature

The algorithm
is automatically selected when there is an adapt()
method in the problem definition.

IMPLEMENTATION

This
documentation has been generated from file
main/lib/continuation.h

AUTHOR

Pierre Saramito
Pierre.Saramito [AT] imag.fr>

COPYRIGHT

Copyright (C)
2000-2018 Pierre Saramito Pierre.Saramito [AT] imag.fr>
GPLv3+: GNU GPL version 3 or later
http://gnu.org/licenses/gpl.html>. This is free
software: you are free to change and redistribute it. There
is NO WARRANTY, to the extent permitted by law.